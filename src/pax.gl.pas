unit pax.gl;
{$mode objfpc}{$H+}
{$ModeSwitch typehelpers}
{$modeswitch advancedrecords}
interface

uses SysUtils, dynlibs;

const
  {$IFDEF WINDOWS}
    libGL = 'opengl32.dll';
  {$ELSEIF DEFINED(LINUX)}
    libGL = 'libGL.so.1';
  {$ELSEIF DEFINED(DARWIN)}
    libGL = 'OpenGL';
  {$ELSE}
  libGL = '';
  {$ENDIF}

type
  GLenum = uint32;
  PGLenum = ^GLenum;
  PPGLenum = ^PGLenum;
  GLboolean = byte;
  PGLboolean = ^GLboolean;
  PPGLboolean = ^PGLboolean;
  GLbitfield = uint32;
  PGLbitfield = ^GLbitfield;
  PPGLbitfield = ^PGLbitfield;
  GLvoid = Pointer; // Not an actual GL type, though used in headers in the past
  PGLvoid = ^GLvoid;
  PPGLvoid = ^PGLvoid;
  GLbyte = int8; //khrplatform
  PGLbyte = ^GLbyte;
  PPGLbyte = ^PGLbyte;
  GLubyte = uint8; //khrplatform
  PGLubyte = ^GLubyte;
  PPGLubyte = ^PGLubyte;
  GLshort = int16; //khrplatform
  PGLshort = ^GLshort;
  PPGLshort = ^PGLshort;
  GLushort = uint16; //khrplatform
  PGLushort = ^GLushort;
  PPGLushort = ^PGLushort;
  GLint = int32;
  PGLint = ^GLint;
  PPGLint = ^PGLint;
  GLuint = uint32;
  PGLuint = ^GLuint;
  PPGLuint = ^PGLuint;
  GLclampx = int32; //khrplatform
  PGLclampx = ^GLclampx;
  PPGLclampx = ^PGLclampx;
  GLsizei = int32;
  PGLsizei = ^GLsizei;
  PPGLsizei = ^PGLsizei;
  GLfloat = single; //khrplatform
  PGLfloat = ^GLfloat;
  PPGLfloat = ^PGLfloat;
  GLclampf = single; //khrplatform
  PGLclampf = ^GLclampf;
  PPGLclampf = ^PGLclampf;
  GLdouble = double;
  PGLdouble = ^GLdouble;
  PPGLdouble = ^PGLdouble;
  GLclampd = double;
  PGLclampd = ^GLclampd;
  PPGLclampd = ^PGLclampd;
  GLeglClientBufferEXT = pointer;
  PGLeglClientBufferEXT = ^GLeglClientBufferEXT;
  PPGLeglClientBufferEXT = ^PGLeglClientBufferEXT;
  GLeglImageOES = pointer;
  PGLeglImageOES = ^GLeglImageOES;
  PPGLeglImageOES = ^PGLeglImageOES;
  GLchar = char;
  PGLchar = ^GLchar;
  PPGLchar = ^PGLchar;
  GLcharARB = char;
  PGLcharARB = ^GLcharARB;
  PPGLcharARB = ^PGLcharARB;
  GLhalf = uint16; //khrplatform
  PGLhalf = ^GLhalf;
  PPGLhalf = ^PGLhalf;
  GLhalfARB = uint16; //khrplatform
  PGLhalfARB = ^GLhalfARB;
  PPGLhalfARB = ^PGLhalfARB;
  GLfixed = int32; //khrplatform
  PGLfixed = ^GLfixed;
  PPGLfixed = ^PGLfixed;
  GLintptr = PtrInt; //khrplatform
  PGLintptr = ^GLintptr;
  PPGLintptr = ^PGLintptr;
  GLintptrARB = PtrInt; //khrplatform
  PGLintptrARB = ^GLintptrARB;
  PPGLintptrARB = ^PGLintptrARB;
  GLsizeiptr = int32; //khrplatform
  PGLsizeiptr = ^GLsizeiptr;
  PPGLsizeiptr = ^PGLsizeiptr;
  GLsizeiptrARB = int32; //khrplatform
  PGLsizeiptrARB = ^GLsizeiptrARB;
  PPGLsizeiptrARB = ^PGLsizeiptrARB;
  GLint64 = int64; //khrplatform
  PGLint64 = ^GLint64;
  PPGLint64 = ^PGLint64;
  GLint64EXT = int64; //khrplatform
  PGLint64EXT = ^GLint64EXT;
  PPGLint64EXT = ^PGLint64EXT;
  GLuint64 = uint64; //khrplatform 
  PGLuint64 = ^GLuint64;
  PPGLuint64 = ^PGLuint64;
  GLuint64EXT = uint64; //khrplatform 
  PGLuint64EXT = ^GLuint64EXT;
  PPGLuint64EXT = ^PGLuint64EXT;
  GLsync = pointer;
  PGLsync = ^GLsync;
  PPGLsync = ^PGLsync;
  _cl_context = record
  end; // compatible with OpenCL cl_context
  P_cl_context = ^_cl_context;
  PP_cl_context = ^P_cl_context;
  _cl_event = record
  end; // compatible with OpenCL cl_event
  P_cl_event = ^_cl_event;
  PP_cl_event = ^P_cl_event;
  GLhalfNV = uint16;
  PGLhalfNV = ^GLhalfNV;
  PPGLhalfNV = ^PGLhalfNV;
  GLvdpauSurfaceNV = GLintptr; //GLintptr
  PGLvdpauSurfaceNV = ^GLvdpauSurfaceNV;
  PPGLvdpauSurfaceNV = ^PGLvdpauSurfaceNV;


  GLDEBUGPROC = procedure(Source: GLenum; aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const message: PGLchar; const userParam: Pointer); cdecl;
  GLDEBUGPROCARB = procedure(Source: GLenum; aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const message: PGLchar; const userParam: Pointer); cdecl;
  GLDEBUGPROCKHR = procedure(Source: GLenum; aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const message: PGLchar; const userParam: Pointer); cdecl;
  GLDEBUGPROCAMD = procedure(id: GLuint; category: GLenum; severity: GLenum; length: GLsizei; const message: PGLchar; userParam: Pointer); cdecl;
  GLVULKANPROCNV = procedure; cdecl;

const
  GL_CURRENT_BIT = $00000001;
  GL_POINT_BIT = $00000002;
  GL_LINE_BIT = $00000004;
  GL_POLYGON_BIT = $00000008;
  GL_POLYGON_STIPPLE_BIT = $00000010;
  GL_PIXEL_MODE_BIT = $00000020;
  GL_LIGHTING_BIT = $00000040;
  GL_FOG_BIT = $00000080;
  GL_DEPTH_BUFFER_BIT = $00000100;
  GL_ACCUM_BUFFER_BIT = $00000200;
  GL_STENCIL_BUFFER_BIT = $00000400;
  GL_VIEWPORT_BIT = $00000800;
  GL_TRANSFORM_BIT = $00001000;
  GL_ENABLE_BIT = $00002000;
  GL_COLOR_BUFFER_BIT = $00004000;
  GL_HINT_BIT = $00008000;
  GL_EVAL_BIT = $00010000;
  GL_LIST_BIT = $00020000;
  GL_TEXTURE_BIT = $00040000;
  GL_SCISSOR_BIT = $00080000;
  GL_MULTISAMPLE_BIT = $20000000;
  GL_MULTISAMPLE_BIT_ARB = $20000000;
  GL_MULTISAMPLE_BIT_EXT = $20000000;
  GL_MULTISAMPLE_BIT_3DFX = $20000000;
  GL_ALL_ATTRIB_BITS = $FFFFFFFF;
  GL_DYNAMIC_STORAGE_BIT = $0100;
  GL_DYNAMIC_STORAGE_BIT_EXT = $0100;
  GL_CLIENT_STORAGE_BIT = $0200;
  GL_CLIENT_STORAGE_BIT_EXT = $0200;
  GL_SPARSE_STORAGE_BIT_ARB = $0400;
  GL_LGPU_SEPARATE_STORAGE_BIT_NVX = $0800;
  GL_PER_GPU_STORAGE_BIT_NV = $0800;
  GL_EXTERNAL_STORAGE_BIT_NVX = $2000;
  GL_COVERAGE_BUFFER_BIT_NV = $00008000;
  GL_CLIENT_PIXEL_STORE_BIT = $00000001;
  GL_CLIENT_VERTEX_ARRAY_BIT = $00000002;
  GL_CLIENT_ALL_ATTRIB_BITS = $FFFFFFFF;
  GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = $00000001;
  GL_CONTEXT_FLAG_DEBUG_BIT = $00000002;
  GL_CONTEXT_FLAG_DEBUG_BIT_KHR = $00000002;
  GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT = $00000004;
  GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = $00000004;
  GL_CONTEXT_FLAG_NO_ERROR_BIT = $00000008;
  GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR = $00000008;
  GL_CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT = $00000010;
  GL_CONTEXT_CORE_PROFILE_BIT = $00000001;
  GL_CONTEXT_COMPATIBILITY_PROFILE_BIT = $00000002;
  GL_MAP_READ_BIT = $0001;
  GL_MAP_READ_BIT_EXT = $0001;
  GL_MAP_WRITE_BIT = $0002;
  GL_MAP_WRITE_BIT_EXT = $0002;
  GL_MAP_INVALIDATE_RANGE_BIT = $0004;
  GL_MAP_INVALIDATE_RANGE_BIT_EXT = $0004;
  GL_MAP_INVALIDATE_BUFFER_BIT = $0008;
  GL_MAP_INVALIDATE_BUFFER_BIT_EXT = $0008;
  GL_MAP_FLUSH_EXPLICIT_BIT = $0010;
  GL_MAP_FLUSH_EXPLICIT_BIT_EXT = $0010;
  GL_MAP_UNSYNCHRONIZED_BIT = $0020;
  GL_MAP_UNSYNCHRONIZED_BIT_EXT = $0020;
  GL_MAP_PERSISTENT_BIT = $0040;
  GL_MAP_PERSISTENT_BIT_EXT = $0040;
  GL_MAP_COHERENT_BIT = $0080;
  GL_MAP_COHERENT_BIT_EXT = $0080;
  GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = $00000001;
  GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT = $00000001;
  GL_ELEMENT_ARRAY_BARRIER_BIT = $00000002;
  GL_ELEMENT_ARRAY_BARRIER_BIT_EXT = $00000002;
  GL_UNIFORM_BARRIER_BIT = $00000004;
  GL_UNIFORM_BARRIER_BIT_EXT = $00000004;
  GL_TEXTURE_FETCH_BARRIER_BIT = $00000008;
  GL_TEXTURE_FETCH_BARRIER_BIT_EXT = $00000008;
  GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV = $00000010;
  GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = $00000020;
  GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT = $00000020;
  GL_COMMAND_BARRIER_BIT = $00000040;
  GL_COMMAND_BARRIER_BIT_EXT = $00000040;
  GL_PIXEL_BUFFER_BARRIER_BIT = $00000080;
  GL_PIXEL_BUFFER_BARRIER_BIT_EXT = $00000080;
  GL_TEXTURE_UPDATE_BARRIER_BIT = $00000100;
  GL_TEXTURE_UPDATE_BARRIER_BIT_EXT = $00000100;
  GL_BUFFER_UPDATE_BARRIER_BIT = $00000200;
  GL_BUFFER_UPDATE_BARRIER_BIT_EXT = $00000200;
  GL_FRAMEBUFFER_BARRIER_BIT = $00000400;
  GL_FRAMEBUFFER_BARRIER_BIT_EXT = $00000400;
  GL_TRANSFORM_FEEDBACK_BARRIER_BIT = $00000800;
  GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT = $00000800;
  GL_ATOMIC_COUNTER_BARRIER_BIT = $00001000;
  GL_ATOMIC_COUNTER_BARRIER_BIT_EXT = $00001000;
  GL_SHADER_STORAGE_BARRIER_BIT = $00002000;
  GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = $00004000;
  GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT = $00004000;
  GL_QUERY_BUFFER_BARRIER_BIT = $00008000;
  GL_ALL_BARRIER_BITS = $FFFFFFFF;
  GL_ALL_BARRIER_BITS_EXT = $FFFFFFFF;
  GL_QUERY_DEPTH_PASS_EVENT_BIT_AMD = $00000001;
  GL_QUERY_DEPTH_FAIL_EVENT_BIT_AMD = $00000002;
  GL_QUERY_STENCIL_FAIL_EVENT_BIT_AMD = $00000004;
  GL_QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD = $00000008;
  GL_QUERY_ALL_EVENT_BITS_AMD = $FFFFFFFF;
  GL_SYNC_FLUSH_COMMANDS_BIT = $00000001;
  GL_SYNC_FLUSH_COMMANDS_BIT_APPLE = $00000001;
  GL_VERTEX_SHADER_BIT = $00000001;
  GL_VERTEX_SHADER_BIT_EXT = $00000001;
  GL_FRAGMENT_SHADER_BIT = $00000002;
  GL_FRAGMENT_SHADER_BIT_EXT = $00000002;
  GL_GEOMETRY_SHADER_BIT = $00000004;
  GL_GEOMETRY_SHADER_BIT_EXT = $00000004;
  GL_GEOMETRY_SHADER_BIT_OES = $00000004;
  GL_TESS_CONTROL_SHADER_BIT = $00000008;
  GL_TESS_CONTROL_SHADER_BIT_EXT = $00000008;
  GL_TESS_CONTROL_SHADER_BIT_OES = $00000008;
  GL_TESS_EVALUATION_SHADER_BIT = $00000010;
  GL_TESS_EVALUATION_SHADER_BIT_EXT = $00000010;
  GL_TESS_EVALUATION_SHADER_BIT_OES = $00000010;
  GL_COMPUTE_SHADER_BIT = $00000020;
  GL_MESH_SHADER_BIT_NV = $00000040;
  GL_TASK_SHADER_BIT_NV = $00000080;
  GL_ALL_SHADER_BITS = $FFFFFFFF;
  GL_ALL_SHADER_BITS_EXT = $FFFFFFFF;
  GL_SUBGROUP_FEATURE_BASIC_BIT_KHR = $00000001;
  GL_SUBGROUP_FEATURE_VOTE_BIT_KHR = $00000002;
  GL_SUBGROUP_FEATURE_ARITHMETIC_BIT_KHR = $00000004;
  GL_SUBGROUP_FEATURE_BALLOT_BIT_KHR = $00000008;
  GL_SUBGROUP_FEATURE_SHUFFLE_BIT_KHR = $00000010;
  GL_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT_KHR = $00000020;
  GL_SUBGROUP_FEATURE_CLUSTERED_BIT_KHR = $00000040;
  GL_SUBGROUP_FEATURE_QUAD_BIT_KHR = $00000080;
  GL_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = $00000100;
  GL_TEXTURE_STORAGE_SPARSE_BIT_AMD = $00000001;
  GL_RED_BIT_ATI = $00000001;
  GL_GREEN_BIT_ATI = $00000002;
  GL_BLUE_BIT_ATI = $00000004;
  GL_2X_BIT_ATI = $00000001;
  GL_4X_BIT_ATI = $00000002;
  GL_8X_BIT_ATI = $00000004;
  GL_HALF_BIT_ATI = $00000008;
  GL_QUARTER_BIT_ATI = $00000010;
  GL_EIGHTH_BIT_ATI = $00000020;
  GL_SATURATE_BIT_ATI = $00000040;
  GL_COMP_BIT_ATI = $00000002;
  GL_NEGATE_BIT_ATI = $00000004;
  GL_BIAS_BIT_ATI = $00000008;
  GL_TRACE_OPERATIONS_BIT_MESA = $0001;
  GL_TRACE_PRIMITIVES_BIT_MESA = $0002;
  GL_TRACE_ARRAYS_BIT_MESA = $0004;
  GL_TRACE_TEXTURES_BIT_MESA = $0008;
  GL_TRACE_PIXELS_BIT_MESA = $0010;
  GL_TRACE_ERRORS_BIT_MESA = $0020;
  GL_TRACE_ALL_BITS_MESA = $FFFF;
  GL_BOLD_BIT_NV = $01;
  GL_ITALIC_BIT_NV = $02;
  GL_GLYPH_WIDTH_BIT_NV = $01;
  GL_GLYPH_HEIGHT_BIT_NV = $02;
  GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV = $04;
  GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV = $08;
  GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV = $10;
  GL_GLYPH_VERTICAL_BEARING_X_BIT_NV = $20;
  GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV = $40;
  GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV = $80;
  GL_GLYPH_HAS_KERNING_BIT_NV = $100;
  GL_FONT_X_MIN_BOUNDS_BIT_NV = $00010000;
  GL_FONT_Y_MIN_BOUNDS_BIT_NV = $00020000;
  GL_FONT_X_MAX_BOUNDS_BIT_NV = $00040000;
  GL_FONT_Y_MAX_BOUNDS_BIT_NV = $00080000;
  GL_FONT_UNITS_PER_EM_BIT_NV = $00100000;
  GL_FONT_ASCENDER_BIT_NV = $00200000;
  GL_FONT_DESCENDER_BIT_NV = $00400000;
  GL_FONT_HEIGHT_BIT_NV = $00800000;
  GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV = $01000000;
  GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV = $02000000;
  GL_FONT_UNDERLINE_POSITION_BIT_NV = $04000000;
  GL_FONT_UNDERLINE_THICKNESS_BIT_NV = $08000000;
  GL_FONT_HAS_KERNING_BIT_NV = $10000000;
  GL_FONT_NUM_GLYPH_INDICES_BIT_NV = $20000000;
  GL_PERFQUERY_SINGLE_CONTEXT_INTEL = $00000000;
  GL_PERFQUERY_GLOBAL_CONTEXT_INTEL = $00000001;
  GL_VERTEX23_BIT_PGI = $00000004;
  GL_VERTEX4_BIT_PGI = $00000008;
  GL_COLOR3_BIT_PGI = $00010000;
  GL_COLOR4_BIT_PGI = $00020000;
  GL_EDGEFLAG_BIT_PGI = $00040000;
  GL_INDEX_BIT_PGI = $00080000;
  GL_MAT_AMBIENT_BIT_PGI = $00100000;
  GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI = $00200000;
  GL_MAT_DIFFUSE_BIT_PGI = $00400000;
  GL_MAT_EMISSION_BIT_PGI = $00800000;
  GL_MAT_COLOR_INDEXES_BIT_PGI = $01000000;
  GL_MAT_SHININESS_BIT_PGI = $02000000;
  GL_MAT_SPECULAR_BIT_PGI = $04000000;
  GL_NORMAL_BIT_PGI = $08000000;
  GL_TEXCOORD1_BIT_PGI = $10000000;
  GL_TEXCOORD2_BIT_PGI = $20000000;
  GL_TEXCOORD3_BIT_PGI = $40000000;
  GL_TEXCOORD4_BIT_PGI = $80000000;
  GL_COLOR_BUFFER_BIT0_QCOM = $00000001;
  GL_COLOR_BUFFER_BIT1_QCOM = $00000002;
  GL_COLOR_BUFFER_BIT2_QCOM = $00000004;
  GL_COLOR_BUFFER_BIT3_QCOM = $00000008;
  GL_COLOR_BUFFER_BIT4_QCOM = $00000010;
  GL_COLOR_BUFFER_BIT5_QCOM = $00000020;
  GL_COLOR_BUFFER_BIT6_QCOM = $00000040;
  GL_COLOR_BUFFER_BIT7_QCOM = $00000080;
  GL_DEPTH_BUFFER_BIT0_QCOM = $00000100;
  GL_DEPTH_BUFFER_BIT1_QCOM = $00000200;
  GL_DEPTH_BUFFER_BIT2_QCOM = $00000400;
  GL_DEPTH_BUFFER_BIT3_QCOM = $00000800;
  GL_DEPTH_BUFFER_BIT4_QCOM = $00001000;
  GL_DEPTH_BUFFER_BIT5_QCOM = $00002000;
  GL_DEPTH_BUFFER_BIT6_QCOM = $00004000;
  GL_DEPTH_BUFFER_BIT7_QCOM = $00008000;
  GL_STENCIL_BUFFER_BIT0_QCOM = $00010000;
  GL_STENCIL_BUFFER_BIT1_QCOM = $00020000;
  GL_STENCIL_BUFFER_BIT2_QCOM = $00040000;
  GL_STENCIL_BUFFER_BIT3_QCOM = $00080000;
  GL_STENCIL_BUFFER_BIT4_QCOM = $00100000;
  GL_STENCIL_BUFFER_BIT5_QCOM = $00200000;
  GL_STENCIL_BUFFER_BIT6_QCOM = $00400000;
  GL_STENCIL_BUFFER_BIT7_QCOM = $00800000;
  GL_MULTISAMPLE_BUFFER_BIT0_QCOM = $01000000;
  GL_MULTISAMPLE_BUFFER_BIT1_QCOM = $02000000;
  GL_MULTISAMPLE_BUFFER_BIT2_QCOM = $04000000;
  GL_MULTISAMPLE_BUFFER_BIT3_QCOM = $08000000;
  GL_MULTISAMPLE_BUFFER_BIT4_QCOM = $10000000;
  GL_MULTISAMPLE_BUFFER_BIT5_QCOM = $20000000;
  GL_MULTISAMPLE_BUFFER_BIT6_QCOM = $40000000;
  GL_MULTISAMPLE_BUFFER_BIT7_QCOM = $80000000;
  GL_FOVEATION_ENABLE_BIT_QCOM = $00000001;
  GL_FOVEATION_SCALED_BIN_METHOD_BIT_QCOM = $00000002;
  GL_FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT_QCOM = $00000004;
  GL_TEXTURE_DEFORMATION_BIT_SGIX = $00000001;
  GL_GEOMETRY_DEFORMATION_BIT_SGIX = $00000002;
  GL_TERMINATE_SEQUENCE_COMMAND_NV = $0000;
  GL_NOP_COMMAND_NV = $0001;
  GL_DRAW_ELEMENTS_COMMAND_NV = $0002;
  GL_DRAW_ARRAYS_COMMAND_NV = $0003;
  GL_DRAW_ELEMENTS_STRIP_COMMAND_NV = $0004;
  GL_DRAW_ARRAYS_STRIP_COMMAND_NV = $0005;
  GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV = $0006;
  GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV = $0007;
  GL_ELEMENT_ADDRESS_COMMAND_NV = $0008;
  GL_ATTRIBUTE_ADDRESS_COMMAND_NV = $0009;
  GL_UNIFORM_ADDRESS_COMMAND_NV = $000A;
  GL_BLEND_COLOR_COMMAND_NV = $000B;
  GL_STENCIL_REF_COMMAND_NV = $000C;
  GL_LINE_WIDTH_COMMAND_NV = $000D;
  GL_POLYGON_OFFSET_COMMAND_NV = $000E;
  GL_ALPHA_REF_COMMAND_NV = $000F;
  GL_VIEWPORT_COMMAND_NV = $0010;
  GL_SCISSOR_COMMAND_NV = $0011;
  GL_FRONT_FACE_COMMAND_NV = $0012;
  GL_LAYOUT_DEFAULT_INTEL = 0;
  GL_LAYOUT_LINEAR_INTEL = 1;
  GL_LAYOUT_LINEAR_CPU_CACHED_INTEL = 2;
  GL_CLOSE_PATH_NV = $00;
  GL_MOVE_TO_NV = $02;
  GL_RELATIVE_MOVE_TO_NV = $03;
  GL_LINE_TO_NV = $04;
  GL_RELATIVE_LINE_TO_NV = $05;
  GL_HORIZONTAL_LINE_TO_NV = $06;
  GL_RELATIVE_HORIZONTAL_LINE_TO_NV = $07;
  GL_VERTICAL_LINE_TO_NV = $08;
  GL_RELATIVE_VERTICAL_LINE_TO_NV = $09;
  GL_QUADRATIC_CURVE_TO_NV = $0A;
  GL_RELATIVE_QUADRATIC_CURVE_TO_NV = $0B;
  GL_CUBIC_CURVE_TO_NV = $0C;
  GL_RELATIVE_CUBIC_CURVE_TO_NV = $0D;
  GL_SMOOTH_QUADRATIC_CURVE_TO_NV = $0E;
  GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV = $0F;
  GL_SMOOTH_CUBIC_CURVE_TO_NV = $10;
  GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV = $11;
  GL_SMALL_CCW_ARC_TO_NV = $12;
  GL_RELATIVE_SMALL_CCW_ARC_TO_NV = $13;
  GL_SMALL_CW_ARC_TO_NV = $14;
  GL_RELATIVE_SMALL_CW_ARC_TO_NV = $15;
  GL_LARGE_CCW_ARC_TO_NV = $16;
  GL_RELATIVE_LARGE_CCW_ARC_TO_NV = $17;
  GL_LARGE_CW_ARC_TO_NV = $18;
  GL_RELATIVE_LARGE_CW_ARC_TO_NV = $19;
  GL_CONIC_CURVE_TO_NV = $1A;
  GL_RELATIVE_CONIC_CURVE_TO_NV = $1B;
  GL_SHARED_EDGE_NV = $C0;
  GL_ROUNDED_RECT_NV = $E8;
  GL_RELATIVE_ROUNDED_RECT_NV = $E9;
  GL_ROUNDED_RECT2_NV = $EA;
  GL_RELATIVE_ROUNDED_RECT2_NV = $EB;
  GL_ROUNDED_RECT4_NV = $EC;
  GL_RELATIVE_ROUNDED_RECT4_NV = $ED;
  GL_ROUNDED_RECT8_NV = $EE;
  GL_RELATIVE_ROUNDED_RECT8_NV = $EF;
  GL_RESTART_PATH_NV = $F0;
  GL_DUP_FIRST_CUBIC_CURVE_TO_NV = $F2;
  GL_DUP_LAST_CUBIC_CURVE_TO_NV = $F4;
  GL_RECT_NV = $F6;
  GL_RELATIVE_RECT_NV = $F7;
  GL_CIRCULAR_CCW_ARC_TO_NV = $F8;
  GL_CIRCULAR_CW_ARC_TO_NV = $FA;
  GL_CIRCULAR_TANGENT_ARC_TO_NV = $FC;
  GL_ARC_TO_NV = $FE;
  GL_RELATIVE_ARC_TO_NV = $FF;
  GL_NEXT_BUFFER_NV = -2;
  GL_SKIP_COMPONENTS4_NV = -3;
  GL_SKIP_COMPONENTS3_NV = -4;
  GL_SKIP_COMPONENTS2_NV = -5;
  GL_SKIP_COMPONENTS1_NV = -6;
  GL_RESTART_SUN = $0001;
  GL_REPLACE_MIDDLE_SUN = $0002;
  GL_REPLACE_OLDEST_SUN = $0003;
  GL_FALSE = 0;
  GL_NO_ERROR = 0;
  GL_ZERO = 0;
  GL_NONE = 0;
  GL_NONE_OES = 0;
  GL_TRUE = 1;
  GL_ONE = 1;
  GL_INVALID_INDEX = $FFFFFFFF;
  GL_ALL_PIXELS_AMD = $FFFFFFFF;
  GL_TIMEOUT_IGNORED = $FFFFFFFFFFFFFFFF;
  GL_TIMEOUT_IGNORED_APPLE = $FFFFFFFFFFFFFFFF;
  GL_VERSION_ES_CL_1_0 = 1;
  GL_VERSION_ES_CM_1_1 = 1;
  GL_VERSION_ES_CL_1_1 = 1;
  GL_UUID_SIZE_EXT = 16;
  GL_LUID_SIZE_EXT = 8;
  GL_POINTS = $0000;
  GL_LINES = $0001;
  GL_LINE_LOOP = $0002;
  GL_LINE_STRIP = $0003;
  GL_TRIANGLES = $0004;
  GL_TRIANGLE_STRIP = $0005;
  GL_TRIANGLE_FAN = $0006;
  GL_QUADS = $0007;
  GL_QUADS_EXT = $0007;
  GL_QUADS_OES = $0007;
  GL_QUAD_STRIP = $0008;
  GL_POLYGON = $0009;
  GL_LINES_ADJACENCY = $000A;
  GL_LINES_ADJACENCY_ARB = $000A;
  GL_LINES_ADJACENCY_EXT = $000A;
  GL_LINES_ADJACENCY_OES = $000A;
  GL_LINE_STRIP_ADJACENCY = $000B;
  GL_LINE_STRIP_ADJACENCY_ARB = $000B;
  GL_LINE_STRIP_ADJACENCY_EXT = $000B;
  GL_LINE_STRIP_ADJACENCY_OES = $000B;
  GL_TRIANGLES_ADJACENCY = $000C;
  GL_TRIANGLES_ADJACENCY_ARB = $000C;
  GL_TRIANGLES_ADJACENCY_EXT = $000C;
  GL_TRIANGLES_ADJACENCY_OES = $000C;
  GL_TRIANGLE_STRIP_ADJACENCY = $000D;
  GL_TRIANGLE_STRIP_ADJACENCY_ARB = $000D;
  GL_TRIANGLE_STRIP_ADJACENCY_EXT = $000D;
  GL_TRIANGLE_STRIP_ADJACENCY_OES = $000D;
  GL_PATCHES = $000E;
  GL_PATCHES_EXT = $000E;
  GL_PATCHES_OES = $000E;
  GL_ACCUM = $0100;
  GL_LOAD = $0101;
  GL_RETURN = $0102;
  GL_MULT = $0103;
  GL_ADD = $0104;
  GL_NEVER = $0200;
  GL_LESS = $0201;
  GL_EQUAL = $0202;
  GL_LEQUAL = $0203;
  GL_GREATER = $0204;
  GL_NOTEQUAL = $0205;
  GL_GEQUAL = $0206;
  GL_ALWAYS = $0207;
  GL_SRC_COLOR = $0300;
  GL_ONE_MINUS_SRC_COLOR = $0301;
  GL_SRC_ALPHA = $0302;
  GL_ONE_MINUS_SRC_ALPHA = $0303;
  GL_DST_ALPHA = $0304;
  GL_ONE_MINUS_DST_ALPHA = $0305;
  GL_DST_COLOR = $0306;
  GL_ONE_MINUS_DST_COLOR = $0307;
  GL_SRC_ALPHA_SATURATE = $0308;
  GL_SRC_ALPHA_SATURATE_EXT = $0308;
  GL_FRONT_LEFT = $0400;
  GL_FRONT_RIGHT = $0401;
  GL_BACK_LEFT = $0402;
  GL_BACK_RIGHT = $0403;
  GL_FRONT = $0404;
  GL_BACK = $0405;
  GL_LEFT = $0406;
  GL_RIGHT = $0407;
  GL_FRONT_AND_BACK = $0408;
  GL_AUX0 = $0409;
  GL_AUX1 = $040A;
  GL_AUX2 = $040B;
  GL_AUX3 = $040C;
  GL_INVALID_ENUM = $0500;
  GL_INVALID_VALUE = $0501;
  GL_INVALID_OPERATION = $0502;
  GL_STACK_OVERFLOW = $0503;
  GL_STACK_OVERFLOW_KHR = $0503;
  GL_STACK_UNDERFLOW = $0504;
  GL_STACK_UNDERFLOW_KHR = $0504;
  GL_OUT_OF_MEMORY = $0505;
  GL_INVALID_FRAMEBUFFER_OPERATION = $0506;
  GL_INVALID_FRAMEBUFFER_OPERATION_EXT = $0506;
  GL_INVALID_FRAMEBUFFER_OPERATION_OES = $0506;
  GL_CONTEXT_LOST = $0507;
  GL_CONTEXT_LOST_KHR = $0507;
  GL_2D = $0600;
  GL_3D = $0601;
  GL_3D_COLOR = $0602;
  GL_3D_COLOR_TEXTURE = $0603;
  GL_4D_COLOR_TEXTURE = $0604;
  GL_PASS_THROUGH_TOKEN = $0700;
  GL_POINT_TOKEN = $0701;
  GL_LINE_TOKEN = $0702;
  GL_POLYGON_TOKEN = $0703;
  GL_BITMAP_TOKEN = $0704;
  GL_DRAW_PIXEL_TOKEN = $0705;
  GL_COPY_PIXEL_TOKEN = $0706;
  GL_LINE_RESET_TOKEN = $0707;
  GL_EXP = $0800;
  GL_EXP2 = $0801;
  GL_CW = $0900;
  GL_CCW = $0901;
  GL_COEFF = $0A00;
  GL_ORDER = $0A01;
  GL_DOMAIN = $0A02;
  GL_CURRENT_COLOR = $0B00;
  GL_CURRENT_INDEX = $0B01;
  GL_CURRENT_NORMAL = $0B02;
  GL_CURRENT_TEXTURE_COORDS = $0B03;
  GL_CURRENT_RASTER_COLOR = $0B04;
  GL_CURRENT_RASTER_INDEX = $0B05;
  GL_CURRENT_RASTER_TEXTURE_COORDS = $0B06;
  GL_CURRENT_RASTER_POSITION = $0B07;
  GL_CURRENT_RASTER_POSITION_VALID = $0B08;
  GL_CURRENT_RASTER_DISTANCE = $0B09;
  GL_POINT_SMOOTH = $0B10;
  GL_POINT_SIZE = $0B11;
  GL_POINT_SIZE_RANGE = $0B12;
  GL_SMOOTH_POINT_SIZE_RANGE = $0B12;
  GL_POINT_SIZE_GRANULARITY = $0B13;
  GL_SMOOTH_POINT_SIZE_GRANULARITY = $0B13;
  GL_LINE_SMOOTH = $0B20;
  GL_LINE_WIDTH = $0B21;
  GL_LINE_WIDTH_RANGE = $0B22;
  GL_SMOOTH_LINE_WIDTH_RANGE = $0B22;
  GL_LINE_WIDTH_GRANULARITY = $0B23;
  GL_SMOOTH_LINE_WIDTH_GRANULARITY = $0B23;
  GL_LINE_STIPPLE = $0B24;
  GL_LINE_STIPPLE_PATTERN = $0B25;
  GL_LINE_STIPPLE_REPEAT = $0B26;
  GL_LIST_MODE = $0B30;
  GL_MAX_LIST_NESTING = $0B31;
  GL_LIST_BASE = $0B32;
  GL_LIST_INDEX = $0B33;
  GL_POLYGON_MODE = $0B40;
  GL_POLYGON_MODE_NV = $0B40;
  GL_POLYGON_SMOOTH = $0B41;
  GL_POLYGON_STIPPLE = $0B42;
  GL_EDGE_FLAG = $0B43;
  GL_CULL_FACE = $0B44;
  GL_CULL_FACE_MODE = $0B45;
  GL_FRONT_FACE = $0B46;
  GL_LIGHTING = $0B50;
  GL_LIGHT_MODEL_LOCAL_VIEWER = $0B51;
  GL_LIGHT_MODEL_TWO_SIDE = $0B52;
  GL_LIGHT_MODEL_AMBIENT = $0B53;
  GL_SHADE_MODEL = $0B54;
  GL_COLOR_MATERIAL_FACE = $0B55;
  GL_COLOR_MATERIAL_PARAMETER = $0B56;
  GL_COLOR_MATERIAL = $0B57;
  GL_FOG = $0B60;
  GL_FOG_INDEX = $0B61;
  GL_FOG_DENSITY = $0B62;
  GL_FOG_START = $0B63;
  GL_FOG_END = $0B64;
  GL_FOG_MODE = $0B65;
  GL_FOG_COLOR = $0B66;
  GL_DEPTH_RANGE = $0B70;
  GL_DEPTH_TEST = $0B71;
  GL_DEPTH_WRITEMASK = $0B72;
  GL_DEPTH_CLEAR_VALUE = $0B73;
  GL_DEPTH_FUNC = $0B74;
  GL_ACCUM_CLEAR_VALUE = $0B80;
  GL_STENCIL_TEST = $0B90;
  GL_STENCIL_CLEAR_VALUE = $0B91;
  GL_STENCIL_FUNC = $0B92;
  GL_STENCIL_VALUE_MASK = $0B93;
  GL_STENCIL_FAIL = $0B94;
  GL_STENCIL_PASS_DEPTH_FAIL = $0B95;
  GL_STENCIL_PASS_DEPTH_PASS = $0B96;
  GL_STENCIL_REF = $0B97;
  GL_STENCIL_WRITEMASK = $0B98;
  GL_MATRIX_MODE = $0BA0;
  GL_NORMALIZE = $0BA1;
  GL_VIEWPORT = $0BA2;
  GL_MODELVIEW_STACK_DEPTH = $0BA3;
  GL_MODELVIEW0_STACK_DEPTH_EXT = $0BA3;
  GL_PATH_MODELVIEW_STACK_DEPTH_NV = $0BA3;
  GL_PROJECTION_STACK_DEPTH = $0BA4;
  GL_PATH_PROJECTION_STACK_DEPTH_NV = $0BA4;
  GL_TEXTURE_STACK_DEPTH = $0BA5;
  GL_MODELVIEW_MATRIX = $0BA6;
  GL_MODELVIEW0_MATRIX_EXT = $0BA6;
  GL_PATH_MODELVIEW_MATRIX_NV = $0BA6;
  GL_PROJECTION_MATRIX = $0BA7;
  GL_PATH_PROJECTION_MATRIX_NV = $0BA7;
  GL_TEXTURE_MATRIX = $0BA8;
  GL_ATTRIB_STACK_DEPTH = $0BB0;
  GL_CLIENT_ATTRIB_STACK_DEPTH = $0BB1;
  GL_ALPHA_TEST = $0BC0;
  GL_ALPHA_TEST_QCOM = $0BC0;
  GL_ALPHA_TEST_FUNC = $0BC1;
  GL_ALPHA_TEST_FUNC_QCOM = $0BC1;
  GL_ALPHA_TEST_REF = $0BC2;
  GL_ALPHA_TEST_REF_QCOM = $0BC2;
  GL_DITHER = $0BD0;
  GL_BLEND_DST = $0BE0;
  GL_BLEND_SRC = $0BE1;
  GL_BLEND = $0BE2;
  GL_LOGIC_OP_MODE = $0BF0;
  GL_INDEX_LOGIC_OP = $0BF1;
  GL_LOGIC_OP = $0BF1;
  GL_COLOR_LOGIC_OP = $0BF2;
  GL_AUX_BUFFERS = $0C00;
  GL_DRAW_BUFFER = $0C01;
  GL_DRAW_BUFFER_EXT = $0C01;
  GL_READ_BUFFER = $0C02;
  GL_READ_BUFFER_EXT = $0C02;
  GL_READ_BUFFER_NV = $0C02;
  GL_SCISSOR_BOX = $0C10;
  GL_SCISSOR_TEST = $0C11;
  GL_INDEX_CLEAR_VALUE = $0C20;
  GL_INDEX_WRITEMASK = $0C21;
  GL_COLOR_CLEAR_VALUE = $0C22;
  GL_COLOR_WRITEMASK = $0C23;
  GL_INDEX_MODE = $0C30;
  GL_RGBA_MODE = $0C31;
  GL_DOUBLEBUFFER = $0C32;
  GL_STEREO = $0C33;
  GL_RENDER_MODE = $0C40;
  GL_PERSPECTIVE_CORRECTION_HINT = $0C50;
  GL_POINT_SMOOTH_HINT = $0C51;
  GL_LINE_SMOOTH_HINT = $0C52;
  GL_POLYGON_SMOOTH_HINT = $0C53;
  GL_FOG_HINT = $0C54;
  GL_TEXTURE_GEN_S = $0C60;
  GL_TEXTURE_GEN_T = $0C61;
  GL_TEXTURE_GEN_R = $0C62;
  GL_TEXTURE_GEN_Q = $0C63;
  GL_PIXEL_MAP_I_TO_I = $0C70;
  GL_PIXEL_MAP_S_TO_S = $0C71;
  GL_PIXEL_MAP_I_TO_R = $0C72;
  GL_PIXEL_MAP_I_TO_G = $0C73;
  GL_PIXEL_MAP_I_TO_B = $0C74;
  GL_PIXEL_MAP_I_TO_A = $0C75;
  GL_PIXEL_MAP_R_TO_R = $0C76;
  GL_PIXEL_MAP_G_TO_G = $0C77;
  GL_PIXEL_MAP_B_TO_B = $0C78;
  GL_PIXEL_MAP_A_TO_A = $0C79;
  GL_PIXEL_MAP_I_TO_I_SIZE = $0CB0;
  GL_PIXEL_MAP_S_TO_S_SIZE = $0CB1;
  GL_PIXEL_MAP_I_TO_R_SIZE = $0CB2;
  GL_PIXEL_MAP_I_TO_G_SIZE = $0CB3;
  GL_PIXEL_MAP_I_TO_B_SIZE = $0CB4;
  GL_PIXEL_MAP_I_TO_A_SIZE = $0CB5;
  GL_PIXEL_MAP_R_TO_R_SIZE = $0CB6;
  GL_PIXEL_MAP_G_TO_G_SIZE = $0CB7;
  GL_PIXEL_MAP_B_TO_B_SIZE = $0CB8;
  GL_PIXEL_MAP_A_TO_A_SIZE = $0CB9;
  GL_UNPACK_SWAP_BYTES = $0CF0;
  GL_UNPACK_LSB_FIRST = $0CF1;
  GL_UNPACK_ROW_LENGTH = $0CF2;
  GL_UNPACK_ROW_LENGTH_EXT = $0CF2;
  GL_UNPACK_SKIP_ROWS = $0CF3;
  GL_UNPACK_SKIP_ROWS_EXT = $0CF3;
  GL_UNPACK_SKIP_PIXELS = $0CF4;
  GL_UNPACK_SKIP_PIXELS_EXT = $0CF4;
  GL_UNPACK_ALIGNMENT = $0CF5;
  GL_PACK_SWAP_BYTES = $0D00;
  GL_PACK_LSB_FIRST = $0D01;
  GL_PACK_ROW_LENGTH = $0D02;
  GL_PACK_ROW_LENGTH_NV = $0D02;
  GL_PACK_SKIP_ROWS = $0D03;
  GL_PACK_SKIP_ROWS_NV = $0D03;
  GL_PACK_SKIP_PIXELS = $0D04;
  GL_PACK_SKIP_PIXELS_NV = $0D04;
  GL_PACK_ALIGNMENT = $0D05;
  GL_MAP_COLOR = $0D10;
  GL_MAP_STENCIL = $0D11;
  GL_INDEX_SHIFT = $0D12;
  GL_INDEX_OFFSET = $0D13;
  GL_RED_SCALE = $0D14;
  GL_RED_BIAS = $0D15;
  GL_ZOOM_X = $0D16;
  GL_ZOOM_Y = $0D17;
  GL_GREEN_SCALE = $0D18;
  GL_GREEN_BIAS = $0D19;
  GL_BLUE_SCALE = $0D1A;
  GL_BLUE_BIAS = $0D1B;
  GL_ALPHA_SCALE = $0D1C;
  GL_ALPHA_BIAS = $0D1D;
  GL_DEPTH_SCALE = $0D1E;
  GL_DEPTH_BIAS = $0D1F;
  GL_MAX_EVAL_ORDER = $0D30;
  GL_MAX_LIGHTS = $0D31;
  GL_MAX_CLIP_PLANES = $0D32;
  GL_MAX_CLIP_PLANES_IMG = $0D32;
  GL_MAX_CLIP_DISTANCES = $0D32;
  GL_MAX_CLIP_DISTANCES_EXT = $0D32;
  GL_MAX_CLIP_DISTANCES_APPLE = $0D32;
  GL_MAX_TEXTURE_SIZE = $0D33;
  GL_MAX_PIXEL_MAP_TABLE = $0D34;
  GL_MAX_ATTRIB_STACK_DEPTH = $0D35;
  GL_MAX_MODELVIEW_STACK_DEPTH = $0D36;
  GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV = $0D36;
  GL_MAX_NAME_STACK_DEPTH = $0D37;
  GL_MAX_PROJECTION_STACK_DEPTH = $0D38;
  GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV = $0D38;
  GL_MAX_TEXTURE_STACK_DEPTH = $0D39;
  GL_MAX_VIEWPORT_DIMS = $0D3A;
  GL_MAX_CLIENT_ATTRIB_STACK_DEPTH = $0D3B;
  GL_SUBPIXEL_BITS = $0D50;
  GL_INDEX_BITS = $0D51;
  GL_RED_BITS = $0D52;
  GL_GREEN_BITS = $0D53;
  GL_BLUE_BITS = $0D54;
  GL_ALPHA_BITS = $0D55;
  GL_DEPTH_BITS = $0D56;
  GL_STENCIL_BITS = $0D57;
  GL_ACCUM_RED_BITS = $0D58;
  GL_ACCUM_GREEN_BITS = $0D59;
  GL_ACCUM_BLUE_BITS = $0D5A;
  GL_ACCUM_ALPHA_BITS = $0D5B;
  GL_NAME_STACK_DEPTH = $0D70;
  GL_AUTO_NORMAL = $0D80;
  GL_MAP1_COLOR_4 = $0D90;
  GL_MAP1_INDEX = $0D91;
  GL_MAP1_NORMAL = $0D92;
  GL_MAP1_TEXTURE_COORD_1 = $0D93;
  GL_MAP1_TEXTURE_COORD_2 = $0D94;
  GL_MAP1_TEXTURE_COORD_3 = $0D95;
  GL_MAP1_TEXTURE_COORD_4 = $0D96;
  GL_MAP1_VERTEX_3 = $0D97;
  GL_MAP1_VERTEX_4 = $0D98;
  GL_MAP2_COLOR_4 = $0DB0;
  GL_MAP2_INDEX = $0DB1;
  GL_MAP2_NORMAL = $0DB2;
  GL_MAP2_TEXTURE_COORD_1 = $0DB3;
  GL_MAP2_TEXTURE_COORD_2 = $0DB4;
  GL_MAP2_TEXTURE_COORD_3 = $0DB5;
  GL_MAP2_TEXTURE_COORD_4 = $0DB6;
  GL_MAP2_VERTEX_3 = $0DB7;
  GL_MAP2_VERTEX_4 = $0DB8;
  GL_MAP1_GRID_DOMAIN = $0DD0;
  GL_MAP1_GRID_SEGMENTS = $0DD1;
  GL_MAP2_GRID_DOMAIN = $0DD2;
  GL_MAP2_GRID_SEGMENTS = $0DD3;
  GL_TEXTURE_1D = $0DE0;
  GL_TEXTURE_2D = $0DE1;
  GL_FEEDBACK_BUFFER_POINTER = $0DF0;
  GL_FEEDBACK_BUFFER_SIZE = $0DF1;
  GL_FEEDBACK_BUFFER_TYPE = $0DF2;
  GL_SELECTION_BUFFER_POINTER = $0DF3;
  GL_SELECTION_BUFFER_SIZE = $0DF4;
  GL_TEXTURE_WIDTH = $1000;
  GL_TEXTURE_HEIGHT = $1001;
  GL_TEXTURE_INTERNAL_FORMAT = $1003;
  GL_TEXTURE_COMPONENTS = $1003;
  GL_TEXTURE_BORDER_COLOR = $1004;
  GL_TEXTURE_BORDER_COLOR_EXT = $1004;
  GL_TEXTURE_BORDER_COLOR_NV = $1004;
  GL_TEXTURE_BORDER_COLOR_OES = $1004;
  GL_TEXTURE_BORDER = $1005;
  GL_TEXTURE_TARGET = $1006;
  GL_DONT_CARE = $1100;
  GL_FASTEST = $1101;
  GL_NICEST = $1102;
  GL_AMBIENT = $1200;
  GL_DIFFUSE = $1201;
  GL_SPECULAR = $1202;
  GL_POSITION = $1203;
  GL_SPOT_DIRECTION = $1204;
  GL_SPOT_EXPONENT = $1205;
  GL_SPOT_CUTOFF = $1206;
  GL_CONSTANT_ATTENUATION = $1207;
  GL_LINEAR_ATTENUATION = $1208;
  GL_QUADRATIC_ATTENUATION = $1209;
  GL_COMPILE = $1300;
  GL_COMPILE_AND_EXECUTE = $1301;
  GL_BYTE = $1400;
  GL_UNSIGNED_BYTE = $1401;
  GL_SHORT = $1402;
  GL_UNSIGNED_SHORT = $1403;
  GL_INT = $1404;
  GL_UNSIGNED_INT = $1405;
  GL_FLOAT = $1406;
  GL_2_BYTES = $1407;
  GL_2_BYTES_NV = $1407;
  GL_3_BYTES = $1408;
  GL_3_BYTES_NV = $1408;
  GL_4_BYTES = $1409;
  GL_4_BYTES_NV = $1409;
  GL_DOUBLE = $140A;
  GL_DOUBLE_EXT = $140A;
  GL_HALF_FLOAT = $140B;
  GL_HALF_FLOAT_ARB = $140B;
  GL_HALF_FLOAT_NV = $140B;
  GL_HALF_APPLE = $140B;
  GL_FIXED = $140C;
  GL_FIXED_OES = $140C;
  GL_INT64_ARB = $140E;
  GL_INT64_NV = $140E;
  GL_UNSIGNED_INT64_ARB = $140F;
  GL_UNSIGNED_INT64_NV = $140F;
  GL_CLEAR = $1500;
  GL_AND = $1501;
  GL_AND_REVERSE = $1502;
  GL_COPY = $1503;
  GL_AND_INVERTED = $1504;
  GL_NOOP = $1505;
  GL_XOR = $1506;
  GL_XOR_NV = $1506;
  GL_OR = $1507;
  GL_NOR = $1508;
  GL_EQUIV = $1509;
  GL_INVERT = $150A;
  GL_OR_REVERSE = $150B;
  GL_COPY_INVERTED = $150C;
  GL_OR_INVERTED = $150D;
  GL_NAND = $150E;
  GL_SET = $150F;
  GL_EMISSION = $1600;
  GL_SHININESS = $1601;
  GL_AMBIENT_AND_DIFFUSE = $1602;
  GL_COLOR_INDEXES = $1603;
  GL_MODELVIEW = $1700;
  GL_MODELVIEW0_ARB = $1700;
  GL_MODELVIEW0_EXT = $1700;
  GL_PATH_MODELVIEW_NV = $1700;
  GL_PROJECTION = $1701;
  GL_PATH_PROJECTION_NV = $1701;
  GL_TEXTURE = $1702;
  GL_COLOR = $1800;
  GL_COLOR_EXT = $1800;
  GL_DEPTH = $1801;
  GL_DEPTH_EXT = $1801;
  GL_STENCIL = $1802;
  GL_STENCIL_EXT = $1802;
  GL_COLOR_INDEX = $1900;
  GL_STENCIL_INDEX = $1901;
  GL_STENCIL_INDEX_OES = $1901;
  GL_DEPTH_COMPONENT = $1902;
  GL_RED = $1903;
  GL_RED_EXT = $1903;
  GL_RED_NV = $1903;
  GL_GREEN = $1904;
  GL_GREEN_NV = $1904;
  GL_BLUE = $1905;
  GL_BLUE_NV = $1905;
  GL_ALPHA = $1906;
  GL_RGB = $1907;
  GL_RGBA = $1908;
  GL_LUMINANCE = $1909;
  GL_LUMINANCE_ALPHA = $190A;
  GL_BITMAP = $1A00;
  GL_POINT = $1B00;
  GL_POINT_NV = $1B00;
  GL_LINE = $1B01;
  GL_LINE_NV = $1B01;
  GL_FILL = $1B02;
  GL_FILL_NV = $1B02;
  GL_RENDER = $1C00;
  GL_FEEDBACK = $1C01;
  GL_SELECT = $1C02;
  GL_FLAT = $1D00;
  GL_SMOOTH = $1D01;
  GL_KEEP = $1E00;
  GL_REPLACE = $1E01;
  GL_INCR = $1E02;
  GL_DECR = $1E03;
  GL_VENDOR = $1F00;
  GL_RENDERER = $1F01;
  GL_VERSION = $1F02;
  GL_EXTENSIONS = $1F03;
  GL_S = $2000;
  GL_T = $2001;
  GL_R = $2002;
  GL_Q = $2003;
  GL_MODULATE = $2100;
  GL_DECAL = $2101;
  GL_TEXTURE_ENV_MODE = $2200;
  GL_TEXTURE_ENV_COLOR = $2201;
  GL_TEXTURE_ENV = $2300;
  GL_EYE_LINEAR = $2400;
  GL_EYE_LINEAR_NV = $2400;
  GL_OBJECT_LINEAR = $2401;
  GL_OBJECT_LINEAR_NV = $2401;
  GL_SPHERE_MAP = $2402;
  GL_TEXTURE_GEN_MODE = $2500;
  GL_TEXTURE_GEN_MODE_OES = $2500;
  GL_OBJECT_PLANE = $2501;
  GL_EYE_PLANE = $2502;
  GL_NEAREST = $2600;
  GL_LINEAR = $2601;
  GL_NEAREST_MIPMAP_NEAREST = $2700;
  GL_LINEAR_MIPMAP_NEAREST = $2701;
  GL_NEAREST_MIPMAP_LINEAR = $2702;
  GL_LINEAR_MIPMAP_LINEAR = $2703;
  GL_TEXTURE_MAG_FILTER = $2800;
  GL_TEXTURE_MIN_FILTER = $2801;
  GL_TEXTURE_WRAP_S = $2802;
  GL_TEXTURE_WRAP_T = $2803;
  GL_CLAMP = $2900;
  GL_REPEAT = $2901;
  GL_POLYGON_OFFSET_UNITS = $2A00;
  GL_POLYGON_OFFSET_POINT = $2A01;
  GL_POLYGON_OFFSET_POINT_NV = $2A01;
  GL_POLYGON_OFFSET_LINE = $2A02;
  GL_POLYGON_OFFSET_LINE_NV = $2A02;
  GL_R3_G3_B2 = $2A10;
  GL_V2F = $2A20;
  GL_V3F = $2A21;
  GL_C4UB_V2F = $2A22;
  GL_C4UB_V3F = $2A23;
  GL_C3F_V3F = $2A24;
  GL_N3F_V3F = $2A25;
  GL_C4F_N3F_V3F = $2A26;
  GL_T2F_V3F = $2A27;
  GL_T4F_V4F = $2A28;
  GL_T2F_C4UB_V3F = $2A29;
  GL_T2F_C3F_V3F = $2A2A;
  GL_T2F_N3F_V3F = $2A2B;
  GL_T2F_C4F_N3F_V3F = $2A2C;
  GL_T4F_C4F_N3F_V4F = $2A2D;
  GL_CLIP_PLANE0 = $3000;
  GL_CLIP_PLANE0_IMG = $3000;
  GL_CLIP_DISTANCE0 = $3000;
  GL_CLIP_DISTANCE0_EXT = $3000;
  GL_CLIP_DISTANCE0_APPLE = $3000;
  GL_CLIP_PLANE1 = $3001;
  GL_CLIP_PLANE1_IMG = $3001;
  GL_CLIP_DISTANCE1 = $3001;
  GL_CLIP_DISTANCE1_EXT = $3001;
  GL_CLIP_DISTANCE1_APPLE = $3001;
  GL_CLIP_PLANE2 = $3002;
  GL_CLIP_PLANE2_IMG = $3002;
  GL_CLIP_DISTANCE2 = $3002;
  GL_CLIP_DISTANCE2_EXT = $3002;
  GL_CLIP_DISTANCE2_APPLE = $3002;
  GL_CLIP_PLANE3 = $3003;
  GL_CLIP_PLANE3_IMG = $3003;
  GL_CLIP_DISTANCE3 = $3003;
  GL_CLIP_DISTANCE3_EXT = $3003;
  GL_CLIP_DISTANCE3_APPLE = $3003;
  GL_CLIP_PLANE4 = $3004;
  GL_CLIP_PLANE4_IMG = $3004;
  GL_CLIP_DISTANCE4 = $3004;
  GL_CLIP_DISTANCE4_EXT = $3004;
  GL_CLIP_DISTANCE4_APPLE = $3004;
  GL_CLIP_PLANE5 = $3005;
  GL_CLIP_PLANE5_IMG = $3005;
  GL_CLIP_DISTANCE5 = $3005;
  GL_CLIP_DISTANCE5_EXT = $3005;
  GL_CLIP_DISTANCE5_APPLE = $3005;
  GL_CLIP_DISTANCE6 = $3006;
  GL_CLIP_DISTANCE6_EXT = $3006;
  GL_CLIP_DISTANCE6_APPLE = $3006;
  GL_CLIP_DISTANCE7 = $3007;
  GL_CLIP_DISTANCE7_EXT = $3007;
  GL_CLIP_DISTANCE7_APPLE = $3007;
  GL_LIGHT0 = $4000;
  GL_LIGHT1 = $4001;
  GL_LIGHT2 = $4002;
  GL_LIGHT3 = $4003;
  GL_LIGHT4 = $4004;
  GL_LIGHT5 = $4005;
  GL_LIGHT6 = $4006;
  GL_LIGHT7 = $4007;
  GL_ABGR_EXT = $8000;
  GL_CONSTANT_COLOR = $8001;
  GL_CONSTANT_COLOR_EXT = $8001;
  GL_ONE_MINUS_CONSTANT_COLOR = $8002;
  GL_ONE_MINUS_CONSTANT_COLOR_EXT = $8002;
  GL_CONSTANT_ALPHA = $8003;
  GL_CONSTANT_ALPHA_EXT = $8003;
  GL_ONE_MINUS_CONSTANT_ALPHA = $8004;
  GL_ONE_MINUS_CONSTANT_ALPHA_EXT = $8004;
  GL_BLEND_COLOR = $8005;
  GL_BLEND_COLOR_EXT = $8005;
  GL_FUNC_ADD = $8006;
  GL_FUNC_ADD_EXT = $8006;
  GL_FUNC_ADD_OES = $8006;
  GL_MIN = $8007;
  GL_MIN_EXT = $8007;
  GL_MAX = $8008;
  GL_MAX_EXT = $8008;
  GL_BLEND_EQUATION = $8009;
  GL_BLEND_EQUATION_EXT = $8009;
  GL_BLEND_EQUATION_OES = $8009;
  GL_BLEND_EQUATION_RGB = $8009;
  GL_BLEND_EQUATION_RGB_EXT = $8009;
  GL_BLEND_EQUATION_RGB_OES = $8009;
  GL_FUNC_SUBTRACT = $800A;
  GL_FUNC_SUBTRACT_EXT = $800A;
  GL_FUNC_SUBTRACT_OES = $800A;
  GL_FUNC_REVERSE_SUBTRACT = $800B;
  GL_FUNC_REVERSE_SUBTRACT_EXT = $800B;
  GL_FUNC_REVERSE_SUBTRACT_OES = $800B;
  GL_CMYK_EXT = $800C;
  GL_CMYKA_EXT = $800D;
  GL_PACK_CMYK_HINT_EXT = $800E;
  GL_UNPACK_CMYK_HINT_EXT = $800F;
  GL_CONVOLUTION_1D = $8010;
  GL_CONVOLUTION_1D_EXT = $8010;
  GL_CONVOLUTION_2D = $8011;
  GL_CONVOLUTION_2D_EXT = $8011;
  GL_SEPARABLE_2D = $8012;
  GL_SEPARABLE_2D_EXT = $8012;
  GL_CONVOLUTION_BORDER_MODE = $8013;
  GL_CONVOLUTION_BORDER_MODE_EXT = $8013;
  GL_CONVOLUTION_FILTER_SCALE = $8014;
  GL_CONVOLUTION_FILTER_SCALE_EXT = $8014;
  GL_CONVOLUTION_FILTER_BIAS = $8015;
  GL_CONVOLUTION_FILTER_BIAS_EXT = $8015;
  GL_REDUCE = $8016;
  GL_REDUCE_EXT = $8016;
  GL_CONVOLUTION_FORMAT = $8017;
  GL_CONVOLUTION_FORMAT_EXT = $8017;
  GL_CONVOLUTION_WIDTH = $8018;
  GL_CONVOLUTION_WIDTH_EXT = $8018;
  GL_CONVOLUTION_HEIGHT = $8019;
  GL_CONVOLUTION_HEIGHT_EXT = $8019;
  GL_MAX_CONVOLUTION_WIDTH = $801A;
  GL_MAX_CONVOLUTION_WIDTH_EXT = $801A;
  GL_MAX_CONVOLUTION_HEIGHT = $801B;
  GL_MAX_CONVOLUTION_HEIGHT_EXT = $801B;
  GL_POST_CONVOLUTION_RED_SCALE = $801C;
  GL_POST_CONVOLUTION_RED_SCALE_EXT = $801C;
  GL_POST_CONVOLUTION_GREEN_SCALE = $801D;
  GL_POST_CONVOLUTION_GREEN_SCALE_EXT = $801D;
  GL_POST_CONVOLUTION_BLUE_SCALE = $801E;
  GL_POST_CONVOLUTION_BLUE_SCALE_EXT = $801E;
  GL_POST_CONVOLUTION_ALPHA_SCALE = $801F;
  GL_POST_CONVOLUTION_ALPHA_SCALE_EXT = $801F;
  GL_POST_CONVOLUTION_RED_BIAS = $8020;
  GL_POST_CONVOLUTION_RED_BIAS_EXT = $8020;
  GL_POST_CONVOLUTION_GREEN_BIAS = $8021;
  GL_POST_CONVOLUTION_GREEN_BIAS_EXT = $8021;
  GL_POST_CONVOLUTION_BLUE_BIAS = $8022;
  GL_POST_CONVOLUTION_BLUE_BIAS_EXT = $8022;
  GL_POST_CONVOLUTION_ALPHA_BIAS = $8023;
  GL_POST_CONVOLUTION_ALPHA_BIAS_EXT = $8023;
  GL_HISTOGRAM = $8024;
  GL_HISTOGRAM_EXT = $8024;
  GL_PROXY_HISTOGRAM = $8025;
  GL_PROXY_HISTOGRAM_EXT = $8025;
  GL_HISTOGRAM_WIDTH = $8026;
  GL_HISTOGRAM_WIDTH_EXT = $8026;
  GL_HISTOGRAM_FORMAT = $8027;
  GL_HISTOGRAM_FORMAT_EXT = $8027;
  GL_HISTOGRAM_RED_SIZE = $8028;
  GL_HISTOGRAM_RED_SIZE_EXT = $8028;
  GL_HISTOGRAM_GREEN_SIZE = $8029;
  GL_HISTOGRAM_GREEN_SIZE_EXT = $8029;
  GL_HISTOGRAM_BLUE_SIZE = $802A;
  GL_HISTOGRAM_BLUE_SIZE_EXT = $802A;
  GL_HISTOGRAM_ALPHA_SIZE = $802B;
  GL_HISTOGRAM_ALPHA_SIZE_EXT = $802B;
  GL_HISTOGRAM_LUMINANCE_SIZE = $802C;
  GL_HISTOGRAM_LUMINANCE_SIZE_EXT = $802C;
  GL_HISTOGRAM_SINK = $802D;
  GL_HISTOGRAM_SINK_EXT = $802D;
  GL_MINMAX = $802E;
  GL_MINMAX_EXT = $802E;
  GL_MINMAX_FORMAT = $802F;
  GL_MINMAX_FORMAT_EXT = $802F;
  GL_MINMAX_SINK = $8030;
  GL_MINMAX_SINK_EXT = $8030;
  GL_TABLE_TOO_LARGE_EXT = $8031;
  GL_TABLE_TOO_LARGE = $8031;
  GL_UNSIGNED_BYTE_3_3_2 = $8032;
  GL_UNSIGNED_BYTE_3_3_2_EXT = $8032;
  GL_UNSIGNED_SHORT_4_4_4_4 = $8033;
  GL_UNSIGNED_SHORT_4_4_4_4_EXT = $8033;
  GL_UNSIGNED_SHORT_5_5_5_1 = $8034;
  GL_UNSIGNED_SHORT_5_5_5_1_EXT = $8034;
  GL_UNSIGNED_INT_8_8_8_8 = $8035;
  GL_UNSIGNED_INT_8_8_8_8_EXT = $8035;
  GL_UNSIGNED_INT_10_10_10_2 = $8036;
  GL_UNSIGNED_INT_10_10_10_2_EXT = $8036;
  GL_POLYGON_OFFSET_EXT = $8037;
  GL_POLYGON_OFFSET_FILL = $8037;
  GL_POLYGON_OFFSET_FACTOR = $8038;
  GL_POLYGON_OFFSET_FACTOR_EXT = $8038;
  GL_POLYGON_OFFSET_BIAS_EXT = $8039;
  GL_RESCALE_NORMAL = $803A;
  GL_RESCALE_NORMAL_EXT = $803A;
  GL_ALPHA4 = $803B;
  GL_ALPHA4_EXT = $803B;
  GL_ALPHA8 = $803C;
  GL_ALPHA8_EXT = $803C;
  GL_ALPHA8_OES = $803C;
  GL_ALPHA12 = $803D;
  GL_ALPHA12_EXT = $803D;
  GL_ALPHA16 = $803E;
  GL_ALPHA16_EXT = $803E;
  GL_LUMINANCE4 = $803F;
  GL_LUMINANCE4_EXT = $803F;
  GL_LUMINANCE8 = $8040;
  GL_LUMINANCE8_EXT = $8040;
  GL_LUMINANCE8_OES = $8040;
  GL_LUMINANCE12 = $8041;
  GL_LUMINANCE12_EXT = $8041;
  GL_LUMINANCE16 = $8042;
  GL_LUMINANCE16_EXT = $8042;
  GL_LUMINANCE4_ALPHA4 = $8043;
  GL_LUMINANCE4_ALPHA4_EXT = $8043;
  GL_LUMINANCE4_ALPHA4_OES = $8043;
  GL_LUMINANCE6_ALPHA2 = $8044;
  GL_LUMINANCE6_ALPHA2_EXT = $8044;
  GL_LUMINANCE8_ALPHA8 = $8045;
  GL_LUMINANCE8_ALPHA8_EXT = $8045;
  GL_LUMINANCE8_ALPHA8_OES = $8045;
  GL_LUMINANCE12_ALPHA4 = $8046;
  GL_LUMINANCE12_ALPHA4_EXT = $8046;
  GL_LUMINANCE12_ALPHA12 = $8047;
  GL_LUMINANCE12_ALPHA12_EXT = $8047;
  GL_LUMINANCE16_ALPHA16 = $8048;
  GL_LUMINANCE16_ALPHA16_EXT = $8048;
  GL_INTENSITY = $8049;
  GL_INTENSITY_EXT = $8049;
  GL_INTENSITY4 = $804A;
  GL_INTENSITY4_EXT = $804A;
  GL_INTENSITY8 = $804B;
  GL_INTENSITY8_EXT = $804B;
  GL_INTENSITY12 = $804C;
  GL_INTENSITY12_EXT = $804C;
  GL_INTENSITY16 = $804D;
  GL_INTENSITY16_EXT = $804D;
  GL_RGB2_EXT = $804E;
  GL_RGB4 = $804F;
  GL_RGB4_EXT = $804F;
  GL_RGB5 = $8050;
  GL_RGB5_EXT = $8050;
  GL_RGB8 = $8051;
  GL_RGB8_EXT = $8051;
  GL_RGB8_OES = $8051;
  GL_RGB10 = $8052;
  GL_RGB10_EXT = $8052;
  GL_RGB12 = $8053;
  GL_RGB12_EXT = $8053;
  GL_RGB16 = $8054;
  GL_RGB16_EXT = $8054;
  GL_RGBA2 = $8055;
  GL_RGBA2_EXT = $8055;
  GL_RGBA4 = $8056;
  GL_RGBA4_EXT = $8056;
  GL_RGBA4_OES = $8056;
  GL_RGB5_A1 = $8057;
  GL_RGB5_A1_EXT = $8057;
  GL_RGB5_A1_OES = $8057;
  GL_RGBA8 = $8058;
  GL_RGBA8_EXT = $8058;
  GL_RGBA8_OES = $8058;
  GL_RGB10_A2 = $8059;
  GL_RGB10_A2_EXT = $8059;
  GL_RGBA12 = $805A;
  GL_RGBA12_EXT = $805A;
  GL_RGBA16 = $805B;
  GL_RGBA16_EXT = $805B;
  GL_TEXTURE_RED_SIZE = $805C;
  GL_TEXTURE_RED_SIZE_EXT = $805C;
  GL_TEXTURE_GREEN_SIZE = $805D;
  GL_TEXTURE_GREEN_SIZE_EXT = $805D;
  GL_TEXTURE_BLUE_SIZE = $805E;
  GL_TEXTURE_BLUE_SIZE_EXT = $805E;
  GL_TEXTURE_ALPHA_SIZE = $805F;
  GL_TEXTURE_ALPHA_SIZE_EXT = $805F;
  GL_TEXTURE_LUMINANCE_SIZE = $8060;
  GL_TEXTURE_LUMINANCE_SIZE_EXT = $8060;
  GL_TEXTURE_INTENSITY_SIZE = $8061;
  GL_TEXTURE_INTENSITY_SIZE_EXT = $8061;
  GL_REPLACE_EXT = $8062;
  GL_PROXY_TEXTURE_1D = $8063;
  GL_PROXY_TEXTURE_1D_EXT = $8063;
  GL_PROXY_TEXTURE_2D = $8064;
  GL_PROXY_TEXTURE_2D_EXT = $8064;
  GL_TEXTURE_TOO_LARGE_EXT = $8065;
  GL_TEXTURE_PRIORITY = $8066;
  GL_TEXTURE_PRIORITY_EXT = $8066;
  GL_TEXTURE_RESIDENT = $8067;
  GL_TEXTURE_RESIDENT_EXT = $8067;
  GL_TEXTURE_1D_BINDING_EXT = $8068;
  GL_TEXTURE_BINDING_1D = $8068;
  GL_TEXTURE_2D_BINDING_EXT = $8069;
  GL_TEXTURE_BINDING_2D = $8069;
  GL_TEXTURE_3D_BINDING_EXT = $806A;
  GL_TEXTURE_3D_BINDING_OES = $806A;
  GL_TEXTURE_BINDING_3D = $806A;
  GL_TEXTURE_BINDING_3D_OES = $806A;
  GL_PACK_SKIP_IMAGES = $806B;
  GL_PACK_SKIP_IMAGES_EXT = $806B;
  GL_PACK_IMAGE_HEIGHT = $806C;
  GL_PACK_IMAGE_HEIGHT_EXT = $806C;
  GL_UNPACK_SKIP_IMAGES = $806D;
  GL_UNPACK_SKIP_IMAGES_EXT = $806D;
  GL_UNPACK_IMAGE_HEIGHT = $806E;
  GL_UNPACK_IMAGE_HEIGHT_EXT = $806E;
  GL_TEXTURE_3D = $806F;
  GL_TEXTURE_3D_EXT = $806F;
  GL_TEXTURE_3D_OES = $806F;
  GL_PROXY_TEXTURE_3D = $8070;
  GL_PROXY_TEXTURE_3D_EXT = $8070;
  GL_TEXTURE_DEPTH = $8071;
  GL_TEXTURE_DEPTH_EXT = $8071;
  GL_TEXTURE_WRAP_R = $8072;
  GL_TEXTURE_WRAP_R_EXT = $8072;
  GL_TEXTURE_WRAP_R_OES = $8072;
  GL_MAX_3D_TEXTURE_SIZE = $8073;
  GL_MAX_3D_TEXTURE_SIZE_EXT = $8073;
  GL_MAX_3D_TEXTURE_SIZE_OES = $8073;
  GL_VERTEX_ARRAY = $8074;
  GL_VERTEX_ARRAY_EXT = $8074;
  GL_VERTEX_ARRAY_KHR = $8074;
  GL_NORMAL_ARRAY = $8075;
  GL_NORMAL_ARRAY_EXT = $8075;
  GL_COLOR_ARRAY = $8076;
  GL_COLOR_ARRAY_EXT = $8076;
  GL_INDEX_ARRAY = $8077;
  GL_INDEX_ARRAY_EXT = $8077;
  GL_TEXTURE_COORD_ARRAY = $8078;
  GL_TEXTURE_COORD_ARRAY_EXT = $8078;
  GL_EDGE_FLAG_ARRAY = $8079;
  GL_EDGE_FLAG_ARRAY_EXT = $8079;
  GL_VERTEX_ARRAY_SIZE = $807A;
  GL_VERTEX_ARRAY_SIZE_EXT = $807A;
  GL_VERTEX_ARRAY_TYPE = $807B;
  GL_VERTEX_ARRAY_TYPE_EXT = $807B;
  GL_VERTEX_ARRAY_STRIDE = $807C;
  GL_VERTEX_ARRAY_STRIDE_EXT = $807C;
  GL_VERTEX_ARRAY_COUNT_EXT = $807D;
  GL_NORMAL_ARRAY_TYPE = $807E;
  GL_NORMAL_ARRAY_TYPE_EXT = $807E;
  GL_NORMAL_ARRAY_STRIDE = $807F;
  GL_NORMAL_ARRAY_STRIDE_EXT = $807F;
  GL_NORMAL_ARRAY_COUNT_EXT = $8080;
  GL_COLOR_ARRAY_SIZE = $8081;
  GL_COLOR_ARRAY_SIZE_EXT = $8081;
  GL_COLOR_ARRAY_TYPE = $8082;
  GL_COLOR_ARRAY_TYPE_EXT = $8082;
  GL_COLOR_ARRAY_STRIDE = $8083;
  GL_COLOR_ARRAY_STRIDE_EXT = $8083;
  GL_COLOR_ARRAY_COUNT_EXT = $8084;
  GL_INDEX_ARRAY_TYPE = $8085;
  GL_INDEX_ARRAY_TYPE_EXT = $8085;
  GL_INDEX_ARRAY_STRIDE = $8086;
  GL_INDEX_ARRAY_STRIDE_EXT = $8086;
  GL_INDEX_ARRAY_COUNT_EXT = $8087;
  GL_TEXTURE_COORD_ARRAY_SIZE = $8088;
  GL_TEXTURE_COORD_ARRAY_SIZE_EXT = $8088;
  GL_TEXTURE_COORD_ARRAY_TYPE = $8089;
  GL_TEXTURE_COORD_ARRAY_TYPE_EXT = $8089;
  GL_TEXTURE_COORD_ARRAY_STRIDE = $808A;
  GL_TEXTURE_COORD_ARRAY_STRIDE_EXT = $808A;
  GL_TEXTURE_COORD_ARRAY_COUNT_EXT = $808B;
  GL_EDGE_FLAG_ARRAY_STRIDE = $808C;
  GL_EDGE_FLAG_ARRAY_STRIDE_EXT = $808C;
  GL_EDGE_FLAG_ARRAY_COUNT_EXT = $808D;
  GL_VERTEX_ARRAY_POINTER = $808E;
  GL_VERTEX_ARRAY_POINTER_EXT = $808E;
  GL_NORMAL_ARRAY_POINTER = $808F;
  GL_NORMAL_ARRAY_POINTER_EXT = $808F;
  GL_COLOR_ARRAY_POINTER = $8090;
  GL_COLOR_ARRAY_POINTER_EXT = $8090;
  GL_INDEX_ARRAY_POINTER = $8091;
  GL_INDEX_ARRAY_POINTER_EXT = $8091;
  GL_TEXTURE_COORD_ARRAY_POINTER = $8092;
  GL_TEXTURE_COORD_ARRAY_POINTER_EXT = $8092;
  GL_EDGE_FLAG_ARRAY_POINTER = $8093;
  GL_EDGE_FLAG_ARRAY_POINTER_EXT = $8093;
  GL_INTERLACE_SGIX = $8094;
  GL_DETAIL_TEXTURE_2D_SGIS = $8095;
  GL_DETAIL_TEXTURE_2D_BINDING_SGIS = $8096;
  GL_LINEAR_DETAIL_SGIS = $8097;
  GL_LINEAR_DETAIL_ALPHA_SGIS = $8098;
  GL_LINEAR_DETAIL_COLOR_SGIS = $8099;
  GL_DETAIL_TEXTURE_LEVEL_SGIS = $809A;
  GL_DETAIL_TEXTURE_MODE_SGIS = $809B;
  GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS = $809C;
  GL_MULTISAMPLE = $809D;
  GL_MULTISAMPLE_ARB = $809D;
  GL_MULTISAMPLE_EXT = $809D;
  GL_MULTISAMPLE_SGIS = $809D;
  GL_SAMPLE_ALPHA_TO_COVERAGE = $809E;
  GL_SAMPLE_ALPHA_TO_COVERAGE_ARB = $809E;
  GL_SAMPLE_ALPHA_TO_MASK_EXT = $809E;
  GL_SAMPLE_ALPHA_TO_MASK_SGIS = $809E;
  GL_SAMPLE_ALPHA_TO_ONE = $809F;
  GL_SAMPLE_ALPHA_TO_ONE_ARB = $809F;
  GL_SAMPLE_ALPHA_TO_ONE_EXT = $809F;
  GL_SAMPLE_ALPHA_TO_ONE_SGIS = $809F;
  GL_SAMPLE_COVERAGE = $80A0;
  GL_SAMPLE_COVERAGE_ARB = $80A0;
  GL_SAMPLE_MASK_EXT = $80A0;
  GL_SAMPLE_MASK_SGIS = $80A0;
  GL_1PASS_EXT = $80A1;
  GL_1PASS_SGIS = $80A1;
  GL_2PASS_0_EXT = $80A2;
  GL_2PASS_0_SGIS = $80A2;
  GL_2PASS_1_EXT = $80A3;
  GL_2PASS_1_SGIS = $80A3;
  GL_4PASS_0_EXT = $80A4;
  GL_4PASS_0_SGIS = $80A4;
  GL_4PASS_1_EXT = $80A5;
  GL_4PASS_1_SGIS = $80A5;
  GL_4PASS_2_EXT = $80A6;
  GL_4PASS_2_SGIS = $80A6;
  GL_4PASS_3_EXT = $80A7;
  GL_4PASS_3_SGIS = $80A7;
  GL_SAMPLE_BUFFERS = $80A8;
  GL_SAMPLE_BUFFERS_ARB = $80A8;
  GL_SAMPLE_BUFFERS_EXT = $80A8;
  GL_SAMPLE_BUFFERS_SGIS = $80A8;
  GL_SAMPLES = $80A9;
  GL_SAMPLES_ARB = $80A9;
  GL_SAMPLES_EXT = $80A9;
  GL_SAMPLES_SGIS = $80A9;
  GL_SAMPLE_COVERAGE_VALUE = $80AA;
  GL_SAMPLE_COVERAGE_VALUE_ARB = $80AA;
  GL_SAMPLE_MASK_VALUE_EXT = $80AA;
  GL_SAMPLE_MASK_VALUE_SGIS = $80AA;
  GL_SAMPLE_COVERAGE_INVERT = $80AB;
  GL_SAMPLE_COVERAGE_INVERT_ARB = $80AB;
  GL_SAMPLE_MASK_INVERT_EXT = $80AB;
  GL_SAMPLE_MASK_INVERT_SGIS = $80AB;
  GL_SAMPLE_PATTERN_EXT = $80AC;
  GL_SAMPLE_PATTERN_SGIS = $80AC;
  GL_LINEAR_SHARPEN_SGIS = $80AD;
  GL_LINEAR_SHARPEN_ALPHA_SGIS = $80AE;
  GL_LINEAR_SHARPEN_COLOR_SGIS = $80AF;
  GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS = $80B0;
  GL_COLOR_MATRIX = $80B1;
  GL_COLOR_MATRIX_SGI = $80B1;
  GL_COLOR_MATRIX_STACK_DEPTH = $80B2;
  GL_COLOR_MATRIX_STACK_DEPTH_SGI = $80B2;
  GL_MAX_COLOR_MATRIX_STACK_DEPTH = $80B3;
  GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI = $80B3;
  GL_POST_COLOR_MATRIX_RED_SCALE = $80B4;
  GL_POST_COLOR_MATRIX_RED_SCALE_SGI = $80B4;
  GL_POST_COLOR_MATRIX_GREEN_SCALE = $80B5;
  GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI = $80B5;
  GL_POST_COLOR_MATRIX_BLUE_SCALE = $80B6;
  GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI = $80B6;
  GL_POST_COLOR_MATRIX_ALPHA_SCALE = $80B7;
  GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI = $80B7;
  GL_POST_COLOR_MATRIX_RED_BIAS = $80B8;
  GL_POST_COLOR_MATRIX_RED_BIAS_SGI = $80B8;
  GL_POST_COLOR_MATRIX_GREEN_BIAS = $80B9;
  GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI = $80B9;
  GL_POST_COLOR_MATRIX_BLUE_BIAS = $80BA;
  GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI = $80BA;
  GL_POST_COLOR_MATRIX_ALPHA_BIAS = $80BB;
  GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI = $80BB;
  GL_TEXTURE_COLOR_TABLE_SGI = $80BC;
  GL_PROXY_TEXTURE_COLOR_TABLE_SGI = $80BD;
  GL_TEXTURE_ENV_BIAS_SGIX = $80BE;
  GL_SHADOW_AMBIENT_SGIX = $80BF;
  GL_TEXTURE_COMPARE_FAIL_VALUE_ARB = $80BF;
  GL_BLEND_DST_RGB = $80C8;
  GL_BLEND_DST_RGB_EXT = $80C8;
  GL_BLEND_DST_RGB_OES = $80C8;
  GL_BLEND_SRC_RGB = $80C9;
  GL_BLEND_SRC_RGB_EXT = $80C9;
  GL_BLEND_SRC_RGB_OES = $80C9;
  GL_BLEND_DST_ALPHA = $80CA;
  GL_BLEND_DST_ALPHA_EXT = $80CA;
  GL_BLEND_DST_ALPHA_OES = $80CA;
  GL_BLEND_SRC_ALPHA = $80CB;
  GL_BLEND_SRC_ALPHA_EXT = $80CB;
  GL_BLEND_SRC_ALPHA_OES = $80CB;
  GL_422_EXT = $80CC;
  GL_422_REV_EXT = $80CD;
  GL_422_AVERAGE_EXT = $80CE;
  GL_422_REV_AVERAGE_EXT = $80CF;
  GL_COLOR_TABLE = $80D0;
  GL_COLOR_TABLE_SGI = $80D0;
  GL_POST_CONVOLUTION_COLOR_TABLE = $80D1;
  GL_POST_CONVOLUTION_COLOR_TABLE_SGI = $80D1;
  GL_POST_COLOR_MATRIX_COLOR_TABLE = $80D2;
  GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI = $80D2;
  GL_PROXY_COLOR_TABLE = $80D3;
  GL_PROXY_COLOR_TABLE_SGI = $80D3;
  GL_PROXY_POST_CONVOLUTION_COLOR_TABLE = $80D4;
  GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = $80D4;
  GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE = $80D5;
  GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = $80D5;
  GL_COLOR_TABLE_SCALE = $80D6;
  GL_COLOR_TABLE_SCALE_SGI = $80D6;
  GL_COLOR_TABLE_BIAS = $80D7;
  GL_COLOR_TABLE_BIAS_SGI = $80D7;
  GL_COLOR_TABLE_FORMAT = $80D8;
  GL_COLOR_TABLE_FORMAT_SGI = $80D8;
  GL_COLOR_TABLE_WIDTH = $80D9;
  GL_COLOR_TABLE_WIDTH_SGI = $80D9;
  GL_COLOR_TABLE_RED_SIZE = $80DA;
  GL_COLOR_TABLE_RED_SIZE_SGI = $80DA;
  GL_COLOR_TABLE_GREEN_SIZE = $80DB;
  GL_COLOR_TABLE_GREEN_SIZE_SGI = $80DB;
  GL_COLOR_TABLE_BLUE_SIZE = $80DC;
  GL_COLOR_TABLE_BLUE_SIZE_SGI = $80DC;
  GL_COLOR_TABLE_ALPHA_SIZE = $80DD;
  GL_COLOR_TABLE_ALPHA_SIZE_SGI = $80DD;
  GL_COLOR_TABLE_LUMINANCE_SIZE = $80DE;
  GL_COLOR_TABLE_LUMINANCE_SIZE_SGI = $80DE;
  GL_COLOR_TABLE_INTENSITY_SIZE = $80DF;
  GL_COLOR_TABLE_INTENSITY_SIZE_SGI = $80DF;
  GL_BGR = $80E0;
  GL_BGR_EXT = $80E0;
  GL_BGRA = $80E1;
  GL_BGRA_EXT = $80E1;
  GL_BGRA_IMG = $80E1;
  GL_COLOR_INDEX1_EXT = $80E2;
  GL_COLOR_INDEX2_EXT = $80E3;
  GL_COLOR_INDEX4_EXT = $80E4;
  GL_COLOR_INDEX8_EXT = $80E5;
  GL_COLOR_INDEX12_EXT = $80E6;
  GL_COLOR_INDEX16_EXT = $80E7;
  GL_MAX_ELEMENTS_VERTICES = $80E8;
  GL_MAX_ELEMENTS_VERTICES_EXT = $80E8;
  GL_MAX_ELEMENTS_INDICES = $80E9;
  GL_MAX_ELEMENTS_INDICES_EXT = $80E9;
  GL_PHONG_WIN = $80EA;
  GL_PHONG_HINT_WIN = $80EB;
  GL_FOG_SPECULAR_TEXTURE_WIN = $80EC;
  GL_TEXTURE_INDEX_SIZE_EXT = $80ED;
  GL_PARAMETER_BUFFER = $80EE;
  GL_PARAMETER_BUFFER_ARB = $80EE;
  GL_PARAMETER_BUFFER_BINDING = $80EF;
  GL_PARAMETER_BUFFER_BINDING_ARB = $80EF;
  GL_CLIP_VOLUME_CLIPPING_HINT_EXT = $80F0;
  GL_DUAL_ALPHA4_SGIS = $8110;
  GL_DUAL_ALPHA8_SGIS = $8111;
  GL_DUAL_ALPHA12_SGIS = $8112;
  GL_DUAL_ALPHA16_SGIS = $8113;
  GL_DUAL_LUMINANCE4_SGIS = $8114;
  GL_DUAL_LUMINANCE8_SGIS = $8115;
  GL_DUAL_LUMINANCE12_SGIS = $8116;
  GL_DUAL_LUMINANCE16_SGIS = $8117;
  GL_DUAL_INTENSITY4_SGIS = $8118;
  GL_DUAL_INTENSITY8_SGIS = $8119;
  GL_DUAL_INTENSITY12_SGIS = $811A;
  GL_DUAL_INTENSITY16_SGIS = $811B;
  GL_DUAL_LUMINANCE_ALPHA4_SGIS = $811C;
  GL_DUAL_LUMINANCE_ALPHA8_SGIS = $811D;
  GL_QUAD_ALPHA4_SGIS = $811E;
  GL_QUAD_ALPHA8_SGIS = $811F;
  GL_QUAD_LUMINANCE4_SGIS = $8120;
  GL_QUAD_LUMINANCE8_SGIS = $8121;
  GL_QUAD_INTENSITY4_SGIS = $8122;
  GL_QUAD_INTENSITY8_SGIS = $8123;
  GL_DUAL_TEXTURE_SELECT_SGIS = $8124;
  GL_QUAD_TEXTURE_SELECT_SGIS = $8125;
  GL_POINT_SIZE_MIN = $8126;
  GL_POINT_SIZE_MIN_ARB = $8126;
  GL_POINT_SIZE_MIN_EXT = $8126;
  GL_POINT_SIZE_MIN_SGIS = $8126;
  GL_POINT_SIZE_MAX = $8127;
  GL_POINT_SIZE_MAX_ARB = $8127;
  GL_POINT_SIZE_MAX_EXT = $8127;
  GL_POINT_SIZE_MAX_SGIS = $8127;
  GL_POINT_FADE_THRESHOLD_SIZE = $8128;
  GL_POINT_FADE_THRESHOLD_SIZE_ARB = $8128;
  GL_POINT_FADE_THRESHOLD_SIZE_EXT = $8128;
  GL_POINT_FADE_THRESHOLD_SIZE_SGIS = $8128;
  GL_DISTANCE_ATTENUATION_EXT = $8129;
  GL_DISTANCE_ATTENUATION_SGIS = $8129;
  GL_POINT_DISTANCE_ATTENUATION = $8129;
  GL_POINT_DISTANCE_ATTENUATION_ARB = $8129;
  GL_FOG_FUNC_SGIS = $812A;
  GL_FOG_FUNC_POINTS_SGIS = $812B;
  GL_MAX_FOG_FUNC_POINTS_SGIS = $812C;
  GL_CLAMP_TO_BORDER = $812D;
  GL_CLAMP_TO_BORDER_ARB = $812D;
  GL_CLAMP_TO_BORDER_EXT = $812D;
  GL_CLAMP_TO_BORDER_NV = $812D;
  GL_CLAMP_TO_BORDER_SGIS = $812D;
  GL_CLAMP_TO_BORDER_OES = $812D;
  GL_TEXTURE_MULTI_BUFFER_HINT_SGIX = $812E;
  GL_CLAMP_TO_EDGE = $812F;
  GL_CLAMP_TO_EDGE_SGIS = $812F;
  GL_PACK_SKIP_VOLUMES_SGIS = $8130;
  GL_PACK_IMAGE_DEPTH_SGIS = $8131;
  GL_UNPACK_SKIP_VOLUMES_SGIS = $8132;
  GL_UNPACK_IMAGE_DEPTH_SGIS = $8133;
  GL_TEXTURE_4D_SGIS = $8134;
  GL_PROXY_TEXTURE_4D_SGIS = $8135;
  GL_TEXTURE_4DSIZE_SGIS = $8136;
  GL_TEXTURE_WRAP_Q_SGIS = $8137;
  GL_MAX_4D_TEXTURE_SIZE_SGIS = $8138;
  GL_PIXEL_TEX_GEN_SGIX = $8139;
  GL_TEXTURE_MIN_LOD = $813A;
  GL_TEXTURE_MIN_LOD_SGIS = $813A;
  GL_TEXTURE_MAX_LOD = $813B;
  GL_TEXTURE_MAX_LOD_SGIS = $813B;
  GL_TEXTURE_BASE_LEVEL = $813C;
  GL_TEXTURE_BASE_LEVEL_SGIS = $813C;
  GL_TEXTURE_MAX_LEVEL = $813D;
  GL_TEXTURE_MAX_LEVEL_APPLE = $813D;
  GL_TEXTURE_MAX_LEVEL_SGIS = $813D;
  GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX = $813E;
  GL_PIXEL_TILE_CACHE_INCREMENT_SGIX = $813F;
  GL_PIXEL_TILE_WIDTH_SGIX = $8140;
  GL_PIXEL_TILE_HEIGHT_SGIX = $8141;
  GL_PIXEL_TILE_GRID_WIDTH_SGIX = $8142;
  GL_PIXEL_TILE_GRID_HEIGHT_SGIX = $8143;
  GL_PIXEL_TILE_GRID_DEPTH_SGIX = $8144;
  GL_PIXEL_TILE_CACHE_SIZE_SGIX = $8145;
  GL_FILTER4_SGIS = $8146;
  GL_TEXTURE_FILTER4_SIZE_SGIS = $8147;
  GL_SPRITE_SGIX = $8148;
  GL_SPRITE_MODE_SGIX = $8149;
  GL_SPRITE_AXIS_SGIX = $814A;
  GL_SPRITE_TRANSLATION_SGIX = $814B;
  GL_SPRITE_AXIAL_SGIX = $814C;
  GL_SPRITE_OBJECT_ALIGNED_SGIX = $814D;
  GL_SPRITE_EYE_ALIGNED_SGIX = $814E;
  GL_TEXTURE_4D_BINDING_SGIS = $814F;
  GL_IGNORE_BORDER_HP = $8150;
  GL_CONSTANT_BORDER = $8151;
  GL_CONSTANT_BORDER_HP = $8151;
  GL_REPLICATE_BORDER = $8153;
  GL_REPLICATE_BORDER_HP = $8153;
  GL_CONVOLUTION_BORDER_COLOR = $8154;
  GL_CONVOLUTION_BORDER_COLOR_HP = $8154;
  GL_IMAGE_SCALE_X_HP = $8155;
  GL_IMAGE_SCALE_Y_HP = $8156;
  GL_IMAGE_TRANSLATE_X_HP = $8157;
  GL_IMAGE_TRANSLATE_Y_HP = $8158;
  GL_IMAGE_ROTATE_ANGLE_HP = $8159;
  GL_IMAGE_ROTATE_ORIGIN_X_HP = $815A;
  GL_IMAGE_ROTATE_ORIGIN_Y_HP = $815B;
  GL_IMAGE_MAG_FILTER_HP = $815C;
  GL_IMAGE_MIN_FILTER_HP = $815D;
  GL_IMAGE_CUBIC_WEIGHT_HP = $815E;
  GL_CUBIC_HP = $815F;
  GL_AVERAGE_HP = $8160;
  GL_IMAGE_TRANSFORM_2D_HP = $8161;
  GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = $8162;
  GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = $8163;
  GL_OCCLUSION_TEST_HP = $8165;
  GL_OCCLUSION_TEST_RESULT_HP = $8166;
  GL_TEXTURE_LIGHTING_MODE_HP = $8167;
  GL_TEXTURE_POST_SPECULAR_HP = $8168;
  GL_TEXTURE_PRE_SPECULAR_HP = $8169;
  GL_LINEAR_CLIPMAP_LINEAR_SGIX = $8170;
  GL_TEXTURE_CLIPMAP_CENTER_SGIX = $8171;
  GL_TEXTURE_CLIPMAP_FRAME_SGIX = $8172;
  GL_TEXTURE_CLIPMAP_OFFSET_SGIX = $8173;
  GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = $8174;
  GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = $8175;
  GL_TEXTURE_CLIPMAP_DEPTH_SGIX = $8176;
  GL_MAX_CLIPMAP_DEPTH_SGIX = $8177;
  GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = $8178;
  GL_POST_TEXTURE_FILTER_BIAS_SGIX = $8179;
  GL_POST_TEXTURE_FILTER_SCALE_SGIX = $817A;
  GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = $817B;
  GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = $817C;
  GL_REFERENCE_PLANE_SGIX = $817D;
  GL_REFERENCE_PLANE_EQUATION_SGIX = $817E;
  GL_IR_INSTRUMENT1_SGIX = $817F;
  GL_INSTRUMENT_BUFFER_POINTER_SGIX = $8180;
  GL_INSTRUMENT_MEASUREMENTS_SGIX = $8181;
  GL_LIST_PRIORITY_SGIX = $8182;
  GL_CALLIGRAPHIC_FRAGMENT_SGIX = $8183;
  GL_PIXEL_TEX_GEN_Q_CEILING_SGIX = $8184;
  GL_PIXEL_TEX_GEN_Q_ROUND_SGIX = $8185;
  GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX = $8186;
  GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX = $8189;
  GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX = $818A;
  GL_FRAMEZOOM_SGIX = $818B;
  GL_FRAMEZOOM_FACTOR_SGIX = $818C;
  GL_MAX_FRAMEZOOM_FACTOR_SGIX = $818D;
  GL_TEXTURE_LOD_BIAS_S_SGIX = $818E;
  GL_TEXTURE_LOD_BIAS_T_SGIX = $818F;
  GL_TEXTURE_LOD_BIAS_R_SGIX = $8190;
  GL_GENERATE_MIPMAP = $8191;
  GL_GENERATE_MIPMAP_SGIS = $8191;
  GL_GENERATE_MIPMAP_HINT = $8192;
  GL_GENERATE_MIPMAP_HINT_SGIS = $8192;
  GL_GEOMETRY_DEFORMATION_SGIX = $8194;
  GL_TEXTURE_DEFORMATION_SGIX = $8195;
  GL_DEFORMATIONS_MASK_SGIX = $8196;
  GL_MAX_DEFORMATION_ORDER_SGIX = $8197;
  GL_FOG_OFFSET_SGIX = $8198;
  GL_FOG_OFFSET_VALUE_SGIX = $8199;
  GL_TEXTURE_COMPARE_SGIX = $819A;
  GL_TEXTURE_COMPARE_OPERATOR_SGIX = $819B;
  GL_TEXTURE_LEQUAL_R_SGIX = $819C;
  GL_TEXTURE_GEQUAL_R_SGIX = $819D;
  GL_DEPTH_COMPONENT16 = $81A5;
  GL_DEPTH_COMPONENT16_ARB = $81A5;
  GL_DEPTH_COMPONENT16_OES = $81A5;
  GL_DEPTH_COMPONENT16_SGIX = $81A5;
  GL_DEPTH_COMPONENT24 = $81A6;
  GL_DEPTH_COMPONENT24_ARB = $81A6;
  GL_DEPTH_COMPONENT24_OES = $81A6;
  GL_DEPTH_COMPONENT24_SGIX = $81A6;
  GL_DEPTH_COMPONENT32 = $81A7;
  GL_DEPTH_COMPONENT32_ARB = $81A7;
  GL_DEPTH_COMPONENT32_OES = $81A7;
  GL_DEPTH_COMPONENT32_SGIX = $81A7;
  GL_ARRAY_ELEMENT_LOCK_FIRST_EXT = $81A8;
  GL_ARRAY_ELEMENT_LOCK_COUNT_EXT = $81A9;
  GL_CULL_VERTEX_EXT = $81AA;
  GL_CULL_VERTEX_EYE_POSITION_EXT = $81AB;
  GL_CULL_VERTEX_OBJECT_POSITION_EXT = $81AC;
  GL_IUI_V2F_EXT = $81AD;
  GL_IUI_V3F_EXT = $81AE;
  GL_IUI_N3F_V2F_EXT = $81AF;
  GL_IUI_N3F_V3F_EXT = $81B0;
  GL_T2F_IUI_V2F_EXT = $81B1;
  GL_T2F_IUI_V3F_EXT = $81B2;
  GL_T2F_IUI_N3F_V2F_EXT = $81B3;
  GL_T2F_IUI_N3F_V3F_EXT = $81B4;
  GL_INDEX_TEST_EXT = $81B5;
  GL_INDEX_TEST_FUNC_EXT = $81B6;
  GL_INDEX_TEST_REF_EXT = $81B7;
  GL_INDEX_MATERIAL_EXT = $81B8;
  GL_INDEX_MATERIAL_PARAMETER_EXT = $81B9;
  GL_INDEX_MATERIAL_FACE_EXT = $81BA;
  GL_YCRCB_422_SGIX = $81BB;
  GL_YCRCB_444_SGIX = $81BC;
  GL_WRAP_BORDER_SUN = $81D4;
  GL_UNPACK_CONSTANT_DATA_SUNX = $81D5;
  GL_TEXTURE_CONSTANT_DATA_SUNX = $81D6;
  GL_TRIANGLE_LIST_SUN = $81D7;
  GL_REPLACEMENT_CODE_SUN = $81D8;
  GL_GLOBAL_ALPHA_SUN = $81D9;
  GL_GLOBAL_ALPHA_FACTOR_SUN = $81DA;
  GL_TEXTURE_COLOR_WRITEMASK_SGIS = $81EF;
  GL_EYE_DISTANCE_TO_POINT_SGIS = $81F0;
  GL_OBJECT_DISTANCE_TO_POINT_SGIS = $81F1;
  GL_EYE_DISTANCE_TO_LINE_SGIS = $81F2;
  GL_OBJECT_DISTANCE_TO_LINE_SGIS = $81F3;
  GL_EYE_POINT_SGIS = $81F4;
  GL_OBJECT_POINT_SGIS = $81F5;
  GL_EYE_LINE_SGIS = $81F6;
  GL_OBJECT_LINE_SGIS = $81F7;
  GL_LIGHT_MODEL_COLOR_CONTROL = $81F8;
  GL_LIGHT_MODEL_COLOR_CONTROL_EXT = $81F8;
  GL_SINGLE_COLOR = $81F9;
  GL_SINGLE_COLOR_EXT = $81F9;
  GL_SEPARATE_SPECULAR_COLOR = $81FA;
  GL_SEPARATE_SPECULAR_COLOR_EXT = $81FA;
  GL_SHARED_TEXTURE_PALETTE_EXT = $81FB;
  GL_TEXT_FRAGMENT_SHADER_ATI = $8200;
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = $8210;
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = $8210;
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = $8211;
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = $8211;
  GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = $8212;
  GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = $8213;
  GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = $8214;
  GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = $8215;
  GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = $8216;
  GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = $8217;
  GL_FRAMEBUFFER_DEFAULT = $8218;
  GL_FRAMEBUFFER_UNDEFINED = $8219;
  GL_FRAMEBUFFER_UNDEFINED_OES = $8219;
  GL_DEPTH_STENCIL_ATTACHMENT = $821A;
  GL_MAJOR_VERSION = $821B;
  GL_MINOR_VERSION = $821C;
  GL_NUM_EXTENSIONS = $821D;
  GL_CONTEXT_FLAGS = $821E;
  GL_BUFFER_IMMUTABLE_STORAGE = $821F;
  GL_BUFFER_IMMUTABLE_STORAGE_EXT = $821F;
  GL_BUFFER_STORAGE_FLAGS = $8220;
  GL_BUFFER_STORAGE_FLAGS_EXT = $8220;
  GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = $8221;
  GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES = $8221;
  GL_INDEX = $8222;
  GL_COMPRESSED_RED = $8225;
  GL_COMPRESSED_RG = $8226;
  GL_RG = $8227;
  GL_RG_EXT = $8227;
  GL_RG_INTEGER = $8228;
  GL_R8 = $8229;
  GL_R8_EXT = $8229;
  GL_R16 = $822A;
  GL_R16_EXT = $822A;
  GL_RG8 = $822B;
  GL_RG8_EXT = $822B;
  GL_RG16 = $822C;
  GL_RG16_EXT = $822C;
  GL_R16F = $822D;
  GL_R16F_EXT = $822D;
  GL_R32F = $822E;
  GL_R32F_EXT = $822E;
  GL_RG16F = $822F;
  GL_RG16F_EXT = $822F;
  GL_RG32F = $8230;
  GL_RG32F_EXT = $8230;
  GL_R8I = $8231;
  GL_R8UI = $8232;
  GL_R16I = $8233;
  GL_R16UI = $8234;
  GL_R32I = $8235;
  GL_R32UI = $8236;
  GL_RG8I = $8237;
  GL_RG8UI = $8238;
  GL_RG16I = $8239;
  GL_RG16UI = $823A;
  GL_RG32I = $823B;
  GL_RG32UI = $823C;
  GL_SYNC_CL_EVENT_ARB = $8240;
  GL_SYNC_CL_EVENT_COMPLETE_ARB = $8241;
  GL_DEBUG_OUTPUT_SYNCHRONOUS = $8242;
  GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB = $8242;
  GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR = $8242;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = $8243;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = $8243;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR = $8243;
  GL_DEBUG_CALLBACK_FUNCTION = $8244;
  GL_DEBUG_CALLBACK_FUNCTION_ARB = $8244;
  GL_DEBUG_CALLBACK_FUNCTION_KHR = $8244;
  GL_DEBUG_CALLBACK_USER_PARAM = $8245;
  GL_DEBUG_CALLBACK_USER_PARAM_ARB = $8245;
  GL_DEBUG_CALLBACK_USER_PARAM_KHR = $8245;
  GL_DEBUG_SOURCE_API = $8246;
  GL_DEBUG_SOURCE_API_ARB = $8246;
  GL_DEBUG_SOURCE_API_KHR = $8246;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM = $8247;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB = $8247;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR = $8247;
  GL_DEBUG_SOURCE_SHADER_COMPILER = $8248;
  GL_DEBUG_SOURCE_SHADER_COMPILER_ARB = $8248;
  GL_DEBUG_SOURCE_SHADER_COMPILER_KHR = $8248;
  GL_DEBUG_SOURCE_THIRD_PARTY = $8249;
  GL_DEBUG_SOURCE_THIRD_PARTY_ARB = $8249;
  GL_DEBUG_SOURCE_THIRD_PARTY_KHR = $8249;
  GL_DEBUG_SOURCE_APPLICATION = $824A;
  GL_DEBUG_SOURCE_APPLICATION_ARB = $824A;
  GL_DEBUG_SOURCE_APPLICATION_KHR = $824A;
  GL_DEBUG_SOURCE_OTHER = $824B;
  GL_DEBUG_SOURCE_OTHER_ARB = $824B;
  GL_DEBUG_SOURCE_OTHER_KHR = $824B;
  GL_DEBUG_TYPE_ERROR = $824C;
  GL_DEBUG_TYPE_ERROR_ARB = $824C;
  GL_DEBUG_TYPE_ERROR_KHR = $824C;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = $824D;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = $824D;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR = $824D;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR = $824E;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = $824E;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR = $824E;
  GL_DEBUG_TYPE_PORTABILITY = $824F;
  GL_DEBUG_TYPE_PORTABILITY_ARB = $824F;
  GL_DEBUG_TYPE_PORTABILITY_KHR = $824F;
  GL_DEBUG_TYPE_PERFORMANCE = $8250;
  GL_DEBUG_TYPE_PERFORMANCE_ARB = $8250;
  GL_DEBUG_TYPE_PERFORMANCE_KHR = $8250;
  GL_DEBUG_TYPE_OTHER = $8251;
  GL_DEBUG_TYPE_OTHER_ARB = $8251;
  GL_DEBUG_TYPE_OTHER_KHR = $8251;
  GL_LOSE_CONTEXT_ON_RESET = $8252;
  GL_LOSE_CONTEXT_ON_RESET_ARB = $8252;
  GL_LOSE_CONTEXT_ON_RESET_EXT = $8252;
  GL_LOSE_CONTEXT_ON_RESET_KHR = $8252;
  GL_GUILTY_CONTEXT_RESET = $8253;
  GL_GUILTY_CONTEXT_RESET_ARB = $8253;
  GL_GUILTY_CONTEXT_RESET_EXT = $8253;
  GL_GUILTY_CONTEXT_RESET_KHR = $8253;
  GL_INNOCENT_CONTEXT_RESET = $8254;
  GL_INNOCENT_CONTEXT_RESET_ARB = $8254;
  GL_INNOCENT_CONTEXT_RESET_EXT = $8254;
  GL_INNOCENT_CONTEXT_RESET_KHR = $8254;
  GL_UNKNOWN_CONTEXT_RESET = $8255;
  GL_UNKNOWN_CONTEXT_RESET_ARB = $8255;
  GL_UNKNOWN_CONTEXT_RESET_EXT = $8255;
  GL_UNKNOWN_CONTEXT_RESET_KHR = $8255;
  GL_RESET_NOTIFICATION_STRATEGY = $8256;
  GL_RESET_NOTIFICATION_STRATEGY_ARB = $8256;
  GL_RESET_NOTIFICATION_STRATEGY_EXT = $8256;
  GL_RESET_NOTIFICATION_STRATEGY_KHR = $8256;
  GL_PROGRAM_BINARY_RETRIEVABLE_HINT = $8257;
  GL_PROGRAM_SEPARABLE = $8258;
  GL_PROGRAM_SEPARABLE_EXT = $8258;
  GL_ACTIVE_PROGRAM = $8259;
  GL_ACTIVE_PROGRAM_EXT = $8259;
  GL_PROGRAM_PIPELINE_BINDING = $825A;
  GL_PROGRAM_PIPELINE_BINDING_EXT = $825A;
  GL_MAX_VIEWPORTS = $825B;
  GL_MAX_VIEWPORTS_NV = $825B;
  GL_MAX_VIEWPORTS_OES = $825B;
  GL_VIEWPORT_SUBPIXEL_BITS = $825C;
  GL_VIEWPORT_SUBPIXEL_BITS_EXT = $825C;
  GL_VIEWPORT_SUBPIXEL_BITS_NV = $825C;
  GL_VIEWPORT_SUBPIXEL_BITS_OES = $825C;
  GL_VIEWPORT_BOUNDS_RANGE = $825D;
  GL_VIEWPORT_BOUNDS_RANGE_EXT = $825D;
  GL_VIEWPORT_BOUNDS_RANGE_NV = $825D;
  GL_VIEWPORT_BOUNDS_RANGE_OES = $825D;
  GL_LAYER_PROVOKING_VERTEX = $825E;
  GL_LAYER_PROVOKING_VERTEX_EXT = $825E;
  GL_LAYER_PROVOKING_VERTEX_OES = $825E;
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX = $825F;
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX_EXT = $825F;
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX_NV = $825F;
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX_OES = $825F;
  GL_UNDEFINED_VERTEX = $8260;
  GL_UNDEFINED_VERTEX_EXT = $8260;
  GL_UNDEFINED_VERTEX_OES = $8260;
  GL_NO_RESET_NOTIFICATION = $8261;
  GL_NO_RESET_NOTIFICATION_ARB = $8261;
  GL_NO_RESET_NOTIFICATION_EXT = $8261;
  GL_NO_RESET_NOTIFICATION_KHR = $8261;
  GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = $8262;
  GL_MAX_COMPUTE_UNIFORM_COMPONENTS = $8263;
  GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = $8264;
  GL_MAX_COMPUTE_ATOMIC_COUNTERS = $8265;
  GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = $8266;
  GL_COMPUTE_WORK_GROUP_SIZE = $8267;
  GL_DEBUG_TYPE_MARKER = $8268;
  GL_DEBUG_TYPE_MARKER_KHR = $8268;
  GL_DEBUG_TYPE_PUSH_GROUP = $8269;
  GL_DEBUG_TYPE_PUSH_GROUP_KHR = $8269;
  GL_DEBUG_TYPE_POP_GROUP = $826A;
  GL_DEBUG_TYPE_POP_GROUP_KHR = $826A;
  GL_DEBUG_SEVERITY_NOTIFICATION = $826B;
  GL_DEBUG_SEVERITY_NOTIFICATION_KHR = $826B;
  GL_MAX_DEBUG_GROUP_STACK_DEPTH = $826C;
  GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR = $826C;
  GL_DEBUG_GROUP_STACK_DEPTH = $826D;
  GL_DEBUG_GROUP_STACK_DEPTH_KHR = $826D;
  GL_MAX_UNIFORM_LOCATIONS = $826E;
  GL_INTERNALFORMAT_SUPPORTED = $826F;
  GL_INTERNALFORMAT_PREFERRED = $8270;
  GL_INTERNALFORMAT_RED_SIZE = $8271;
  GL_INTERNALFORMAT_GREEN_SIZE = $8272;
  GL_INTERNALFORMAT_BLUE_SIZE = $8273;
  GL_INTERNALFORMAT_ALPHA_SIZE = $8274;
  GL_INTERNALFORMAT_DEPTH_SIZE = $8275;
  GL_INTERNALFORMAT_STENCIL_SIZE = $8276;
  GL_INTERNALFORMAT_SHARED_SIZE = $8277;
  GL_INTERNALFORMAT_RED_TYPE = $8278;
  GL_INTERNALFORMAT_GREEN_TYPE = $8279;
  GL_INTERNALFORMAT_BLUE_TYPE = $827A;
  GL_INTERNALFORMAT_ALPHA_TYPE = $827B;
  GL_INTERNALFORMAT_DEPTH_TYPE = $827C;
  GL_INTERNALFORMAT_STENCIL_TYPE = $827D;
  GL_MAX_WIDTH = $827E;
  GL_MAX_HEIGHT = $827F;
  GL_MAX_DEPTH = $8280;
  GL_MAX_LAYERS = $8281;
  GL_MAX_COMBINED_DIMENSIONS = $8282;
  GL_COLOR_COMPONENTS = $8283;
  GL_DEPTH_COMPONENTS = $8284;
  GL_STENCIL_COMPONENTS = $8285;
  GL_COLOR_RENDERABLE = $8286;
  GL_DEPTH_RENDERABLE = $8287;
  GL_STENCIL_RENDERABLE = $8288;
  GL_FRAMEBUFFER_RENDERABLE = $8289;
  GL_FRAMEBUFFER_RENDERABLE_LAYERED = $828A;
  GL_FRAMEBUFFER_BLEND = $828B;
  GL_READ_PIXELS = $828C;
  GL_READ_PIXELS_FORMAT = $828D;
  GL_READ_PIXELS_TYPE = $828E;
  GL_TEXTURE_IMAGE_FORMAT = $828F;
  GL_TEXTURE_IMAGE_TYPE = $8290;
  GL_GET_TEXTURE_IMAGE_FORMAT = $8291;
  GL_GET_TEXTURE_IMAGE_TYPE = $8292;
  GL_MIPMAP = $8293;
  GL_MANUAL_GENERATE_MIPMAP = $8294;
  GL_AUTO_GENERATE_MIPMAP = $8295;
  GL_COLOR_ENCODING = $8296;
  GL_SRGB_READ = $8297;
  GL_SRGB_WRITE = $8298;
  GL_SRGB_DECODE_ARB = $8299;
  GL_FILTER = $829A;
  GL_VERTEX_TEXTURE = $829B;
  GL_TESS_CONTROL_TEXTURE = $829C;
  GL_TESS_EVALUATION_TEXTURE = $829D;
  GL_GEOMETRY_TEXTURE = $829E;
  GL_FRAGMENT_TEXTURE = $829F;
  GL_COMPUTE_TEXTURE = $82A0;
  GL_TEXTURE_SHADOW = $82A1;
  GL_TEXTURE_GATHER = $82A2;
  GL_TEXTURE_GATHER_SHADOW = $82A3;
  GL_SHADER_IMAGE_LOAD = $82A4;
  GL_SHADER_IMAGE_STORE = $82A5;
  GL_SHADER_IMAGE_ATOMIC = $82A6;
  GL_IMAGE_TEXEL_SIZE = $82A7;
  GL_IMAGE_COMPATIBILITY_CLASS = $82A8;
  GL_IMAGE_PIXEL_FORMAT = $82A9;
  GL_IMAGE_PIXEL_TYPE = $82AA;
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = $82AC;
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = $82AD;
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = $82AE;
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = $82AF;
  GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = $82B1;
  GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = $82B2;
  GL_TEXTURE_COMPRESSED_BLOCK_SIZE = $82B3;
  GL_CLEAR_BUFFER = $82B4;
  GL_TEXTURE_VIEW = $82B5;
  GL_VIEW_COMPATIBILITY_CLASS = $82B6;
  GL_FULL_SUPPORT = $82B7;
  GL_CAVEAT_SUPPORT = $82B8;
  GL_IMAGE_CLASS_4_X_32 = $82B9;
  GL_IMAGE_CLASS_2_X_32 = $82BA;
  GL_IMAGE_CLASS_1_X_32 = $82BB;
  GL_IMAGE_CLASS_4_X_16 = $82BC;
  GL_IMAGE_CLASS_2_X_16 = $82BD;
  GL_IMAGE_CLASS_1_X_16 = $82BE;
  GL_IMAGE_CLASS_4_X_8 = $82BF;
  GL_IMAGE_CLASS_2_X_8 = $82C0;
  GL_IMAGE_CLASS_1_X_8 = $82C1;
  GL_IMAGE_CLASS_11_11_10 = $82C2;
  GL_IMAGE_CLASS_10_10_10_2 = $82C3;
  GL_VIEW_CLASS_128_BITS = $82C4;
  GL_VIEW_CLASS_96_BITS = $82C5;
  GL_VIEW_CLASS_64_BITS = $82C6;
  GL_VIEW_CLASS_48_BITS = $82C7;
  GL_VIEW_CLASS_32_BITS = $82C8;
  GL_VIEW_CLASS_24_BITS = $82C9;
  GL_VIEW_CLASS_16_BITS = $82CA;
  GL_VIEW_CLASS_8_BITS = $82CB;
  GL_VIEW_CLASS_S3TC_DXT1_RGB = $82CC;
  GL_VIEW_CLASS_S3TC_DXT1_RGBA = $82CD;
  GL_VIEW_CLASS_S3TC_DXT3_RGBA = $82CE;
  GL_VIEW_CLASS_S3TC_DXT5_RGBA = $82CF;
  GL_VIEW_CLASS_RGTC1_RED = $82D0;
  GL_VIEW_CLASS_RGTC2_RG = $82D1;
  GL_VIEW_CLASS_BPTC_UNORM = $82D2;
  GL_VIEW_CLASS_BPTC_FLOAT = $82D3;
  GL_VERTEX_ATTRIB_BINDING = $82D4;
  GL_VERTEX_ATTRIB_RELATIVE_OFFSET = $82D5;
  GL_VERTEX_BINDING_DIVISOR = $82D6;
  GL_VERTEX_BINDING_OFFSET = $82D7;
  GL_VERTEX_BINDING_STRIDE = $82D8;
  GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = $82D9;
  GL_MAX_VERTEX_ATTRIB_BINDINGS = $82DA;
  GL_TEXTURE_VIEW_MIN_LEVEL = $82DB;
  GL_TEXTURE_VIEW_MIN_LEVEL_EXT = $82DB;
  GL_TEXTURE_VIEW_MIN_LEVEL_OES = $82DB;
  GL_TEXTURE_VIEW_NUM_LEVELS = $82DC;
  GL_TEXTURE_VIEW_NUM_LEVELS_EXT = $82DC;
  GL_TEXTURE_VIEW_NUM_LEVELS_OES = $82DC;
  GL_TEXTURE_VIEW_MIN_LAYER = $82DD;
  GL_TEXTURE_VIEW_MIN_LAYER_EXT = $82DD;
  GL_TEXTURE_VIEW_MIN_LAYER_OES = $82DD;
  GL_TEXTURE_VIEW_NUM_LAYERS = $82DE;
  GL_TEXTURE_VIEW_NUM_LAYERS_EXT = $82DE;
  GL_TEXTURE_VIEW_NUM_LAYERS_OES = $82DE;
  GL_TEXTURE_IMMUTABLE_LEVELS = $82DF;
  GL_BUFFER = $82E0;
  GL_BUFFER_KHR = $82E0;
  GL_SHADER = $82E1;
  GL_SHADER_KHR = $82E1;
  GL_PROGRAM = $82E2;
  GL_PROGRAM_KHR = $82E2;
  GL_QUERY = $82E3;
  GL_QUERY_KHR = $82E3;
  GL_PROGRAM_PIPELINE = $82E4;
  GL_PROGRAM_PIPELINE_KHR = $82E4;
  GL_MAX_VERTEX_ATTRIB_STRIDE = $82E5;
  GL_SAMPLER = $82E6;
  GL_SAMPLER_KHR = $82E6;
  GL_DISPLAY_LIST = $82E7;
  GL_MAX_LABEL_LENGTH = $82E8;
  GL_MAX_LABEL_LENGTH_KHR = $82E8;
  GL_NUM_SHADING_LANGUAGE_VERSIONS = $82E9;
  GL_QUERY_TARGET = $82EA;
  GL_TRANSFORM_FEEDBACK_OVERFLOW = $82EC;
  GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB = $82EC;
  GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW = $82ED;
  GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB = $82ED;
  GL_VERTICES_SUBMITTED = $82EE;
  GL_VERTICES_SUBMITTED_ARB = $82EE;
  GL_PRIMITIVES_SUBMITTED = $82EF;
  GL_PRIMITIVES_SUBMITTED_ARB = $82EF;
  GL_VERTEX_SHADER_INVOCATIONS = $82F0;
  GL_VERTEX_SHADER_INVOCATIONS_ARB = $82F0;
  GL_TESS_CONTROL_SHADER_PATCHES = $82F1;
  GL_TESS_CONTROL_SHADER_PATCHES_ARB = $82F1;
  GL_TESS_EVALUATION_SHADER_INVOCATIONS = $82F2;
  GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB = $82F2;
  GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED = $82F3;
  GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB = $82F3;
  GL_FRAGMENT_SHADER_INVOCATIONS = $82F4;
  GL_FRAGMENT_SHADER_INVOCATIONS_ARB = $82F4;
  GL_COMPUTE_SHADER_INVOCATIONS = $82F5;
  GL_COMPUTE_SHADER_INVOCATIONS_ARB = $82F5;
  GL_CLIPPING_INPUT_PRIMITIVES = $82F6;
  GL_CLIPPING_INPUT_PRIMITIVES_ARB = $82F6;
  GL_CLIPPING_OUTPUT_PRIMITIVES = $82F7;
  GL_CLIPPING_OUTPUT_PRIMITIVES_ARB = $82F7;
  GL_SPARSE_BUFFER_PAGE_SIZE_ARB = $82F8;
  GL_MAX_CULL_DISTANCES = $82F9;
  GL_MAX_CULL_DISTANCES_EXT = $82F9;
  GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = $82FA;
  GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES_EXT = $82FA;
  GL_CONTEXT_RELEASE_BEHAVIOR = $82FB;
  GL_CONTEXT_RELEASE_BEHAVIOR_KHR = $82FB;
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = $82FC;
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR = $82FC;
  GL_ROBUST_GPU_TIMEOUT_MS_KHR = $82FD;
  GL_DEPTH_PASS_INSTRUMENT_SGIX = $8310;
  GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX = $8311;
  GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX = $8312;
  GL_FRAGMENTS_INSTRUMENT_SGIX = $8313;
  GL_FRAGMENTS_INSTRUMENT_COUNTERS_SGIX = $8314;
  GL_FRAGMENTS_INSTRUMENT_MAX_SGIX = $8315;
  GL_CONVOLUTION_HINT_SGIX = $8316;
  GL_YCRCB_SGIX = $8318;
  GL_YCRCBA_SGIX = $8319;
  GL_UNPACK_COMPRESSED_SIZE_SGIX = $831A;
  GL_PACK_MAX_COMPRESSED_SIZE_SGIX = $831B;
  GL_PACK_COMPRESSED_SIZE_SGIX = $831C;
  GL_SLIM8U_SGIX = $831D;
  GL_SLIM10U_SGIX = $831E;
  GL_SLIM12S_SGIX = $831F;
  GL_ALPHA_MIN_SGIX = $8320;
  GL_ALPHA_MAX_SGIX = $8321;
  GL_SCALEBIAS_HINT_SGIX = $8322;
  GL_ASYNC_MARKER_SGIX = $8329;
  GL_PIXEL_TEX_GEN_MODE_SGIX = $832B;
  GL_ASYNC_HISTOGRAM_SGIX = $832C;
  GL_MAX_ASYNC_HISTOGRAM_SGIX = $832D;
  GL_PIXEL_TRANSFORM_2D_EXT = $8330;
  GL_PIXEL_MAG_FILTER_EXT = $8331;
  GL_PIXEL_MIN_FILTER_EXT = $8332;
  GL_PIXEL_CUBIC_WEIGHT_EXT = $8333;
  GL_CUBIC_EXT = $8334;
  GL_AVERAGE_EXT = $8335;
  GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = $8336;
  GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = $8337;
  GL_PIXEL_TRANSFORM_2D_MATRIX_EXT = $8338;
  GL_FRAGMENT_MATERIAL_EXT = $8349;
  GL_FRAGMENT_NORMAL_EXT = $834A;
  GL_FRAGMENT_COLOR_EXT = $834C;
  GL_ATTENUATION_EXT = $834D;
  GL_SHADOW_ATTENUATION_EXT = $834E;
  GL_TEXTURE_APPLICATION_MODE_EXT = $834F;
  GL_TEXTURE_LIGHT_EXT = $8350;
  GL_TEXTURE_MATERIAL_FACE_EXT = $8351;
  GL_TEXTURE_MATERIAL_PARAMETER_EXT = $8352;
  GL_PIXEL_TEXTURE_SGIS = $8353;
  GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS = $8354;
  GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = $8355;
  GL_PIXEL_GROUP_COLOR_SGIS = $8356;
  GL_LINE_QUALITY_HINT_SGIX = $835B;
  GL_ASYNC_TEX_IMAGE_SGIX = $835C;
  GL_ASYNC_DRAW_PIXELS_SGIX = $835D;
  GL_ASYNC_READ_PIXELS_SGIX = $835E;
  GL_MAX_ASYNC_TEX_IMAGE_SGIX = $835F;
  GL_MAX_ASYNC_DRAW_PIXELS_SGIX = $8360;
  GL_MAX_ASYNC_READ_PIXELS_SGIX = $8361;
  GL_UNSIGNED_BYTE_2_3_3_REV = $8362;
  GL_UNSIGNED_BYTE_2_3_3_REV_EXT = $8362;
  GL_UNSIGNED_SHORT_5_6_5 = $8363;
  GL_UNSIGNED_SHORT_5_6_5_EXT = $8363;
  GL_UNSIGNED_SHORT_5_6_5_REV = $8364;
  GL_UNSIGNED_SHORT_5_6_5_REV_EXT = $8364;
  GL_UNSIGNED_SHORT_4_4_4_4_REV = $8365;
  GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT = $8365;
  GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG = $8365;
  GL_UNSIGNED_SHORT_1_5_5_5_REV = $8366;
  GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT = $8366;
  GL_UNSIGNED_INT_8_8_8_8_REV = $8367;
  GL_UNSIGNED_INT_8_8_8_8_REV_EXT = $8367;
  GL_UNSIGNED_INT_2_10_10_10_REV = $8368;
  GL_UNSIGNED_INT_2_10_10_10_REV_EXT = $8368;
  GL_TEXTURE_MAX_CLAMP_S_SGIX = $8369;
  GL_TEXTURE_MAX_CLAMP_T_SGIX = $836A;
  GL_TEXTURE_MAX_CLAMP_R_SGIX = $836B;
  GL_MIRRORED_REPEAT = $8370;
  GL_MIRRORED_REPEAT_ARB = $8370;
  GL_MIRRORED_REPEAT_IBM = $8370;
  GL_MIRRORED_REPEAT_OES = $8370;
  GL_RGB_S3TC = $83A0;
  GL_RGB4_S3TC = $83A1;
  GL_RGBA_S3TC = $83A2;
  GL_RGBA4_S3TC = $83A3;
  GL_RGBA_DXT5_S3TC = $83A4;
  GL_RGBA4_DXT5_S3TC = $83A5;
  GL_VERTEX_PRECLIP_SGIX = $83EE;
  GL_VERTEX_PRECLIP_HINT_SGIX = $83EF;
  GL_COMPRESSED_RGB_S3TC_DXT1_EXT = $83F0;
  GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = $83F1;
  GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE = $83F2;
  GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = $83F2;
  GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE = $83F3;
  GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = $83F3;
  GL_PARALLEL_ARRAYS_INTEL = $83F4;
  GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL = $83F5;
  GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL = $83F6;
  GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL = $83F7;
  GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL = $83F8;
  GL_PERFQUERY_DONOT_FLUSH_INTEL = $83F9;
  GL_PERFQUERY_FLUSH_INTEL = $83FA;
  GL_PERFQUERY_WAIT_INTEL = $83FB;
  GL_BLACKHOLE_RENDER_INTEL = $83FC;
  GL_CONSERVATIVE_RASTERIZATION_INTEL = $83FE;
  GL_TEXTURE_MEMORY_LAYOUT_INTEL = $83FF;
  GL_FRAGMENT_LIGHTING_SGIX = $8400;
  GL_FRAGMENT_COLOR_MATERIAL_SGIX = $8401;
  GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX = $8402;
  GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = $8403;
  GL_MAX_FRAGMENT_LIGHTS_SGIX = $8404;
  GL_MAX_ACTIVE_LIGHTS_SGIX = $8405;
  GL_CURRENT_RASTER_NORMAL_SGIX = $8406;
  GL_LIGHT_ENV_MODE_SGIX = $8407;
  GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = $8408;
  GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = $8409;
  GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = $840A;
  GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = $840B;
  GL_FRAGMENT_LIGHT0_SGIX = $840C;
  GL_FRAGMENT_LIGHT1_SGIX = $840D;
  GL_FRAGMENT_LIGHT2_SGIX = $840E;
  GL_FRAGMENT_LIGHT3_SGIX = $840F;
  GL_FRAGMENT_LIGHT4_SGIX = $8410;
  GL_FRAGMENT_LIGHT5_SGIX = $8411;
  GL_FRAGMENT_LIGHT6_SGIX = $8412;
  GL_FRAGMENT_LIGHT7_SGIX = $8413;
  GL_PACK_RESAMPLE_SGIX = $842E;
  GL_UNPACK_RESAMPLE_SGIX = $842F;
  GL_RESAMPLE_DECIMATE_SGIX = $8430;
  GL_RESAMPLE_REPLICATE_SGIX = $8433;
  GL_RESAMPLE_ZERO_FILL_SGIX = $8434;
  GL_TANGENT_ARRAY_EXT = $8439;
  GL_BINORMAL_ARRAY_EXT = $843A;
  GL_CURRENT_TANGENT_EXT = $843B;
  GL_CURRENT_BINORMAL_EXT = $843C;
  GL_TANGENT_ARRAY_TYPE_EXT = $843E;
  GL_TANGENT_ARRAY_STRIDE_EXT = $843F;
  GL_BINORMAL_ARRAY_TYPE_EXT = $8440;
  GL_BINORMAL_ARRAY_STRIDE_EXT = $8441;
  GL_TANGENT_ARRAY_POINTER_EXT = $8442;
  GL_BINORMAL_ARRAY_POINTER_EXT = $8443;
  GL_MAP1_TANGENT_EXT = $8444;
  GL_MAP2_TANGENT_EXT = $8445;
  GL_MAP1_BINORMAL_EXT = $8446;
  GL_MAP2_BINORMAL_EXT = $8447;
  GL_NEAREST_CLIPMAP_NEAREST_SGIX = $844D;
  GL_NEAREST_CLIPMAP_LINEAR_SGIX = $844E;
  GL_LINEAR_CLIPMAP_NEAREST_SGIX = $844F;
  GL_FOG_COORDINATE_SOURCE = $8450;
  GL_FOG_COORDINATE_SOURCE_EXT = $8450;
  GL_FOG_COORD_SRC = $8450;
  GL_FOG_COORDINATE = $8451;
  GL_FOG_COORDINATE_EXT = $8451;
  GL_FOG_COORD = $8451;
  GL_FRAGMENT_DEPTH = $8452;
  GL_FRAGMENT_DEPTH_EXT = $8452;
  GL_CURRENT_FOG_COORDINATE = $8453;
  GL_CURRENT_FOG_COORD = $8453;
  GL_CURRENT_FOG_COORDINATE_EXT = $8453;
  GL_FOG_COORDINATE_ARRAY_TYPE = $8454;
  GL_FOG_COORDINATE_ARRAY_TYPE_EXT = $8454;
  GL_FOG_COORD_ARRAY_TYPE = $8454;
  GL_FOG_COORDINATE_ARRAY_STRIDE = $8455;
  GL_FOG_COORDINATE_ARRAY_STRIDE_EXT = $8455;
  GL_FOG_COORD_ARRAY_STRIDE = $8455;
  GL_FOG_COORDINATE_ARRAY_POINTER = $8456;
  GL_FOG_COORDINATE_ARRAY_POINTER_EXT = $8456;
  GL_FOG_COORD_ARRAY_POINTER = $8456;
  GL_FOG_COORDINATE_ARRAY = $8457;
  GL_FOG_COORDINATE_ARRAY_EXT = $8457;
  GL_FOG_COORD_ARRAY = $8457;
  GL_COLOR_SUM = $8458;
  GL_COLOR_SUM_ARB = $8458;
  GL_COLOR_SUM_EXT = $8458;
  GL_CURRENT_SECONDARY_COLOR = $8459;
  GL_CURRENT_SECONDARY_COLOR_EXT = $8459;
  GL_SECONDARY_COLOR_ARRAY_SIZE = $845A;
  GL_SECONDARY_COLOR_ARRAY_SIZE_EXT = $845A;
  GL_SECONDARY_COLOR_ARRAY_TYPE = $845B;
  GL_SECONDARY_COLOR_ARRAY_TYPE_EXT = $845B;
  GL_SECONDARY_COLOR_ARRAY_STRIDE = $845C;
  GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT = $845C;
  GL_SECONDARY_COLOR_ARRAY_POINTER = $845D;
  GL_SECONDARY_COLOR_ARRAY_POINTER_EXT = $845D;
  GL_SECONDARY_COLOR_ARRAY = $845E;
  GL_SECONDARY_COLOR_ARRAY_EXT = $845E;
  GL_CURRENT_RASTER_SECONDARY_COLOR = $845F;
  GL_ALIASED_POINT_SIZE_RANGE = $846D;
  GL_ALIASED_LINE_WIDTH_RANGE = $846E;
  GL_SCREEN_COORDINATES_REND = $8490;
  GL_INVERTED_SCREEN_W_REND = $8491;
  GL_TEXTURE0 = $84C0;
  GL_TEXTURE0_ARB = $84C0;
  GL_TEXTURE1 = $84C1;
  GL_TEXTURE1_ARB = $84C1;
  GL_TEXTURE2 = $84C2;
  GL_TEXTURE2_ARB = $84C2;
  GL_TEXTURE3 = $84C3;
  GL_TEXTURE3_ARB = $84C3;
  GL_TEXTURE4 = $84C4;
  GL_TEXTURE4_ARB = $84C4;
  GL_TEXTURE5 = $84C5;
  GL_TEXTURE5_ARB = $84C5;
  GL_TEXTURE6 = $84C6;
  GL_TEXTURE6_ARB = $84C6;
  GL_TEXTURE7 = $84C7;
  GL_TEXTURE7_ARB = $84C7;
  GL_TEXTURE8 = $84C8;
  GL_TEXTURE8_ARB = $84C8;
  GL_TEXTURE9 = $84C9;
  GL_TEXTURE9_ARB = $84C9;
  GL_TEXTURE10 = $84CA;
  GL_TEXTURE10_ARB = $84CA;
  GL_TEXTURE11 = $84CB;
  GL_TEXTURE11_ARB = $84CB;
  GL_TEXTURE12 = $84CC;
  GL_TEXTURE12_ARB = $84CC;
  GL_TEXTURE13 = $84CD;
  GL_TEXTURE13_ARB = $84CD;
  GL_TEXTURE14 = $84CE;
  GL_TEXTURE14_ARB = $84CE;
  GL_TEXTURE15 = $84CF;
  GL_TEXTURE15_ARB = $84CF;
  GL_TEXTURE16 = $84D0;
  GL_TEXTURE16_ARB = $84D0;
  GL_TEXTURE17 = $84D1;
  GL_TEXTURE17_ARB = $84D1;
  GL_TEXTURE18 = $84D2;
  GL_TEXTURE18_ARB = $84D2;
  GL_TEXTURE19 = $84D3;
  GL_TEXTURE19_ARB = $84D3;
  GL_TEXTURE20 = $84D4;
  GL_TEXTURE20_ARB = $84D4;
  GL_TEXTURE21 = $84D5;
  GL_TEXTURE21_ARB = $84D5;
  GL_TEXTURE22 = $84D6;
  GL_TEXTURE22_ARB = $84D6;
  GL_TEXTURE23 = $84D7;
  GL_TEXTURE23_ARB = $84D7;
  GL_TEXTURE24 = $84D8;
  GL_TEXTURE24_ARB = $84D8;
  GL_TEXTURE25 = $84D9;
  GL_TEXTURE25_ARB = $84D9;
  GL_TEXTURE26 = $84DA;
  GL_TEXTURE26_ARB = $84DA;
  GL_TEXTURE27 = $84DB;
  GL_TEXTURE27_ARB = $84DB;
  GL_TEXTURE28 = $84DC;
  GL_TEXTURE28_ARB = $84DC;
  GL_TEXTURE29 = $84DD;
  GL_TEXTURE29_ARB = $84DD;
  GL_TEXTURE30 = $84DE;
  GL_TEXTURE30_ARB = $84DE;
  GL_TEXTURE31 = $84DF;
  GL_TEXTURE31_ARB = $84DF;
  GL_ACTIVE_TEXTURE = $84E0;
  GL_ACTIVE_TEXTURE_ARB = $84E0;
  GL_CLIENT_ACTIVE_TEXTURE = $84E1;
  GL_CLIENT_ACTIVE_TEXTURE_ARB = $84E1;
  GL_MAX_TEXTURE_UNITS = $84E2;
  GL_MAX_TEXTURE_UNITS_ARB = $84E2;
  GL_TRANSPOSE_MODELVIEW_MATRIX = $84E3;
  GL_TRANSPOSE_MODELVIEW_MATRIX_ARB = $84E3;
  GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV = $84E3;
  GL_TRANSPOSE_PROJECTION_MATRIX = $84E4;
  GL_TRANSPOSE_PROJECTION_MATRIX_ARB = $84E4;
  GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV = $84E4;
  GL_TRANSPOSE_TEXTURE_MATRIX = $84E5;
  GL_TRANSPOSE_TEXTURE_MATRIX_ARB = $84E5;
  GL_TRANSPOSE_COLOR_MATRIX = $84E6;
  GL_TRANSPOSE_COLOR_MATRIX_ARB = $84E6;
  GL_SUBTRACT = $84E7;
  GL_SUBTRACT_ARB = $84E7;
  GL_MAX_RENDERBUFFER_SIZE = $84E8;
  GL_MAX_RENDERBUFFER_SIZE_EXT = $84E8;
  GL_MAX_RENDERBUFFER_SIZE_OES = $84E8;
  GL_COMPRESSED_ALPHA = $84E9;
  GL_COMPRESSED_ALPHA_ARB = $84E9;
  GL_COMPRESSED_LUMINANCE = $84EA;
  GL_COMPRESSED_LUMINANCE_ARB = $84EA;
  GL_COMPRESSED_LUMINANCE_ALPHA = $84EB;
  GL_COMPRESSED_LUMINANCE_ALPHA_ARB = $84EB;
  GL_COMPRESSED_INTENSITY = $84EC;
  GL_COMPRESSED_INTENSITY_ARB = $84EC;
  GL_COMPRESSED_RGB = $84ED;
  GL_COMPRESSED_RGB_ARB = $84ED;
  GL_COMPRESSED_RGBA = $84EE;
  GL_COMPRESSED_RGBA_ARB = $84EE;
  GL_TEXTURE_COMPRESSION_HINT = $84EF;
  GL_TEXTURE_COMPRESSION_HINT_ARB = $84EF;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = $84F0;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = $84F1;
  GL_ALL_COMPLETED_NV = $84F2;
  GL_FENCE_STATUS_NV = $84F3;
  GL_FENCE_CONDITION_NV = $84F4;
  GL_TEXTURE_RECTANGLE = $84F5;
  GL_TEXTURE_RECTANGLE_ARB = $84F5;
  GL_TEXTURE_RECTANGLE_NV = $84F5;
  GL_TEXTURE_BINDING_RECTANGLE = $84F6;
  GL_TEXTURE_BINDING_RECTANGLE_ARB = $84F6;
  GL_TEXTURE_BINDING_RECTANGLE_NV = $84F6;
  GL_PROXY_TEXTURE_RECTANGLE = $84F7;
  GL_PROXY_TEXTURE_RECTANGLE_ARB = $84F7;
  GL_PROXY_TEXTURE_RECTANGLE_NV = $84F7;
  GL_MAX_RECTANGLE_TEXTURE_SIZE = $84F8;
  GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB = $84F8;
  GL_MAX_RECTANGLE_TEXTURE_SIZE_NV = $84F8;
  GL_DEPTH_STENCIL = $84F9;
  GL_DEPTH_STENCIL_EXT = $84F9;
  GL_DEPTH_STENCIL_NV = $84F9;
  GL_DEPTH_STENCIL_OES = $84F9;
  GL_UNSIGNED_INT_24_8 = $84FA;
  GL_UNSIGNED_INT_24_8_EXT = $84FA;
  GL_UNSIGNED_INT_24_8_NV = $84FA;
  GL_UNSIGNED_INT_24_8_OES = $84FA;
  GL_MAX_TEXTURE_LOD_BIAS = $84FD;
  GL_MAX_TEXTURE_LOD_BIAS_EXT = $84FD;
  GL_TEXTURE_MAX_ANISOTROPY = $84FE;
  GL_TEXTURE_MAX_ANISOTROPY_EXT = $84FE;
  GL_MAX_TEXTURE_MAX_ANISOTROPY = $84FF;
  GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = $84FF;
  GL_TEXTURE_FILTER_CONTROL = $8500;
  GL_TEXTURE_FILTER_CONTROL_EXT = $8500;
  GL_TEXTURE_LOD_BIAS = $8501;
  GL_TEXTURE_LOD_BIAS_EXT = $8501;
  GL_MODELVIEW1_STACK_DEPTH_EXT = $8502;
  GL_COMBINE4_NV = $8503;
  GL_MAX_SHININESS_NV = $8504;
  GL_MAX_SPOT_EXPONENT_NV = $8505;
  GL_MODELVIEW1_MATRIX_EXT = $8506;
  GL_INCR_WRAP = $8507;
  GL_INCR_WRAP_EXT = $8507;
  GL_INCR_WRAP_OES = $8507;
  GL_DECR_WRAP = $8508;
  GL_DECR_WRAP_EXT = $8508;
  GL_DECR_WRAP_OES = $8508;
  GL_VERTEX_WEIGHTING_EXT = $8509;
  GL_MODELVIEW1_ARB = $850A;
  GL_MODELVIEW1_EXT = $850A;
  GL_CURRENT_VERTEX_WEIGHT_EXT = $850B;
  GL_VERTEX_WEIGHT_ARRAY_EXT = $850C;
  GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT = $850D;
  GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT = $850E;
  GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT = $850F;
  GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT = $8510;
  GL_NORMAL_MAP = $8511;
  GL_NORMAL_MAP_ARB = $8511;
  GL_NORMAL_MAP_EXT = $8511;
  GL_NORMAL_MAP_NV = $8511;
  GL_NORMAL_MAP_OES = $8511;
  GL_REFLECTION_MAP = $8512;
  GL_REFLECTION_MAP_ARB = $8512;
  GL_REFLECTION_MAP_EXT = $8512;
  GL_REFLECTION_MAP_NV = $8512;
  GL_REFLECTION_MAP_OES = $8512;
  GL_TEXTURE_CUBE_MAP = $8513;
  GL_TEXTURE_CUBE_MAP_ARB = $8513;
  GL_TEXTURE_CUBE_MAP_EXT = $8513;
  GL_TEXTURE_CUBE_MAP_OES = $8513;
  GL_TEXTURE_BINDING_CUBE_MAP = $8514;
  GL_TEXTURE_BINDING_CUBE_MAP_ARB = $8514;
  GL_TEXTURE_BINDING_CUBE_MAP_EXT = $8514;
  GL_TEXTURE_BINDING_CUBE_MAP_OES = $8514;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X = $8515;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = $8515;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT = $8515;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES = $8515;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X = $8516;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = $8516;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT = $8516;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES = $8516;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y = $8517;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = $8517;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT = $8517;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES = $8517;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = $8518;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = $8518;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT = $8518;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES = $8518;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z = $8519;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = $8519;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT = $8519;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES = $8519;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = $851A;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = $851A;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT = $851A;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES = $851A;
  GL_PROXY_TEXTURE_CUBE_MAP = $851B;
  GL_PROXY_TEXTURE_CUBE_MAP_ARB = $851B;
  GL_PROXY_TEXTURE_CUBE_MAP_EXT = $851B;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE = $851C;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB = $851C;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT = $851C;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE_OES = $851C;
  GL_VERTEX_ARRAY_RANGE_APPLE = $851D;
  GL_VERTEX_ARRAY_RANGE_NV = $851D;
  GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE = $851E;
  GL_VERTEX_ARRAY_RANGE_LENGTH_NV = $851E;
  GL_VERTEX_ARRAY_RANGE_VALID_NV = $851F;
  GL_VERTEX_ARRAY_STORAGE_HINT_APPLE = $851F;
  GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV = $8520;
  GL_VERTEX_ARRAY_RANGE_POINTER_APPLE = $8521;
  GL_VERTEX_ARRAY_RANGE_POINTER_NV = $8521;
  GL_REGISTER_COMBINERS_NV = $8522;
  GL_VARIABLE_A_NV = $8523;
  GL_VARIABLE_B_NV = $8524;
  GL_VARIABLE_C_NV = $8525;
  GL_VARIABLE_D_NV = $8526;
  GL_VARIABLE_E_NV = $8527;
  GL_VARIABLE_F_NV = $8528;
  GL_VARIABLE_G_NV = $8529;
  GL_CONSTANT_COLOR0_NV = $852A;
  GL_CONSTANT_COLOR1_NV = $852B;
  GL_PRIMARY_COLOR_NV = $852C;
  GL_SECONDARY_COLOR_NV = $852D;
  GL_SPARE0_NV = $852E;
  GL_SPARE1_NV = $852F;
  GL_DISCARD_NV = $8530;
  GL_E_TIMES_F_NV = $8531;
  GL_SPARE0_PLUS_SECONDARY_COLOR_NV = $8532;
  GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV = $8533;
  GL_MULTISAMPLE_FILTER_HINT_NV = $8534;
  GL_PER_STAGE_CONSTANTS_NV = $8535;
  GL_UNSIGNED_IDENTITY_NV = $8536;
  GL_UNSIGNED_INVERT_NV = $8537;
  GL_EXPAND_NORMAL_NV = $8538;
  GL_EXPAND_NEGATE_NV = $8539;
  GL_HALF_BIAS_NORMAL_NV = $853A;
  GL_HALF_BIAS_NEGATE_NV = $853B;
  GL_SIGNED_IDENTITY_NV = $853C;
  GL_SIGNED_NEGATE_NV = $853D;
  GL_SCALE_BY_TWO_NV = $853E;
  GL_SCALE_BY_FOUR_NV = $853F;
  GL_SCALE_BY_ONE_HALF_NV = $8540;
  GL_BIAS_BY_NEGATIVE_ONE_HALF_NV = $8541;
  GL_COMBINER_INPUT_NV = $8542;
  GL_COMBINER_MAPPING_NV = $8543;
  GL_COMBINER_COMPONENT_USAGE_NV = $8544;
  GL_COMBINER_AB_DOT_PRODUCT_NV = $8545;
  GL_COMBINER_CD_DOT_PRODUCT_NV = $8546;
  GL_COMBINER_MUX_SUM_NV = $8547;
  GL_COMBINER_SCALE_NV = $8548;
  GL_COMBINER_BIAS_NV = $8549;
  GL_COMBINER_AB_OUTPUT_NV = $854A;
  GL_COMBINER_CD_OUTPUT_NV = $854B;
  GL_COMBINER_SUM_OUTPUT_NV = $854C;
  GL_MAX_GENERAL_COMBINERS_NV = $854D;
  GL_NUM_GENERAL_COMBINERS_NV = $854E;
  GL_COLOR_SUM_CLAMP_NV = $854F;
  GL_COMBINER0_NV = $8550;
  GL_COMBINER1_NV = $8551;
  GL_COMBINER2_NV = $8552;
  GL_COMBINER3_NV = $8553;
  GL_COMBINER4_NV = $8554;
  GL_COMBINER5_NV = $8555;
  GL_COMBINER6_NV = $8556;
  GL_COMBINER7_NV = $8557;
  GL_PRIMITIVE_RESTART_NV = $8558;
  GL_PRIMITIVE_RESTART_INDEX_NV = $8559;
  GL_FOG_DISTANCE_MODE_NV = $855A;
  GL_EYE_RADIAL_NV = $855B;
  GL_EYE_PLANE_ABSOLUTE_NV = $855C;
  GL_EMBOSS_LIGHT_NV = $855D;
  GL_EMBOSS_CONSTANT_NV = $855E;
  GL_EMBOSS_MAP_NV = $855F;
  GL_RED_MIN_CLAMP_INGR = $8560;
  GL_GREEN_MIN_CLAMP_INGR = $8561;
  GL_BLUE_MIN_CLAMP_INGR = $8562;
  GL_ALPHA_MIN_CLAMP_INGR = $8563;
  GL_RED_MAX_CLAMP_INGR = $8564;
  GL_GREEN_MAX_CLAMP_INGR = $8565;
  GL_BLUE_MAX_CLAMP_INGR = $8566;
  GL_ALPHA_MAX_CLAMP_INGR = $8567;
  GL_INTERLACE_READ_INGR = $8568;
  GL_COMBINE = $8570;
  GL_COMBINE_ARB = $8570;
  GL_COMBINE_EXT = $8570;
  GL_COMBINE_RGB = $8571;
  GL_COMBINE_RGB_ARB = $8571;
  GL_COMBINE_RGB_EXT = $8571;
  GL_COMBINE_ALPHA = $8572;
  GL_COMBINE_ALPHA_ARB = $8572;
  GL_COMBINE_ALPHA_EXT = $8572;
  GL_RGB_SCALE = $8573;
  GL_RGB_SCALE_ARB = $8573;
  GL_RGB_SCALE_EXT = $8573;
  GL_ADD_SIGNED = $8574;
  GL_ADD_SIGNED_ARB = $8574;
  GL_ADD_SIGNED_EXT = $8574;
  GL_INTERPOLATE = $8575;
  GL_INTERPOLATE_ARB = $8575;
  GL_INTERPOLATE_EXT = $8575;
  GL_CONSTANT = $8576;
  GL_CONSTANT_ARB = $8576;
  GL_CONSTANT_EXT = $8576;
  GL_CONSTANT_NV = $8576;
  GL_PRIMARY_COLOR = $8577;
  GL_PRIMARY_COLOR_ARB = $8577;
  GL_PRIMARY_COLOR_EXT = $8577;
  GL_PREVIOUS = $8578;
  GL_PREVIOUS_ARB = $8578;
  GL_PREVIOUS_EXT = $8578;
  GL_SOURCE0_RGB = $8580;
  GL_SOURCE0_RGB_ARB = $8580;
  GL_SOURCE0_RGB_EXT = $8580;
  GL_SRC0_RGB = $8580;
  GL_SOURCE1_RGB = $8581;
  GL_SOURCE1_RGB_ARB = $8581;
  GL_SOURCE1_RGB_EXT = $8581;
  GL_SRC1_RGB = $8581;
  GL_SOURCE2_RGB = $8582;
  GL_SOURCE2_RGB_ARB = $8582;
  GL_SOURCE2_RGB_EXT = $8582;
  GL_SRC2_RGB = $8582;
  GL_SOURCE3_RGB_NV = $8583;
  GL_SOURCE0_ALPHA = $8588;
  GL_SOURCE0_ALPHA_ARB = $8588;
  GL_SOURCE0_ALPHA_EXT = $8588;
  GL_SRC0_ALPHA = $8588;
  GL_SOURCE1_ALPHA = $8589;
  GL_SOURCE1_ALPHA_ARB = $8589;
  GL_SOURCE1_ALPHA_EXT = $8589;
  GL_SRC1_ALPHA = $8589;
  GL_SRC1_ALPHA_EXT = $8589;
  GL_SOURCE2_ALPHA = $858A;
  GL_SOURCE2_ALPHA_ARB = $858A;
  GL_SOURCE2_ALPHA_EXT = $858A;
  GL_SRC2_ALPHA = $858A;
  GL_SOURCE3_ALPHA_NV = $858B;
  GL_OPERAND0_RGB = $8590;
  GL_OPERAND0_RGB_ARB = $8590;
  GL_OPERAND0_RGB_EXT = $8590;
  GL_OPERAND1_RGB = $8591;
  GL_OPERAND1_RGB_ARB = $8591;
  GL_OPERAND1_RGB_EXT = $8591;
  GL_OPERAND2_RGB = $8592;
  GL_OPERAND2_RGB_ARB = $8592;
  GL_OPERAND2_RGB_EXT = $8592;
  GL_OPERAND3_RGB_NV = $8593;
  GL_OPERAND0_ALPHA = $8598;
  GL_OPERAND0_ALPHA_ARB = $8598;
  GL_OPERAND0_ALPHA_EXT = $8598;
  GL_OPERAND1_ALPHA = $8599;
  GL_OPERAND1_ALPHA_ARB = $8599;
  GL_OPERAND1_ALPHA_EXT = $8599;
  GL_OPERAND2_ALPHA = $859A;
  GL_OPERAND2_ALPHA_ARB = $859A;
  GL_OPERAND2_ALPHA_EXT = $859A;
  GL_OPERAND3_ALPHA_NV = $859B;
  GL_PACK_SUBSAMPLE_RATE_SGIX = $85A0;
  GL_UNPACK_SUBSAMPLE_RATE_SGIX = $85A1;
  GL_PIXEL_SUBSAMPLE_4444_SGIX = $85A2;
  GL_PIXEL_SUBSAMPLE_2424_SGIX = $85A3;
  GL_PIXEL_SUBSAMPLE_4242_SGIX = $85A4;
  GL_PERTURB_EXT = $85AE;
  GL_TEXTURE_NORMAL_EXT = $85AF;
  GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE = $85B0;
  GL_TRANSFORM_HINT_APPLE = $85B1;
  GL_UNPACK_CLIENT_STORAGE_APPLE = $85B2;
  GL_BUFFER_OBJECT_APPLE = $85B3;
  GL_STORAGE_CLIENT_APPLE = $85B4;
  GL_VERTEX_ARRAY_BINDING = $85B5;
  GL_VERTEX_ARRAY_BINDING_APPLE = $85B5;
  GL_VERTEX_ARRAY_BINDING_OES = $85B5;
  GL_TEXTURE_RANGE_LENGTH_APPLE = $85B7;
  GL_TEXTURE_RANGE_POINTER_APPLE = $85B8;
  GL_YCBCR_422_APPLE = $85B9;
  GL_UNSIGNED_SHORT_8_8_APPLE = $85BA;
  GL_UNSIGNED_SHORT_8_8_MESA = $85BA;
  GL_UNSIGNED_SHORT_8_8_REV_APPLE = $85BB;
  GL_UNSIGNED_SHORT_8_8_REV_MESA = $85BB;
  GL_TEXTURE_STORAGE_HINT_APPLE = $85BC;
  GL_STORAGE_PRIVATE_APPLE = $85BD;
  GL_STORAGE_CACHED_APPLE = $85BE;
  GL_STORAGE_SHARED_APPLE = $85BF;
  GL_REPLACEMENT_CODE_ARRAY_SUN = $85C0;
  GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN = $85C1;
  GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN = $85C2;
  GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN = $85C3;
  GL_R1UI_V3F_SUN = $85C4;
  GL_R1UI_C4UB_V3F_SUN = $85C5;
  GL_R1UI_C3F_V3F_SUN = $85C6;
  GL_R1UI_N3F_V3F_SUN = $85C7;
  GL_R1UI_C4F_N3F_V3F_SUN = $85C8;
  GL_R1UI_T2F_V3F_SUN = $85C9;
  GL_R1UI_T2F_N3F_V3F_SUN = $85CA;
  GL_R1UI_T2F_C4F_N3F_V3F_SUN = $85CB;
  GL_SLICE_ACCUM_SUN = $85CC;
  GL_QUAD_MESH_SUN = $8614;
  GL_TRIANGLE_MESH_SUN = $8615;
  GL_VERTEX_PROGRAM_ARB = $8620;
  GL_VERTEX_PROGRAM_NV = $8620;
  GL_VERTEX_STATE_PROGRAM_NV = $8621;
  GL_VERTEX_ATTRIB_ARRAY_ENABLED = $8622;
  GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB = $8622;
  GL_ATTRIB_ARRAY_SIZE_NV = $8623;
  GL_VERTEX_ATTRIB_ARRAY_SIZE = $8623;
  GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB = $8623;
  GL_ATTRIB_ARRAY_STRIDE_NV = $8624;
  GL_VERTEX_ATTRIB_ARRAY_STRIDE = $8624;
  GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB = $8624;
  GL_ATTRIB_ARRAY_TYPE_NV = $8625;
  GL_VERTEX_ATTRIB_ARRAY_TYPE = $8625;
  GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB = $8625;
  GL_CURRENT_ATTRIB_NV = $8626;
  GL_CURRENT_VERTEX_ATTRIB = $8626;
  GL_CURRENT_VERTEX_ATTRIB_ARB = $8626;
  GL_PROGRAM_LENGTH_ARB = $8627;
  GL_PROGRAM_LENGTH_NV = $8627;
  GL_PROGRAM_STRING_ARB = $8628;
  GL_PROGRAM_STRING_NV = $8628;
  GL_MODELVIEW_PROJECTION_NV = $8629;
  GL_IDENTITY_NV = $862A;
  GL_INVERSE_NV = $862B;
  GL_TRANSPOSE_NV = $862C;
  GL_INVERSE_TRANSPOSE_NV = $862D;
  GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB = $862E;
  GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV = $862E;
  GL_MAX_PROGRAM_MATRICES_ARB = $862F;
  GL_MAX_TRACK_MATRICES_NV = $862F;
  GL_MATRIX0_NV = $8630;
  GL_MATRIX1_NV = $8631;
  GL_MATRIX2_NV = $8632;
  GL_MATRIX3_NV = $8633;
  GL_MATRIX4_NV = $8634;
  GL_MATRIX5_NV = $8635;
  GL_MATRIX6_NV = $8636;
  GL_MATRIX7_NV = $8637;
  GL_CURRENT_MATRIX_STACK_DEPTH_ARB = $8640;
  GL_CURRENT_MATRIX_STACK_DEPTH_NV = $8640;
  GL_CURRENT_MATRIX_ARB = $8641;
  GL_CURRENT_MATRIX_NV = $8641;
  GL_VERTEX_PROGRAM_POINT_SIZE = $8642;
  GL_VERTEX_PROGRAM_POINT_SIZE_ARB = $8642;
  GL_VERTEX_PROGRAM_POINT_SIZE_NV = $8642;
  GL_PROGRAM_POINT_SIZE = $8642;
  GL_PROGRAM_POINT_SIZE_ARB = $8642;
  GL_PROGRAM_POINT_SIZE_EXT = $8642;
  GL_VERTEX_PROGRAM_TWO_SIDE = $8643;
  GL_VERTEX_PROGRAM_TWO_SIDE_ARB = $8643;
  GL_VERTEX_PROGRAM_TWO_SIDE_NV = $8643;
  GL_PROGRAM_PARAMETER_NV = $8644;
  GL_ATTRIB_ARRAY_POINTER_NV = $8645;
  GL_VERTEX_ATTRIB_ARRAY_POINTER = $8645;
  GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB = $8645;
  GL_PROGRAM_TARGET_NV = $8646;
  GL_PROGRAM_RESIDENT_NV = $8647;
  GL_TRACK_MATRIX_NV = $8648;
  GL_TRACK_MATRIX_TRANSFORM_NV = $8649;
  GL_VERTEX_PROGRAM_BINDING_NV = $864A;
  GL_PROGRAM_ERROR_POSITION_ARB = $864B;
  GL_PROGRAM_ERROR_POSITION_NV = $864B;
  GL_OFFSET_TEXTURE_RECTANGLE_NV = $864C;
  GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV = $864D;
  GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV = $864E;
  GL_DEPTH_CLAMP = $864F;
  GL_DEPTH_CLAMP_NV = $864F;
  GL_DEPTH_CLAMP_EXT = $864F;
  GL_VERTEX_ATTRIB_ARRAY0_NV = $8650;
  GL_VERTEX_ATTRIB_ARRAY1_NV = $8651;
  GL_VERTEX_ATTRIB_ARRAY2_NV = $8652;
  GL_VERTEX_ATTRIB_ARRAY3_NV = $8653;
  GL_VERTEX_ATTRIB_ARRAY4_NV = $8654;
  GL_VERTEX_ATTRIB_ARRAY5_NV = $8655;
  GL_VERTEX_ATTRIB_ARRAY6_NV = $8656;
  GL_VERTEX_ATTRIB_ARRAY7_NV = $8657;
  GL_VERTEX_ATTRIB_ARRAY8_NV = $8658;
  GL_VERTEX_ATTRIB_ARRAY9_NV = $8659;
  GL_VERTEX_ATTRIB_ARRAY10_NV = $865A;
  GL_VERTEX_ATTRIB_ARRAY11_NV = $865B;
  GL_VERTEX_ATTRIB_ARRAY12_NV = $865C;
  GL_VERTEX_ATTRIB_ARRAY13_NV = $865D;
  GL_VERTEX_ATTRIB_ARRAY14_NV = $865E;
  GL_VERTEX_ATTRIB_ARRAY15_NV = $865F;
  GL_MAP1_VERTEX_ATTRIB0_4_NV = $8660;
  GL_MAP1_VERTEX_ATTRIB1_4_NV = $8661;
  GL_MAP1_VERTEX_ATTRIB2_4_NV = $8662;
  GL_MAP1_VERTEX_ATTRIB3_4_NV = $8663;
  GL_MAP1_VERTEX_ATTRIB4_4_NV = $8664;
  GL_MAP1_VERTEX_ATTRIB5_4_NV = $8665;
  GL_MAP1_VERTEX_ATTRIB6_4_NV = $8666;
  GL_MAP1_VERTEX_ATTRIB7_4_NV = $8667;
  GL_MAP1_VERTEX_ATTRIB8_4_NV = $8668;
  GL_MAP1_VERTEX_ATTRIB9_4_NV = $8669;
  GL_MAP1_VERTEX_ATTRIB10_4_NV = $866A;
  GL_MAP1_VERTEX_ATTRIB11_4_NV = $866B;
  GL_MAP1_VERTEX_ATTRIB12_4_NV = $866C;
  GL_MAP1_VERTEX_ATTRIB13_4_NV = $866D;
  GL_MAP1_VERTEX_ATTRIB14_4_NV = $866E;
  GL_MAP1_VERTEX_ATTRIB15_4_NV = $866F;
  GL_MAP2_VERTEX_ATTRIB0_4_NV = $8670;
  GL_MAP2_VERTEX_ATTRIB1_4_NV = $8671;
  GL_MAP2_VERTEX_ATTRIB2_4_NV = $8672;
  GL_MAP2_VERTEX_ATTRIB3_4_NV = $8673;
  GL_MAP2_VERTEX_ATTRIB4_4_NV = $8674;
  GL_MAP2_VERTEX_ATTRIB5_4_NV = $8675;
  GL_MAP2_VERTEX_ATTRIB6_4_NV = $8676;
  GL_MAP2_VERTEX_ATTRIB7_4_NV = $8677;
  GL_PROGRAM_BINDING_ARB = $8677;
  GL_MAP2_VERTEX_ATTRIB8_4_NV = $8678;
  GL_MAP2_VERTEX_ATTRIB9_4_NV = $8679;
  GL_MAP2_VERTEX_ATTRIB10_4_NV = $867A;
  GL_MAP2_VERTEX_ATTRIB11_4_NV = $867B;
  GL_MAP2_VERTEX_ATTRIB12_4_NV = $867C;
  GL_MAP2_VERTEX_ATTRIB13_4_NV = $867D;
  GL_MAP2_VERTEX_ATTRIB14_4_NV = $867E;
  GL_MAP2_VERTEX_ATTRIB15_4_NV = $867F;
  GL_TEXTURE_COMPRESSED_IMAGE_SIZE = $86A0;
  GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB = $86A0;
  GL_TEXTURE_COMPRESSED = $86A1;
  GL_TEXTURE_COMPRESSED_ARB = $86A1;
  GL_NUM_COMPRESSED_TEXTURE_FORMATS = $86A2;
  GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB = $86A2;
  GL_COMPRESSED_TEXTURE_FORMATS = $86A3;
  GL_COMPRESSED_TEXTURE_FORMATS_ARB = $86A3;
  GL_MAX_VERTEX_UNITS_ARB = $86A4;
  GL_MAX_VERTEX_UNITS_OES = $86A4;
  GL_ACTIVE_VERTEX_UNITS_ARB = $86A5;
  GL_WEIGHT_SUM_UNITY_ARB = $86A6;
  GL_VERTEX_BLEND_ARB = $86A7;
  GL_CURRENT_WEIGHT_ARB = $86A8;
  GL_WEIGHT_ARRAY_TYPE_ARB = $86A9;
  GL_WEIGHT_ARRAY_TYPE_OES = $86A9;
  GL_WEIGHT_ARRAY_STRIDE_ARB = $86AA;
  GL_WEIGHT_ARRAY_STRIDE_OES = $86AA;
  GL_WEIGHT_ARRAY_SIZE_ARB = $86AB;
  GL_WEIGHT_ARRAY_SIZE_OES = $86AB;
  GL_WEIGHT_ARRAY_POINTER_ARB = $86AC;
  GL_WEIGHT_ARRAY_POINTER_OES = $86AC;
  GL_WEIGHT_ARRAY_ARB = $86AD;
  GL_WEIGHT_ARRAY_OES = $86AD;
  GL_DOT3_RGB = $86AE;
  GL_DOT3_RGB_ARB = $86AE;
  GL_DOT3_RGBA = $86AF;
  GL_DOT3_RGBA_ARB = $86AF;
  GL_DOT3_RGBA_IMG = $86AF;
  GL_COMPRESSED_RGB_FXT1_3DFX = $86B0;
  GL_COMPRESSED_RGBA_FXT1_3DFX = $86B1;
  GL_MULTISAMPLE_3DFX = $86B2;
  GL_SAMPLE_BUFFERS_3DFX = $86B3;
  GL_SAMPLES_3DFX = $86B4;
  GL_EVAL_2D_NV = $86C0;
  GL_EVAL_TRIANGULAR_2D_NV = $86C1;
  GL_MAP_TESSELLATION_NV = $86C2;
  GL_MAP_ATTRIB_U_ORDER_NV = $86C3;
  GL_MAP_ATTRIB_V_ORDER_NV = $86C4;
  GL_EVAL_FRACTIONAL_TESSELLATION_NV = $86C5;
  GL_EVAL_VERTEX_ATTRIB0_NV = $86C6;
  GL_EVAL_VERTEX_ATTRIB1_NV = $86C7;
  GL_EVAL_VERTEX_ATTRIB2_NV = $86C8;
  GL_EVAL_VERTEX_ATTRIB3_NV = $86C9;
  GL_EVAL_VERTEX_ATTRIB4_NV = $86CA;
  GL_EVAL_VERTEX_ATTRIB5_NV = $86CB;
  GL_EVAL_VERTEX_ATTRIB6_NV = $86CC;
  GL_EVAL_VERTEX_ATTRIB7_NV = $86CD;
  GL_EVAL_VERTEX_ATTRIB8_NV = $86CE;
  GL_EVAL_VERTEX_ATTRIB9_NV = $86CF;
  GL_EVAL_VERTEX_ATTRIB10_NV = $86D0;
  GL_EVAL_VERTEX_ATTRIB11_NV = $86D1;
  GL_EVAL_VERTEX_ATTRIB12_NV = $86D2;
  GL_EVAL_VERTEX_ATTRIB13_NV = $86D3;
  GL_EVAL_VERTEX_ATTRIB14_NV = $86D4;
  GL_EVAL_VERTEX_ATTRIB15_NV = $86D5;
  GL_MAX_MAP_TESSELLATION_NV = $86D6;
  GL_MAX_RATIONAL_EVAL_ORDER_NV = $86D7;
  GL_MAX_PROGRAM_PATCH_ATTRIBS_NV = $86D8;
  GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV = $86D9;
  GL_UNSIGNED_INT_S8_S8_8_8_NV = $86DA;
  GL_UNSIGNED_INT_8_8_S8_S8_REV_NV = $86DB;
  GL_DSDT_MAG_INTENSITY_NV = $86DC;
  GL_SHADER_CONSISTENT_NV = $86DD;
  GL_TEXTURE_SHADER_NV = $86DE;
  GL_SHADER_OPERATION_NV = $86DF;
  GL_CULL_MODES_NV = $86E0;
  GL_OFFSET_TEXTURE_MATRIX_NV = $86E1;
  GL_OFFSET_TEXTURE_2D_MATRIX_NV = $86E1;
  GL_OFFSET_TEXTURE_SCALE_NV = $86E2;
  GL_OFFSET_TEXTURE_2D_SCALE_NV = $86E2;
  GL_OFFSET_TEXTURE_BIAS_NV = $86E3;
  GL_OFFSET_TEXTURE_2D_BIAS_NV = $86E3;
  GL_PREVIOUS_TEXTURE_INPUT_NV = $86E4;
  GL_CONST_EYE_NV = $86E5;
  GL_PASS_THROUGH_NV = $86E6;
  GL_CULL_FRAGMENT_NV = $86E7;
  GL_OFFSET_TEXTURE_2D_NV = $86E8;
  GL_DEPENDENT_AR_TEXTURE_2D_NV = $86E9;
  GL_DEPENDENT_GB_TEXTURE_2D_NV = $86EA;
  GL_SURFACE_STATE_NV = $86EB;
  GL_DOT_PRODUCT_NV = $86EC;
  GL_DOT_PRODUCT_DEPTH_REPLACE_NV = $86ED;
  GL_DOT_PRODUCT_TEXTURE_2D_NV = $86EE;
  GL_DOT_PRODUCT_TEXTURE_3D_NV = $86EF;
  GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV = $86F0;
  GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV = $86F1;
  GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV = $86F2;
  GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV = $86F3;
  GL_HILO_NV = $86F4;
  GL_DSDT_NV = $86F5;
  GL_DSDT_MAG_NV = $86F6;
  GL_DSDT_MAG_VIB_NV = $86F7;
  GL_HILO16_NV = $86F8;
  GL_SIGNED_HILO_NV = $86F9;
  GL_SIGNED_HILO16_NV = $86FA;
  GL_SIGNED_RGBA_NV = $86FB;
  GL_SIGNED_RGBA8_NV = $86FC;
  GL_SURFACE_REGISTERED_NV = $86FD;
  GL_SIGNED_RGB_NV = $86FE;
  GL_SIGNED_RGB8_NV = $86FF;
  GL_SURFACE_MAPPED_NV = $8700;
  GL_SIGNED_LUMINANCE_NV = $8701;
  GL_SIGNED_LUMINANCE8_NV = $8702;
  GL_SIGNED_LUMINANCE_ALPHA_NV = $8703;
  GL_SIGNED_LUMINANCE8_ALPHA8_NV = $8704;
  GL_SIGNED_ALPHA_NV = $8705;
  GL_SIGNED_ALPHA8_NV = $8706;
  GL_SIGNED_INTENSITY_NV = $8707;
  GL_SIGNED_INTENSITY8_NV = $8708;
  GL_DSDT8_NV = $8709;
  GL_DSDT8_MAG8_NV = $870A;
  GL_DSDT8_MAG8_INTENSITY8_NV = $870B;
  GL_SIGNED_RGB_UNSIGNED_ALPHA_NV = $870C;
  GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV = $870D;
  GL_HI_SCALE_NV = $870E;
  GL_LO_SCALE_NV = $870F;
  GL_DS_SCALE_NV = $8710;
  GL_DT_SCALE_NV = $8711;
  GL_MAGNITUDE_SCALE_NV = $8712;
  GL_VIBRANCE_SCALE_NV = $8713;
  GL_HI_BIAS_NV = $8714;
  GL_LO_BIAS_NV = $8715;
  GL_DS_BIAS_NV = $8716;
  GL_DT_BIAS_NV = $8717;
  GL_MAGNITUDE_BIAS_NV = $8718;
  GL_VIBRANCE_BIAS_NV = $8719;
  GL_TEXTURE_BORDER_VALUES_NV = $871A;
  GL_TEXTURE_HI_SIZE_NV = $871B;
  GL_TEXTURE_LO_SIZE_NV = $871C;
  GL_TEXTURE_DS_SIZE_NV = $871D;
  GL_TEXTURE_DT_SIZE_NV = $871E;
  GL_TEXTURE_MAG_SIZE_NV = $871F;
  GL_MODELVIEW2_ARB = $8722;
  GL_MODELVIEW3_ARB = $8723;
  GL_MODELVIEW4_ARB = $8724;
  GL_MODELVIEW5_ARB = $8725;
  GL_MODELVIEW6_ARB = $8726;
  GL_MODELVIEW7_ARB = $8727;
  GL_MODELVIEW8_ARB = $8728;
  GL_MODELVIEW9_ARB = $8729;
  GL_MODELVIEW10_ARB = $872A;
  GL_MODELVIEW11_ARB = $872B;
  GL_MODELVIEW12_ARB = $872C;
  GL_MODELVIEW13_ARB = $872D;
  GL_MODELVIEW14_ARB = $872E;
  GL_MODELVIEW15_ARB = $872F;
  GL_MODELVIEW16_ARB = $8730;
  GL_MODELVIEW17_ARB = $8731;
  GL_MODELVIEW18_ARB = $8732;
  GL_MODELVIEW19_ARB = $8733;
  GL_MODELVIEW20_ARB = $8734;
  GL_MODELVIEW21_ARB = $8735;
  GL_MODELVIEW22_ARB = $8736;
  GL_MODELVIEW23_ARB = $8737;
  GL_MODELVIEW24_ARB = $8738;
  GL_MODELVIEW25_ARB = $8739;
  GL_MODELVIEW26_ARB = $873A;
  GL_MODELVIEW27_ARB = $873B;
  GL_MODELVIEW28_ARB = $873C;
  GL_MODELVIEW29_ARB = $873D;
  GL_MODELVIEW30_ARB = $873E;
  GL_MODELVIEW31_ARB = $873F;
  GL_DOT3_RGB_EXT = $8740;
  GL_Z400_BINARY_AMD = $8740;
  GL_DOT3_RGBA_EXT = $8741;
  GL_PROGRAM_BINARY_LENGTH_OES = $8741;
  GL_PROGRAM_BINARY_LENGTH = $8741;
  GL_MIRROR_CLAMP_ATI = $8742;
  GL_MIRROR_CLAMP_EXT = $8742;
  GL_MIRROR_CLAMP_TO_EDGE = $8743;
  GL_MIRROR_CLAMP_TO_EDGE_ATI = $8743;
  GL_MIRROR_CLAMP_TO_EDGE_EXT = $8743;
  GL_MODULATE_ADD_ATI = $8744;
  GL_MODULATE_SIGNED_ADD_ATI = $8745;
  GL_MODULATE_SUBTRACT_ATI = $8746;
  GL_SET_AMD = $874A;
  GL_REPLACE_VALUE_AMD = $874B;
  GL_STENCIL_OP_VALUE_AMD = $874C;
  GL_STENCIL_BACK_OP_VALUE_AMD = $874D;
  GL_VERTEX_ATTRIB_ARRAY_LONG = $874E;
  GL_OCCLUSION_QUERY_EVENT_MASK_AMD = $874F;
  GL_DEPTH_STENCIL_MESA = $8750;
  GL_UNSIGNED_INT_24_8_MESA = $8751;
  GL_UNSIGNED_INT_8_24_REV_MESA = $8752;
  GL_UNSIGNED_SHORT_15_1_MESA = $8753;
  GL_UNSIGNED_SHORT_1_15_REV_MESA = $8754;
  GL_TRACE_MASK_MESA = $8755;
  GL_TRACE_NAME_MESA = $8756;
  GL_YCBCR_MESA = $8757;
  GL_PACK_INVERT_MESA = $8758;
  GL_DEBUG_OBJECT_MESA = $8759;
  GL_TEXTURE_1D_STACK_MESAX = $8759;
  GL_DEBUG_PRINT_MESA = $875A;
  GL_TEXTURE_2D_STACK_MESAX = $875A;
  GL_DEBUG_ASSERT_MESA = $875B;
  GL_PROXY_TEXTURE_1D_STACK_MESAX = $875B;
  GL_PROXY_TEXTURE_2D_STACK_MESAX = $875C;
  GL_TEXTURE_1D_STACK_BINDING_MESAX = $875D;
  GL_TEXTURE_2D_STACK_BINDING_MESAX = $875E;
  GL_PROGRAM_BINARY_FORMAT_MESA = $875F;
  GL_STATIC_ATI = $8760;
  GL_DYNAMIC_ATI = $8761;
  GL_PRESERVE_ATI = $8762;
  GL_DISCARD_ATI = $8763;
  GL_BUFFER_SIZE = $8764;
  GL_BUFFER_SIZE_ARB = $8764;
  GL_OBJECT_BUFFER_SIZE_ATI = $8764;
  GL_BUFFER_USAGE = $8765;
  GL_BUFFER_USAGE_ARB = $8765;
  GL_OBJECT_BUFFER_USAGE_ATI = $8765;
  GL_ARRAY_OBJECT_BUFFER_ATI = $8766;
  GL_ARRAY_OBJECT_OFFSET_ATI = $8767;
  GL_ELEMENT_ARRAY_ATI = $8768;
  GL_ELEMENT_ARRAY_TYPE_ATI = $8769;
  GL_ELEMENT_ARRAY_POINTER_ATI = $876A;
  GL_MAX_VERTEX_STREAMS_ATI = $876B;
  GL_VERTEX_STREAM0_ATI = $876C;
  GL_VERTEX_STREAM1_ATI = $876D;
  GL_VERTEX_STREAM2_ATI = $876E;
  GL_VERTEX_STREAM3_ATI = $876F;
  GL_VERTEX_STREAM4_ATI = $8770;
  GL_VERTEX_STREAM5_ATI = $8771;
  GL_VERTEX_STREAM6_ATI = $8772;
  GL_VERTEX_STREAM7_ATI = $8773;
  GL_VERTEX_SOURCE_ATI = $8774;
  GL_BUMP_ROT_MATRIX_ATI = $8775;
  GL_BUMP_ROT_MATRIX_SIZE_ATI = $8776;
  GL_BUMP_NUM_TEX_UNITS_ATI = $8777;
  GL_BUMP_TEX_UNITS_ATI = $8778;
  GL_DUDV_ATI = $8779;
  GL_DU8DV8_ATI = $877A;
  GL_BUMP_ENVMAP_ATI = $877B;
  GL_BUMP_TARGET_ATI = $877C;
  GL_VERTEX_SHADER_EXT = $8780;
  GL_VERTEX_SHADER_BINDING_EXT = $8781;
  GL_OP_INDEX_EXT = $8782;
  GL_OP_NEGATE_EXT = $8783;
  GL_OP_DOT3_EXT = $8784;
  GL_OP_DOT4_EXT = $8785;
  GL_OP_MUL_EXT = $8786;
  GL_OP_ADD_EXT = $8787;
  GL_OP_MADD_EXT = $8788;
  GL_OP_FRAC_EXT = $8789;
  GL_OP_MAX_EXT = $878A;
  GL_OP_MIN_EXT = $878B;
  GL_OP_SET_GE_EXT = $878C;
  GL_OP_SET_LT_EXT = $878D;
  GL_OP_CLAMP_EXT = $878E;
  GL_OP_FLOOR_EXT = $878F;
  GL_OP_ROUND_EXT = $8790;
  GL_OP_EXP_BASE_2_EXT = $8791;
  GL_OP_LOG_BASE_2_EXT = $8792;
  GL_OP_POWER_EXT = $8793;
  GL_OP_RECIP_EXT = $8794;
  GL_OP_RECIP_SQRT_EXT = $8795;
  GL_OP_SUB_EXT = $8796;
  GL_OP_CROSS_PRODUCT_EXT = $8797;
  GL_OP_MULTIPLY_MATRIX_EXT = $8798;
  GL_OP_MOV_EXT = $8799;
  GL_OUTPUT_VERTEX_EXT = $879A;
  GL_OUTPUT_COLOR0_EXT = $879B;
  GL_OUTPUT_COLOR1_EXT = $879C;
  GL_OUTPUT_TEXTURE_COORD0_EXT = $879D;
  GL_OUTPUT_TEXTURE_COORD1_EXT = $879E;
  GL_OUTPUT_TEXTURE_COORD2_EXT = $879F;
  GL_OUTPUT_TEXTURE_COORD3_EXT = $87A0;
  GL_OUTPUT_TEXTURE_COORD4_EXT = $87A1;
  GL_OUTPUT_TEXTURE_COORD5_EXT = $87A2;
  GL_OUTPUT_TEXTURE_COORD6_EXT = $87A3;
  GL_OUTPUT_TEXTURE_COORD7_EXT = $87A4;
  GL_OUTPUT_TEXTURE_COORD8_EXT = $87A5;
  GL_OUTPUT_TEXTURE_COORD9_EXT = $87A6;
  GL_OUTPUT_TEXTURE_COORD10_EXT = $87A7;
  GL_OUTPUT_TEXTURE_COORD11_EXT = $87A8;
  GL_OUTPUT_TEXTURE_COORD12_EXT = $87A9;
  GL_OUTPUT_TEXTURE_COORD13_EXT = $87AA;
  GL_OUTPUT_TEXTURE_COORD14_EXT = $87AB;
  GL_OUTPUT_TEXTURE_COORD15_EXT = $87AC;
  GL_OUTPUT_TEXTURE_COORD16_EXT = $87AD;
  GL_OUTPUT_TEXTURE_COORD17_EXT = $87AE;
  GL_OUTPUT_TEXTURE_COORD18_EXT = $87AF;
  GL_OUTPUT_TEXTURE_COORD19_EXT = $87B0;
  GL_OUTPUT_TEXTURE_COORD20_EXT = $87B1;
  GL_OUTPUT_TEXTURE_COORD21_EXT = $87B2;
  GL_OUTPUT_TEXTURE_COORD22_EXT = $87B3;
  GL_OUTPUT_TEXTURE_COORD23_EXT = $87B4;
  GL_OUTPUT_TEXTURE_COORD24_EXT = $87B5;
  GL_OUTPUT_TEXTURE_COORD25_EXT = $87B6;
  GL_OUTPUT_TEXTURE_COORD26_EXT = $87B7;
  GL_OUTPUT_TEXTURE_COORD27_EXT = $87B8;
  GL_OUTPUT_TEXTURE_COORD28_EXT = $87B9;
  GL_OUTPUT_TEXTURE_COORD29_EXT = $87BA;
  GL_OUTPUT_TEXTURE_COORD30_EXT = $87BB;
  GL_OUTPUT_TEXTURE_COORD31_EXT = $87BC;
  GL_OUTPUT_FOG_EXT = $87BD;
  GL_SCALAR_EXT = $87BE;
  GL_VECTOR_EXT = $87BF;
  GL_MATRIX_EXT = $87C0;
  GL_VARIANT_EXT = $87C1;
  GL_INVARIANT_EXT = $87C2;
  GL_LOCAL_CONSTANT_EXT = $87C3;
  GL_LOCAL_EXT = $87C4;
  GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT = $87C5;
  GL_MAX_VERTEX_SHADER_VARIANTS_EXT = $87C6;
  GL_MAX_VERTEX_SHADER_INVARIANTS_EXT = $87C7;
  GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = $87C8;
  GL_MAX_VERTEX_SHADER_LOCALS_EXT = $87C9;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT = $87CA;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT = $87CB;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = $87CC;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT = $87CD;
  GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT = $87CE;
  GL_VERTEX_SHADER_INSTRUCTIONS_EXT = $87CF;
  GL_VERTEX_SHADER_VARIANTS_EXT = $87D0;
  GL_VERTEX_SHADER_INVARIANTS_EXT = $87D1;
  GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = $87D2;
  GL_VERTEX_SHADER_LOCALS_EXT = $87D3;
  GL_VERTEX_SHADER_OPTIMIZED_EXT = $87D4;
  GL_X_EXT = $87D5;
  GL_Y_EXT = $87D6;
  GL_Z_EXT = $87D7;
  GL_W_EXT = $87D8;
  GL_NEGATIVE_X_EXT = $87D9;
  GL_NEGATIVE_Y_EXT = $87DA;
  GL_NEGATIVE_Z_EXT = $87DB;
  GL_NEGATIVE_W_EXT = $87DC;
  GL_ZERO_EXT = $87DD;
  GL_ONE_EXT = $87DE;
  GL_NEGATIVE_ONE_EXT = $87DF;
  GL_NORMALIZED_RANGE_EXT = $87E0;
  GL_FULL_RANGE_EXT = $87E1;
  GL_CURRENT_VERTEX_EXT = $87E2;
  GL_MVP_MATRIX_EXT = $87E3;
  GL_VARIANT_VALUE_EXT = $87E4;
  GL_VARIANT_DATATYPE_EXT = $87E5;
  GL_VARIANT_ARRAY_STRIDE_EXT = $87E6;
  GL_VARIANT_ARRAY_TYPE_EXT = $87E7;
  GL_VARIANT_ARRAY_EXT = $87E8;
  GL_VARIANT_ARRAY_POINTER_EXT = $87E9;
  GL_INVARIANT_VALUE_EXT = $87EA;
  GL_INVARIANT_DATATYPE_EXT = $87EB;
  GL_LOCAL_CONSTANT_VALUE_EXT = $87EC;
  GL_LOCAL_CONSTANT_DATATYPE_EXT = $87ED;
  GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD = $87EE;
  GL_PN_TRIANGLES_ATI = $87F0;
  GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI = $87F1;
  GL_PN_TRIANGLES_POINT_MODE_ATI = $87F2;
  GL_PN_TRIANGLES_NORMAL_MODE_ATI = $87F3;
  GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI = $87F4;
  GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI = $87F5;
  GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI = $87F6;
  GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI = $87F7;
  GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI = $87F8;
  GL_3DC_X_AMD = $87F9;
  GL_3DC_XY_AMD = $87FA;
  GL_VBO_FREE_MEMORY_ATI = $87FB;
  GL_TEXTURE_FREE_MEMORY_ATI = $87FC;
  GL_RENDERBUFFER_FREE_MEMORY_ATI = $87FD;
  GL_NUM_PROGRAM_BINARY_FORMATS = $87FE;
  GL_NUM_PROGRAM_BINARY_FORMATS_OES = $87FE;
  GL_PROGRAM_BINARY_FORMATS = $87FF;
  GL_PROGRAM_BINARY_FORMATS_OES = $87FF;
  GL_STENCIL_BACK_FUNC = $8800;
  GL_STENCIL_BACK_FUNC_ATI = $8800;
  GL_STENCIL_BACK_FAIL = $8801;
  GL_STENCIL_BACK_FAIL_ATI = $8801;
  GL_STENCIL_BACK_PASS_DEPTH_FAIL = $8802;
  GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI = $8802;
  GL_STENCIL_BACK_PASS_DEPTH_PASS = $8803;
  GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI = $8803;
  GL_FRAGMENT_PROGRAM_ARB = $8804;
  GL_PROGRAM_ALU_INSTRUCTIONS_ARB = $8805;
  GL_PROGRAM_TEX_INSTRUCTIONS_ARB = $8806;
  GL_PROGRAM_TEX_INDIRECTIONS_ARB = $8807;
  GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = $8808;
  GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = $8809;
  GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = $880A;
  GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB = $880B;
  GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB = $880C;
  GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB = $880D;
  GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = $880E;
  GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = $880F;
  GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = $8810;
  GL_RGBA32F = $8814;
  GL_RGBA32F_ARB = $8814;
  GL_RGBA32F_EXT = $8814;
  GL_RGBA_FLOAT32_APPLE = $8814;
  GL_RGBA_FLOAT32_ATI = $8814;
  GL_RGB32F = $8815;
  GL_RGB32F_ARB = $8815;
  GL_RGB32F_EXT = $8815;
  GL_RGB_FLOAT32_APPLE = $8815;
  GL_RGB_FLOAT32_ATI = $8815;
  GL_ALPHA32F_ARB = $8816;
  GL_ALPHA32F_EXT = $8816;
  GL_ALPHA_FLOAT32_APPLE = $8816;
  GL_ALPHA_FLOAT32_ATI = $8816;
  GL_INTENSITY32F_ARB = $8817;
  GL_INTENSITY_FLOAT32_APPLE = $8817;
  GL_INTENSITY_FLOAT32_ATI = $8817;
  GL_LUMINANCE32F_ARB = $8818;
  GL_LUMINANCE32F_EXT = $8818;
  GL_LUMINANCE_FLOAT32_APPLE = $8818;
  GL_LUMINANCE_FLOAT32_ATI = $8818;
  GL_LUMINANCE_ALPHA32F_ARB = $8819;
  GL_LUMINANCE_ALPHA32F_EXT = $8819;
  GL_LUMINANCE_ALPHA_FLOAT32_APPLE = $8819;
  GL_LUMINANCE_ALPHA_FLOAT32_ATI = $8819;
  GL_RGBA16F = $881A;
  GL_RGBA16F_ARB = $881A;
  GL_RGBA16F_EXT = $881A;
  GL_RGBA_FLOAT16_APPLE = $881A;
  GL_RGBA_FLOAT16_ATI = $881A;
  GL_RGB16F = $881B;
  GL_RGB16F_ARB = $881B;
  GL_RGB16F_EXT = $881B;
  GL_RGB_FLOAT16_APPLE = $881B;
  GL_RGB_FLOAT16_ATI = $881B;
  GL_ALPHA16F_ARB = $881C;
  GL_ALPHA16F_EXT = $881C;
  GL_ALPHA_FLOAT16_APPLE = $881C;
  GL_ALPHA_FLOAT16_ATI = $881C;
  GL_INTENSITY16F_ARB = $881D;
  GL_INTENSITY_FLOAT16_APPLE = $881D;
  GL_INTENSITY_FLOAT16_ATI = $881D;
  GL_LUMINANCE16F_ARB = $881E;
  GL_LUMINANCE16F_EXT = $881E;
  GL_LUMINANCE_FLOAT16_APPLE = $881E;
  GL_LUMINANCE_FLOAT16_ATI = $881E;
  GL_LUMINANCE_ALPHA16F_ARB = $881F;
  GL_LUMINANCE_ALPHA16F_EXT = $881F;
  GL_LUMINANCE_ALPHA_FLOAT16_APPLE = $881F;
  GL_LUMINANCE_ALPHA_FLOAT16_ATI = $881F;
  GL_RGBA_FLOAT_MODE_ARB = $8820;
  GL_RGBA_FLOAT_MODE_ATI = $8820;
  GL_WRITEONLY_RENDERING_QCOM = $8823;
  GL_MAX_DRAW_BUFFERS = $8824;
  GL_MAX_DRAW_BUFFERS_ARB = $8824;
  GL_MAX_DRAW_BUFFERS_ATI = $8824;
  GL_MAX_DRAW_BUFFERS_EXT = $8824;
  GL_MAX_DRAW_BUFFERS_NV = $8824;
  GL_DRAW_BUFFER0 = $8825;
  GL_DRAW_BUFFER0_ARB = $8825;
  GL_DRAW_BUFFER0_ATI = $8825;
  GL_DRAW_BUFFER0_EXT = $8825;
  GL_DRAW_BUFFER0_NV = $8825;
  GL_DRAW_BUFFER1 = $8826;
  GL_DRAW_BUFFER1_ARB = $8826;
  GL_DRAW_BUFFER1_ATI = $8826;
  GL_DRAW_BUFFER1_EXT = $8826;
  GL_DRAW_BUFFER1_NV = $8826;
  GL_DRAW_BUFFER2 = $8827;
  GL_DRAW_BUFFER2_ARB = $8827;
  GL_DRAW_BUFFER2_ATI = $8827;
  GL_DRAW_BUFFER2_EXT = $8827;
  GL_DRAW_BUFFER2_NV = $8827;
  GL_DRAW_BUFFER3 = $8828;
  GL_DRAW_BUFFER3_ARB = $8828;
  GL_DRAW_BUFFER3_ATI = $8828;
  GL_DRAW_BUFFER3_EXT = $8828;
  GL_DRAW_BUFFER3_NV = $8828;
  GL_DRAW_BUFFER4 = $8829;
  GL_DRAW_BUFFER4_ARB = $8829;
  GL_DRAW_BUFFER4_ATI = $8829;
  GL_DRAW_BUFFER4_EXT = $8829;
  GL_DRAW_BUFFER4_NV = $8829;
  GL_DRAW_BUFFER5 = $882A;
  GL_DRAW_BUFFER5_ARB = $882A;
  GL_DRAW_BUFFER5_ATI = $882A;
  GL_DRAW_BUFFER5_EXT = $882A;
  GL_DRAW_BUFFER5_NV = $882A;
  GL_DRAW_BUFFER6 = $882B;
  GL_DRAW_BUFFER6_ARB = $882B;
  GL_DRAW_BUFFER6_ATI = $882B;
  GL_DRAW_BUFFER6_EXT = $882B;
  GL_DRAW_BUFFER6_NV = $882B;
  GL_DRAW_BUFFER7 = $882C;
  GL_DRAW_BUFFER7_ARB = $882C;
  GL_DRAW_BUFFER7_ATI = $882C;
  GL_DRAW_BUFFER7_EXT = $882C;
  GL_DRAW_BUFFER7_NV = $882C;
  GL_DRAW_BUFFER8 = $882D;
  GL_DRAW_BUFFER8_ARB = $882D;
  GL_DRAW_BUFFER8_ATI = $882D;
  GL_DRAW_BUFFER8_EXT = $882D;
  GL_DRAW_BUFFER8_NV = $882D;
  GL_DRAW_BUFFER9 = $882E;
  GL_DRAW_BUFFER9_ARB = $882E;
  GL_DRAW_BUFFER9_ATI = $882E;
  GL_DRAW_BUFFER9_EXT = $882E;
  GL_DRAW_BUFFER9_NV = $882E;
  GL_DRAW_BUFFER10 = $882F;
  GL_DRAW_BUFFER10_ARB = $882F;
  GL_DRAW_BUFFER10_ATI = $882F;
  GL_DRAW_BUFFER10_EXT = $882F;
  GL_DRAW_BUFFER10_NV = $882F;
  GL_DRAW_BUFFER11 = $8830;
  GL_DRAW_BUFFER11_ARB = $8830;
  GL_DRAW_BUFFER11_ATI = $8830;
  GL_DRAW_BUFFER11_EXT = $8830;
  GL_DRAW_BUFFER11_NV = $8830;
  GL_DRAW_BUFFER12 = $8831;
  GL_DRAW_BUFFER12_ARB = $8831;
  GL_DRAW_BUFFER12_ATI = $8831;
  GL_DRAW_BUFFER12_EXT = $8831;
  GL_DRAW_BUFFER12_NV = $8831;
  GL_DRAW_BUFFER13 = $8832;
  GL_DRAW_BUFFER13_ARB = $8832;
  GL_DRAW_BUFFER13_ATI = $8832;
  GL_DRAW_BUFFER13_EXT = $8832;
  GL_DRAW_BUFFER13_NV = $8832;
  GL_DRAW_BUFFER14 = $8833;
  GL_DRAW_BUFFER14_ARB = $8833;
  GL_DRAW_BUFFER14_ATI = $8833;
  GL_DRAW_BUFFER14_EXT = $8833;
  GL_DRAW_BUFFER14_NV = $8833;
  GL_DRAW_BUFFER15 = $8834;
  GL_DRAW_BUFFER15_ARB = $8834;
  GL_DRAW_BUFFER15_ATI = $8834;
  GL_DRAW_BUFFER15_EXT = $8834;
  GL_DRAW_BUFFER15_NV = $8834;
  GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI = $8835;
  GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI = $8837;
  GL_BLEND_EQUATION_ALPHA = $883D;
  GL_BLEND_EQUATION_ALPHA_EXT = $883D;
  GL_BLEND_EQUATION_ALPHA_OES = $883D;
  GL_SUBSAMPLE_DISTANCE_AMD = $883F;
  GL_MATRIX_PALETTE_ARB = $8840;
  GL_MATRIX_PALETTE_OES = $8840;
  GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB = $8841;
  GL_MAX_PALETTE_MATRICES_ARB = $8842;
  GL_MAX_PALETTE_MATRICES_OES = $8842;
  GL_CURRENT_PALETTE_MATRIX_ARB = $8843;
  GL_CURRENT_PALETTE_MATRIX_OES = $8843;
  GL_MATRIX_INDEX_ARRAY_ARB = $8844;
  GL_MATRIX_INDEX_ARRAY_OES = $8844;
  GL_CURRENT_MATRIX_INDEX_ARB = $8845;
  GL_MATRIX_INDEX_ARRAY_SIZE_ARB = $8846;
  GL_MATRIX_INDEX_ARRAY_SIZE_OES = $8846;
  GL_MATRIX_INDEX_ARRAY_TYPE_ARB = $8847;
  GL_MATRIX_INDEX_ARRAY_TYPE_OES = $8847;
  GL_MATRIX_INDEX_ARRAY_STRIDE_ARB = $8848;
  GL_MATRIX_INDEX_ARRAY_STRIDE_OES = $8848;
  GL_MATRIX_INDEX_ARRAY_POINTER_ARB = $8849;
  GL_MATRIX_INDEX_ARRAY_POINTER_OES = $8849;
  GL_TEXTURE_DEPTH_SIZE = $884A;
  GL_TEXTURE_DEPTH_SIZE_ARB = $884A;
  GL_DEPTH_TEXTURE_MODE = $884B;
  GL_DEPTH_TEXTURE_MODE_ARB = $884B;
  GL_TEXTURE_COMPARE_MODE = $884C;
  GL_TEXTURE_COMPARE_MODE_ARB = $884C;
  GL_TEXTURE_COMPARE_MODE_EXT = $884C;
  GL_TEXTURE_COMPARE_FUNC = $884D;
  GL_TEXTURE_COMPARE_FUNC_ARB = $884D;
  GL_TEXTURE_COMPARE_FUNC_EXT = $884D;
  GL_COMPARE_R_TO_TEXTURE = $884E;
  GL_COMPARE_R_TO_TEXTURE_ARB = $884E;
  GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT = $884E;
  GL_COMPARE_REF_TO_TEXTURE = $884E;
  GL_COMPARE_REF_TO_TEXTURE_EXT = $884E;
  GL_TEXTURE_CUBE_MAP_SEAMLESS = $884F;
  GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV = $8850;
  GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV = $8851;
  GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV = $8852;
  GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV = $8853;
  GL_OFFSET_HILO_TEXTURE_2D_NV = $8854;
  GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV = $8855;
  GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV = $8856;
  GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV = $8857;
  GL_DEPENDENT_HILO_TEXTURE_2D_NV = $8858;
  GL_DEPENDENT_RGB_TEXTURE_3D_NV = $8859;
  GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV = $885A;
  GL_DOT_PRODUCT_PASS_THROUGH_NV = $885B;
  GL_DOT_PRODUCT_TEXTURE_1D_NV = $885C;
  GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV = $885D;
  GL_HILO8_NV = $885E;
  GL_SIGNED_HILO8_NV = $885F;
  GL_FORCE_BLUE_TO_ONE_NV = $8860;
  GL_POINT_SPRITE = $8861;
  GL_POINT_SPRITE_ARB = $8861;
  GL_POINT_SPRITE_NV = $8861;
  GL_POINT_SPRITE_OES = $8861;
  GL_COORD_REPLACE = $8862;
  GL_COORD_REPLACE_ARB = $8862;
  GL_COORD_REPLACE_NV = $8862;
  GL_COORD_REPLACE_OES = $8862;
  GL_POINT_SPRITE_R_MODE_NV = $8863;
  GL_PIXEL_COUNTER_BITS_NV = $8864;
  GL_QUERY_COUNTER_BITS = $8864;
  GL_QUERY_COUNTER_BITS_ARB = $8864;
  GL_QUERY_COUNTER_BITS_EXT = $8864;
  GL_CURRENT_OCCLUSION_QUERY_ID_NV = $8865;
  GL_CURRENT_QUERY = $8865;
  GL_CURRENT_QUERY_ARB = $8865;
  GL_CURRENT_QUERY_EXT = $8865;
  GL_PIXEL_COUNT_NV = $8866;
  GL_QUERY_RESULT = $8866;
  GL_QUERY_RESULT_ARB = $8866;
  GL_QUERY_RESULT_EXT = $8866;
  GL_PIXEL_COUNT_AVAILABLE_NV = $8867;
  GL_QUERY_RESULT_AVAILABLE = $8867;
  GL_QUERY_RESULT_AVAILABLE_ARB = $8867;
  GL_QUERY_RESULT_AVAILABLE_EXT = $8867;
  GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV = $8868;
  GL_MAX_VERTEX_ATTRIBS = $8869;
  GL_MAX_VERTEX_ATTRIBS_ARB = $8869;
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = $886A;
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB = $886A;
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = $886C;
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT = $886C;
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_OES = $886C;
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = $886D;
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT = $886D;
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES = $886D;
  GL_DEPTH_STENCIL_TO_RGBA_NV = $886E;
  GL_DEPTH_STENCIL_TO_BGRA_NV = $886F;
  GL_FRAGMENT_PROGRAM_NV = $8870;
  GL_MAX_TEXTURE_COORDS = $8871;
  GL_MAX_TEXTURE_COORDS_ARB = $8871;
  GL_MAX_TEXTURE_COORDS_NV = $8871;
  GL_MAX_TEXTURE_IMAGE_UNITS = $8872;
  GL_MAX_TEXTURE_IMAGE_UNITS_ARB = $8872;
  GL_MAX_TEXTURE_IMAGE_UNITS_NV = $8872;
  GL_FRAGMENT_PROGRAM_BINDING_NV = $8873;
  GL_PROGRAM_ERROR_STRING_ARB = $8874;
  GL_PROGRAM_ERROR_STRING_NV = $8874;
  GL_PROGRAM_FORMAT_ASCII_ARB = $8875;
  GL_PROGRAM_FORMAT_ARB = $8876;
  GL_WRITE_PIXEL_DATA_RANGE_NV = $8878;
  GL_READ_PIXEL_DATA_RANGE_NV = $8879;
  GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV = $887A;
  GL_READ_PIXEL_DATA_RANGE_LENGTH_NV = $887B;
  GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV = $887C;
  GL_READ_PIXEL_DATA_RANGE_POINTER_NV = $887D;
  GL_GEOMETRY_SHADER_INVOCATIONS = $887F;
  GL_GEOMETRY_SHADER_INVOCATIONS_EXT = $887F;
  GL_GEOMETRY_SHADER_INVOCATIONS_OES = $887F;
  GL_FLOAT_R_NV = $8880;
  GL_FLOAT_RG_NV = $8881;
  GL_FLOAT_RGB_NV = $8882;
  GL_FLOAT_RGBA_NV = $8883;
  GL_FLOAT_R16_NV = $8884;
  GL_FLOAT_R32_NV = $8885;
  GL_FLOAT_RG16_NV = $8886;
  GL_FLOAT_RG32_NV = $8887;
  GL_FLOAT_RGB16_NV = $8888;
  GL_FLOAT_RGB32_NV = $8889;
  GL_FLOAT_RGBA16_NV = $888A;
  GL_FLOAT_RGBA32_NV = $888B;
  GL_TEXTURE_FLOAT_COMPONENTS_NV = $888C;
  GL_FLOAT_CLEAR_COLOR_VALUE_NV = $888D;
  GL_FLOAT_RGBA_MODE_NV = $888E;
  GL_TEXTURE_UNSIGNED_REMAP_MODE_NV = $888F;
  GL_DEPTH_BOUNDS_TEST_EXT = $8890;
  GL_DEPTH_BOUNDS_EXT = $8891;
  GL_ARRAY_BUFFER = $8892;
  GL_ARRAY_BUFFER_ARB = $8892;
  GL_ELEMENT_ARRAY_BUFFER = $8893;
  GL_ELEMENT_ARRAY_BUFFER_ARB = $8893;
  GL_ARRAY_BUFFER_BINDING = $8894;
  GL_ARRAY_BUFFER_BINDING_ARB = $8894;
  GL_ELEMENT_ARRAY_BUFFER_BINDING = $8895;
  GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB = $8895;
  GL_VERTEX_ARRAY_BUFFER_BINDING = $8896;
  GL_VERTEX_ARRAY_BUFFER_BINDING_ARB = $8896;
  GL_NORMAL_ARRAY_BUFFER_BINDING = $8897;
  GL_NORMAL_ARRAY_BUFFER_BINDING_ARB = $8897;
  GL_COLOR_ARRAY_BUFFER_BINDING = $8898;
  GL_COLOR_ARRAY_BUFFER_BINDING_ARB = $8898;
  GL_INDEX_ARRAY_BUFFER_BINDING = $8899;
  GL_INDEX_ARRAY_BUFFER_BINDING_ARB = $8899;
  GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING = $889A;
  GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB = $889A;
  GL_EDGE_FLAG_ARRAY_BUFFER_BINDING = $889B;
  GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB = $889B;
  GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING = $889C;
  GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB = $889C;
  GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB = $889D;
  GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING = $889D;
  GL_FOG_COORD_ARRAY_BUFFER_BINDING = $889D;
  GL_WEIGHT_ARRAY_BUFFER_BINDING = $889E;
  GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB = $889E;
  GL_WEIGHT_ARRAY_BUFFER_BINDING_OES = $889E;
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = $889F;
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB = $889F;
  GL_PROGRAM_INSTRUCTIONS_ARB = $88A0;
  GL_MAX_PROGRAM_INSTRUCTIONS_ARB = $88A1;
  GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB = $88A2;
  GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB = $88A3;
  GL_PROGRAM_TEMPORARIES_ARB = $88A4;
  GL_MAX_PROGRAM_TEMPORARIES_ARB = $88A5;
  GL_PROGRAM_NATIVE_TEMPORARIES_ARB = $88A6;
  GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB = $88A7;
  GL_PROGRAM_PARAMETERS_ARB = $88A8;
  GL_MAX_PROGRAM_PARAMETERS_ARB = $88A9;
  GL_PROGRAM_NATIVE_PARAMETERS_ARB = $88AA;
  GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB = $88AB;
  GL_PROGRAM_ATTRIBS_ARB = $88AC;
  GL_MAX_PROGRAM_ATTRIBS_ARB = $88AD;
  GL_PROGRAM_NATIVE_ATTRIBS_ARB = $88AE;
  GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB = $88AF;
  GL_PROGRAM_ADDRESS_REGISTERS_ARB = $88B0;
  GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB = $88B1;
  GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = $88B2;
  GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = $88B3;
  GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB = $88B4;
  GL_MAX_PROGRAM_ENV_PARAMETERS_ARB = $88B5;
  GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB = $88B6;
  GL_TRANSPOSE_CURRENT_MATRIX_ARB = $88B7;
  GL_READ_ONLY = $88B8;
  GL_READ_ONLY_ARB = $88B8;
  GL_WRITE_ONLY = $88B9;
  GL_WRITE_ONLY_ARB = $88B9;
  GL_WRITE_ONLY_OES = $88B9;
  GL_READ_WRITE = $88BA;
  GL_READ_WRITE_ARB = $88BA;
  GL_BUFFER_ACCESS = $88BB;
  GL_BUFFER_ACCESS_ARB = $88BB;
  GL_BUFFER_ACCESS_OES = $88BB;
  GL_BUFFER_MAPPED = $88BC;
  GL_BUFFER_MAPPED_ARB = $88BC;
  GL_BUFFER_MAPPED_OES = $88BC;
  GL_BUFFER_MAP_POINTER = $88BD;
  GL_BUFFER_MAP_POINTER_ARB = $88BD;
  GL_BUFFER_MAP_POINTER_OES = $88BD;
  GL_WRITE_DISCARD_NV = $88BE;
  GL_TIME_ELAPSED = $88BF;
  GL_TIME_ELAPSED_EXT = $88BF;
  GL_MATRIX0_ARB = $88C0;
  GL_MATRIX1_ARB = $88C1;
  GL_MATRIX2_ARB = $88C2;
  GL_MATRIX3_ARB = $88C3;
  GL_MATRIX4_ARB = $88C4;
  GL_MATRIX5_ARB = $88C5;
  GL_MATRIX6_ARB = $88C6;
  GL_MATRIX7_ARB = $88C7;
  GL_MATRIX8_ARB = $88C8;
  GL_MATRIX9_ARB = $88C9;
  GL_MATRIX10_ARB = $88CA;
  GL_MATRIX11_ARB = $88CB;
  GL_MATRIX12_ARB = $88CC;
  GL_MATRIX13_ARB = $88CD;
  GL_MATRIX14_ARB = $88CE;
  GL_MATRIX15_ARB = $88CF;
  GL_MATRIX16_ARB = $88D0;
  GL_MATRIX17_ARB = $88D1;
  GL_MATRIX18_ARB = $88D2;
  GL_MATRIX19_ARB = $88D3;
  GL_MATRIX20_ARB = $88D4;
  GL_MATRIX21_ARB = $88D5;
  GL_MATRIX22_ARB = $88D6;
  GL_MATRIX23_ARB = $88D7;
  GL_MATRIX24_ARB = $88D8;
  GL_MATRIX25_ARB = $88D9;
  GL_MATRIX26_ARB = $88DA;
  GL_MATRIX27_ARB = $88DB;
  GL_MATRIX28_ARB = $88DC;
  GL_MATRIX29_ARB = $88DD;
  GL_MATRIX30_ARB = $88DE;
  GL_MATRIX31_ARB = $88DF;
  GL_STREAM_DRAW = $88E0;
  GL_STREAM_DRAW_ARB = $88E0;
  GL_STREAM_READ = $88E1;
  GL_STREAM_READ_ARB = $88E1;
  GL_STREAM_COPY = $88E2;
  GL_STREAM_COPY_ARB = $88E2;
  GL_STATIC_DRAW = $88E4;
  GL_STATIC_DRAW_ARB = $88E4;
  GL_STATIC_READ = $88E5;
  GL_STATIC_READ_ARB = $88E5;
  GL_STATIC_COPY = $88E6;
  GL_STATIC_COPY_ARB = $88E6;
  GL_DYNAMIC_DRAW = $88E8;
  GL_DYNAMIC_DRAW_ARB = $88E8;
  GL_DYNAMIC_READ = $88E9;
  GL_DYNAMIC_READ_ARB = $88E9;
  GL_DYNAMIC_COPY = $88EA;
  GL_DYNAMIC_COPY_ARB = $88EA;
  GL_PIXEL_PACK_BUFFER = $88EB;
  GL_PIXEL_PACK_BUFFER_ARB = $88EB;
  GL_PIXEL_PACK_BUFFER_EXT = $88EB;
  GL_PIXEL_PACK_BUFFER_NV = $88EB;
  GL_PIXEL_UNPACK_BUFFER = $88EC;
  GL_PIXEL_UNPACK_BUFFER_ARB = $88EC;
  GL_PIXEL_UNPACK_BUFFER_EXT = $88EC;
  GL_PIXEL_UNPACK_BUFFER_NV = $88EC;
  GL_PIXEL_PACK_BUFFER_BINDING = $88ED;
  GL_PIXEL_PACK_BUFFER_BINDING_ARB = $88ED;
  GL_PIXEL_PACK_BUFFER_BINDING_EXT = $88ED;
  GL_PIXEL_PACK_BUFFER_BINDING_NV = $88ED;
  GL_ETC1_SRGB8_NV = $88EE;
  GL_PIXEL_UNPACK_BUFFER_BINDING = $88EF;
  GL_PIXEL_UNPACK_BUFFER_BINDING_ARB = $88EF;
  GL_PIXEL_UNPACK_BUFFER_BINDING_EXT = $88EF;
  GL_PIXEL_UNPACK_BUFFER_BINDING_NV = $88EF;
  GL_DEPTH24_STENCIL8 = $88F0;
  GL_DEPTH24_STENCIL8_EXT = $88F0;
  GL_DEPTH24_STENCIL8_OES = $88F0;
  GL_TEXTURE_STENCIL_SIZE = $88F1;
  GL_TEXTURE_STENCIL_SIZE_EXT = $88F1;
  GL_STENCIL_TAG_BITS_EXT = $88F2;
  GL_STENCIL_CLEAR_TAG_VALUE_EXT = $88F3;
  GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV = $88F4;
  GL_MAX_PROGRAM_CALL_DEPTH_NV = $88F5;
  GL_MAX_PROGRAM_IF_DEPTH_NV = $88F6;
  GL_MAX_PROGRAM_LOOP_DEPTH_NV = $88F7;
  GL_MAX_PROGRAM_LOOP_COUNT_NV = $88F8;
  GL_SRC1_COLOR = $88F9;
  GL_SRC1_COLOR_EXT = $88F9;
  GL_ONE_MINUS_SRC1_COLOR = $88FA;
  GL_ONE_MINUS_SRC1_COLOR_EXT = $88FA;
  GL_ONE_MINUS_SRC1_ALPHA = $88FB;
  GL_ONE_MINUS_SRC1_ALPHA_EXT = $88FB;
  GL_MAX_DUAL_SOURCE_DRAW_BUFFERS = $88FC;
  GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT = $88FC;
  GL_VERTEX_ATTRIB_ARRAY_INTEGER = $88FD;
  GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT = $88FD;
  GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV = $88FD;
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR = $88FE;
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = $88FE;
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB = $88FE;
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT = $88FE;
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV = $88FE;
  GL_MAX_ARRAY_TEXTURE_LAYERS = $88FF;
  GL_MAX_ARRAY_TEXTURE_LAYERS_EXT = $88FF;
  GL_MIN_PROGRAM_TEXEL_OFFSET = $8904;
  GL_MIN_PROGRAM_TEXEL_OFFSET_EXT = $8904;
  GL_MIN_PROGRAM_TEXEL_OFFSET_NV = $8904;
  GL_MAX_PROGRAM_TEXEL_OFFSET = $8905;
  GL_MAX_PROGRAM_TEXEL_OFFSET_EXT = $8905;
  GL_MAX_PROGRAM_TEXEL_OFFSET_NV = $8905;
  GL_PROGRAM_ATTRIB_COMPONENTS_NV = $8906;
  GL_PROGRAM_RESULT_COMPONENTS_NV = $8907;
  GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV = $8908;
  GL_MAX_PROGRAM_RESULT_COMPONENTS_NV = $8909;
  GL_STENCIL_TEST_TWO_SIDE_EXT = $8910;
  GL_ACTIVE_STENCIL_FACE_EXT = $8911;
  GL_MIRROR_CLAMP_TO_BORDER_EXT = $8912;
  GL_SAMPLES_PASSED = $8914;
  GL_SAMPLES_PASSED_ARB = $8914;
  GL_GEOMETRY_VERTICES_OUT = $8916;
  GL_GEOMETRY_LINKED_VERTICES_OUT_EXT = $8916;
  GL_GEOMETRY_LINKED_VERTICES_OUT_OES = $8916;
  GL_GEOMETRY_INPUT_TYPE = $8917;
  GL_GEOMETRY_LINKED_INPUT_TYPE_EXT = $8917;
  GL_GEOMETRY_LINKED_INPUT_TYPE_OES = $8917;
  GL_GEOMETRY_OUTPUT_TYPE = $8918;
  GL_GEOMETRY_LINKED_OUTPUT_TYPE_EXT = $8918;
  GL_GEOMETRY_LINKED_OUTPUT_TYPE_OES = $8918;
  GL_SAMPLER_BINDING = $8919;
  GL_CLAMP_VERTEX_COLOR = $891A;
  GL_CLAMP_VERTEX_COLOR_ARB = $891A;
  GL_CLAMP_FRAGMENT_COLOR = $891B;
  GL_CLAMP_FRAGMENT_COLOR_ARB = $891B;
  GL_CLAMP_READ_COLOR = $891C;
  GL_CLAMP_READ_COLOR_ARB = $891C;
  GL_FIXED_ONLY = $891D;
  GL_FIXED_ONLY_ARB = $891D;
  GL_TESS_CONTROL_PROGRAM_NV = $891E;
  GL_TESS_EVALUATION_PROGRAM_NV = $891F;
  GL_FRAGMENT_SHADER_ATI = $8920;
  GL_REG_0_ATI = $8921;
  GL_REG_1_ATI = $8922;
  GL_REG_2_ATI = $8923;
  GL_REG_3_ATI = $8924;
  GL_REG_4_ATI = $8925;
  GL_REG_5_ATI = $8926;
  GL_REG_6_ATI = $8927;
  GL_REG_7_ATI = $8928;
  GL_REG_8_ATI = $8929;
  GL_REG_9_ATI = $892A;
  GL_REG_10_ATI = $892B;
  GL_REG_11_ATI = $892C;
  GL_REG_12_ATI = $892D;
  GL_REG_13_ATI = $892E;
  GL_REG_14_ATI = $892F;
  GL_REG_15_ATI = $8930;
  GL_REG_16_ATI = $8931;
  GL_REG_17_ATI = $8932;
  GL_REG_18_ATI = $8933;
  GL_REG_19_ATI = $8934;
  GL_REG_20_ATI = $8935;
  GL_REG_21_ATI = $8936;
  GL_REG_22_ATI = $8937;
  GL_REG_23_ATI = $8938;
  GL_REG_24_ATI = $8939;
  GL_REG_25_ATI = $893A;
  GL_REG_26_ATI = $893B;
  GL_REG_27_ATI = $893C;
  GL_REG_28_ATI = $893D;
  GL_REG_29_ATI = $893E;
  GL_REG_30_ATI = $893F;
  GL_REG_31_ATI = $8940;
  GL_CON_0_ATI = $8941;
  GL_CON_1_ATI = $8942;
  GL_CON_2_ATI = $8943;
  GL_CON_3_ATI = $8944;
  GL_CON_4_ATI = $8945;
  GL_CON_5_ATI = $8946;
  GL_CON_6_ATI = $8947;
  GL_CON_7_ATI = $8948;
  GL_CON_8_ATI = $8949;
  GL_CON_9_ATI = $894A;
  GL_CON_10_ATI = $894B;
  GL_CON_11_ATI = $894C;
  GL_CON_12_ATI = $894D;
  GL_CON_13_ATI = $894E;
  GL_CON_14_ATI = $894F;
  GL_CON_15_ATI = $8950;
  GL_CON_16_ATI = $8951;
  GL_CON_17_ATI = $8952;
  GL_CON_18_ATI = $8953;
  GL_CON_19_ATI = $8954;
  GL_CON_20_ATI = $8955;
  GL_CON_21_ATI = $8956;
  GL_CON_22_ATI = $8957;
  GL_CON_23_ATI = $8958;
  GL_CON_24_ATI = $8959;
  GL_CON_25_ATI = $895A;
  GL_CON_26_ATI = $895B;
  GL_CON_27_ATI = $895C;
  GL_CON_28_ATI = $895D;
  GL_CON_29_ATI = $895E;
  GL_CON_30_ATI = $895F;
  GL_CON_31_ATI = $8960;
  GL_MOV_ATI = $8961;
  GL_ADD_ATI = $8963;
  GL_MUL_ATI = $8964;
  GL_SUB_ATI = $8965;
  GL_DOT3_ATI = $8966;
  GL_DOT4_ATI = $8967;
  GL_MAD_ATI = $8968;
  GL_LERP_ATI = $8969;
  GL_CND_ATI = $896A;
  GL_CND0_ATI = $896B;
  GL_DOT2_ADD_ATI = $896C;
  GL_SECONDARY_INTERPOLATOR_ATI = $896D;
  GL_NUM_FRAGMENT_REGISTERS_ATI = $896E;
  GL_NUM_FRAGMENT_CONSTANTS_ATI = $896F;
  GL_NUM_PASSES_ATI = $8970;
  GL_NUM_INSTRUCTIONS_PER_PASS_ATI = $8971;
  GL_NUM_INSTRUCTIONS_TOTAL_ATI = $8972;
  GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI = $8973;
  GL_NUM_LOOPBACK_COMPONENTS_ATI = $8974;
  GL_COLOR_ALPHA_PAIRING_ATI = $8975;
  GL_SWIZZLE_STR_ATI = $8976;
  GL_SWIZZLE_STQ_ATI = $8977;
  GL_SWIZZLE_STR_DR_ATI = $8978;
  GL_SWIZZLE_STQ_DQ_ATI = $8979;
  GL_SWIZZLE_STRQ_ATI = $897A;
  GL_SWIZZLE_STRQ_DQ_ATI = $897B;
  GL_INTERLACE_OML = $8980;
  GL_INTERLACE_READ_OML = $8981;
  GL_FORMAT_SUBSAMPLE_24_24_OML = $8982;
  GL_FORMAT_SUBSAMPLE_244_244_OML = $8983;
  GL_PACK_RESAMPLE_OML = $8984;
  GL_UNPACK_RESAMPLE_OML = $8985;
  GL_RESAMPLE_REPLICATE_OML = $8986;
  GL_RESAMPLE_ZERO_FILL_OML = $8987;
  GL_RESAMPLE_AVERAGE_OML = $8988;
  GL_RESAMPLE_DECIMATE_OML = $8989;
  GL_POINT_SIZE_ARRAY_TYPE_OES = $898A;
  GL_POINT_SIZE_ARRAY_STRIDE_OES = $898B;
  GL_POINT_SIZE_ARRAY_POINTER_OES = $898C;
  GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES = $898D;
  GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES = $898E;
  GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES = $898F;
  GL_VERTEX_ATTRIB_MAP1_APPLE = $8A00;
  GL_VERTEX_ATTRIB_MAP2_APPLE = $8A01;
  GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE = $8A02;
  GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE = $8A03;
  GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE = $8A04;
  GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE = $8A05;
  GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE = $8A06;
  GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE = $8A07;
  GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE = $8A08;
  GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE = $8A09;
  GL_DRAW_PIXELS_APPLE = $8A0A;
  GL_FENCE_APPLE = $8A0B;
  GL_ELEMENT_ARRAY_APPLE = $8A0C;
  GL_ELEMENT_ARRAY_TYPE_APPLE = $8A0D;
  GL_ELEMENT_ARRAY_POINTER_APPLE = $8A0E;
  GL_COLOR_FLOAT_APPLE = $8A0F;
  GL_UNIFORM_BUFFER = $8A11;
  GL_BUFFER_SERIALIZED_MODIFY_APPLE = $8A12;
  GL_BUFFER_FLUSHING_UNMAP_APPLE = $8A13;
  GL_AUX_DEPTH_STENCIL_APPLE = $8A14;
  GL_PACK_ROW_BYTES_APPLE = $8A15;
  GL_UNPACK_ROW_BYTES_APPLE = $8A16;
  GL_RELEASED_APPLE = $8A19;
  GL_VOLATILE_APPLE = $8A1A;
  GL_RETAINED_APPLE = $8A1B;
  GL_UNDEFINED_APPLE = $8A1C;
  GL_PURGEABLE_APPLE = $8A1D;
  GL_RGB_422_APPLE = $8A1F;
  GL_UNIFORM_BUFFER_BINDING = $8A28;
  GL_UNIFORM_BUFFER_START = $8A29;
  GL_UNIFORM_BUFFER_SIZE = $8A2A;
  GL_MAX_VERTEX_UNIFORM_BLOCKS = $8A2B;
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS = $8A2C;
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS_EXT = $8A2C;
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS_OES = $8A2C;
  GL_MAX_FRAGMENT_UNIFORM_BLOCKS = $8A2D;
  GL_MAX_COMBINED_UNIFORM_BLOCKS = $8A2E;
  GL_MAX_UNIFORM_BUFFER_BINDINGS = $8A2F;
  GL_MAX_UNIFORM_BLOCK_SIZE = $8A30;
  GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = $8A31;
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = $8A32;
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT = $8A32;
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES = $8A32;
  GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = $8A33;
  GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = $8A34;
  GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = $8A35;
  GL_ACTIVE_UNIFORM_BLOCKS = $8A36;
  GL_UNIFORM_TYPE = $8A37;
  GL_UNIFORM_SIZE = $8A38;
  GL_UNIFORM_NAME_LENGTH = $8A39;
  GL_UNIFORM_BLOCK_INDEX = $8A3A;
  GL_UNIFORM_OFFSET = $8A3B;
  GL_UNIFORM_ARRAY_STRIDE = $8A3C;
  GL_UNIFORM_MATRIX_STRIDE = $8A3D;
  GL_UNIFORM_IS_ROW_MAJOR = $8A3E;
  GL_UNIFORM_BLOCK_BINDING = $8A3F;
  GL_UNIFORM_BLOCK_DATA_SIZE = $8A40;
  GL_UNIFORM_BLOCK_NAME_LENGTH = $8A41;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = $8A42;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = $8A43;
  GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = $8A44;
  GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = $8A45;
  GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = $8A46;
  GL_TEXTURE_SRGB_DECODE_EXT = $8A48;
  GL_DECODE_EXT = $8A49;
  GL_SKIP_DECODE_EXT = $8A4A;
  GL_PROGRAM_PIPELINE_OBJECT_EXT = $8A4F;
  GL_RGB_RAW_422_APPLE = $8A51;
  GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT = $8A52;
  GL_SYNC_OBJECT_APPLE = $8A53;
  GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT = $8A54;
  GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT = $8A55;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT = $8A56;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT = $8A57;
  GL_FRAGMENT_SHADER = $8B30;
  GL_FRAGMENT_SHADER_ARB = $8B30;
  GL_VERTEX_SHADER = $8B31;
  GL_VERTEX_SHADER_ARB = $8B31;
  GL_PROGRAM_OBJECT_ARB = $8B40;
  GL_PROGRAM_OBJECT_EXT = $8B40;
  GL_SHADER_OBJECT_ARB = $8B48;
  GL_SHADER_OBJECT_EXT = $8B48;
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = $8B49;
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB = $8B49;
  GL_MAX_VERTEX_UNIFORM_COMPONENTS = $8B4A;
  GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB = $8B4A;
  GL_MAX_VARYING_FLOATS = $8B4B;
  GL_MAX_VARYING_COMPONENTS = $8B4B;
  GL_MAX_VARYING_COMPONENTS_EXT = $8B4B;
  GL_MAX_VARYING_FLOATS_ARB = $8B4B;
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = $8B4C;
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB = $8B4C;
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = $8B4D;
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB = $8B4D;
  GL_OBJECT_TYPE_ARB = $8B4E;
  GL_SHADER_TYPE = $8B4F;
  GL_OBJECT_SUBTYPE_ARB = $8B4F;
  GL_FLOAT_VEC2 = $8B50;
  GL_FLOAT_VEC2_ARB = $8B50;
  GL_FLOAT_VEC3 = $8B51;
  GL_FLOAT_VEC3_ARB = $8B51;
  GL_FLOAT_VEC4 = $8B52;
  GL_FLOAT_VEC4_ARB = $8B52;
  GL_INT_VEC2 = $8B53;
  GL_INT_VEC2_ARB = $8B53;
  GL_INT_VEC3 = $8B54;
  GL_INT_VEC3_ARB = $8B54;
  GL_INT_VEC4 = $8B55;
  GL_INT_VEC4_ARB = $8B55;
  GL_BOOL = $8B56;
  GL_BOOL_ARB = $8B56;
  GL_BOOL_VEC2 = $8B57;
  GL_BOOL_VEC2_ARB = $8B57;
  GL_BOOL_VEC3 = $8B58;
  GL_BOOL_VEC3_ARB = $8B58;
  GL_BOOL_VEC4 = $8B59;
  GL_BOOL_VEC4_ARB = $8B59;
  GL_FLOAT_MAT2 = $8B5A;
  GL_FLOAT_MAT2_ARB = $8B5A;
  GL_FLOAT_MAT3 = $8B5B;
  GL_FLOAT_MAT3_ARB = $8B5B;
  GL_FLOAT_MAT4 = $8B5C;
  GL_FLOAT_MAT4_ARB = $8B5C;
  GL_SAMPLER_1D = $8B5D;
  GL_SAMPLER_1D_ARB = $8B5D;
  GL_SAMPLER_2D = $8B5E;
  GL_SAMPLER_2D_ARB = $8B5E;
  GL_SAMPLER_3D = $8B5F;
  GL_SAMPLER_3D_ARB = $8B5F;
  GL_SAMPLER_3D_OES = $8B5F;
  GL_SAMPLER_CUBE = $8B60;
  GL_SAMPLER_CUBE_ARB = $8B60;
  GL_SAMPLER_1D_SHADOW = $8B61;
  GL_SAMPLER_1D_SHADOW_ARB = $8B61;
  GL_SAMPLER_2D_SHADOW = $8B62;
  GL_SAMPLER_2D_SHADOW_ARB = $8B62;
  GL_SAMPLER_2D_SHADOW_EXT = $8B62;
  GL_SAMPLER_2D_RECT = $8B63;
  GL_SAMPLER_2D_RECT_ARB = $8B63;
  GL_SAMPLER_2D_RECT_SHADOW = $8B64;
  GL_SAMPLER_2D_RECT_SHADOW_ARB = $8B64;
  GL_FLOAT_MAT2x3 = $8B65;
  GL_FLOAT_MAT2x3_NV = $8B65;
  GL_FLOAT_MAT2x4 = $8B66;
  GL_FLOAT_MAT2x4_NV = $8B66;
  GL_FLOAT_MAT3x2 = $8B67;
  GL_FLOAT_MAT3x2_NV = $8B67;
  GL_FLOAT_MAT3x4 = $8B68;
  GL_FLOAT_MAT3x4_NV = $8B68;
  GL_FLOAT_MAT4x2 = $8B69;
  GL_FLOAT_MAT4x2_NV = $8B69;
  GL_FLOAT_MAT4x3 = $8B6A;
  GL_FLOAT_MAT4x3_NV = $8B6A;
  GL_DELETE_STATUS = $8B80;
  GL_OBJECT_DELETE_STATUS_ARB = $8B80;
  GL_COMPILE_STATUS = $8B81;
  GL_OBJECT_COMPILE_STATUS_ARB = $8B81;
  GL_LINK_STATUS = $8B82;
  GL_OBJECT_LINK_STATUS_ARB = $8B82;
  GL_VALIDATE_STATUS = $8B83;
  GL_OBJECT_VALIDATE_STATUS_ARB = $8B83;
  GL_INFO_LOG_LENGTH = $8B84;
  GL_OBJECT_INFO_LOG_LENGTH_ARB = $8B84;
  GL_ATTACHED_SHADERS = $8B85;
  GL_OBJECT_ATTACHED_OBJECTS_ARB = $8B85;
  GL_ACTIVE_UNIFORMS = $8B86;
  GL_OBJECT_ACTIVE_UNIFORMS_ARB = $8B86;
  GL_ACTIVE_UNIFORM_MAX_LENGTH = $8B87;
  GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB = $8B87;
  GL_SHADER_SOURCE_LENGTH = $8B88;
  GL_OBJECT_SHADER_SOURCE_LENGTH_ARB = $8B88;
  GL_ACTIVE_ATTRIBUTES = $8B89;
  GL_OBJECT_ACTIVE_ATTRIBUTES_ARB = $8B89;
  GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = $8B8A;
  GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB = $8B8A;
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT = $8B8B;
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = $8B8B;
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES = $8B8B;
  GL_SHADING_LANGUAGE_VERSION = $8B8C;
  GL_SHADING_LANGUAGE_VERSION_ARB = $8B8C;
  GL_CURRENT_PROGRAM = $8B8D;
  //GL_ACTIVE_PROGRAM_EXT = $8B8D;
  GL_PALETTE4_RGB8_OES = $8B90;
  GL_PALETTE4_RGBA8_OES = $8B91;
  GL_PALETTE4_R5_G6_B5_OES = $8B92;
  GL_PALETTE4_RGBA4_OES = $8B93;
  GL_PALETTE4_RGB5_A1_OES = $8B94;
  GL_PALETTE8_RGB8_OES = $8B95;
  GL_PALETTE8_RGBA8_OES = $8B96;
  GL_PALETTE8_R5_G6_B5_OES = $8B97;
  GL_PALETTE8_RGBA4_OES = $8B98;
  GL_PALETTE8_RGB5_A1_OES = $8B99;
  GL_IMPLEMENTATION_COLOR_READ_TYPE = $8B9A;
  GL_IMPLEMENTATION_COLOR_READ_TYPE_OES = $8B9A;
  GL_IMPLEMENTATION_COLOR_READ_FORMAT = $8B9B;
  GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES = $8B9B;
  GL_POINT_SIZE_ARRAY_OES = $8B9C;
  GL_TEXTURE_CROP_RECT_OES = $8B9D;
  GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES = $8B9E;
  GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES = $8B9F;
  GL_FRAGMENT_PROGRAM_POSITION_MESA = $8BB0;
  GL_FRAGMENT_PROGRAM_CALLBACK_MESA = $8BB1;
  GL_FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA = $8BB2;
  GL_FRAGMENT_PROGRAM_CALLBACK_DATA_MESA = $8BB3;
  GL_VERTEX_PROGRAM_POSITION_MESA = $8BB4;
  GL_VERTEX_PROGRAM_CALLBACK_MESA = $8BB5;
  GL_VERTEX_PROGRAM_CALLBACK_FUNC_MESA = $8BB6;
  GL_VERTEX_PROGRAM_CALLBACK_DATA_MESA = $8BB7;
  GL_TILE_RASTER_ORDER_FIXED_MESA = $8BB8;
  GL_TILE_RASTER_ORDER_INCREASING_X_MESA = $8BB9;
  GL_TILE_RASTER_ORDER_INCREASING_Y_MESA = $8BBA;
  GL_FRAMEBUFFER_FLIP_Y_MESA = $8BBB;
  GL_FRAMEBUFFER_FLIP_X_MESA = $8BBC;
  GL_FRAMEBUFFER_SWAP_XY_MESA = $8BBD;
  GL_CONST_BW_TILING_MESA = $8BBE;
  GL_COUNTER_TYPE_AMD = $8BC0;
  GL_COUNTER_RANGE_AMD = $8BC1;
  GL_UNSIGNED_INT64_AMD = $8BC2;
  GL_PERCENTAGE_AMD = $8BC3;
  GL_PERFMON_RESULT_AVAILABLE_AMD = $8BC4;
  GL_PERFMON_RESULT_SIZE_AMD = $8BC5;
  GL_PERFMON_RESULT_AMD = $8BC6;
  GL_TEXTURE_WIDTH_QCOM = $8BD2;
  GL_TEXTURE_HEIGHT_QCOM = $8BD3;
  GL_TEXTURE_DEPTH_QCOM = $8BD4;
  GL_TEXTURE_INTERNAL_FORMAT_QCOM = $8BD5;
  GL_TEXTURE_FORMAT_QCOM = $8BD6;
  GL_TEXTURE_TYPE_QCOM = $8BD7;
  GL_TEXTURE_IMAGE_VALID_QCOM = $8BD8;
  GL_TEXTURE_NUM_LEVELS_QCOM = $8BD9;
  GL_TEXTURE_TARGET_QCOM = $8BDA;
  GL_TEXTURE_OBJECT_VALID_QCOM = $8BDB;
  GL_STATE_RESTORE = $8BDC;
  GL_SAMPLER_EXTERNAL_2D_Y2Y_EXT = $8BE7;
  GL_TEXTURE_PROTECTED_EXT = $8BFA;
  GL_TEXTURE_FOVEATED_FEATURE_BITS_QCOM = $8BFB;
  GL_TEXTURE_FOVEATED_MIN_PIXEL_DENSITY_QCOM = $8BFC;
  GL_TEXTURE_FOVEATED_FEATURE_QUERY_QCOM = $8BFD;
  GL_TEXTURE_FOVEATED_NUM_FOCAL_POINTS_QUERY_QCOM = $8BFE;
  GL_FRAMEBUFFER_INCOMPLETE_FOVEATION_QCOM = $8BFF;
  GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = $8C00;
  GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = $8C01;
  GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = $8C02;
  GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = $8C03;
  GL_MODULATE_COLOR_IMG = $8C04;
  GL_RECIP_ADD_SIGNED_ALPHA_IMG = $8C05;
  GL_TEXTURE_ALPHA_MODULATE_IMG = $8C06;
  GL_FACTOR_ALPHA_MODULATE_IMG = $8C07;
  GL_FRAGMENT_ALPHA_MODULATE_IMG = $8C08;
  GL_ADD_BLEND_IMG = $8C09;
  GL_SGX_BINARY_IMG = $8C0A;
  GL_TEXTURE_RED_TYPE = $8C10;
  GL_TEXTURE_RED_TYPE_ARB = $8C10;
  GL_TEXTURE_GREEN_TYPE = $8C11;
  GL_TEXTURE_GREEN_TYPE_ARB = $8C11;
  GL_TEXTURE_BLUE_TYPE = $8C12;
  GL_TEXTURE_BLUE_TYPE_ARB = $8C12;
  GL_TEXTURE_ALPHA_TYPE = $8C13;
  GL_TEXTURE_ALPHA_TYPE_ARB = $8C13;
  GL_TEXTURE_LUMINANCE_TYPE = $8C14;
  GL_TEXTURE_LUMINANCE_TYPE_ARB = $8C14;
  GL_TEXTURE_INTENSITY_TYPE = $8C15;
  GL_TEXTURE_INTENSITY_TYPE_ARB = $8C15;
  GL_TEXTURE_DEPTH_TYPE = $8C16;
  GL_TEXTURE_DEPTH_TYPE_ARB = $8C16;
  GL_UNSIGNED_NORMALIZED = $8C17;
  GL_UNSIGNED_NORMALIZED_ARB = $8C17;
  GL_UNSIGNED_NORMALIZED_EXT = $8C17;
  GL_TEXTURE_1D_ARRAY = $8C18;
  GL_TEXTURE_1D_ARRAY_EXT = $8C18;
  GL_PROXY_TEXTURE_1D_ARRAY = $8C19;
  GL_PROXY_TEXTURE_1D_ARRAY_EXT = $8C19;
  GL_TEXTURE_2D_ARRAY = $8C1A;
  GL_TEXTURE_2D_ARRAY_EXT = $8C1A;
  GL_PROXY_TEXTURE_2D_ARRAY = $8C1B;
  GL_PROXY_TEXTURE_2D_ARRAY_EXT = $8C1B;
  GL_TEXTURE_BINDING_1D_ARRAY = $8C1C;
  GL_TEXTURE_BINDING_1D_ARRAY_EXT = $8C1C;
  GL_TEXTURE_BINDING_2D_ARRAY = $8C1D;
  GL_TEXTURE_BINDING_2D_ARRAY_EXT = $8C1D;
  GL_GEOMETRY_PROGRAM_NV = $8C26;
  GL_MAX_PROGRAM_OUTPUT_VERTICES_NV = $8C27;
  GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV = $8C28;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = $8C29;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB = $8C29;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT = $8C29;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES = $8C29;
  GL_TEXTURE_BUFFER = $8C2A;
  GL_TEXTURE_BUFFER_ARB = $8C2A;
  GL_TEXTURE_BUFFER_EXT = $8C2A;
  GL_TEXTURE_BUFFER_OES = $8C2A;
  GL_TEXTURE_BUFFER_BINDING = $8C2A;
  GL_TEXTURE_BUFFER_BINDING_EXT = $8C2A;
  GL_TEXTURE_BUFFER_BINDING_OES = $8C2A;
  GL_MAX_TEXTURE_BUFFER_SIZE = $8C2B;
  GL_MAX_TEXTURE_BUFFER_SIZE_ARB = $8C2B;
  GL_MAX_TEXTURE_BUFFER_SIZE_EXT = $8C2B;
  GL_MAX_TEXTURE_BUFFER_SIZE_OES = $8C2B;
  GL_TEXTURE_BINDING_BUFFER = $8C2C;
  GL_TEXTURE_BINDING_BUFFER_ARB = $8C2C;
  GL_TEXTURE_BINDING_BUFFER_EXT = $8C2C;
  GL_TEXTURE_BINDING_BUFFER_OES = $8C2C;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING = $8C2D;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB = $8C2D;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT = $8C2D;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_OES = $8C2D;
  GL_TEXTURE_BUFFER_FORMAT_ARB = $8C2E;
  GL_TEXTURE_BUFFER_FORMAT_EXT = $8C2E;
  GL_ANY_SAMPLES_PASSED = $8C2F;
  GL_ANY_SAMPLES_PASSED_EXT = $8C2F;
  GL_SAMPLE_SHADING = $8C36;
  GL_SAMPLE_SHADING_ARB = $8C36;
  GL_SAMPLE_SHADING_OES = $8C36;
  GL_MIN_SAMPLE_SHADING_VALUE = $8C37;
  GL_MIN_SAMPLE_SHADING_VALUE_ARB = $8C37;
  GL_MIN_SAMPLE_SHADING_VALUE_OES = $8C37;
  GL_R11F_G11F_B10F = $8C3A;
  GL_R11F_G11F_B10F_APPLE = $8C3A;
  GL_R11F_G11F_B10F_EXT = $8C3A;
  GL_UNSIGNED_INT_10F_11F_11F_REV = $8C3B;
  GL_UNSIGNED_INT_10F_11F_11F_REV_APPLE = $8C3B;
  GL_UNSIGNED_INT_10F_11F_11F_REV_EXT = $8C3B;
  GL_RGBA_SIGNED_COMPONENTS_EXT = $8C3C;
  GL_RGB9_E5 = $8C3D;
  GL_RGB9_E5_APPLE = $8C3D;
  GL_RGB9_E5_EXT = $8C3D;
  GL_UNSIGNED_INT_5_9_9_9_REV = $8C3E;
  GL_UNSIGNED_INT_5_9_9_9_REV_APPLE = $8C3E;
  GL_UNSIGNED_INT_5_9_9_9_REV_EXT = $8C3E;
  GL_TEXTURE_SHARED_SIZE = $8C3F;
  GL_TEXTURE_SHARED_SIZE_EXT = $8C3F;
  GL_SRGB = $8C40;
  GL_SRGB_EXT = $8C40;
  GL_SRGB8 = $8C41;
  GL_SRGB8_EXT = $8C41;
  GL_SRGB8_NV = $8C41;
  GL_SRGB_ALPHA = $8C42;
  GL_SRGB_ALPHA_EXT = $8C42;
  GL_SRGB8_ALPHA8 = $8C43;
  GL_SRGB8_ALPHA8_EXT = $8C43;
  GL_SLUMINANCE_ALPHA = $8C44;
  GL_SLUMINANCE_ALPHA_EXT = $8C44;
  GL_SLUMINANCE_ALPHA_NV = $8C44;
  GL_SLUMINANCE8_ALPHA8 = $8C45;
  GL_SLUMINANCE8_ALPHA8_EXT = $8C45;
  GL_SLUMINANCE8_ALPHA8_NV = $8C45;
  GL_SLUMINANCE = $8C46;
  GL_SLUMINANCE_EXT = $8C46;
  GL_SLUMINANCE_NV = $8C46;
  GL_SLUMINANCE8 = $8C47;
  GL_SLUMINANCE8_EXT = $8C47;
  GL_SLUMINANCE8_NV = $8C47;
  GL_COMPRESSED_SRGB = $8C48;
  GL_COMPRESSED_SRGB_EXT = $8C48;
  GL_COMPRESSED_SRGB_ALPHA = $8C49;
  GL_COMPRESSED_SRGB_ALPHA_EXT = $8C49;
  GL_COMPRESSED_SLUMINANCE = $8C4A;
  GL_COMPRESSED_SLUMINANCE_EXT = $8C4A;
  GL_COMPRESSED_SLUMINANCE_ALPHA = $8C4B;
  GL_COMPRESSED_SLUMINANCE_ALPHA_EXT = $8C4B;
  GL_COMPRESSED_SRGB_S3TC_DXT1_EXT = $8C4C;
  GL_COMPRESSED_SRGB_S3TC_DXT1_NV = $8C4C;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = $8C4D;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV = $8C4D;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = $8C4E;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV = $8C4E;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = $8C4F;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV = $8C4F;
  GL_COMPRESSED_LUMINANCE_LATC1_EXT = $8C70;
  GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT = $8C71;
  GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT = $8C72;
  GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT = $8C73;
  GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV = $8C74;
  GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV = $8C75;
  GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = $8C76;
  GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT = $8C76;
  GL_BACK_PRIMARY_COLOR_NV = $8C77;
  GL_BACK_SECONDARY_COLOR_NV = $8C78;
  GL_TEXTURE_COORD_NV = $8C79;
  GL_CLIP_DISTANCE_NV = $8C7A;
  GL_VERTEX_ID_NV = $8C7B;
  GL_PRIMITIVE_ID_NV = $8C7C;
  GL_GENERIC_ATTRIB_NV = $8C7D;
  GL_TRANSFORM_FEEDBACK_ATTRIBS_NV = $8C7E;
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE = $8C7F;
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT = $8C7F;
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV = $8C7F;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = $8C80;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT = $8C80;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV = $8C80;
  GL_ACTIVE_VARYINGS_NV = $8C81;
  GL_ACTIVE_VARYING_MAX_LENGTH_NV = $8C82;
  GL_TRANSFORM_FEEDBACK_VARYINGS = $8C83;
  GL_TRANSFORM_FEEDBACK_VARYINGS_EXT = $8C83;
  GL_TRANSFORM_FEEDBACK_VARYINGS_NV = $8C83;
  GL_TRANSFORM_FEEDBACK_BUFFER_START = $8C84;
  GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT = $8C84;
  GL_TRANSFORM_FEEDBACK_BUFFER_START_NV = $8C84;
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = $8C85;
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT = $8C85;
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV = $8C85;
  GL_TRANSFORM_FEEDBACK_RECORD_NV = $8C86;
  GL_PRIMITIVES_GENERATED = $8C87;
  GL_PRIMITIVES_GENERATED_EXT = $8C87;
  GL_PRIMITIVES_GENERATED_NV = $8C87;
  GL_PRIMITIVES_GENERATED_OES = $8C87;
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = $8C88;
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT = $8C88;
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV = $8C88;
  GL_RASTERIZER_DISCARD = $8C89;
  GL_RASTERIZER_DISCARD_EXT = $8C89;
  GL_RASTERIZER_DISCARD_NV = $8C89;
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = $8C8A;
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT = $8C8A;
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV = $8C8A;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = $8C8B;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT = $8C8B;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV = $8C8B;
  GL_INTERLEAVED_ATTRIBS = $8C8C;
  GL_INTERLEAVED_ATTRIBS_EXT = $8C8C;
  GL_INTERLEAVED_ATTRIBS_NV = $8C8C;
  GL_SEPARATE_ATTRIBS = $8C8D;
  GL_SEPARATE_ATTRIBS_EXT = $8C8D;
  GL_SEPARATE_ATTRIBS_NV = $8C8D;
  GL_TRANSFORM_FEEDBACK_BUFFER = $8C8E;
  GL_TRANSFORM_FEEDBACK_BUFFER_EXT = $8C8E;
  GL_TRANSFORM_FEEDBACK_BUFFER_NV = $8C8E;
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = $8C8F;
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT = $8C8F;
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV = $8C8F;
  GL_MOTION_ESTIMATION_SEARCH_BLOCK_X_QCOM = $8C90;
  GL_MOTION_ESTIMATION_SEARCH_BLOCK_Y_QCOM = $8C91;
  GL_ATC_RGB_AMD = $8C92;
  GL_ATC_RGBA_EXPLICIT_ALPHA_AMD = $8C93;
  GL_TEXTURE_LOD_BIAS_QCOM = $8C96;
  GL_POINT_SPRITE_COORD_ORIGIN = $8CA0;
  GL_LOWER_LEFT = $8CA1;
  GL_LOWER_LEFT_EXT = $8CA1;
  GL_UPPER_LEFT = $8CA2;
  GL_UPPER_LEFT_EXT = $8CA2;
  GL_STENCIL_BACK_REF = $8CA3;
  GL_STENCIL_BACK_VALUE_MASK = $8CA4;
  GL_STENCIL_BACK_WRITEMASK = $8CA5;
  GL_DRAW_FRAMEBUFFER_BINDING = $8CA6;
  GL_DRAW_FRAMEBUFFER_BINDING_ANGLE = $8CA6;
  GL_DRAW_FRAMEBUFFER_BINDING_APPLE = $8CA6;
  GL_DRAW_FRAMEBUFFER_BINDING_EXT = $8CA6;
  GL_DRAW_FRAMEBUFFER_BINDING_NV = $8CA6;
  GL_FRAMEBUFFER_BINDING = $8CA6;
  GL_FRAMEBUFFER_BINDING_ANGLE = $8CA6;
  GL_FRAMEBUFFER_BINDING_EXT = $8CA6;
  GL_FRAMEBUFFER_BINDING_OES = $8CA6;
  GL_RENDERBUFFER_BINDING = $8CA7;
  GL_RENDERBUFFER_BINDING_ANGLE = $8CA7;
  GL_RENDERBUFFER_BINDING_EXT = $8CA7;
  GL_RENDERBUFFER_BINDING_OES = $8CA7;
  GL_READ_FRAMEBUFFER = $8CA8;
  GL_READ_FRAMEBUFFER_ANGLE = $8CA8;
  GL_READ_FRAMEBUFFER_APPLE = $8CA8;
  GL_READ_FRAMEBUFFER_EXT = $8CA8;
  GL_READ_FRAMEBUFFER_NV = $8CA8;
  GL_DRAW_FRAMEBUFFER = $8CA9;
  GL_DRAW_FRAMEBUFFER_ANGLE = $8CA9;
  GL_DRAW_FRAMEBUFFER_APPLE = $8CA9;
  GL_DRAW_FRAMEBUFFER_EXT = $8CA9;
  GL_DRAW_FRAMEBUFFER_NV = $8CA9;
  GL_READ_FRAMEBUFFER_BINDING = $8CAA;
  GL_READ_FRAMEBUFFER_BINDING_ANGLE = $8CAA;
  GL_READ_FRAMEBUFFER_BINDING_APPLE = $8CAA;
  GL_READ_FRAMEBUFFER_BINDING_EXT = $8CAA;
  GL_READ_FRAMEBUFFER_BINDING_NV = $8CAA;
  GL_RENDERBUFFER_COVERAGE_SAMPLES_NV = $8CAB;
  GL_RENDERBUFFER_SAMPLES = $8CAB;
  GL_RENDERBUFFER_SAMPLES_ANGLE = $8CAB;
  GL_RENDERBUFFER_SAMPLES_APPLE = $8CAB;
  GL_RENDERBUFFER_SAMPLES_EXT = $8CAB;
  GL_RENDERBUFFER_SAMPLES_NV = $8CAB;
  GL_DEPTH_COMPONENT32F = $8CAC;
  GL_DEPTH32F_STENCIL8 = $8CAD;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = $8CD0;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT = $8CD0;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES = $8CD0;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = $8CD1;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT = $8CD1;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES = $8CD1;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = $8CD2;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT = $8CD2;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES = $8CD2;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = $8CD3;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT = $8CD3;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES = $8CD3;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT = $8CD4;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES = $8CD4;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = $8CD4;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT = $8CD4;
  GL_FRAMEBUFFER_COMPLETE = $8CD5;
  GL_FRAMEBUFFER_COMPLETE_EXT = $8CD5;
  GL_FRAMEBUFFER_COMPLETE_OES = $8CD5;
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = $8CD6;
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT = $8CD6;
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_OES = $8CD6;
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = $8CD7;
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT = $8CD7;
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_OES = $8CD7;
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = $8CD9;
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT = $8CD9;
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_OES = $8CD9;
  GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT = $8CDA;
  GL_FRAMEBUFFER_INCOMPLETE_FORMATS_OES = $8CDA;
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = $8CDB;
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT = $8CDB;
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_OES = $8CDB;
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = $8CDC;
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT = $8CDC;
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_OES = $8CDC;
  GL_FRAMEBUFFER_UNSUPPORTED = $8CDD;
  GL_FRAMEBUFFER_UNSUPPORTED_EXT = $8CDD;
  GL_FRAMEBUFFER_UNSUPPORTED_OES = $8CDD;
  GL_MAX_COLOR_ATTACHMENTS = $8CDF;
  GL_MAX_COLOR_ATTACHMENTS_EXT = $8CDF;
  GL_MAX_COLOR_ATTACHMENTS_NV = $8CDF;
  GL_COLOR_ATTACHMENT0 = $8CE0;
  GL_COLOR_ATTACHMENT0_EXT = $8CE0;
  GL_COLOR_ATTACHMENT0_NV = $8CE0;
  GL_COLOR_ATTACHMENT0_OES = $8CE0;
  GL_COLOR_ATTACHMENT1 = $8CE1;
  GL_COLOR_ATTACHMENT1_EXT = $8CE1;
  GL_COLOR_ATTACHMENT1_NV = $8CE1;
  GL_COLOR_ATTACHMENT2 = $8CE2;
  GL_COLOR_ATTACHMENT2_EXT = $8CE2;
  GL_COLOR_ATTACHMENT2_NV = $8CE2;
  GL_COLOR_ATTACHMENT3 = $8CE3;
  GL_COLOR_ATTACHMENT3_EXT = $8CE3;
  GL_COLOR_ATTACHMENT3_NV = $8CE3;
  GL_COLOR_ATTACHMENT4 = $8CE4;
  GL_COLOR_ATTACHMENT4_EXT = $8CE4;
  GL_COLOR_ATTACHMENT4_NV = $8CE4;
  GL_COLOR_ATTACHMENT5 = $8CE5;
  GL_COLOR_ATTACHMENT5_EXT = $8CE5;
  GL_COLOR_ATTACHMENT5_NV = $8CE5;
  GL_COLOR_ATTACHMENT6 = $8CE6;
  GL_COLOR_ATTACHMENT6_EXT = $8CE6;
  GL_COLOR_ATTACHMENT6_NV = $8CE6;
  GL_COLOR_ATTACHMENT7 = $8CE7;
  GL_COLOR_ATTACHMENT7_EXT = $8CE7;
  GL_COLOR_ATTACHMENT7_NV = $8CE7;
  GL_COLOR_ATTACHMENT8 = $8CE8;
  GL_COLOR_ATTACHMENT8_EXT = $8CE8;
  GL_COLOR_ATTACHMENT8_NV = $8CE8;
  GL_COLOR_ATTACHMENT9 = $8CE9;
  GL_COLOR_ATTACHMENT9_EXT = $8CE9;
  GL_COLOR_ATTACHMENT9_NV = $8CE9;
  GL_COLOR_ATTACHMENT10 = $8CEA;
  GL_COLOR_ATTACHMENT10_EXT = $8CEA;
  GL_COLOR_ATTACHMENT10_NV = $8CEA;
  GL_COLOR_ATTACHMENT11 = $8CEB;
  GL_COLOR_ATTACHMENT11_EXT = $8CEB;
  GL_COLOR_ATTACHMENT11_NV = $8CEB;
  GL_COLOR_ATTACHMENT12 = $8CEC;
  GL_COLOR_ATTACHMENT12_EXT = $8CEC;
  GL_COLOR_ATTACHMENT12_NV = $8CEC;
  GL_COLOR_ATTACHMENT13 = $8CED;
  GL_COLOR_ATTACHMENT13_EXT = $8CED;
  GL_COLOR_ATTACHMENT13_NV = $8CED;
  GL_COLOR_ATTACHMENT14 = $8CEE;
  GL_COLOR_ATTACHMENT14_EXT = $8CEE;
  GL_COLOR_ATTACHMENT14_NV = $8CEE;
  GL_COLOR_ATTACHMENT15 = $8CEF;
  GL_COLOR_ATTACHMENT15_EXT = $8CEF;
  GL_COLOR_ATTACHMENT15_NV = $8CEF;
  GL_COLOR_ATTACHMENT16 = $8CF0;
  GL_COLOR_ATTACHMENT17 = $8CF1;
  GL_COLOR_ATTACHMENT18 = $8CF2;
  GL_COLOR_ATTACHMENT19 = $8CF3;
  GL_COLOR_ATTACHMENT20 = $8CF4;
  GL_COLOR_ATTACHMENT21 = $8CF5;
  GL_COLOR_ATTACHMENT22 = $8CF6;
  GL_COLOR_ATTACHMENT23 = $8CF7;
  GL_COLOR_ATTACHMENT24 = $8CF8;
  GL_COLOR_ATTACHMENT25 = $8CF9;
  GL_COLOR_ATTACHMENT26 = $8CFA;
  GL_COLOR_ATTACHMENT27 = $8CFB;
  GL_COLOR_ATTACHMENT28 = $8CFC;
  GL_COLOR_ATTACHMENT29 = $8CFD;
  GL_COLOR_ATTACHMENT30 = $8CFE;
  GL_COLOR_ATTACHMENT31 = $8CFF;
  GL_DEPTH_ATTACHMENT = $8D00;
  GL_DEPTH_ATTACHMENT_EXT = $8D00;
  GL_DEPTH_ATTACHMENT_OES = $8D00;
  GL_STENCIL_ATTACHMENT = $8D20;
  GL_STENCIL_ATTACHMENT_EXT = $8D20;
  GL_STENCIL_ATTACHMENT_OES = $8D20;
  GL_FRAMEBUFFER = $8D40;
  GL_FRAMEBUFFER_EXT = $8D40;
  GL_FRAMEBUFFER_OES = $8D40;
  GL_RENDERBUFFER = $8D41;
  GL_RENDERBUFFER_EXT = $8D41;
  GL_RENDERBUFFER_OES = $8D41;
  GL_RENDERBUFFER_WIDTH = $8D42;
  GL_RENDERBUFFER_WIDTH_EXT = $8D42;
  GL_RENDERBUFFER_WIDTH_OES = $8D42;
  GL_RENDERBUFFER_HEIGHT = $8D43;
  GL_RENDERBUFFER_HEIGHT_EXT = $8D43;
  GL_RENDERBUFFER_HEIGHT_OES = $8D43;
  GL_RENDERBUFFER_INTERNAL_FORMAT = $8D44;
  GL_RENDERBUFFER_INTERNAL_FORMAT_EXT = $8D44;
  GL_RENDERBUFFER_INTERNAL_FORMAT_OES = $8D44;
  GL_STENCIL_INDEX1 = $8D46;
  GL_STENCIL_INDEX1_EXT = $8D46;
  GL_STENCIL_INDEX1_OES = $8D46;
  GL_STENCIL_INDEX4 = $8D47;
  GL_STENCIL_INDEX4_EXT = $8D47;
  GL_STENCIL_INDEX4_OES = $8D47;
  GL_STENCIL_INDEX8 = $8D48;
  GL_STENCIL_INDEX8_EXT = $8D48;
  GL_STENCIL_INDEX8_OES = $8D48;
  GL_STENCIL_INDEX16 = $8D49;
  GL_STENCIL_INDEX16_EXT = $8D49;
  GL_RENDERBUFFER_RED_SIZE = $8D50;
  GL_RENDERBUFFER_RED_SIZE_EXT = $8D50;
  GL_RENDERBUFFER_RED_SIZE_OES = $8D50;
  GL_RENDERBUFFER_GREEN_SIZE = $8D51;
  GL_RENDERBUFFER_GREEN_SIZE_EXT = $8D51;
  GL_RENDERBUFFER_GREEN_SIZE_OES = $8D51;
  GL_RENDERBUFFER_BLUE_SIZE = $8D52;
  GL_RENDERBUFFER_BLUE_SIZE_EXT = $8D52;
  GL_RENDERBUFFER_BLUE_SIZE_OES = $8D52;
  GL_RENDERBUFFER_ALPHA_SIZE = $8D53;
  GL_RENDERBUFFER_ALPHA_SIZE_EXT = $8D53;
  GL_RENDERBUFFER_ALPHA_SIZE_OES = $8D53;
  GL_RENDERBUFFER_DEPTH_SIZE = $8D54;
  GL_RENDERBUFFER_DEPTH_SIZE_EXT = $8D54;
  GL_RENDERBUFFER_DEPTH_SIZE_OES = $8D54;
  GL_RENDERBUFFER_STENCIL_SIZE = $8D55;
  GL_RENDERBUFFER_STENCIL_SIZE_EXT = $8D55;
  GL_RENDERBUFFER_STENCIL_SIZE_OES = $8D55;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = $8D56;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE = $8D56;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE = $8D56;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = $8D56;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV = $8D56;
  GL_MAX_SAMPLES = $8D57;
  GL_MAX_SAMPLES_ANGLE = $8D57;
  GL_MAX_SAMPLES_APPLE = $8D57;
  GL_MAX_SAMPLES_EXT = $8D57;
  GL_MAX_SAMPLES_NV = $8D57;
  GL_TEXTURE_GEN_STR_OES = $8D60;
  GL_HALF_FLOAT_OES = $8D61;
  GL_RGB565_OES = $8D62;
  GL_RGB565 = $8D62;
  GL_ETC1_RGB8_OES = $8D64;
  GL_TEXTURE_EXTERNAL_OES = $8D65;
  GL_SAMPLER_EXTERNAL_OES = $8D66;
  GL_TEXTURE_BINDING_EXTERNAL_OES = $8D67;
  GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES = $8D68;
  GL_PRIMITIVE_RESTART_FIXED_INDEX = $8D69;
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE = $8D6A;
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT = $8D6A;
  GL_MAX_ELEMENT_INDEX = $8D6B;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT = $8D6C;
  GL_RGBA32UI = $8D70;
  GL_RGBA32UI_EXT = $8D70;
  GL_RGB32UI = $8D71;
  GL_RGB32UI_EXT = $8D71;
  GL_ALPHA32UI_EXT = $8D72;
  GL_INTENSITY32UI_EXT = $8D73;
  GL_LUMINANCE32UI_EXT = $8D74;
  GL_LUMINANCE_ALPHA32UI_EXT = $8D75;
  GL_RGBA16UI = $8D76;
  GL_RGBA16UI_EXT = $8D76;
  GL_RGB16UI = $8D77;
  GL_RGB16UI_EXT = $8D77;
  GL_ALPHA16UI_EXT = $8D78;
  GL_INTENSITY16UI_EXT = $8D79;
  GL_LUMINANCE16UI_EXT = $8D7A;
  GL_LUMINANCE_ALPHA16UI_EXT = $8D7B;
  GL_RGBA8UI = $8D7C;
  GL_RGBA8UI_EXT = $8D7C;
  GL_RGB8UI = $8D7D;
  GL_RGB8UI_EXT = $8D7D;
  GL_ALPHA8UI_EXT = $8D7E;
  GL_INTENSITY8UI_EXT = $8D7F;
  GL_LUMINANCE8UI_EXT = $8D80;
  GL_LUMINANCE_ALPHA8UI_EXT = $8D81;
  GL_RGBA32I = $8D82;
  GL_RGBA32I_EXT = $8D82;
  GL_RGB32I = $8D83;
  GL_RGB32I_EXT = $8D83;
  GL_ALPHA32I_EXT = $8D84;
  GL_INTENSITY32I_EXT = $8D85;
  GL_LUMINANCE32I_EXT = $8D86;
  GL_LUMINANCE_ALPHA32I_EXT = $8D87;
  GL_RGBA16I = $8D88;
  GL_RGBA16I_EXT = $8D88;
  GL_RGB16I = $8D89;
  GL_RGB16I_EXT = $8D89;
  GL_ALPHA16I_EXT = $8D8A;
  GL_INTENSITY16I_EXT = $8D8B;
  GL_LUMINANCE16I_EXT = $8D8C;
  GL_LUMINANCE_ALPHA16I_EXT = $8D8D;
  GL_RGBA8I = $8D8E;
  GL_RGBA8I_EXT = $8D8E;
  GL_RGB8I = $8D8F;
  GL_RGB8I_EXT = $8D8F;
  GL_ALPHA8I_EXT = $8D90;
  GL_INTENSITY8I_EXT = $8D91;
  GL_LUMINANCE8I_EXT = $8D92;
  GL_LUMINANCE_ALPHA8I_EXT = $8D93;
  GL_RED_INTEGER = $8D94;
  GL_RED_INTEGER_EXT = $8D94;
  GL_GREEN_INTEGER = $8D95;
  GL_GREEN_INTEGER_EXT = $8D95;
  GL_BLUE_INTEGER = $8D96;
  GL_BLUE_INTEGER_EXT = $8D96;
  GL_ALPHA_INTEGER = $8D97;
  GL_ALPHA_INTEGER_EXT = $8D97;
  GL_RGB_INTEGER = $8D98;
  GL_RGB_INTEGER_EXT = $8D98;
  GL_RGBA_INTEGER = $8D99;
  GL_RGBA_INTEGER_EXT = $8D99;
  GL_BGR_INTEGER = $8D9A;
  GL_BGR_INTEGER_EXT = $8D9A;
  GL_BGRA_INTEGER = $8D9B;
  GL_BGRA_INTEGER_EXT = $8D9B;
  GL_LUMINANCE_INTEGER_EXT = $8D9C;
  GL_LUMINANCE_ALPHA_INTEGER_EXT = $8D9D;
  GL_RGBA_INTEGER_MODE_EXT = $8D9E;
  GL_INT_2_10_10_10_REV = $8D9F;
  GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV = $8DA0;
  GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV = $8DA1;
  GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV = $8DA2;
  GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV = $8DA3;
  GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV = $8DA4;
  GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV = $8DA5;
  GL_MAX_PROGRAM_GENERIC_RESULTS_NV = $8DA6;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED = $8DA7;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB = $8DA7;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT = $8DA7;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_OES = $8DA7;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = $8DA8;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB = $8DA8;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT = $8DA8;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES = $8DA8;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB = $8DA9;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT = $8DA9;
  GL_LAYER_NV = $8DAA;
  GL_DEPTH_COMPONENT32F_NV = $8DAB;
  GL_DEPTH32F_STENCIL8_NV = $8DAC;
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV = $8DAD;
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV = $8DAD;
  GL_SHADER_INCLUDE_ARB = $8DAE;
  GL_DEPTH_BUFFER_FLOAT_MODE_NV = $8DAF;
  GL_FRAMEBUFFER_SRGB = $8DB9;
  GL_FRAMEBUFFER_SRGB_EXT = $8DB9;
  GL_FRAMEBUFFER_SRGB_CAPABLE_EXT = $8DBA;
  GL_COMPRESSED_RED_RGTC1 = $8DBB;
  GL_COMPRESSED_RED_RGTC1_EXT = $8DBB;
  GL_COMPRESSED_SIGNED_RED_RGTC1 = $8DBC;
  GL_COMPRESSED_SIGNED_RED_RGTC1_EXT = $8DBC;
  GL_COMPRESSED_RED_GREEN_RGTC2_EXT = $8DBD;
  GL_COMPRESSED_RG_RGTC2 = $8DBD;
  GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = $8DBE;
  GL_COMPRESSED_SIGNED_RG_RGTC2 = $8DBE;
  GL_SAMPLER_1D_ARRAY = $8DC0;
  GL_SAMPLER_1D_ARRAY_EXT = $8DC0;
  GL_SAMPLER_2D_ARRAY = $8DC1;
  GL_SAMPLER_2D_ARRAY_EXT = $8DC1;
  GL_SAMPLER_BUFFER = $8DC2;
  GL_SAMPLER_BUFFER_EXT = $8DC2;
  GL_SAMPLER_BUFFER_OES = $8DC2;
  GL_SAMPLER_1D_ARRAY_SHADOW = $8DC3;
  GL_SAMPLER_1D_ARRAY_SHADOW_EXT = $8DC3;
  GL_SAMPLER_2D_ARRAY_SHADOW = $8DC4;
  GL_SAMPLER_2D_ARRAY_SHADOW_EXT = $8DC4;
  GL_SAMPLER_2D_ARRAY_SHADOW_NV = $8DC4;
  GL_SAMPLER_CUBE_SHADOW = $8DC5;
  GL_SAMPLER_CUBE_SHADOW_EXT = $8DC5;
  GL_SAMPLER_CUBE_SHADOW_NV = $8DC5;
  GL_UNSIGNED_INT_VEC2 = $8DC6;
  GL_UNSIGNED_INT_VEC2_EXT = $8DC6;
  GL_UNSIGNED_INT_VEC3 = $8DC7;
  GL_UNSIGNED_INT_VEC3_EXT = $8DC7;
  GL_UNSIGNED_INT_VEC4 = $8DC8;
  GL_UNSIGNED_INT_VEC4_EXT = $8DC8;
  GL_INT_SAMPLER_1D = $8DC9;
  GL_INT_SAMPLER_1D_EXT = $8DC9;
  GL_INT_SAMPLER_2D = $8DCA;
  GL_INT_SAMPLER_2D_EXT = $8DCA;
  GL_INT_SAMPLER_3D = $8DCB;
  GL_INT_SAMPLER_3D_EXT = $8DCB;
  GL_INT_SAMPLER_CUBE = $8DCC;
  GL_INT_SAMPLER_CUBE_EXT = $8DCC;
  GL_INT_SAMPLER_2D_RECT = $8DCD;
  GL_INT_SAMPLER_2D_RECT_EXT = $8DCD;
  GL_INT_SAMPLER_1D_ARRAY = $8DCE;
  GL_INT_SAMPLER_1D_ARRAY_EXT = $8DCE;
  GL_INT_SAMPLER_2D_ARRAY = $8DCF;
  GL_INT_SAMPLER_2D_ARRAY_EXT = $8DCF;
  GL_INT_SAMPLER_BUFFER = $8DD0;
  GL_INT_SAMPLER_BUFFER_EXT = $8DD0;
  GL_INT_SAMPLER_BUFFER_OES = $8DD0;
  GL_UNSIGNED_INT_SAMPLER_1D = $8DD1;
  GL_UNSIGNED_INT_SAMPLER_1D_EXT = $8DD1;
  GL_UNSIGNED_INT_SAMPLER_2D = $8DD2;
  GL_UNSIGNED_INT_SAMPLER_2D_EXT = $8DD2;
  GL_UNSIGNED_INT_SAMPLER_3D = $8DD3;
  GL_UNSIGNED_INT_SAMPLER_3D_EXT = $8DD3;
  GL_UNSIGNED_INT_SAMPLER_CUBE = $8DD4;
  GL_UNSIGNED_INT_SAMPLER_CUBE_EXT = $8DD4;
  GL_UNSIGNED_INT_SAMPLER_2D_RECT = $8DD5;
  GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT = $8DD5;
  GL_UNSIGNED_INT_SAMPLER_1D_ARRAY = $8DD6;
  GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT = $8DD6;
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = $8DD7;
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT = $8DD7;
  GL_UNSIGNED_INT_SAMPLER_BUFFER = $8DD8;
  GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT = $8DD8;
  GL_UNSIGNED_INT_SAMPLER_BUFFER_OES = $8DD8;
  GL_GEOMETRY_SHADER = $8DD9;
  GL_GEOMETRY_SHADER_ARB = $8DD9;
  GL_GEOMETRY_SHADER_EXT = $8DD9;
  GL_GEOMETRY_SHADER_OES = $8DD9;
  GL_GEOMETRY_VERTICES_OUT_ARB = $8DDA;
  GL_GEOMETRY_VERTICES_OUT_EXT = $8DDA;
  GL_GEOMETRY_INPUT_TYPE_ARB = $8DDB;
  GL_GEOMETRY_INPUT_TYPE_EXT = $8DDB;
  GL_GEOMETRY_OUTPUT_TYPE_ARB = $8DDC;
  GL_GEOMETRY_OUTPUT_TYPE_EXT = $8DDC;
  GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB = $8DDD;
  GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT = $8DDD;
  GL_MAX_VERTEX_VARYING_COMPONENTS_ARB = $8DDE;
  GL_MAX_VERTEX_VARYING_COMPONENTS_EXT = $8DDE;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS = $8DDF;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB = $8DDF;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT = $8DDF;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_OES = $8DDF;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES = $8DE0;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB = $8DE0;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT = $8DE0;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_OES = $8DE0;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = $8DE1;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB = $8DE1;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT = $8DE1;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES = $8DE1;
  GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT = $8DE2;
  GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT = $8DE3;
  GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT = $8DE4;
  GL_ACTIVE_SUBROUTINES = $8DE5;
  GL_ACTIVE_SUBROUTINE_UNIFORMS = $8DE6;
  GL_MAX_SUBROUTINES = $8DE7;
  GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = $8DE8;
  GL_NAMED_STRING_LENGTH_ARB = $8DE9;
  GL_NAMED_STRING_TYPE_ARB = $8DEA;
  GL_MAX_BINDABLE_UNIFORM_SIZE_EXT = $8DED;
  GL_UNIFORM_BUFFER_EXT = $8DEE;
  GL_UNIFORM_BUFFER_BINDING_EXT = $8DEF;
  GL_LOW_FLOAT = $8DF0;
  GL_MEDIUM_FLOAT = $8DF1;
  GL_HIGH_FLOAT = $8DF2;
  GL_LOW_INT = $8DF3;
  GL_MEDIUM_INT = $8DF4;
  GL_HIGH_INT = $8DF5;
  GL_UNSIGNED_INT_10_10_10_2_OES = $8DF6;
  GL_INT_10_10_10_2_OES = $8DF7;
  GL_SHADER_BINARY_FORMATS = $8DF8;
  GL_NUM_SHADER_BINARY_FORMATS = $8DF9;
  GL_SHADER_COMPILER = $8DFA;
  GL_MAX_VERTEX_UNIFORM_VECTORS = $8DFB;
  GL_MAX_VARYING_VECTORS = $8DFC;
  GL_MAX_FRAGMENT_UNIFORM_VECTORS = $8DFD;
  GL_RENDERBUFFER_COLOR_SAMPLES_NV = $8E10;
  GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV = $8E11;
  GL_MULTISAMPLE_COVERAGE_MODES_NV = $8E12;
  GL_QUERY_WAIT = $8E13;
  GL_QUERY_WAIT_NV = $8E13;
  GL_QUERY_NO_WAIT = $8E14;
  GL_QUERY_NO_WAIT_NV = $8E14;
  GL_QUERY_BY_REGION_WAIT = $8E15;
  GL_QUERY_BY_REGION_WAIT_NV = $8E15;
  GL_QUERY_BY_REGION_NO_WAIT = $8E16;
  GL_QUERY_BY_REGION_NO_WAIT_NV = $8E16;
  GL_QUERY_WAIT_INVERTED = $8E17;
  GL_QUERY_NO_WAIT_INVERTED = $8E18;
  GL_QUERY_BY_REGION_WAIT_INVERTED = $8E19;
  GL_QUERY_BY_REGION_NO_WAIT_INVERTED = $8E1A;
  GL_POLYGON_OFFSET_CLAMP = $8E1B;
  GL_POLYGON_OFFSET_CLAMP_EXT = $8E1B;
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = $8E1E;
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = $8E1E;
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES = $8E1E;
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = $8E1F;
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = $8E1F;
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = $8E1F;
  GL_COLOR_SAMPLES_NV = $8E20;
  GL_TRANSFORM_FEEDBACK = $8E22;
  GL_TRANSFORM_FEEDBACK_NV = $8E22;
  GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = $8E23;
  GL_TRANSFORM_FEEDBACK_PAUSED = $8E23;
  GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV = $8E23;
  GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = $8E24;
  GL_TRANSFORM_FEEDBACK_ACTIVE = $8E24;
  GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV = $8E24;
  GL_TRANSFORM_FEEDBACK_BINDING = $8E25;
  GL_TRANSFORM_FEEDBACK_BINDING_NV = $8E25;
  GL_FRAME_NV = $8E26;
  GL_FIELDS_NV = $8E27;
  GL_CURRENT_TIME_NV = $8E28;
  GL_TIMESTAMP = $8E28;
  GL_TIMESTAMP_EXT = $8E28;
  GL_NUM_FILL_STREAMS_NV = $8E29;
  GL_PRESENT_TIME_NV = $8E2A;
  GL_PRESENT_DURATION_NV = $8E2B;
  GL_DEPTH_COMPONENT16_NONLINEAR_NV = $8E2C;
  GL_PROGRAM_MATRIX_EXT = $8E2D;
  GL_TRANSPOSE_PROGRAM_MATRIX_EXT = $8E2E;
  GL_PROGRAM_MATRIX_STACK_DEPTH_EXT = $8E2F;
  GL_TEXTURE_SWIZZLE_R = $8E42;
  GL_TEXTURE_SWIZZLE_R_EXT = $8E42;
  GL_TEXTURE_SWIZZLE_G = $8E43;
  GL_TEXTURE_SWIZZLE_G_EXT = $8E43;
  GL_TEXTURE_SWIZZLE_B = $8E44;
  GL_TEXTURE_SWIZZLE_B_EXT = $8E44;
  GL_TEXTURE_SWIZZLE_A = $8E45;
  GL_TEXTURE_SWIZZLE_A_EXT = $8E45;
  GL_TEXTURE_SWIZZLE_RGBA = $8E46;
  GL_TEXTURE_SWIZZLE_RGBA_EXT = $8E46;
  GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = $8E47;
  GL_ACTIVE_SUBROUTINE_MAX_LENGTH = $8E48;
  GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = $8E49;
  GL_NUM_COMPATIBLE_SUBROUTINES = $8E4A;
  GL_COMPATIBLE_SUBROUTINES = $8E4B;
  GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = $8E4C;
  GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT = $8E4C;
  GL_FIRST_VERTEX_CONVENTION = $8E4D;
  GL_FIRST_VERTEX_CONVENTION_EXT = $8E4D;
  GL_FIRST_VERTEX_CONVENTION_OES = $8E4D;
  GL_LAST_VERTEX_CONVENTION = $8E4E;
  GL_LAST_VERTEX_CONVENTION_EXT = $8E4E;
  GL_LAST_VERTEX_CONVENTION_OES = $8E4E;
  GL_PROVOKING_VERTEX = $8E4F;
  GL_PROVOKING_VERTEX_EXT = $8E4F;
  GL_SAMPLE_POSITION = $8E50;
  GL_SAMPLE_POSITION_NV = $8E50;
  GL_SAMPLE_LOCATION_ARB = $8E50;
  GL_SAMPLE_LOCATION_NV = $8E50;
  GL_SAMPLE_MASK = $8E51;
  GL_SAMPLE_MASK_NV = $8E51;
  GL_SAMPLE_MASK_VALUE = $8E52;
  GL_SAMPLE_MASK_VALUE_NV = $8E52;
  GL_TEXTURE_BINDING_RENDERBUFFER_NV = $8E53;
  GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV = $8E54;
  GL_TEXTURE_RENDERBUFFER_NV = $8E55;
  GL_SAMPLER_RENDERBUFFER_NV = $8E56;
  GL_INT_SAMPLER_RENDERBUFFER_NV = $8E57;
  GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV = $8E58;
  GL_MAX_SAMPLE_MASK_WORDS = $8E59;
  GL_MAX_SAMPLE_MASK_WORDS_NV = $8E59;
  GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV = $8E5A;
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS = $8E5A;
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT = $8E5A;
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS_OES = $8E5A;
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = $8E5B;
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES = $8E5B;
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV = $8E5B;
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = $8E5C;
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES = $8E5C;
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV = $8E5C;
  GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = $8E5D;
  GL_FRAGMENT_INTERPOLATION_OFFSET_BITS_OES = $8E5D;
  GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV = $8E5D;
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET = $8E5E;
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = $8E5E;
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV = $8E5E;
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET = $8E5F;
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = $8E5F;
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV = $8E5F;
  GL_MAX_MESH_UNIFORM_BLOCKS_NV = $8E60;
  GL_MAX_MESH_TEXTURE_IMAGE_UNITS_NV = $8E61;
  GL_MAX_MESH_IMAGE_UNIFORMS_NV = $8E62;
  GL_MAX_MESH_UNIFORM_COMPONENTS_NV = $8E63;
  GL_MAX_MESH_ATOMIC_COUNTER_BUFFERS_NV = $8E64;
  GL_MAX_MESH_ATOMIC_COUNTERS_NV = $8E65;
  GL_MAX_MESH_SHADER_STORAGE_BLOCKS_NV = $8E66;
  GL_MAX_COMBINED_MESH_UNIFORM_COMPONENTS_NV = $8E67;
  GL_MAX_TASK_UNIFORM_BLOCKS_NV = $8E68;
  GL_MAX_TASK_TEXTURE_IMAGE_UNITS_NV = $8E69;
  GL_MAX_TASK_IMAGE_UNIFORMS_NV = $8E6A;
  GL_MAX_TASK_UNIFORM_COMPONENTS_NV = $8E6B;
  GL_MAX_TASK_ATOMIC_COUNTER_BUFFERS_NV = $8E6C;
  GL_MAX_TASK_ATOMIC_COUNTERS_NV = $8E6D;
  GL_MAX_TASK_SHADER_STORAGE_BLOCKS_NV = $8E6E;
  GL_MAX_COMBINED_TASK_UNIFORM_COMPONENTS_NV = $8E6F;
  GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = $8E70;
  GL_MAX_VERTEX_STREAMS = $8E71;
  GL_PATCH_VERTICES = $8E72;
  GL_PATCH_VERTICES_EXT = $8E72;
  GL_PATCH_VERTICES_OES = $8E72;
  GL_PATCH_DEFAULT_INNER_LEVEL = $8E73;
  GL_PATCH_DEFAULT_INNER_LEVEL_EXT = $8E73;
  GL_PATCH_DEFAULT_OUTER_LEVEL = $8E74;
  GL_PATCH_DEFAULT_OUTER_LEVEL_EXT = $8E74;
  GL_TESS_CONTROL_OUTPUT_VERTICES = $8E75;
  GL_TESS_CONTROL_OUTPUT_VERTICES_EXT = $8E75;
  GL_TESS_CONTROL_OUTPUT_VERTICES_OES = $8E75;
  GL_TESS_GEN_MODE = $8E76;
  GL_TESS_GEN_MODE_EXT = $8E76;
  GL_TESS_GEN_MODE_OES = $8E76;
  GL_TESS_GEN_SPACING = $8E77;
  GL_TESS_GEN_SPACING_EXT = $8E77;
  GL_TESS_GEN_SPACING_OES = $8E77;
  GL_TESS_GEN_VERTEX_ORDER = $8E78;
  GL_TESS_GEN_VERTEX_ORDER_EXT = $8E78;
  GL_TESS_GEN_VERTEX_ORDER_OES = $8E78;
  GL_TESS_GEN_POINT_MODE = $8E79;
  GL_TESS_GEN_POINT_MODE_EXT = $8E79;
  GL_TESS_GEN_POINT_MODE_OES = $8E79;
  GL_ISOLINES = $8E7A;
  GL_ISOLINES_EXT = $8E7A;
  GL_ISOLINES_OES = $8E7A;
  GL_FRACTIONAL_ODD = $8E7B;
  GL_FRACTIONAL_ODD_EXT = $8E7B;
  GL_FRACTIONAL_ODD_OES = $8E7B;
  GL_FRACTIONAL_EVEN = $8E7C;
  GL_FRACTIONAL_EVEN_EXT = $8E7C;
  GL_FRACTIONAL_EVEN_OES = $8E7C;
  GL_MAX_PATCH_VERTICES = $8E7D;
  GL_MAX_PATCH_VERTICES_EXT = $8E7D;
  GL_MAX_PATCH_VERTICES_OES = $8E7D;
  GL_MAX_TESS_GEN_LEVEL = $8E7E;
  GL_MAX_TESS_GEN_LEVEL_EXT = $8E7E;
  GL_MAX_TESS_GEN_LEVEL_OES = $8E7E;
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = $8E7F;
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = $8E7F;
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES = $8E7F;
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = $8E80;
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = $8E80;
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = $8E80;
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = $8E81;
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT = $8E81;
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES = $8E81;
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = $8E82;
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT = $8E82;
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES = $8E82;
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = $8E83;
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT = $8E83;
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES = $8E83;
  GL_MAX_TESS_PATCH_COMPONENTS = $8E84;
  GL_MAX_TESS_PATCH_COMPONENTS_EXT = $8E84;
  GL_MAX_TESS_PATCH_COMPONENTS_OES = $8E84;
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = $8E85;
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT = $8E85;
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES = $8E85;
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = $8E86;
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT = $8E86;
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES = $8E86;
  GL_TESS_EVALUATION_SHADER = $8E87;
  GL_TESS_EVALUATION_SHADER_EXT = $8E87;
  GL_TESS_EVALUATION_SHADER_OES = $8E87;
  GL_TESS_CONTROL_SHADER = $8E88;
  GL_TESS_CONTROL_SHADER_EXT = $8E88;
  GL_TESS_CONTROL_SHADER_OES = $8E88;
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = $8E89;
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT = $8E89;
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES = $8E89;
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = $8E8A;
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT = $8E8A;
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES = $8E8A;
  GL_COMPRESSED_RGBA_BPTC_UNORM = $8E8C;
  GL_COMPRESSED_RGBA_BPTC_UNORM_ARB = $8E8C;
  GL_COMPRESSED_RGBA_BPTC_UNORM_EXT = $8E8C;
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = $8E8D;
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB = $8E8D;
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = $8E8D;
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = $8E8E;
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB = $8E8E;
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = $8E8E;
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = $8E8F;
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB = $8E8F;
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = $8E8F;
  GL_TRP_IMG = $8EA0;
  GL_TRP_ERROR_CONTEXT_RESET_IMG = $8EA1;
  GL_TRP_UNSUPPORTED_CONTEXT_IMG = $8EA2;
  GL_PVRIC_SIGNATURE_MISMATCH_IMG = $8EA3;
  GL_COVERAGE_COMPONENT_NV = $8ED0;
  GL_COVERAGE_COMPONENT4_NV = $8ED1;
  GL_COVERAGE_ATTACHMENT_NV = $8ED2;
  GL_COVERAGE_BUFFERS_NV = $8ED3;
  GL_COVERAGE_SAMPLES_NV = $8ED4;
  GL_COVERAGE_ALL_FRAGMENTS_NV = $8ED5;
  GL_COVERAGE_EDGE_FRAGMENTS_NV = $8ED6;
  GL_COVERAGE_AUTOMATIC_NV = $8ED7;
  GL_INCLUSIVE_EXT = $8F10;
  GL_EXCLUSIVE_EXT = $8F11;
  GL_WINDOW_RECTANGLE_EXT = $8F12;
  GL_WINDOW_RECTANGLE_MODE_EXT = $8F13;
  GL_MAX_WINDOW_RECTANGLES_EXT = $8F14;
  GL_NUM_WINDOW_RECTANGLES_EXT = $8F15;
  GL_BUFFER_GPU_ADDRESS_NV = $8F1D;
  GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV = $8F1E;
  GL_ELEMENT_ARRAY_UNIFIED_NV = $8F1F;
  GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV = $8F20;
  GL_VERTEX_ARRAY_ADDRESS_NV = $8F21;
  GL_NORMAL_ARRAY_ADDRESS_NV = $8F22;
  GL_COLOR_ARRAY_ADDRESS_NV = $8F23;
  GL_INDEX_ARRAY_ADDRESS_NV = $8F24;
  GL_TEXTURE_COORD_ARRAY_ADDRESS_NV = $8F25;
  GL_EDGE_FLAG_ARRAY_ADDRESS_NV = $8F26;
  GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV = $8F27;
  GL_FOG_COORD_ARRAY_ADDRESS_NV = $8F28;
  GL_ELEMENT_ARRAY_ADDRESS_NV = $8F29;
  GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV = $8F2A;
  GL_VERTEX_ARRAY_LENGTH_NV = $8F2B;
  GL_NORMAL_ARRAY_LENGTH_NV = $8F2C;
  GL_COLOR_ARRAY_LENGTH_NV = $8F2D;
  GL_INDEX_ARRAY_LENGTH_NV = $8F2E;
  GL_TEXTURE_COORD_ARRAY_LENGTH_NV = $8F2F;
  GL_EDGE_FLAG_ARRAY_LENGTH_NV = $8F30;
  GL_SECONDARY_COLOR_ARRAY_LENGTH_NV = $8F31;
  GL_FOG_COORD_ARRAY_LENGTH_NV = $8F32;
  GL_ELEMENT_ARRAY_LENGTH_NV = $8F33;
  GL_GPU_ADDRESS_NV = $8F34;
  GL_MAX_SHADER_BUFFER_ADDRESS_NV = $8F35;
  GL_COPY_READ_BUFFER = $8F36;
  GL_COPY_READ_BUFFER_NV = $8F36;
  GL_COPY_READ_BUFFER_BINDING = $8F36;
  GL_COPY_WRITE_BUFFER = $8F37;
  GL_COPY_WRITE_BUFFER_NV = $8F37;
  GL_COPY_WRITE_BUFFER_BINDING = $8F37;
  GL_MAX_IMAGE_UNITS = $8F38;
  GL_MAX_IMAGE_UNITS_EXT = $8F38;
  GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = $8F39;
  GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT = $8F39;
  GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = $8F39;
  GL_IMAGE_BINDING_NAME = $8F3A;
  GL_IMAGE_BINDING_NAME_EXT = $8F3A;
  GL_IMAGE_BINDING_LEVEL = $8F3B;
  GL_IMAGE_BINDING_LEVEL_EXT = $8F3B;
  GL_IMAGE_BINDING_LAYERED = $8F3C;
  GL_IMAGE_BINDING_LAYERED_EXT = $8F3C;
  GL_IMAGE_BINDING_LAYER = $8F3D;
  GL_IMAGE_BINDING_LAYER_EXT = $8F3D;
  GL_IMAGE_BINDING_ACCESS = $8F3E;
  GL_IMAGE_BINDING_ACCESS_EXT = $8F3E;
  GL_DRAW_INDIRECT_BUFFER = $8F3F;
  GL_DRAW_INDIRECT_UNIFIED_NV = $8F40;
  GL_DRAW_INDIRECT_ADDRESS_NV = $8F41;
  GL_DRAW_INDIRECT_LENGTH_NV = $8F42;
  GL_DRAW_INDIRECT_BUFFER_BINDING = $8F43;
  GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV = $8F44;
  GL_MAX_PROGRAM_SUBROUTINE_NUM_NV = $8F45;
  GL_DOUBLE_MAT2 = $8F46;
  GL_DOUBLE_MAT2_EXT = $8F46;
  GL_DOUBLE_MAT3 = $8F47;
  GL_DOUBLE_MAT3_EXT = $8F47;
  GL_DOUBLE_MAT4 = $8F48;
  GL_DOUBLE_MAT4_EXT = $8F48;
  GL_DOUBLE_MAT2x3 = $8F49;
  GL_DOUBLE_MAT2x3_EXT = $8F49;
  GL_DOUBLE_MAT2x4 = $8F4A;
  GL_DOUBLE_MAT2x4_EXT = $8F4A;
  GL_DOUBLE_MAT3x2 = $8F4B;
  GL_DOUBLE_MAT3x2_EXT = $8F4B;
  GL_DOUBLE_MAT3x4 = $8F4C;
  GL_DOUBLE_MAT3x4_EXT = $8F4C;
  GL_DOUBLE_MAT4x2 = $8F4D;
  GL_DOUBLE_MAT4x2_EXT = $8F4D;
  GL_DOUBLE_MAT4x3 = $8F4E;
  GL_DOUBLE_MAT4x3_EXT = $8F4E;
  GL_VERTEX_BINDING_BUFFER = $8F4F;
  GL_MALI_SHADER_BINARY_ARM = $8F60;
  GL_MALI_PROGRAM_BINARY_ARM = $8F61;
  GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT = $8F63;
  GL_SHADER_PIXEL_LOCAL_STORAGE_EXT = $8F64;
  GL_FETCH_PER_SAMPLE_ARM = $8F65;
  GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM = $8F66;
  GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT = $8F67;
  GL_TEXTURE_ASTC_DECODE_PRECISION_EXT = $8F69;
  GL_TEXTURE_UNNORMALIZED_COORDINATES_ARM = $8F6A;
  GL_NUM_SURFACE_COMPRESSION_FIXED_RATES_EXT = $8F6E;
  GL_FRAGMENT_SHADING_RATE_NON_TRIVIAL_COMBINERS_SUPPORTED_EXT = $8F6F;
  GL_RED_SNORM = $8F90;
  GL_RG_SNORM = $8F91;
  GL_RGB_SNORM = $8F92;
  GL_RGBA_SNORM = $8F93;
  GL_R8_SNORM = $8F94;
  GL_RG8_SNORM = $8F95;
  GL_RGB8_SNORM = $8F96;
  GL_RGBA8_SNORM = $8F97;
  GL_R16_SNORM = $8F98;
  GL_R16_SNORM_EXT = $8F98;
  GL_RG16_SNORM = $8F99;
  GL_RG16_SNORM_EXT = $8F99;
  GL_RGB16_SNORM = $8F9A;
  GL_RGB16_SNORM_EXT = $8F9A;
  GL_RGBA16_SNORM = $8F9B;
  GL_RGBA16_SNORM_EXT = $8F9B;
  GL_SIGNED_NORMALIZED = $8F9C;
  GL_PRIMITIVE_RESTART = $8F9D;
  GL_PRIMITIVE_RESTART_INDEX = $8F9E;
  GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB = $8F9F;
  GL_PERFMON_GLOBAL_MODE_QCOM = $8FA0;
  GL_MAX_SHADER_SUBSAMPLED_IMAGE_UNITS_QCOM = $8FA1;
  GL_BINNING_CONTROL_HINT_QCOM = $8FB0;
  GL_CPU_OPTIMIZED_QCOM = $8FB1;
  GL_GPU_OPTIMIZED_QCOM = $8FB2;
  GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM = $8FB3;
  GL_GPU_DISJOINT_EXT = $8FBB;
  GL_SR8_EXT = $8FBD;
  GL_SRG8_EXT = $8FBE;
  GL_TEXTURE_FORMAT_SRGB_OVERRIDE_EXT = $8FBF;
  GL_SHADER_BINARY_VIV = $8FC4;
  GL_INT8_NV = $8FE0;
  GL_INT8_VEC2_NV = $8FE1;
  GL_INT8_VEC3_NV = $8FE2;
  GL_INT8_VEC4_NV = $8FE3;
  GL_INT16_NV = $8FE4;
  GL_INT16_VEC2_NV = $8FE5;
  GL_INT16_VEC3_NV = $8FE6;
  GL_INT16_VEC4_NV = $8FE7;
  GL_INT64_VEC2_ARB = $8FE9;
  GL_INT64_VEC2_NV = $8FE9;
  GL_INT64_VEC3_ARB = $8FEA;
  GL_INT64_VEC3_NV = $8FEA;
  GL_INT64_VEC4_ARB = $8FEB;
  GL_INT64_VEC4_NV = $8FEB;
  GL_UNSIGNED_INT8_NV = $8FEC;
  GL_UNSIGNED_INT8_VEC2_NV = $8FED;
  GL_UNSIGNED_INT8_VEC3_NV = $8FEE;
  GL_UNSIGNED_INT8_VEC4_NV = $8FEF;
  GL_UNSIGNED_INT16_NV = $8FF0;
  GL_UNSIGNED_INT16_VEC2_NV = $8FF1;
  GL_UNSIGNED_INT16_VEC3_NV = $8FF2;
  GL_UNSIGNED_INT16_VEC4_NV = $8FF3;
  GL_UNSIGNED_INT64_VEC2_ARB = $8FF5;
  GL_UNSIGNED_INT64_VEC2_NV = $8FF5;
  GL_UNSIGNED_INT64_VEC3_ARB = $8FF6;
  GL_UNSIGNED_INT64_VEC3_NV = $8FF6;
  GL_UNSIGNED_INT64_VEC4_ARB = $8FF7;
  GL_UNSIGNED_INT64_VEC4_NV = $8FF7;
  GL_FLOAT16_NV = $8FF8;
  GL_FLOAT16_VEC2_NV = $8FF9;
  GL_FLOAT16_VEC3_NV = $8FFA;
  GL_FLOAT16_VEC4_NV = $8FFB;
  GL_DOUBLE_VEC2 = $8FFC;
  GL_DOUBLE_VEC2_EXT = $8FFC;
  GL_DOUBLE_VEC3 = $8FFD;
  GL_DOUBLE_VEC3_EXT = $8FFD;
  GL_DOUBLE_VEC4 = $8FFE;
  GL_DOUBLE_VEC4_EXT = $8FFE;
  GL_SAMPLER_BUFFER_AMD = $9001;
  GL_INT_SAMPLER_BUFFER_AMD = $9002;
  GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD = $9003;
  GL_TESSELLATION_MODE_AMD = $9004;
  GL_TESSELLATION_FACTOR_AMD = $9005;
  GL_DISCRETE_AMD = $9006;
  GL_CONTINUOUS_AMD = $9007;
  GL_TEXTURE_CUBE_MAP_ARRAY = $9009;
  GL_TEXTURE_CUBE_MAP_ARRAY_ARB = $9009;
  GL_TEXTURE_CUBE_MAP_ARRAY_EXT = $9009;
  GL_TEXTURE_CUBE_MAP_ARRAY_OES = $9009;
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = $900A;
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB = $900A;
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT = $900A;
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_OES = $900A;
  GL_PROXY_TEXTURE_CUBE_MAP_ARRAY = $900B;
  GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB = $900B;
  GL_SAMPLER_CUBE_MAP_ARRAY = $900C;
  GL_SAMPLER_CUBE_MAP_ARRAY_ARB = $900C;
  GL_SAMPLER_CUBE_MAP_ARRAY_EXT = $900C;
  GL_SAMPLER_CUBE_MAP_ARRAY_OES = $900C;
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW = $900D;
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB = $900D;
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT = $900D;
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES = $900D;
  GL_INT_SAMPLER_CUBE_MAP_ARRAY = $900E;
  GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = $900E;
  GL_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = $900E;
  GL_INT_SAMPLER_CUBE_MAP_ARRAY_OES = $900E;
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = $900F;
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = $900F;
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = $900F;
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES = $900F;
  GL_ALPHA_SNORM = $9010;
  GL_LUMINANCE_SNORM = $9011;
  GL_LUMINANCE_ALPHA_SNORM = $9012;
  GL_INTENSITY_SNORM = $9013;
  GL_ALPHA8_SNORM = $9014;
  GL_LUMINANCE8_SNORM = $9015;
  GL_LUMINANCE8_ALPHA8_SNORM = $9016;
  GL_INTENSITY8_SNORM = $9017;
  GL_ALPHA16_SNORM = $9018;
  GL_LUMINANCE16_SNORM = $9019;
  GL_LUMINANCE16_ALPHA16_SNORM = $901A;
  GL_INTENSITY16_SNORM = $901B;
  GL_FACTOR_MIN_AMD = $901C;
  GL_FACTOR_MAX_AMD = $901D;
  GL_DEPTH_CLAMP_NEAR_AMD = $901E;
  GL_DEPTH_CLAMP_FAR_AMD = $901F;
  GL_VIDEO_BUFFER_NV = $9020;
  GL_VIDEO_BUFFER_BINDING_NV = $9021;
  GL_FIELD_UPPER_NV = $9022;
  GL_FIELD_LOWER_NV = $9023;
  GL_NUM_VIDEO_CAPTURE_STREAMS_NV = $9024;
  GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV = $9025;
  GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV = $9026;
  GL_LAST_VIDEO_CAPTURE_STATUS_NV = $9027;
  GL_VIDEO_BUFFER_PITCH_NV = $9028;
  GL_VIDEO_COLOR_CONVERSION_MATRIX_NV = $9029;
  GL_VIDEO_COLOR_CONVERSION_MAX_NV = $902A;
  GL_VIDEO_COLOR_CONVERSION_MIN_NV = $902B;
  GL_VIDEO_COLOR_CONVERSION_OFFSET_NV = $902C;
  GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV = $902D;
  GL_PARTIAL_SUCCESS_NV = $902E;
  GL_SUCCESS_NV = $902F;
  GL_FAILURE_NV = $9030;
  GL_YCBYCR8_422_NV = $9031;
  GL_YCBAYCR8A_4224_NV = $9032;
  GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV = $9033;
  GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV = $9034;
  GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV = $9035;
  GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV = $9036;
  GL_Z4Y12Z4CB12Z4CR12_444_NV = $9037;
  GL_VIDEO_CAPTURE_FRAME_WIDTH_NV = $9038;
  GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV = $9039;
  GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV = $903A;
  GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV = $903B;
  GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV = $903C;
  GL_TEXTURE_COVERAGE_SAMPLES_NV = $9045;
  GL_TEXTURE_COLOR_SAMPLES_NV = $9046;
  GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX = $9047;
  GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX = $9048;
  GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX = $9049;
  GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX = $904A;
  GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX = $904B;
  GL_IMAGE_1D = $904C;
  GL_IMAGE_1D_EXT = $904C;
  GL_IMAGE_2D = $904D;
  GL_IMAGE_2D_EXT = $904D;
  GL_IMAGE_3D = $904E;
  GL_IMAGE_3D_EXT = $904E;
  GL_IMAGE_2D_RECT = $904F;
  GL_IMAGE_2D_RECT_EXT = $904F;
  GL_IMAGE_CUBE = $9050;
  GL_IMAGE_CUBE_EXT = $9050;
  GL_IMAGE_BUFFER = $9051;
  GL_IMAGE_BUFFER_EXT = $9051;
  GL_IMAGE_BUFFER_OES = $9051;
  GL_IMAGE_1D_ARRAY = $9052;
  GL_IMAGE_1D_ARRAY_EXT = $9052;
  GL_IMAGE_2D_ARRAY = $9053;
  GL_IMAGE_2D_ARRAY_EXT = $9053;
  GL_IMAGE_CUBE_MAP_ARRAY = $9054;
  GL_IMAGE_CUBE_MAP_ARRAY_EXT = $9054;
  GL_IMAGE_CUBE_MAP_ARRAY_OES = $9054;
  GL_IMAGE_2D_MULTISAMPLE = $9055;
  GL_IMAGE_2D_MULTISAMPLE_EXT = $9055;
  GL_IMAGE_2D_MULTISAMPLE_ARRAY = $9056;
  GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = $9056;
  GL_INT_IMAGE_1D = $9057;
  GL_INT_IMAGE_1D_EXT = $9057;
  GL_INT_IMAGE_2D = $9058;
  GL_INT_IMAGE_2D_EXT = $9058;
  GL_INT_IMAGE_3D = $9059;
  GL_INT_IMAGE_3D_EXT = $9059;
  GL_INT_IMAGE_2D_RECT = $905A;
  GL_INT_IMAGE_2D_RECT_EXT = $905A;
  GL_INT_IMAGE_CUBE = $905B;
  GL_INT_IMAGE_CUBE_EXT = $905B;
  GL_INT_IMAGE_BUFFER = $905C;
  GL_INT_IMAGE_BUFFER_EXT = $905C;
  GL_INT_IMAGE_BUFFER_OES = $905C;
  GL_INT_IMAGE_1D_ARRAY = $905D;
  GL_INT_IMAGE_1D_ARRAY_EXT = $905D;
  GL_INT_IMAGE_2D_ARRAY = $905E;
  GL_INT_IMAGE_2D_ARRAY_EXT = $905E;
  GL_INT_IMAGE_CUBE_MAP_ARRAY = $905F;
  GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT = $905F;
  GL_INT_IMAGE_CUBE_MAP_ARRAY_OES = $905F;
  GL_INT_IMAGE_2D_MULTISAMPLE = $9060;
  GL_INT_IMAGE_2D_MULTISAMPLE_EXT = $9060;
  GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = $9061;
  GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = $9061;
  GL_UNSIGNED_INT_IMAGE_1D = $9062;
  GL_UNSIGNED_INT_IMAGE_1D_EXT = $9062;
  GL_UNSIGNED_INT_IMAGE_2D = $9063;
  GL_UNSIGNED_INT_IMAGE_2D_EXT = $9063;
  GL_UNSIGNED_INT_IMAGE_3D = $9064;
  GL_UNSIGNED_INT_IMAGE_3D_EXT = $9064;
  GL_UNSIGNED_INT_IMAGE_2D_RECT = $9065;
  GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT = $9065;
  GL_UNSIGNED_INT_IMAGE_CUBE = $9066;
  GL_UNSIGNED_INT_IMAGE_CUBE_EXT = $9066;
  GL_UNSIGNED_INT_IMAGE_BUFFER = $9067;
  GL_UNSIGNED_INT_IMAGE_BUFFER_EXT = $9067;
  GL_UNSIGNED_INT_IMAGE_BUFFER_OES = $9067;
  GL_UNSIGNED_INT_IMAGE_1D_ARRAY = $9068;
  GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT = $9068;
  GL_UNSIGNED_INT_IMAGE_2D_ARRAY = $9069;
  GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT = $9069;
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = $906A;
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT = $906A;
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES = $906A;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = $906B;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT = $906B;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = $906C;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = $906C;
  GL_MAX_IMAGE_SAMPLES = $906D;
  GL_MAX_IMAGE_SAMPLES_EXT = $906D;
  GL_IMAGE_BINDING_FORMAT = $906E;
  GL_IMAGE_BINDING_FORMAT_EXT = $906E;
  GL_RGB10_A2UI = $906F;
  GL_PATH_FORMAT_SVG_NV = $9070;
  GL_PATH_FORMAT_PS_NV = $9071;
  GL_STANDARD_FONT_NAME_NV = $9072;
  GL_SYSTEM_FONT_NAME_NV = $9073;
  GL_FILE_NAME_NV = $9074;
  GL_PATH_STROKE_WIDTH_NV = $9075;
  GL_PATH_END_CAPS_NV = $9076;
  GL_PATH_INITIAL_END_CAP_NV = $9077;
  GL_PATH_TERMINAL_END_CAP_NV = $9078;
  GL_PATH_JOIN_STYLE_NV = $9079;
  GL_PATH_MITER_LIMIT_NV = $907A;
  GL_PATH_DASH_CAPS_NV = $907B;
  GL_PATH_INITIAL_DASH_CAP_NV = $907C;
  GL_PATH_TERMINAL_DASH_CAP_NV = $907D;
  GL_PATH_DASH_OFFSET_NV = $907E;
  GL_PATH_CLIENT_LENGTH_NV = $907F;
  GL_PATH_FILL_MODE_NV = $9080;
  GL_PATH_FILL_MASK_NV = $9081;
  GL_PATH_FILL_COVER_MODE_NV = $9082;
  GL_PATH_STROKE_COVER_MODE_NV = $9083;
  GL_PATH_STROKE_MASK_NV = $9084;
  GL_COUNT_UP_NV = $9088;
  GL_COUNT_DOWN_NV = $9089;
  GL_PATH_OBJECT_BOUNDING_BOX_NV = $908A;
  GL_CONVEX_HULL_NV = $908B;
  GL_BOUNDING_BOX_NV = $908D;
  GL_TRANSLATE_X_NV = $908E;
  GL_TRANSLATE_Y_NV = $908F;
  GL_TRANSLATE_2D_NV = $9090;
  GL_TRANSLATE_3D_NV = $9091;
  GL_AFFINE_2D_NV = $9092;
  GL_AFFINE_3D_NV = $9094;
  GL_TRANSPOSE_AFFINE_2D_NV = $9096;
  GL_TRANSPOSE_AFFINE_3D_NV = $9098;
  GL_UTF8_NV = $909A;
  GL_UTF16_NV = $909B;
  GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV = $909C;
  GL_PATH_COMMAND_COUNT_NV = $909D;
  GL_PATH_COORD_COUNT_NV = $909E;
  GL_PATH_DASH_ARRAY_COUNT_NV = $909F;
  GL_PATH_COMPUTED_LENGTH_NV = $90A0;
  GL_PATH_FILL_BOUNDING_BOX_NV = $90A1;
  GL_PATH_STROKE_BOUNDING_BOX_NV = $90A2;
  GL_SQUARE_NV = $90A3;
  GL_ROUND_NV = $90A4;
  GL_TRIANGULAR_NV = $90A5;
  GL_BEVEL_NV = $90A6;
  GL_MITER_REVERT_NV = $90A7;
  GL_MITER_TRUNCATE_NV = $90A8;
  GL_SKIP_MISSING_GLYPH_NV = $90A9;
  GL_USE_MISSING_GLYPH_NV = $90AA;
  GL_PATH_ERROR_POSITION_NV = $90AB;
  GL_PATH_FOG_GEN_MODE_NV = $90AC;
  GL_ACCUM_ADJACENT_PAIRS_NV = $90AD;
  GL_ADJACENT_PAIRS_NV = $90AE;
  GL_FIRST_TO_REST_NV = $90AF;
  GL_PATH_GEN_MODE_NV = $90B0;
  GL_PATH_GEN_COEFF_NV = $90B1;
  GL_PATH_GEN_COLOR_FORMAT_NV = $90B2;
  GL_PATH_GEN_COMPONENTS_NV = $90B3;
  GL_PATH_DASH_OFFSET_RESET_NV = $90B4;
  GL_MOVE_TO_RESETS_NV = $90B5;
  GL_MOVE_TO_CONTINUES_NV = $90B6;
  GL_PATH_STENCIL_FUNC_NV = $90B7;
  GL_PATH_STENCIL_REF_NV = $90B8;
  GL_PATH_STENCIL_VALUE_MASK_NV = $90B9;
  GL_SCALED_RESOLVE_FASTEST_EXT = $90BA;
  GL_SCALED_RESOLVE_NICEST_EXT = $90BB;
  GL_MIN_MAP_BUFFER_ALIGNMENT = $90BC;
  GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV = $90BD;
  GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV = $90BE;
  GL_PATH_COVER_DEPTH_FUNC_NV = $90BF;
  GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = $90C7;
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = $90C8;
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = $90C9;
  GL_MAX_VERTEX_IMAGE_UNIFORMS = $90CA;
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = $90CB;
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT = $90CB;
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES = $90CB;
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = $90CC;
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT = $90CC;
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES = $90CC;
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS = $90CD;
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT = $90CD;
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS_OES = $90CD;
  GL_MAX_FRAGMENT_IMAGE_UNIFORMS = $90CE;
  GL_MAX_COMBINED_IMAGE_UNIFORMS = $90CF;
  GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV = $90D0;
  GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV = $90D1;
  GL_SHADER_STORAGE_BUFFER = $90D2;
  GL_SHADER_STORAGE_BUFFER_BINDING = $90D3;
  GL_SHADER_STORAGE_BUFFER_START = $90D4;
  GL_SHADER_STORAGE_BUFFER_SIZE = $90D5;
  GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = $90D6;
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = $90D7;
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT = $90D7;
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES = $90D7;
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = $90D8;
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT = $90D8;
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES = $90D8;
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = $90D9;
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT = $90D9;
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES = $90D9;
  GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = $90DA;
  GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = $90DB;
  GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = $90DC;
  GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = $90DD;
  GL_MAX_SHADER_STORAGE_BLOCK_SIZE = $90DE;
  GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = $90DF;
  GL_SYNC_X11_FENCE_EXT = $90E1;
  GL_DEPTH_STENCIL_TEXTURE_MODE = $90EA;
  GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS = $90EB;
  GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB = $90EB;
  GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = $90EC;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = $90ED;
  GL_DISPATCH_INDIRECT_BUFFER = $90EE;
  GL_DISPATCH_INDIRECT_BUFFER_BINDING = $90EF;
  GL_COLOR_ATTACHMENT_EXT = $90F0;
  GL_MULTIVIEW_EXT = $90F1;
  GL_MAX_MULTIVIEW_BUFFERS_EXT = $90F2;
  GL_CONTEXT_ROBUST_ACCESS = $90F3;
  GL_CONTEXT_ROBUST_ACCESS_EXT = $90F3;
  GL_CONTEXT_ROBUST_ACCESS_KHR = $90F3;
  GL_COMPUTE_PROGRAM_NV = $90FB;
  GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV = $90FC;
  GL_TEXTURE_2D_MULTISAMPLE = $9100;
  GL_PROXY_TEXTURE_2D_MULTISAMPLE = $9101;
  GL_TEXTURE_2D_MULTISAMPLE_ARRAY = $9102;
  GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES = $9102;
  GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = $9103;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE = $9104;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = $9105;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES = $9105;
  GL_TEXTURE_SAMPLES = $9106;
  GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = $9107;
  GL_SAMPLER_2D_MULTISAMPLE = $9108;
  GL_INT_SAMPLER_2D_MULTISAMPLE = $9109;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = $910A;
  GL_SAMPLER_2D_MULTISAMPLE_ARRAY = $910B;
  GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = $910B;
  GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = $910C;
  GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = $910C;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = $910D;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = $910D;
  GL_MAX_COLOR_TEXTURE_SAMPLES = $910E;
  GL_MAX_DEPTH_TEXTURE_SAMPLES = $910F;
  GL_MAX_INTEGER_SAMPLES = $9110;
  GL_MAX_SERVER_WAIT_TIMEOUT = $9111;
  GL_MAX_SERVER_WAIT_TIMEOUT_APPLE = $9111;
  GL_OBJECT_TYPE = $9112;
  GL_OBJECT_TYPE_APPLE = $9112;
  GL_SYNC_CONDITION = $9113;
  GL_SYNC_CONDITION_APPLE = $9113;
  GL_SYNC_STATUS = $9114;
  GL_SYNC_STATUS_APPLE = $9114;
  GL_SYNC_FLAGS = $9115;
  GL_SYNC_FLAGS_APPLE = $9115;
  GL_SYNC_FENCE = $9116;
  GL_SYNC_FENCE_APPLE = $9116;
  GL_SYNC_GPU_COMMANDS_COMPLETE = $9117;
  GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE = $9117;
  GL_UNSIGNALED = $9118;
  GL_UNSIGNALED_APPLE = $9118;
  GL_SIGNALED = $9119;
  GL_SIGNALED_APPLE = $9119;
  GL_ALREADY_SIGNALED = $911A;
  GL_ALREADY_SIGNALED_APPLE = $911A;
  GL_TIMEOUT_EXPIRED = $911B;
  GL_TIMEOUT_EXPIRED_APPLE = $911B;
  GL_CONDITION_SATISFIED = $911C;
  GL_CONDITION_SATISFIED_APPLE = $911C;
  GL_WAIT_FAILED = $911D;
  GL_WAIT_FAILED_APPLE = $911D;
  GL_BUFFER_ACCESS_FLAGS = $911F;
  GL_BUFFER_MAP_LENGTH = $9120;
  GL_BUFFER_MAP_OFFSET = $9121;
  GL_MAX_VERTEX_OUTPUT_COMPONENTS = $9122;
  GL_MAX_GEOMETRY_INPUT_COMPONENTS = $9123;
  GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT = $9123;
  GL_MAX_GEOMETRY_INPUT_COMPONENTS_OES = $9123;
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS = $9124;
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT = $9124;
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_OES = $9124;
  GL_MAX_FRAGMENT_INPUT_COMPONENTS = $9125;
  GL_CONTEXT_PROFILE_MASK = $9126;
  GL_UNPACK_COMPRESSED_BLOCK_WIDTH = $9127;
  GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = $9128;
  GL_UNPACK_COMPRESSED_BLOCK_DEPTH = $9129;
  GL_UNPACK_COMPRESSED_BLOCK_SIZE = $912A;
  GL_PACK_COMPRESSED_BLOCK_WIDTH = $912B;
  GL_PACK_COMPRESSED_BLOCK_HEIGHT = $912C;
  GL_PACK_COMPRESSED_BLOCK_DEPTH = $912D;
  GL_PACK_COMPRESSED_BLOCK_SIZE = $912E;
  GL_TEXTURE_IMMUTABLE_FORMAT = $912F;
  GL_TEXTURE_IMMUTABLE_FORMAT_EXT = $912F;
  GL_SGX_PROGRAM_BINARY_IMG = $9130;
  GL_RENDERBUFFER_SAMPLES_IMG = $9133;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG = $9134;
  GL_MAX_SAMPLES_IMG = $9135;
  GL_TEXTURE_SAMPLES_IMG = $9136;
  GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG = $9137;
  GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG = $9138;
  GL_CUBIC_IMG = $9139;
  GL_CUBIC_MIPMAP_NEAREST_IMG = $913A;
  GL_CUBIC_MIPMAP_LINEAR_IMG = $913B;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_AND_DOWNSAMPLE_IMG = $913C;
  GL_NUM_DOWNSAMPLE_SCALES_IMG = $913D;
  GL_DOWNSAMPLE_SCALES_IMG = $913E;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG = $913F;
  GL_MAX_DEBUG_MESSAGE_LENGTH = $9143;
  GL_MAX_DEBUG_MESSAGE_LENGTH_AMD = $9143;
  GL_MAX_DEBUG_MESSAGE_LENGTH_ARB = $9143;
  GL_MAX_DEBUG_MESSAGE_LENGTH_KHR = $9143;
  GL_MAX_DEBUG_LOGGED_MESSAGES = $9144;
  GL_MAX_DEBUG_LOGGED_MESSAGES_AMD = $9144;
  GL_MAX_DEBUG_LOGGED_MESSAGES_ARB = $9144;
  GL_MAX_DEBUG_LOGGED_MESSAGES_KHR = $9144;
  GL_DEBUG_LOGGED_MESSAGES = $9145;
  GL_DEBUG_LOGGED_MESSAGES_AMD = $9145;
  GL_DEBUG_LOGGED_MESSAGES_ARB = $9145;
  GL_DEBUG_LOGGED_MESSAGES_KHR = $9145;
  GL_DEBUG_SEVERITY_HIGH = $9146;
  GL_DEBUG_SEVERITY_HIGH_AMD = $9146;
  GL_DEBUG_SEVERITY_HIGH_ARB = $9146;
  GL_DEBUG_SEVERITY_HIGH_KHR = $9146;
  GL_DEBUG_SEVERITY_MEDIUM = $9147;
  GL_DEBUG_SEVERITY_MEDIUM_AMD = $9147;
  GL_DEBUG_SEVERITY_MEDIUM_ARB = $9147;
  GL_DEBUG_SEVERITY_MEDIUM_KHR = $9147;
  GL_DEBUG_SEVERITY_LOW = $9148;
  GL_DEBUG_SEVERITY_LOW_AMD = $9148;
  GL_DEBUG_SEVERITY_LOW_ARB = $9148;
  GL_DEBUG_SEVERITY_LOW_KHR = $9148;
  GL_DEBUG_CATEGORY_API_ERROR_AMD = $9149;
  GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD = $914A;
  GL_DEBUG_CATEGORY_DEPRECATION_AMD = $914B;
  GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD = $914C;
  GL_DEBUG_CATEGORY_PERFORMANCE_AMD = $914D;
  GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD = $914E;
  GL_DEBUG_CATEGORY_APPLICATION_AMD = $914F;
  GL_DEBUG_CATEGORY_OTHER_AMD = $9150;
  GL_BUFFER_OBJECT_EXT = $9151;
  GL_DATA_BUFFER_AMD = $9151;
  GL_PERFORMANCE_MONITOR_AMD = $9152;
  GL_QUERY_OBJECT_AMD = $9153;
  GL_QUERY_OBJECT_EXT = $9153;
  GL_VERTEX_ARRAY_OBJECT_AMD = $9154;
  GL_VERTEX_ARRAY_OBJECT_EXT = $9154;
  GL_SAMPLER_OBJECT_AMD = $9155;
  GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD = $9160;
  GL_QUERY_BUFFER = $9192;
  GL_QUERY_BUFFER_AMD = $9192;
  GL_QUERY_BUFFER_BINDING = $9193;
  GL_QUERY_BUFFER_BINDING_AMD = $9193;
  GL_QUERY_RESULT_NO_WAIT = $9194;
  GL_QUERY_RESULT_NO_WAIT_AMD = $9194;
  GL_VIRTUAL_PAGE_SIZE_X_ARB = $9195;
  GL_VIRTUAL_PAGE_SIZE_X_EXT = $9195;
  GL_VIRTUAL_PAGE_SIZE_X_AMD = $9195;
  GL_VIRTUAL_PAGE_SIZE_Y_ARB = $9196;
  GL_VIRTUAL_PAGE_SIZE_Y_EXT = $9196;
  GL_VIRTUAL_PAGE_SIZE_Y_AMD = $9196;
  GL_VIRTUAL_PAGE_SIZE_Z_ARB = $9197;
  GL_VIRTUAL_PAGE_SIZE_Z_EXT = $9197;
  GL_VIRTUAL_PAGE_SIZE_Z_AMD = $9197;
  GL_MAX_SPARSE_TEXTURE_SIZE_ARB = $9198;
  GL_MAX_SPARSE_TEXTURE_SIZE_EXT = $9198;
  GL_MAX_SPARSE_TEXTURE_SIZE_AMD = $9198;
  GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB = $9199;
  GL_MAX_SPARSE_3D_TEXTURE_SIZE_EXT = $9199;
  GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD = $9199;
  GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS = $919A;
  GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB = $919A;
  GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT = $919A;
  GL_MIN_SPARSE_LEVEL_AMD = $919B;
  GL_MIN_LOD_WARNING_AMD = $919C;
  GL_TEXTURE_BUFFER_OFFSET = $919D;
  GL_TEXTURE_BUFFER_OFFSET_EXT = $919D;
  GL_TEXTURE_BUFFER_OFFSET_OES = $919D;
  GL_TEXTURE_BUFFER_SIZE = $919E;
  GL_TEXTURE_BUFFER_SIZE_EXT = $919E;
  GL_TEXTURE_BUFFER_SIZE_OES = $919E;
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = $919F;
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT = $919F;
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES = $919F;
  GL_STREAM_RASTERIZATION_AMD = $91A0;
  GL_VERTEX_ELEMENT_SWIZZLE_AMD = $91A4;
  GL_VERTEX_ID_SWIZZLE_AMD = $91A5;
  GL_TEXTURE_SPARSE_ARB = $91A6;
  GL_TEXTURE_SPARSE_EXT = $91A6;
  GL_VIRTUAL_PAGE_SIZE_INDEX_ARB = $91A7;
  GL_VIRTUAL_PAGE_SIZE_INDEX_EXT = $91A7;
  GL_NUM_VIRTUAL_PAGE_SIZES_ARB = $91A8;
  GL_NUM_VIRTUAL_PAGE_SIZES_EXT = $91A8;
  GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB = $91A9;
  GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT = $91A9;
  GL_NUM_SPARSE_LEVELS_ARB = $91AA;
  GL_NUM_SPARSE_LEVELS_EXT = $91AA;
  GL_PIXELS_PER_SAMPLE_PATTERN_X_AMD = $91AE;
  GL_PIXELS_PER_SAMPLE_PATTERN_Y_AMD = $91AF;
  GL_MAX_SHADER_COMPILER_THREADS_KHR = $91B0;
  GL_MAX_SHADER_COMPILER_THREADS_ARB = $91B0;
  GL_COMPLETION_STATUS_KHR = $91B1;
  GL_COMPLETION_STATUS_ARB = $91B1;
  GL_RENDERBUFFER_STORAGE_SAMPLES_AMD = $91B2;
  GL_MAX_COLOR_FRAMEBUFFER_SAMPLES_AMD = $91B3;
  GL_MAX_COLOR_FRAMEBUFFER_STORAGE_SAMPLES_AMD = $91B4;
  GL_MAX_DEPTH_STENCIL_FRAMEBUFFER_SAMPLES_AMD = $91B5;
  GL_NUM_SUPPORTED_MULTISAMPLE_MODES_AMD = $91B6;
  GL_SUPPORTED_MULTISAMPLE_MODES_AMD = $91B7;
  GL_COMPUTE_SHADER = $91B9;
  GL_MAX_COMPUTE_UNIFORM_BLOCKS = $91BB;
  GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = $91BC;
  GL_MAX_COMPUTE_IMAGE_UNIFORMS = $91BD;
  GL_MAX_COMPUTE_WORK_GROUP_COUNT = $91BE;
  GL_MAX_COMPUTE_WORK_GROUP_SIZE = $91BF;
  GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB = $91BF;
  GL_FLOAT16_MAT2_AMD = $91C5;
  GL_FLOAT16_MAT3_AMD = $91C6;
  GL_FLOAT16_MAT4_AMD = $91C7;
  GL_FLOAT16_MAT2x3_AMD = $91C8;
  GL_FLOAT16_MAT2x4_AMD = $91C9;
  GL_FLOAT16_MAT3x2_AMD = $91CA;
  GL_FLOAT16_MAT3x4_AMD = $91CB;
  GL_FLOAT16_MAT4x2_AMD = $91CC;
  GL_FLOAT16_MAT4x3_AMD = $91CD;
  GL_UNPACK_FLIP_Y_WEBGL = $9240;
  GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = $9241;
  GL_CONTEXT_LOST_WEBGL = $9242;
  GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = $9243;
  GL_BROWSER_DEFAULT_WEBGL = $9244;
  GL_UNMASKED_VENDOR_WEBGL = $9245;
  GL_UNMASKED_RENDERER_WEBGL = $9246;
  GL_MAX_CLIENT_WAIT_TIMEOUT_WEBGL = $9247;
  GL_TEXTURE_VIDEO_IMAGE_WEBGL = $9248;
  GL_SAMPLER_VIDEO_IMAGE_WEBGL = $9249;
  GL_SHADER_BINARY_DMP = $9250;
  GL_SMAPHS30_PROGRAM_BINARY_DMP = $9251;
  GL_SMAPHS_PROGRAM_BINARY_DMP = $9252;
  GL_DMP_PROGRAM_BINARY_DMP = $9253;
  GL_GCCSO_SHADER_BINARY_FJ = $9260;
  GL_COMPRESSED_R11_EAC = $9270;
  GL_COMPRESSED_R11_EAC_OES = $9270;
  GL_COMPRESSED_SIGNED_R11_EAC = $9271;
  GL_COMPRESSED_SIGNED_R11_EAC_OES = $9271;
  GL_COMPRESSED_RG11_EAC = $9272;
  GL_COMPRESSED_RG11_EAC_OES = $9272;
  GL_COMPRESSED_SIGNED_RG11_EAC = $9273;
  GL_COMPRESSED_SIGNED_RG11_EAC_OES = $9273;
  GL_COMPRESSED_RGB8_ETC2 = $9274;
  GL_COMPRESSED_RGB8_ETC2_OES = $9274;
  GL_COMPRESSED_SRGB8_ETC2 = $9275;
  GL_COMPRESSED_SRGB8_ETC2_OES = $9275;
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9276;
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = $9276;
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9277;
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = $9277;
  GL_COMPRESSED_RGBA8_ETC2_EAC = $9278;
  GL_COMPRESSED_RGBA8_ETC2_EAC_OES = $9278;
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = $9279;
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC_OES = $9279;
  GL_BLEND_PREMULTIPLIED_SRC_NV = $9280;
  GL_BLEND_OVERLAP_NV = $9281;
  GL_UNCORRELATED_NV = $9282;
  GL_DISJOINT_NV = $9283;
  GL_CONJOINT_NV = $9284;
  GL_BLEND_ADVANCED_COHERENT_KHR = $9285;
  GL_BLEND_ADVANCED_COHERENT_NV = $9285;
  GL_SRC_NV = $9286;
  GL_DST_NV = $9287;
  GL_SRC_OVER_NV = $9288;
  GL_DST_OVER_NV = $9289;
  GL_SRC_IN_NV = $928A;
  GL_DST_IN_NV = $928B;
  GL_SRC_OUT_NV = $928C;
  GL_DST_OUT_NV = $928D;
  GL_SRC_ATOP_NV = $928E;
  GL_DST_ATOP_NV = $928F;
  GL_PLUS_NV = $9291;
  GL_PLUS_DARKER_NV = $9292;
  GL_MULTIPLY = $9294;
  GL_MULTIPLY_KHR = $9294;
  GL_MULTIPLY_NV = $9294;
  GL_SCREEN = $9295;
  GL_SCREEN_KHR = $9295;
  GL_SCREEN_NV = $9295;
  GL_OVERLAY = $9296;
  GL_OVERLAY_KHR = $9296;
  GL_OVERLAY_NV = $9296;
  GL_DARKEN = $9297;
  GL_DARKEN_KHR = $9297;
  GL_DARKEN_NV = $9297;
  GL_LIGHTEN = $9298;
  GL_LIGHTEN_KHR = $9298;
  GL_LIGHTEN_NV = $9298;
  GL_COLORDODGE = $9299;
  GL_COLORDODGE_KHR = $9299;
  GL_COLORDODGE_NV = $9299;
  GL_COLORBURN = $929A;
  GL_COLORBURN_KHR = $929A;
  GL_COLORBURN_NV = $929A;
  GL_HARDLIGHT = $929B;
  GL_HARDLIGHT_KHR = $929B;
  GL_HARDLIGHT_NV = $929B;
  GL_SOFTLIGHT = $929C;
  GL_SOFTLIGHT_KHR = $929C;
  GL_SOFTLIGHT_NV = $929C;
  GL_DIFFERENCE = $929E;
  GL_DIFFERENCE_KHR = $929E;
  GL_DIFFERENCE_NV = $929E;
  GL_MINUS_NV = $929F;
  GL_EXCLUSION = $92A0;
  GL_EXCLUSION_KHR = $92A0;
  GL_EXCLUSION_NV = $92A0;
  GL_CONTRAST_NV = $92A1;
  GL_INVERT_RGB_NV = $92A3;
  GL_LINEARDODGE_NV = $92A4;
  GL_LINEARBURN_NV = $92A5;
  GL_VIVIDLIGHT_NV = $92A6;
  GL_LINEARLIGHT_NV = $92A7;
  GL_PINLIGHT_NV = $92A8;
  GL_HARDMIX_NV = $92A9;
  GL_HSL_HUE = $92AD;
  GL_HSL_HUE_KHR = $92AD;
  GL_HSL_HUE_NV = $92AD;
  GL_HSL_SATURATION = $92AE;
  GL_HSL_SATURATION_KHR = $92AE;
  GL_HSL_SATURATION_NV = $92AE;
  GL_HSL_COLOR = $92AF;
  GL_HSL_COLOR_KHR = $92AF;
  GL_HSL_COLOR_NV = $92AF;
  GL_HSL_LUMINOSITY = $92B0;
  GL_HSL_LUMINOSITY_KHR = $92B0;
  GL_HSL_LUMINOSITY_NV = $92B0;
  GL_PLUS_CLAMPED_NV = $92B1;
  GL_PLUS_CLAMPED_ALPHA_NV = $92B2;
  GL_MINUS_CLAMPED_NV = $92B3;
  GL_INVERT_OVG_NV = $92B4;
  GL_MAX_LGPU_GPUS_NVX = $92BA;
  GL_MULTICAST_GPUS_NV = $92BA;
  GL_PURGED_CONTEXT_RESET_NV = $92BB;
  GL_PRIMITIVE_BOUNDING_BOX_ARB = $92BE;
  GL_PRIMITIVE_BOUNDING_BOX = $92BE;
  GL_PRIMITIVE_BOUNDING_BOX_EXT = $92BE;
  GL_PRIMITIVE_BOUNDING_BOX_OES = $92BE;
  GL_ALPHA_TO_COVERAGE_DITHER_MODE_NV = $92BF;
  GL_ATOMIC_COUNTER_BUFFER = $92C0;
  GL_ATOMIC_COUNTER_BUFFER_BINDING = $92C1;
  GL_ATOMIC_COUNTER_BUFFER_START = $92C2;
  GL_ATOMIC_COUNTER_BUFFER_SIZE = $92C3;
  GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = $92C4;
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = $92C5;
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = $92C6;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = $92C7;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = $92C8;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = $92C9;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = $92CA;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = $92CB;
  GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = $92CC;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = $92CD;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT = $92CD;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES = $92CD;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = $92CE;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT = $92CE;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES = $92CE;
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = $92CF;
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT = $92CF;
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES = $92CF;
  GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = $92D0;
  GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = $92D1;
  GL_MAX_VERTEX_ATOMIC_COUNTERS = $92D2;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = $92D3;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT = $92D3;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES = $92D3;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = $92D4;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT = $92D4;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES = $92D4;
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS = $92D5;
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT = $92D5;
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS_OES = $92D5;
  GL_MAX_FRAGMENT_ATOMIC_COUNTERS = $92D6;
  GL_MAX_COMBINED_ATOMIC_COUNTERS = $92D7;
  GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = $92D8;
  GL_ACTIVE_ATOMIC_COUNTER_BUFFERS = $92D9;
  GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = $92DA;
  GL_UNSIGNED_INT_ATOMIC_COUNTER = $92DB;
  GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = $92DC;
  GL_FRAGMENT_COVERAGE_TO_COLOR_NV = $92DD;
  GL_FRAGMENT_COVERAGE_COLOR_NV = $92DE;
  GL_MESH_OUTPUT_PER_VERTEX_GRANULARITY_NV = $92DF;
  GL_DEBUG_OUTPUT = $92E0;
  GL_DEBUG_OUTPUT_KHR = $92E0;
  GL_UNIFORM = $92E1;
  GL_UNIFORM_BLOCK = $92E2;
  GL_PROGRAM_INPUT = $92E3;
  GL_PROGRAM_OUTPUT = $92E4;
  GL_BUFFER_VARIABLE = $92E5;
  GL_SHADER_STORAGE_BLOCK = $92E6;
  GL_IS_PER_PATCH = $92E7;
  GL_IS_PER_PATCH_EXT = $92E7;
  GL_IS_PER_PATCH_OES = $92E7;
  GL_VERTEX_SUBROUTINE = $92E8;
  GL_TESS_CONTROL_SUBROUTINE = $92E9;
  GL_TESS_EVALUATION_SUBROUTINE = $92EA;
  GL_GEOMETRY_SUBROUTINE = $92EB;
  GL_FRAGMENT_SUBROUTINE = $92EC;
  GL_COMPUTE_SUBROUTINE = $92ED;
  GL_VERTEX_SUBROUTINE_UNIFORM = $92EE;
  GL_TESS_CONTROL_SUBROUTINE_UNIFORM = $92EF;
  GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = $92F0;
  GL_GEOMETRY_SUBROUTINE_UNIFORM = $92F1;
  GL_FRAGMENT_SUBROUTINE_UNIFORM = $92F2;
  GL_COMPUTE_SUBROUTINE_UNIFORM = $92F3;
  GL_TRANSFORM_FEEDBACK_VARYING = $92F4;
  GL_ACTIVE_RESOURCES = $92F5;
  GL_MAX_NAME_LENGTH = $92F6;
  GL_MAX_NUM_ACTIVE_VARIABLES = $92F7;
  GL_MAX_NUM_COMPATIBLE_SUBROUTINES = $92F8;
  GL_NAME_LENGTH = $92F9;
  GL_TYPE = $92FA;
  GL_ARRAY_SIZE = $92FB;
  GL_OFFSET = $92FC;
  GL_BLOCK_INDEX = $92FD;
  GL_ARRAY_STRIDE = $92FE;
  GL_MATRIX_STRIDE = $92FF;
  GL_IS_ROW_MAJOR = $9300;
  GL_ATOMIC_COUNTER_BUFFER_INDEX = $9301;
  GL_BUFFER_BINDING = $9302;
  GL_BUFFER_DATA_SIZE = $9303;
  GL_NUM_ACTIVE_VARIABLES = $9304;
  GL_ACTIVE_VARIABLES = $9305;
  GL_REFERENCED_BY_VERTEX_SHADER = $9306;
  GL_REFERENCED_BY_TESS_CONTROL_SHADER = $9307;
  GL_REFERENCED_BY_TESS_CONTROL_SHADER_EXT = $9307;
  GL_REFERENCED_BY_TESS_CONTROL_SHADER_OES = $9307;
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER = $9308;
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER_EXT = $9308;
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER_OES = $9308;
  GL_REFERENCED_BY_GEOMETRY_SHADER = $9309;
  GL_REFERENCED_BY_GEOMETRY_SHADER_EXT = $9309;
  GL_REFERENCED_BY_GEOMETRY_SHADER_OES = $9309;
  GL_REFERENCED_BY_FRAGMENT_SHADER = $930A;
  GL_REFERENCED_BY_COMPUTE_SHADER = $930B;
  GL_TOP_LEVEL_ARRAY_SIZE = $930C;
  GL_TOP_LEVEL_ARRAY_STRIDE = $930D;
  GL_LOCATION = $930E;
  GL_LOCATION_INDEX = $930F;
  GL_LOCATION_INDEX_EXT = $930F;
  GL_FRAMEBUFFER_DEFAULT_WIDTH = $9310;
  GL_FRAMEBUFFER_DEFAULT_HEIGHT = $9311;
  GL_FRAMEBUFFER_DEFAULT_LAYERS = $9312;
  GL_FRAMEBUFFER_DEFAULT_LAYERS_EXT = $9312;
  GL_FRAMEBUFFER_DEFAULT_LAYERS_OES = $9312;
  GL_FRAMEBUFFER_DEFAULT_SAMPLES = $9313;
  GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = $9314;
  GL_MAX_FRAMEBUFFER_WIDTH = $9315;
  GL_MAX_FRAMEBUFFER_HEIGHT = $9316;
  GL_MAX_FRAMEBUFFER_LAYERS = $9317;
  GL_MAX_FRAMEBUFFER_LAYERS_EXT = $9317;
  GL_MAX_FRAMEBUFFER_LAYERS_OES = $9317;
  GL_MAX_FRAMEBUFFER_SAMPLES = $9318;
  GL_RASTER_MULTISAMPLE_EXT = $9327;
  GL_RASTER_SAMPLES_EXT = $9328;
  GL_MAX_RASTER_SAMPLES_EXT = $9329;
  GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT = $932A;
  GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT = $932B;
  GL_EFFECTIVE_RASTER_SAMPLES_EXT = $932C;
  GL_DEPTH_SAMPLES_NV = $932D;
  GL_STENCIL_SAMPLES_NV = $932E;
  GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV = $932F;
  GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV = $9330;
  GL_COVERAGE_MODULATION_TABLE_NV = $9331;
  GL_COVERAGE_MODULATION_NV = $9332;
  GL_COVERAGE_MODULATION_TABLE_SIZE_NV = $9333;
  GL_WARP_SIZE_NV = $9339;
  GL_WARPS_PER_SM_NV = $933A;
  GL_SM_COUNT_NV = $933B;
  GL_FILL_RECTANGLE_NV = $933C;
  GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB = $933D;
  GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV = $933D;
  GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB = $933E;
  GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV = $933E;
  GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB = $933F;
  GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV = $933F;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB = $9340;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV = $9340;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB = $9341;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_NV = $9341;
  GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB = $9342;
  GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV = $9342;
  GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB = $9343;
  GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV = $9343;
  GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB = $9344;
  GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB = $9345;
  GL_CONSERVATIVE_RASTERIZATION_NV = $9346;
  GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV = $9347;
  GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV = $9348;
  GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV = $9349;
  GL_LOCATION_COMPONENT = $934A;
  GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = $934B;
  GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = $934C;
  GL_ALPHA_TO_COVERAGE_DITHER_DEFAULT_NV = $934D;
  GL_ALPHA_TO_COVERAGE_DITHER_ENABLE_NV = $934E;
  GL_ALPHA_TO_COVERAGE_DITHER_DISABLE_NV = $934F;
  GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV = $9350;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV = $9351;
  GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV = $9352;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV = $9353;
  GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV = $9354;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV = $9355;
  GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV = $9356;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV = $9357;
  GL_VIEWPORT_SWIZZLE_X_NV = $9358;
  GL_VIEWPORT_SWIZZLE_Y_NV = $9359;
  GL_VIEWPORT_SWIZZLE_Z_NV = $935A;
  GL_VIEWPORT_SWIZZLE_W_NV = $935B;
  GL_CLIP_ORIGIN = $935C;
  GL_CLIP_ORIGIN_EXT = $935C;
  GL_CLIP_DEPTH_MODE = $935D;
  GL_CLIP_DEPTH_MODE_EXT = $935D;
  GL_NEGATIVE_ONE_TO_ONE = $935E;
  GL_NEGATIVE_ONE_TO_ONE_EXT = $935E;
  GL_ZERO_TO_ONE = $935F;
  GL_ZERO_TO_ONE_EXT = $935F;
  GL_CLEAR_TEXTURE = $9365;
  GL_TEXTURE_REDUCTION_MODE_ARB = $9366;
  GL_TEXTURE_REDUCTION_MODE_EXT = $9366;
  GL_WEIGHTED_AVERAGE_ARB = $9367;
  GL_WEIGHTED_AVERAGE_EXT = $9367;
  GL_FONT_GLYPHS_AVAILABLE_NV = $9368;
  GL_FONT_TARGET_UNAVAILABLE_NV = $9369;
  GL_FONT_UNAVAILABLE_NV = $936A;
  GL_FONT_UNINTELLIGIBLE_NV = $936B;
  GL_STANDARD_FONT_FORMAT_NV = $936C;
  GL_FRAGMENT_INPUT_NV = $936D;
  GL_UNIFORM_BUFFER_UNIFIED_NV = $936E;
  GL_UNIFORM_BUFFER_ADDRESS_NV = $936F;
  GL_UNIFORM_BUFFER_LENGTH_NV = $9370;
  GL_MULTISAMPLES_NV = $9371;
  GL_SUPERSAMPLE_SCALE_X_NV = $9372;
  GL_SUPERSAMPLE_SCALE_Y_NV = $9373;
  GL_CONFORMANT_NV = $9374;
  GL_CONSERVATIVE_RASTER_DILATE_NV = $9379;
  GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV = $937A;
  GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV = $937B;
  GL_VIEWPORT_POSITION_W_SCALE_NV = $937C;
  GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV = $937D;
  GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV = $937E;
  GL_REPRESENTATIVE_FRAGMENT_TEST_NV = $937F;
  GL_NUM_SAMPLE_COUNTS = $9380;
  GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB = $9381;
  GL_MULTISAMPLE_LINE_WIDTH_RANGE = $9381;
  GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB = $9382;
  GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY = $9382;
  GL_VIEW_CLASS_EAC_R11 = $9383;
  GL_VIEW_CLASS_EAC_RG11 = $9384;
  GL_VIEW_CLASS_ETC2_RGB = $9385;
  GL_VIEW_CLASS_ETC2_RGBA = $9386;
  GL_VIEW_CLASS_ETC2_EAC_RGBA = $9387;
  GL_VIEW_CLASS_ASTC_4x4_RGBA = $9388;
  GL_VIEW_CLASS_ASTC_5x4_RGBA = $9389;
  GL_VIEW_CLASS_ASTC_5x5_RGBA = $938A;
  GL_VIEW_CLASS_ASTC_6x5_RGBA = $938B;
  GL_VIEW_CLASS_ASTC_6x6_RGBA = $938C;
  GL_VIEW_CLASS_ASTC_8x5_RGBA = $938D;
  GL_VIEW_CLASS_ASTC_8x6_RGBA = $938E;
  GL_VIEW_CLASS_ASTC_8x8_RGBA = $938F;
  GL_VIEW_CLASS_ASTC_10x5_RGBA = $9390;
  GL_VIEW_CLASS_ASTC_10x6_RGBA = $9391;
  GL_VIEW_CLASS_ASTC_10x8_RGBA = $9392;
  GL_VIEW_CLASS_ASTC_10x10_RGBA = $9393;
  GL_VIEW_CLASS_ASTC_12x10_RGBA = $9394;
  GL_VIEW_CLASS_ASTC_12x12_RGBA = $9395;
  GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE = $93A0;
  GL_BGRA8_EXT = $93A1;
  GL_TEXTURE_USAGE_ANGLE = $93A2;
  GL_FRAMEBUFFER_ATTACHMENT_ANGLE = $93A3;
  GL_PACK_REVERSE_ROW_ORDER_ANGLE = $93A4;
  GL_PROGRAM_BINARY_ANGLE = $93A6;
  GL_COMPRESSED_RGBA_ASTC_4x4 = $93B0;
  GL_COMPRESSED_RGBA_ASTC_4x4_KHR = $93B0;
  GL_COMPRESSED_RGBA_ASTC_5x4 = $93B1;
  GL_COMPRESSED_RGBA_ASTC_5x4_KHR = $93B1;
  GL_COMPRESSED_RGBA_ASTC_5x5 = $93B2;
  GL_COMPRESSED_RGBA_ASTC_5x5_KHR = $93B2;
  GL_COMPRESSED_RGBA_ASTC_6x5 = $93B3;
  GL_COMPRESSED_RGBA_ASTC_6x5_KHR = $93B3;
  GL_COMPRESSED_RGBA_ASTC_6x6 = $93B4;
  GL_COMPRESSED_RGBA_ASTC_6x6_KHR = $93B4;
  GL_COMPRESSED_RGBA_ASTC_8x5 = $93B5;
  GL_COMPRESSED_RGBA_ASTC_8x5_KHR = $93B5;
  GL_COMPRESSED_RGBA_ASTC_8x6 = $93B6;
  GL_COMPRESSED_RGBA_ASTC_8x6_KHR = $93B6;
  GL_COMPRESSED_RGBA_ASTC_8x8 = $93B7;
  GL_COMPRESSED_RGBA_ASTC_8x8_KHR = $93B7;
  GL_COMPRESSED_RGBA_ASTC_10x5 = $93B8;
  GL_COMPRESSED_RGBA_ASTC_10x5_KHR = $93B8;
  GL_COMPRESSED_RGBA_ASTC_10x6 = $93B9;
  GL_COMPRESSED_RGBA_ASTC_10x6_KHR = $93B9;
  GL_COMPRESSED_RGBA_ASTC_10x8 = $93BA;
  GL_COMPRESSED_RGBA_ASTC_10x8_KHR = $93BA;
  GL_COMPRESSED_RGBA_ASTC_10x10 = $93BB;
  GL_COMPRESSED_RGBA_ASTC_10x10_KHR = $93BB;
  GL_COMPRESSED_RGBA_ASTC_12x10 = $93BC;
  GL_COMPRESSED_RGBA_ASTC_12x10_KHR = $93BC;
  GL_COMPRESSED_RGBA_ASTC_12x12 = $93BD;
  GL_COMPRESSED_RGBA_ASTC_12x12_KHR = $93BD;
  GL_COMPRESSED_RGBA_ASTC_3x3x3_OES = $93C0;
  GL_COMPRESSED_RGBA_ASTC_4x3x3_OES = $93C1;
  GL_COMPRESSED_RGBA_ASTC_4x4x3_OES = $93C2;
  GL_COMPRESSED_RGBA_ASTC_4x4x4_OES = $93C3;
  GL_COMPRESSED_RGBA_ASTC_5x4x4_OES = $93C4;
  GL_COMPRESSED_RGBA_ASTC_5x5x4_OES = $93C5;
  GL_COMPRESSED_RGBA_ASTC_5x5x5_OES = $93C6;
  GL_COMPRESSED_RGBA_ASTC_6x5x5_OES = $93C7;
  GL_COMPRESSED_RGBA_ASTC_6x6x5_OES = $93C8;
  GL_COMPRESSED_RGBA_ASTC_6x6x6_OES = $93C9;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4 = $93D0;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = $93D0;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4 = $93D1;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = $93D1;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5 = $93D2;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = $93D2;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5 = $93D3;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = $93D3;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6 = $93D4;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = $93D4;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5 = $93D5;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = $93D5;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6 = $93D6;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = $93D6;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8 = $93D7;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = $93D7;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5 = $93D8;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = $93D8;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6 = $93D9;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = $93D9;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8 = $93DA;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = $93DA;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10 = $93DB;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = $93DB;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10 = $93DC;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = $93DC;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12 = $93DD;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = $93DD;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES = $93E0;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES = $93E1;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES = $93E2;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES = $93E3;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES = $93E4;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES = $93E5;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES = $93E6;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES = $93E7;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES = $93E8;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES = $93E9;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG = $93F0;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG = $93F1;
  GL_PERFQUERY_COUNTER_EVENT_INTEL = $94F0;
  GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL = $94F1;
  GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL = $94F2;
  GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL = $94F3;
  GL_PERFQUERY_COUNTER_RAW_INTEL = $94F4;
  GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL = $94F5;
  GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL = $94F8;
  GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL = $94F9;
  GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL = $94FA;
  GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL = $94FB;
  GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL = $94FC;
  GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL = $94FD;
  GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL = $94FE;
  GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL = $94FF;
  GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL = $9500;
  GL_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT = $9530;
  GL_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT = $9531;
  GL_SUBGROUP_SIZE_KHR = $9532;
  GL_SUBGROUP_SUPPORTED_STAGES_KHR = $9533;
  GL_SUBGROUP_SUPPORTED_FEATURES_KHR = $9534;
  GL_SUBGROUP_QUAD_ALL_STAGES_KHR = $9535;
  GL_MAX_MESH_TOTAL_MEMORY_SIZE_NV = $9536;
  GL_MAX_TASK_TOTAL_MEMORY_SIZE_NV = $9537;
  GL_MAX_MESH_OUTPUT_VERTICES_NV = $9538;
  GL_MAX_MESH_OUTPUT_PRIMITIVES_NV = $9539;
  GL_MAX_TASK_OUTPUT_COUNT_NV = $953A;
  GL_MAX_MESH_WORK_GROUP_SIZE_NV = $953B;
  GL_MAX_TASK_WORK_GROUP_SIZE_NV = $953C;
  GL_MAX_DRAW_MESH_TASKS_COUNT_NV = $953D;
  GL_MESH_WORK_GROUP_SIZE_NV = $953E;
  GL_TASK_WORK_GROUP_SIZE_NV = $953F;
  GL_QUERY_RESOURCE_TYPE_VIDMEM_ALLOC_NV = $9540;
  GL_QUERY_RESOURCE_MEMTYPE_VIDMEM_NV = $9542;
  GL_MESH_OUTPUT_PER_PRIMITIVE_GRANULARITY_NV = $9543;
  GL_QUERY_RESOURCE_SYS_RESERVED_NV = $9544;
  GL_QUERY_RESOURCE_TEXTURE_NV = $9545;
  GL_QUERY_RESOURCE_RENDERBUFFER_NV = $9546;
  GL_QUERY_RESOURCE_BUFFEROBJECT_NV = $9547;
  GL_PER_GPU_STORAGE_NV = $9548;
  GL_MULTICAST_PROGRAMMABLE_SAMPLE_LOCATION_NV = $9549;
  GL_UPLOAD_GPU_MASK_NVX = $954A;
  GL_CONSERVATIVE_RASTER_MODE_NV = $954D;
  GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV = $954E;
  GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV = $954F;
  GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_NV = $9550;
  GL_SHADER_BINARY_FORMAT_SPIR_V = $9551;
  GL_SHADER_BINARY_FORMAT_SPIR_V_ARB = $9551;
  GL_SPIR_V_BINARY = $9552;
  GL_SPIR_V_BINARY_ARB = $9552;
  GL_SPIR_V_EXTENSIONS = $9553;
  GL_NUM_SPIR_V_EXTENSIONS = $9554;
  GL_SCISSOR_TEST_EXCLUSIVE_NV = $9555;
  GL_SCISSOR_BOX_EXCLUSIVE_NV = $9556;
  GL_MAX_MESH_VIEWS_NV = $9557;
  GL_RENDER_GPU_MASK_NV = $9558;
  GL_MESH_SHADER_NV = $9559;
  GL_TASK_SHADER_NV = $955A;
  GL_SHADING_RATE_IMAGE_BINDING_NV = $955B;
  GL_SHADING_RATE_IMAGE_TEXEL_WIDTH_NV = $955C;
  GL_SHADING_RATE_IMAGE_TEXEL_HEIGHT_NV = $955D;
  GL_SHADING_RATE_IMAGE_PALETTE_SIZE_NV = $955E;
  GL_MAX_COARSE_FRAGMENT_SAMPLES_NV = $955F;
  GL_SHADING_RATE_IMAGE_NV = $9563;
  GL_SHADING_RATE_NO_INVOCATIONS_NV = $9564;
  GL_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = $9565;
  GL_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = $9566;
  GL_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = $9567;
  GL_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = $9568;
  GL_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = $9569;
  GL_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = $956A;
  GL_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = $956B;
  GL_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = $956C;
  GL_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = $956D;
  GL_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = $956E;
  GL_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = $956F;
  GL_MESH_VERTICES_OUT_NV = $9579;
  GL_MESH_PRIMITIVES_OUT_NV = $957A;
  GL_MESH_OUTPUT_TYPE_NV = $957B;
  GL_MESH_SUBROUTINE_NV = $957C;
  GL_TASK_SUBROUTINE_NV = $957D;
  GL_MESH_SUBROUTINE_UNIFORM_NV = $957E;
  GL_TASK_SUBROUTINE_UNIFORM_NV = $957F;
  GL_TEXTURE_TILING_EXT = $9580;
  GL_DEDICATED_MEMORY_OBJECT_EXT = $9581;
  GL_NUM_TILING_TYPES_EXT = $9582;
  GL_TILING_TYPES_EXT = $9583;
  GL_OPTIMAL_TILING_EXT = $9584;
  GL_LINEAR_TILING_EXT = $9585;
  GL_HANDLE_TYPE_OPAQUE_FD_EXT = $9586;
  GL_HANDLE_TYPE_OPAQUE_WIN32_EXT = $9587;
  GL_HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT = $9588;
  GL_HANDLE_TYPE_D3D12_TILEPOOL_EXT = $9589;
  GL_HANDLE_TYPE_D3D12_RESOURCE_EXT = $958A;
  GL_HANDLE_TYPE_D3D11_IMAGE_EXT = $958B;
  GL_HANDLE_TYPE_D3D11_IMAGE_KMT_EXT = $958C;
  GL_LAYOUT_GENERAL_EXT = $958D;
  GL_LAYOUT_COLOR_ATTACHMENT_EXT = $958E;
  GL_LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT = $958F;
  GL_LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT = $9590;
  GL_LAYOUT_SHADER_READ_ONLY_EXT = $9591;
  GL_LAYOUT_TRANSFER_SRC_EXT = $9592;
  GL_LAYOUT_TRANSFER_DST_EXT = $9593;
  GL_HANDLE_TYPE_D3D12_FENCE_EXT = $9594;
  GL_D3D12_FENCE_VALUE_EXT = $9595;
  GL_TIMELINE_SEMAPHORE_VALUE_NV = $9595;
  GL_NUM_DEVICE_UUIDS_EXT = $9596;
  GL_DEVICE_UUID_EXT = $9597;
  GL_DRIVER_UUID_EXT = $9598;
  GL_DEVICE_LUID_EXT = $9599;
  GL_DEVICE_NODE_MASK_EXT = $959A;
  GL_PROTECTED_MEMORY_OBJECT_EXT = $959B;
  GL_UNIFORM_BLOCK_REFERENCED_BY_MESH_SHADER_NV = $959C;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TASK_SHADER_NV = $959D;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_MESH_SHADER_NV = $959E;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TASK_SHADER_NV = $959F;
  GL_REFERENCED_BY_MESH_SHADER_NV = $95A0;
  GL_REFERENCED_BY_TASK_SHADER_NV = $95A1;
  GL_MAX_MESH_WORK_GROUP_INVOCATIONS_NV = $95A2;
  GL_MAX_TASK_WORK_GROUP_INVOCATIONS_NV = $95A3;
  GL_ATTACHED_MEMORY_OBJECT_NV = $95A4;
  GL_ATTACHED_MEMORY_OFFSET_NV = $95A5;
  GL_MEMORY_ATTACHABLE_ALIGNMENT_NV = $95A6;
  GL_MEMORY_ATTACHABLE_SIZE_NV = $95A7;
  GL_MEMORY_ATTACHABLE_NV = $95A8;
  GL_DETACHED_MEMORY_INCARNATION_NV = $95A9;
  GL_DETACHED_TEXTURES_NV = $95AA;
  GL_DETACHED_BUFFERS_NV = $95AB;
  GL_MAX_DETACHED_TEXTURES_NV = $95AC;
  GL_MAX_DETACHED_BUFFERS_NV = $95AD;
  GL_SHADING_RATE_SAMPLE_ORDER_DEFAULT_NV = $95AE;
  GL_SHADING_RATE_SAMPLE_ORDER_PIXEL_MAJOR_NV = $95AF;
  GL_SHADING_RATE_SAMPLE_ORDER_SAMPLE_MAJOR_NV = $95B0;
  GL_SHADING_RATE_IMAGE_PER_PRIMITIVE_NV = $95B1;
  GL_SHADING_RATE_IMAGE_PALETTE_COUNT_NV = $95B2;
  GL_SEMAPHORE_TYPE_NV = $95B3;
  GL_SEMAPHORE_TYPE_BINARY_NV = $95B4;
  GL_SEMAPHORE_TYPE_TIMELINE_NV = $95B5;
  GL_MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE_NV = $95B6;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR = $9630;
  GL_MAX_VIEWS_OVR = $9631;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR = $9632;
  GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR = $9633;
  GL_GS_SHADER_BINARY_MTK = $9640;
  GL_GS_PROGRAM_BINARY_MTK = $9641;
  GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_FAST_SIZE_EXT = $9650;
  GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_SIZE_EXT = $9651;
  GL_FRAMEBUFFER_INCOMPLETE_INSUFFICIENT_SHADER_COMBINED_LOCAL_STORAGE_EXT = $9652;
  GL_TEXTURE_FOVEATED_CUTOFF_DENSITY_QCOM = $96A0;
  GL_FRAMEBUFFER_FETCH_NONCOHERENT_QCOM = $96A2;
  GL_VALIDATE_SHADER_BINARY_QCOM = $96A3;
  GL_SHADING_RATE_QCOM = $96A4;
  GL_SHADING_RATE_PRESERVE_ASPECT_RATIO_QCOM = $96A5;
  GL_SHADING_RATE_1X1_PIXELS_QCOM = $96A6;
  GL_SHADING_RATE_1X2_PIXELS_QCOM = $96A7;
  GL_SHADING_RATE_2X1_PIXELS_QCOM = $96A8;
  GL_SHADING_RATE_2X2_PIXELS_QCOM = $96A9;
  GL_SHADING_RATE_1X4_PIXELS_QCOM = $96AA;
  GL_SHADING_RATE_4X1_PIXELS_QCOM = $96AB;
  GL_SHADING_RATE_4X2_PIXELS_QCOM = $96AC;
  GL_SHADING_RATE_2X4_PIXELS_QCOM = $96AD;
  GL_SHADING_RATE_4X4_PIXELS_QCOM = $96AE;
  GL_SHADING_RATE_1X1_PIXELS_EXT = $96A6;
  GL_SHADING_RATE_1X2_PIXELS_EXT = $96A7;
  GL_SHADING_RATE_2X1_PIXELS_EXT = $96A8;
  GL_SHADING_RATE_2X2_PIXELS_EXT = $96A9;
  GL_SHADING_RATE_1X4_PIXELS_EXT = $96AA;
  GL_SHADING_RATE_4X1_PIXELS_EXT = $96AB;
  GL_SHADING_RATE_4X2_PIXELS_EXT = $96AC;
  GL_SHADING_RATE_2X4_PIXELS_EXT = $96AD;
  GL_SHADING_RATE_4X4_PIXELS_EXT = $96AE;
  GL_SURFACE_COMPRESSION_EXT = $96C0;
  GL_SURFACE_COMPRESSION_FIXED_RATE_NONE_EXT = $96C1;
  GL_SURFACE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = $96C2;
  GL_SURFACE_COMPRESSION_FIXED_RATE_1BPC_EXT = $96C4;
  GL_SURFACE_COMPRESSION_FIXED_RATE_2BPC_EXT = $96C5;
  GL_SURFACE_COMPRESSION_FIXED_RATE_3BPC_EXT = $96C6;
  GL_SURFACE_COMPRESSION_FIXED_RATE_4BPC_EXT = $96C7;
  GL_SURFACE_COMPRESSION_FIXED_RATE_5BPC_EXT = $96C8;
  GL_SURFACE_COMPRESSION_FIXED_RATE_6BPC_EXT = $96C9;
  GL_SURFACE_COMPRESSION_FIXED_RATE_7BPC_EXT = $96CA;
  GL_SURFACE_COMPRESSION_FIXED_RATE_8BPC_EXT = $96CB;
  GL_SURFACE_COMPRESSION_FIXED_RATE_9BPC_EXT = $96CC;
  GL_SURFACE_COMPRESSION_FIXED_RATE_10BPC_EXT = $96CD;
  GL_SURFACE_COMPRESSION_FIXED_RATE_11BPC_EXT = $96CE;
  GL_SURFACE_COMPRESSION_FIXED_RATE_12BPC_EXT = $96CF;
  GL_SHADING_RATE_EXT = $96D0;
  GL_SHADING_RATE_ATTACHMENT_EXT = $96D1;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_EXT = $96D2;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_EXT = $96D3;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_EXT = $96D4;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_EXT = $96D5;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_EXT = $96D6;
  GL_MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH_EXT = $96D7;
  GL_MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH_EXT = $96D8;
  GL_MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT_EXT = $96D9;
  GL_MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT_EXT = $96DA;
  GL_MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_ASPECT_RATIO_EXT = $96DB;
  GL_MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_LAYERS_EXT = $96DC;
  GL_FRAGMENT_SHADING_RATE_WITH_SHADER_DEPTH_STENCIL_WRITES_SUPPORTED_EXT = $96DD;
  GL_FRAGMENT_SHADING_RATE_WITH_SAMPLE_MASK_SUPPORTED_EXT = $96DE;
  GL_FRAGMENT_SHADING_RATE_ATTACHMENT_WITH_DEFAULT_FRAMEBUFFER_SUPPORTED_EXT = $96DF;
  GL_SHADER_CORE_COUNT_ARM = $96F0;
  GL_SHADER_CORE_ACTIVE_COUNT_ARM = $96F1;
  GL_SHADER_CORE_PRESENT_MASK_ARM = $96F2;
  GL_SHADER_CORE_MAX_WARP_COUNT_ARM = $96F3;
  GL_SHADER_CORE_PIXEL_RATE_ARM = $96F4;
  GL_SHADER_CORE_TEXEL_RATE_ARM = $96F5;
  GL_SHADER_CORE_FMA_RATE_ARM = $96F6;
  GL_TEXTURE_Y_DEGAMMA_QCOM = $9710;
  GL_TEXTURE_CBCR_DEGAMMA_QCOM = $9711;
  GL_HUAWEI_SHADER_BINARY = $9770;
  GL_HUAWEI_PROGRAM_BINARY = $9771;
  GL_RASTER_POSITION_UNCLIPPED_IBM = $19262;
  GL_CULL_VERTEX_IBM = 103050;
  GL_ALL_STATIC_DATA_IBM = 103060;
  GL_STATIC_VERTEX_ARRAY_IBM = 103061;
  GL_VERTEX_ARRAY_LIST_IBM = 103070;
  GL_NORMAL_ARRAY_LIST_IBM = 103071;
  GL_COLOR_ARRAY_LIST_IBM = 103072;
  GL_INDEX_ARRAY_LIST_IBM = 103073;
  GL_TEXTURE_COORD_ARRAY_LIST_IBM = 103074;
  GL_EDGE_FLAG_ARRAY_LIST_IBM = 103075;
  GL_FOG_COORDINATE_ARRAY_LIST_IBM = 103076;
  GL_SECONDARY_COLOR_ARRAY_LIST_IBM = 103077;
  GL_VERTEX_ARRAY_LIST_STRIDE_IBM = 103080;
  GL_NORMAL_ARRAY_LIST_STRIDE_IBM = 103081;
  GL_COLOR_ARRAY_LIST_STRIDE_IBM = 103082;
  GL_INDEX_ARRAY_LIST_STRIDE_IBM = 103083;
  GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM = 103084;
  GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM = 103085;
  GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM = 103086;
  GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM = 103087;
  GL_PREFER_DOUBLEBUFFER_HINT_PGI = $1A1F8;
  GL_CONSERVE_MEMORY_HINT_PGI = $1A1FD;
  GL_RECLAIM_MEMORY_HINT_PGI = $1A1FE;
  GL_NATIVE_GRAPHICS_HANDLE_PGI = $1A202;
  GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI = $1A203;
  GL_NATIVE_GRAPHICS_END_HINT_PGI = $1A204;
  GL_ALWAYS_FAST_HINT_PGI = $1A20C;
  GL_ALWAYS_SOFT_HINT_PGI = $1A20D;
  GL_ALLOW_DRAW_OBJ_HINT_PGI = $1A20E;
  GL_ALLOW_DRAW_WIN_HINT_PGI = $1A20F;
  GL_ALLOW_DRAW_FRG_HINT_PGI = $1A210;
  GL_ALLOW_DRAW_MEM_HINT_PGI = $1A211;
  GL_STRICT_DEPTHFUNC_HINT_PGI = $1A216;
  GL_STRICT_LIGHTING_HINT_PGI = $1A217;
  GL_STRICT_SCISSOR_HINT_PGI = $1A218;
  GL_FULL_STIPPLE_HINT_PGI = $1A219;
  GL_CLIP_NEAR_HINT_PGI = $1A220;
  GL_CLIP_FAR_HINT_PGI = $1A221;
  GL_WIDE_LINE_HINT_PGI = $1A222;
  GL_BACK_NORMALS_HINT_PGI = $1A223;
  GL_VERTEX_DATA_HINT_PGI = $1A22A;
  GL_VERTEX_CONSISTENT_HINT_PGI = $1A22B;
  GL_MATERIAL_SIDE_HINT_PGI = $1A22C;
  GL_MAX_VERTEX_HINT_PGI = $1A22D;

type
  IGL_VERSION_1_0 = interface(IInterface)
    ['{8E37828A-42E6-4D9D-86E8-2F7F99C0B74A}']
    procedure glCullFace(mode: GLenum); overload;
    procedure glFrontFace(mode: GLenum); overload;
    procedure glHint(target: GLenum; mode: GLenum); overload;
    procedure glLineWidth(Width: GLfloat); overload;
    procedure glPointSize(size: GLfloat); overload;
    procedure glPolygonMode(face: GLenum; mode: GLenum); overload;
    procedure glScissor(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); overload;
    procedure glTexParameterf(target: GLenum; pname: GLenum; param: GLfloat); overload;
    procedure glTexParameterfv(target: GLenum; pname: GLenum; const params: PGLfloat); overload;
    procedure glTexParameteri(target: GLenum; pname: GLenum; param: GLint); overload;
    procedure glTexParameteriv(target: GLenum; pname: GLenum; const params: PGLint); overload;
    procedure glTexImage1D(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glTexImage2D(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glDrawBuffer(buf: GLenum); overload;
    procedure glClear(mask: GLbitfield); overload;
    procedure glClearColor(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); overload;
    procedure glClearStencil(s: GLint); overload;
    procedure glClearDepth(depth: GLdouble); overload;
    procedure glStencilMask(mask: GLuint); overload;
    procedure glColorMask(red: GLboolean; green: GLboolean; blue: GLboolean; alpha: GLboolean); overload;
    procedure glDepthMask(flag: GLboolean); overload;
    procedure glDisable(cap: GLenum); overload;
    procedure glEnable(cap: GLenum); overload;
    procedure glFinish(); overload;
    procedure glFlush(); overload;
    procedure glBlendFunc(sfactor: GLenum; dfactor: GLenum); overload;
    procedure glLogicOp(opcode: GLenum); overload;
    procedure glStencilFunc(func: GLenum; ref: GLint; mask: GLuint); overload;
    procedure glStencilOp(fail: GLenum; zfail: GLenum; zpass: GLenum); overload;
    procedure glDepthFunc(func: GLenum); overload;
    procedure glPixelStoref(pname: GLenum; param: GLfloat); overload;
    procedure glPixelStorei(pname: GLenum; param: GLint); overload;
    procedure glReadBuffer(src: GLenum); overload;
    procedure glReadPixels(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; pixels: Pointer); overload;
    procedure glGetBooleanv(pname: GLenum; Data: PGLboolean); overload;
    procedure glGetDoublev(pname: GLenum; Data: PGLdouble); overload;
    function glGetError(): GLenum; overload;
    procedure glGetFloatv(pname: GLenum; Data: PGLfloat); overload;
    procedure glGetIntegerv(pname: GLenum; Data: PGLint); overload;
    function glGetString(Name: GLenum): PGLubyte; overload;
    procedure glGetTexImage(target: GLenum; level: GLint; format: GLenum; aType: GLenum; pixels: Pointer); overload;
    procedure glGetTexParameterfv(target: GLenum; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTexParameteriv(target: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetTexLevelParameterfv(target: GLenum; level: GLint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTexLevelParameteriv(target: GLenum; level: GLint; pname: GLenum; params: PGLint); overload;
    function glIsEnabled(cap: GLenum): GLboolean; overload;
    procedure glDepthRange(n: GLdouble; f: GLdouble); overload;
    procedure glViewport(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); overload;
    procedure glNewList(list: GLuint; mode: GLenum); overload;
    procedure glEndList(); overload;
    procedure glCallList(list: GLuint); overload;
    procedure glCallLists(n: GLsizei; aType: GLenum; const lists: Pointer); overload;
    procedure glDeleteLists(list: GLuint; range: GLsizei); overload;
    function glGenLists(range: GLsizei): GLuint; overload;
    procedure glListBase(base: GLuint); overload;
    procedure glBegin(mode: GLenum); overload;
    procedure glBitmap(Width: GLsizei; Height: GLsizei; xorig: GLfloat; yorig: GLfloat; xmove: GLfloat; ymove: GLfloat; const bitmap: PGLubyte); overload;
    procedure glColor3b(red: GLbyte; green: GLbyte; blue: GLbyte); overload;
    procedure glColor3bv(const v: PGLbyte); overload;
    procedure glColor3d(red: GLdouble; green: GLdouble; blue: GLdouble); overload;
    procedure glColor3dv(const v: PGLdouble); overload;
    procedure glColor3f(red: GLfloat; green: GLfloat; blue: GLfloat); overload;
    procedure glColor3fv(const v: PGLfloat); overload;
    procedure glColor3i(red: GLint; green: GLint; blue: GLint); overload;
    procedure glColor3iv(const v: PGLint); overload;
    procedure glColor3s(red: GLshort; green: GLshort; blue: GLshort); overload;
    procedure glColor3sv(const v: PGLshort); overload;
    procedure glColor3ub(red: GLubyte; green: GLubyte; blue: GLubyte); overload;
    procedure glColor3ubv(const v: PGLubyte); overload;
    procedure glColor3ui(red: GLuint; green: GLuint; blue: GLuint); overload;
    procedure glColor3uiv(const v: PGLuint); overload;
    procedure glColor3us(red: GLushort; green: GLushort; blue: GLushort); overload;
    procedure glColor3usv(const v: PGLushort); overload;
    procedure glColor4b(red: GLbyte; green: GLbyte; blue: GLbyte; alpha: GLbyte); overload;
    procedure glColor4bv(const v: PGLbyte); overload;
    procedure glColor4d(red: GLdouble; green: GLdouble; blue: GLdouble; alpha: GLdouble); overload;
    procedure glColor4dv(const v: PGLdouble); overload;
    procedure glColor4f(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); overload;
    procedure glColor4fv(const v: PGLfloat); overload;
    procedure glColor4i(red: GLint; green: GLint; blue: GLint; alpha: GLint); overload;
    procedure glColor4iv(const v: PGLint); overload;
    procedure glColor4s(red: GLshort; green: GLshort; blue: GLshort; alpha: GLshort); overload;
    procedure glColor4sv(const v: PGLshort); overload;
    procedure glColor4ub(red: GLubyte; green: GLubyte; blue: GLubyte; alpha: GLubyte); overload;
    procedure glColor4ubv(const v: PGLubyte); overload;
    procedure glColor4ui(red: GLuint; green: GLuint; blue: GLuint; alpha: GLuint); overload;
    procedure glColor4uiv(const v: PGLuint); overload;
    procedure glColor4us(red: GLushort; green: GLushort; blue: GLushort; alpha: GLushort); overload;
    procedure glColor4usv(const v: PGLushort); overload;
    procedure glEdgeFlag(flag: GLboolean); overload;
    procedure glEdgeFlagv(const flag: PGLboolean); overload;
    procedure glEnd(); overload;
    procedure glIndexd(c: GLdouble); overload;
    procedure glIndexdv(const c: PGLdouble); overload;
    procedure glIndexf(c: GLfloat); overload;
    procedure glIndexfv(const c: PGLfloat); overload;
    procedure glIndexi(c: GLint); overload;
    procedure glIndexiv(const c: PGLint); overload;
    procedure glIndexs(c: GLshort); overload;
    procedure glIndexsv(const c: PGLshort); overload;
    procedure glNormal3b(nx: GLbyte; ny: GLbyte; nz: GLbyte); overload;
    procedure glNormal3bv(const v: PGLbyte); overload;
    procedure glNormal3d(nx: GLdouble; ny: GLdouble; nz: GLdouble); overload;
    procedure glNormal3dv(const v: PGLdouble); overload;
    procedure glNormal3f(nx: GLfloat; ny: GLfloat; nz: GLfloat); overload;
    procedure glNormal3fv(const v: PGLfloat); overload;
    procedure glNormal3i(nx: GLint; ny: GLint; nz: GLint); overload;
    procedure glNormal3iv(const v: PGLint); overload;
    procedure glNormal3s(nx: GLshort; ny: GLshort; nz: GLshort); overload;
    procedure glNormal3sv(const v: PGLshort); overload;
    procedure glRasterPos2d(x: GLdouble; y: GLdouble); overload;
    procedure glRasterPos2dv(const v: PGLdouble); overload;
    procedure glRasterPos2f(x: GLfloat; y: GLfloat); overload;
    procedure glRasterPos2fv(const v: PGLfloat); overload;
    procedure glRasterPos2i(x: GLint; y: GLint); overload;
    procedure glRasterPos2iv(const v: PGLint); overload;
    procedure glRasterPos2s(x: GLshort; y: GLshort); overload;
    procedure glRasterPos2sv(const v: PGLshort); overload;
    procedure glRasterPos3d(x: GLdouble; y: GLdouble; z: GLdouble); overload;
    procedure glRasterPos3dv(const v: PGLdouble); overload;
    procedure glRasterPos3f(x: GLfloat; y: GLfloat; z: GLfloat); overload;
    procedure glRasterPos3fv(const v: PGLfloat); overload;
    procedure glRasterPos3i(x: GLint; y: GLint; z: GLint); overload;
    procedure glRasterPos3iv(const v: PGLint); overload;
    procedure glRasterPos3s(x: GLshort; y: GLshort; z: GLshort); overload;
    procedure glRasterPos3sv(const v: PGLshort); overload;
    procedure glRasterPos4d(x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); overload;
    procedure glRasterPos4dv(const v: PGLdouble); overload;
    procedure glRasterPos4f(x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); overload;
    procedure glRasterPos4fv(const v: PGLfloat); overload;
    procedure glRasterPos4i(x: GLint; y: GLint; z: GLint; w: GLint); overload;
    procedure glRasterPos4iv(const v: PGLint); overload;
    procedure glRasterPos4s(x: GLshort; y: GLshort; z: GLshort; w: GLshort); overload;
    procedure glRasterPos4sv(const v: PGLshort); overload;
    procedure glRectd(x1: GLdouble; y1: GLdouble; x2: GLdouble; y2: GLdouble); overload;
    procedure glRectdv(const v1: PGLdouble; const v2: PGLdouble); overload;
    procedure glRectf(x1: GLfloat; y1: GLfloat; x2: GLfloat; y2: GLfloat); overload;
    procedure glRectfv(const v1: PGLfloat; const v2: PGLfloat); overload;
    procedure glRecti(x1: GLint; y1: GLint; x2: GLint; y2: GLint); overload;
    procedure glRectiv(const v1: PGLint; const v2: PGLint); overload;
    procedure glRects(x1: GLshort; y1: GLshort; x2: GLshort; y2: GLshort); overload;
    procedure glRectsv(const v1: PGLshort; const v2: PGLshort); overload;
    procedure glTexCoord1d(s: GLdouble); overload;
    procedure glTexCoord1dv(const v: PGLdouble); overload;
    procedure glTexCoord1f(s: GLfloat); overload;
    procedure glTexCoord1fv(const v: PGLfloat); overload;
    procedure glTexCoord1i(s: GLint); overload;
    procedure glTexCoord1iv(const v: PGLint); overload;
    procedure glTexCoord1s(s: GLshort); overload;
    procedure glTexCoord1sv(const v: PGLshort); overload;
    procedure glTexCoord2d(s: GLdouble; t: GLdouble); overload;
    procedure glTexCoord2dv(const v: PGLdouble); overload;
    procedure glTexCoord2f(s: GLfloat; t: GLfloat); overload;
    procedure glTexCoord2fv(const v: PGLfloat); overload;
    procedure glTexCoord2i(s: GLint; t: GLint); overload;
    procedure glTexCoord2iv(const v: PGLint); overload;
    procedure glTexCoord2s(s: GLshort; t: GLshort); overload;
    procedure glTexCoord2sv(const v: PGLshort); overload;
    procedure glTexCoord3d(s: GLdouble; t: GLdouble; r: GLdouble); overload;
    procedure glTexCoord3dv(const v: PGLdouble); overload;
    procedure glTexCoord3f(s: GLfloat; t: GLfloat; r: GLfloat); overload;
    procedure glTexCoord3fv(const v: PGLfloat); overload;
    procedure glTexCoord3i(s: GLint; t: GLint; r: GLint); overload;
    procedure glTexCoord3iv(const v: PGLint); overload;
    procedure glTexCoord3s(s: GLshort; t: GLshort; r: GLshort); overload;
    procedure glTexCoord3sv(const v: PGLshort); overload;
    procedure glTexCoord4d(s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble); overload;
    procedure glTexCoord4dv(const v: PGLdouble); overload;
    procedure glTexCoord4f(s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat); overload;
    procedure glTexCoord4fv(const v: PGLfloat); overload;
    procedure glTexCoord4i(s: GLint; t: GLint; r: GLint; q: GLint); overload;
    procedure glTexCoord4iv(const v: PGLint); overload;
    procedure glTexCoord4s(s: GLshort; t: GLshort; r: GLshort; q: GLshort); overload;
    procedure glTexCoord4sv(const v: PGLshort); overload;
    procedure glVertex2d(x: GLdouble; y: GLdouble); overload;
    procedure glVertex2dv(const v: PGLdouble); overload;
    procedure glVertex2f(x: GLfloat; y: GLfloat); overload;
    procedure glVertex2fv(const v: PGLfloat); overload;
    procedure glVertex2i(x: GLint; y: GLint); overload;
    procedure glVertex2iv(const v: PGLint); overload;
    procedure glVertex2s(x: GLshort; y: GLshort); overload;
    procedure glVertex2sv(const v: PGLshort); overload;
    procedure glVertex3d(x: GLdouble; y: GLdouble; z: GLdouble); overload;
    procedure glVertex3dv(const v: PGLdouble); overload;
    procedure glVertex3f(x: GLfloat; y: GLfloat; z: GLfloat); overload;
    procedure glVertex3fv(const v: PGLfloat); overload;
    procedure glVertex3i(x: GLint; y: GLint; z: GLint); overload;
    procedure glVertex3iv(const v: PGLint); overload;
    procedure glVertex3s(x: GLshort; y: GLshort; z: GLshort); overload;
    procedure glVertex3sv(const v: PGLshort); overload;
    procedure glVertex4d(x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); overload;
    procedure glVertex4dv(const v: PGLdouble); overload;
    procedure glVertex4f(x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); overload;
    procedure glVertex4fv(const v: PGLfloat); overload;
    procedure glVertex4i(x: GLint; y: GLint; z: GLint; w: GLint); overload;
    procedure glVertex4iv(const v: PGLint); overload;
    procedure glVertex4s(x: GLshort; y: GLshort; z: GLshort; w: GLshort); overload;
    procedure glVertex4sv(const v: PGLshort); overload;
    procedure glClipPlane(plane: GLenum; const equation: PGLdouble); overload;
    procedure glColorMaterial(face: GLenum; mode: GLenum); overload;
    procedure glFogf(pname: GLenum; param: GLfloat); overload;
    procedure glFogfv(pname: GLenum; const params: PGLfloat); overload;
    procedure glFogi(pname: GLenum; param: GLint); overload;
    procedure glFogiv(pname: GLenum; const params: PGLint); overload;
    procedure glLightf(light: GLenum; pname: GLenum; param: GLfloat); overload;
    procedure glLightfv(light: GLenum; pname: GLenum; const params: PGLfloat); overload;
    procedure glLighti(light: GLenum; pname: GLenum; param: GLint); overload;
    procedure glLightiv(light: GLenum; pname: GLenum; const params: PGLint); overload;
    procedure glLightModelf(pname: GLenum; param: GLfloat); overload;
    procedure glLightModelfv(pname: GLenum; const params: PGLfloat); overload;
    procedure glLightModeli(pname: GLenum; param: GLint); overload;
    procedure glLightModeliv(pname: GLenum; const params: PGLint); overload;
    procedure glLineStipple(factor: GLint; pattern: GLushort); overload;
    procedure glMaterialf(face: GLenum; pname: GLenum; param: GLfloat); overload;
    procedure glMaterialfv(face: GLenum; pname: GLenum; const params: PGLfloat); overload;
    procedure glMateriali(face: GLenum; pname: GLenum; param: GLint); overload;
    procedure glMaterialiv(face: GLenum; pname: GLenum; const params: PGLint); overload;
    procedure glPolygonStipple(const mask: PGLubyte); overload;
    procedure glShadeModel(mode: GLenum); overload;
    procedure glTexEnvf(target: GLenum; pname: GLenum; param: GLfloat); overload;
    procedure glTexEnvfv(target: GLenum; pname: GLenum; const params: PGLfloat); overload;
    procedure glTexEnvi(target: GLenum; pname: GLenum; param: GLint); overload;
    procedure glTexEnviv(target: GLenum; pname: GLenum; const params: PGLint); overload;
    procedure glTexGend(coord: GLenum; pname: GLenum; param: GLdouble); overload;
    procedure glTexGendv(coord: GLenum; pname: GLenum; const params: PGLdouble); overload;
    procedure glTexGenf(coord: GLenum; pname: GLenum; param: GLfloat); overload;
    procedure glTexGenfv(coord: GLenum; pname: GLenum; const params: PGLfloat); overload;
    procedure glTexGeni(coord: GLenum; pname: GLenum; param: GLint); overload;
    procedure glTexGeniv(coord: GLenum; pname: GLenum; const params: PGLint); overload;
    procedure glFeedbackBuffer(size: GLsizei; aType: GLenum; buffer: PGLfloat); overload;
    procedure glSelectBuffer(size: GLsizei; buffer: PGLuint); overload;
    function glRenderMode(mode: GLenum): GLint; overload;
    procedure glInitNames(); overload;
    procedure glLoadName(Name: GLuint); overload;
    procedure glPassThrough(token: GLfloat); overload;
    procedure glPopName(); overload;
    procedure glPushName(Name: GLuint); overload;
    procedure glClearAccum(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); overload;
    procedure glClearIndex(c: GLfloat); overload;
    procedure glIndexMask(mask: GLuint); overload;
    procedure glAccum(op: GLenum; Value: GLfloat); overload;
    procedure glPopAttrib(); overload;
    procedure glPushAttrib(mask: GLbitfield); overload;
    procedure glMap1d(target: GLenum; u1: GLdouble; u2: GLdouble; stride: GLint; order: GLint; const points: PGLdouble); overload;
    procedure glMap1f(target: GLenum; u1: GLfloat; u2: GLfloat; stride: GLint; order: GLint; const points: PGLfloat); overload;
    procedure glMap2d(target: GLenum; u1: GLdouble; u2: GLdouble; ustride: GLint; uorder: GLint; v1: GLdouble; v2: GLdouble; vstride: GLint; vorder: GLint; const points: PGLdouble); overload;
    procedure glMap2f(target: GLenum; u1: GLfloat; u2: GLfloat; ustride: GLint; uorder: GLint; v1: GLfloat; v2: GLfloat; vstride: GLint; vorder: GLint; const points: PGLfloat); overload;
    procedure glMapGrid1d(un: GLint; u1: GLdouble; u2: GLdouble); overload;
    procedure glMapGrid1f(un: GLint; u1: GLfloat; u2: GLfloat); overload;
    procedure glMapGrid2d(un: GLint; u1: GLdouble; u2: GLdouble; vn: GLint; v1: GLdouble; v2: GLdouble); overload;
    procedure glMapGrid2f(un: GLint; u1: GLfloat; u2: GLfloat; vn: GLint; v1: GLfloat; v2: GLfloat); overload;
    procedure glEvalCoord1d(u: GLdouble); overload;
    procedure glEvalCoord1dv(const u: PGLdouble); overload;
    procedure glEvalCoord1f(u: GLfloat); overload;
    procedure glEvalCoord1fv(const u: PGLfloat); overload;
    procedure glEvalCoord2d(u: GLdouble; v: GLdouble); overload;
    procedure glEvalCoord2dv(const u: PGLdouble); overload;
    procedure glEvalCoord2f(u: GLfloat; v: GLfloat); overload;
    procedure glEvalCoord2fv(const u: PGLfloat); overload;
    procedure glEvalMesh1(mode: GLenum; i1: GLint; i2: GLint); overload;
    procedure glEvalPoint1(i: GLint); overload;
    procedure glEvalMesh2(mode: GLenum; i1: GLint; i2: GLint; j1: GLint; j2: GLint); overload;
    procedure glEvalPoint2(i: GLint; j: GLint); overload;
    procedure glAlphaFunc(func: GLenum; ref: GLfloat); overload;
    procedure glPixelZoom(xfactor: GLfloat; yfactor: GLfloat); overload;
    procedure glPixelTransferf(pname: GLenum; param: GLfloat); overload;
    procedure glPixelTransferi(pname: GLenum; param: GLint); overload;
    procedure glPixelMapfv(map: GLenum; mapsize: GLsizei; const values: PGLfloat); overload;
    procedure glPixelMapuiv(map: GLenum; mapsize: GLsizei; const values: PGLuint); overload;
    procedure glPixelMapusv(map: GLenum; mapsize: GLsizei; const values: PGLushort); overload;
    procedure glCopyPixels(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; aType: GLenum); overload;
    procedure glDrawPixels(Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glGetClipPlane(plane: GLenum; equation: PGLdouble); overload;
    procedure glGetLightfv(light: GLenum; pname: GLenum; params: PGLfloat); overload;
    procedure glGetLightiv(light: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetMapdv(target: GLenum; query: GLenum; v: PGLdouble); overload;
    procedure glGetMapfv(target: GLenum; query: GLenum; v: PGLfloat); overload;
    procedure glGetMapiv(target: GLenum; query: GLenum; v: PGLint); overload;
    procedure glGetMaterialfv(face: GLenum; pname: GLenum; params: PGLfloat); overload;
    procedure glGetMaterialiv(face: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetPixelMapfv(map: GLenum; values: PGLfloat); overload;
    procedure glGetPixelMapuiv(map: GLenum; values: PGLuint); overload;
    procedure glGetPixelMapusv(map: GLenum; values: PGLushort); overload;
    procedure glGetPolygonStipple(mask: PGLubyte); overload;
    procedure glGetTexEnvfv(target: GLenum; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTexEnviv(target: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetTexGendv(coord: GLenum; pname: GLenum; params: PGLdouble); overload;
    procedure glGetTexGenfv(coord: GLenum; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTexGeniv(coord: GLenum; pname: GLenum; params: PGLint); overload;
    function glIsList(list: GLuint): GLboolean; overload;
    procedure glFrustum(left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); overload;
    procedure glLoadIdentity(); overload;
    procedure glLoadMatrixf(const m: PGLfloat); overload;
    procedure glLoadMatrixd(const m: PGLdouble); overload;
    procedure glMatrixMode(mode: GLenum); overload;
    procedure glMultMatrixf(const m: PGLfloat); overload;
    procedure glMultMatrixd(const m: PGLdouble); overload;
    procedure glOrtho(left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); overload;
    procedure glPopMatrix(); overload;
    procedure glPushMatrix(); overload;
    procedure glRotated(angle: GLdouble; x: GLdouble; y: GLdouble; z: GLdouble); overload;
    procedure glRotatef(angle: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); overload;
    procedure glScaled(x: GLdouble; y: GLdouble; z: GLdouble); overload;
    procedure glScalef(x: GLfloat; y: GLfloat; z: GLfloat); overload;
    procedure glTranslated(x: GLdouble; y: GLdouble; z: GLdouble); overload;
    procedure glTranslatef(x: GLfloat; y: GLfloat; z: GLfloat); overload;
  end;

  IGL_VERSION_1_1 = interface(IGL_VERSION_1_0)
    ['{B69806CD-2AB7-4860-B5BF-4446B6D098B6}']
    procedure glDrawArrays(mode: GLenum; First: GLint; Count: GLsizei); overload;
    procedure glDrawElements(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer); overload;
    procedure glGetPointerv(pname: GLenum; params: Pointer); overload;
    procedure glPolygonOffset(factor: GLfloat; units: GLfloat); overload;
    procedure glCopyTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; border: GLint); overload;
    procedure glCopyTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; border: GLint); overload;
    procedure glCopyTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei); overload;
    procedure glCopyTexSubImage2D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); overload;
    procedure glTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glTexSubImage2D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glBindTexture(target: GLenum; texture: GLuint); overload;
    procedure glDeleteTextures(n: GLsizei; const textures: PGLuint); overload;
    procedure glGenTextures(n: GLsizei; textures: PGLuint); overload;
    function glIsTexture(texture: GLuint): GLboolean; overload;
    procedure glArrayElement(i: GLint); overload;
    procedure glColorPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    procedure glDisableClientState(aArray: GLenum); overload;
    procedure glEdgeFlagPointer(stride: GLsizei; const aPointer: Pointer); overload;
    procedure glEnableClientState(aArray: GLenum); overload;
    procedure glIndexPointer(aType: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    procedure glInterleavedArrays(format: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    procedure glNormalPointer(aType: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    procedure glTexCoordPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    procedure glVertexPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    function glAreTexturesResident(n: GLsizei; const textures: PGLuint; residences: PGLboolean): GLboolean; overload;
    procedure glPrioritizeTextures(n: GLsizei; const textures: PGLuint; const priorities: PGLfloat); overload;
    procedure glIndexub(c: GLubyte); overload;
    procedure glIndexubv(const c: PGLubyte); overload;
    procedure glPopClientAttrib(); overload;
    procedure glPushClientAttrib(mask: GLbitfield); overload;
  end;

  IGL_VERSION_1_2 = interface(IGL_VERSION_1_1)
    ['{62720565-7C0F-46D5-9C84-73388F9F1B52}']
    procedure glDrawRangeElements(mode: GLenum; start: GLuint; aEnd: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer); overload;
    procedure glTexImage3D(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glTexSubImage3D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glCopyTexSubImage3D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); overload;
  end;

  IGL_VERSION_1_3 = interface(IGL_VERSION_1_2)
    ['{159522A4-4418-4BCB-B9E7-30FB9D20C080}']
    procedure glActiveTexture(texture: GLenum); overload;
    procedure glSampleCoverage(Value: GLfloat; invert: GLboolean); overload;
    procedure glCompressedTexImage3D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTexSubImage3D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTexSubImage2D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glGetCompressedTexImage(target: GLenum; level: GLint; img: Pointer); overload;
    procedure glClientActiveTexture(texture: GLenum); overload;
    procedure glMultiTexCoord1d(target: GLenum; s: GLdouble); overload;
    procedure glMultiTexCoord1dv(target: GLenum; const v: PGLdouble); overload;
    procedure glMultiTexCoord1f(target: GLenum; s: GLfloat); overload;
    procedure glMultiTexCoord1fv(target: GLenum; const v: PGLfloat); overload;
    procedure glMultiTexCoord1i(target: GLenum; s: GLint); overload;
    procedure glMultiTexCoord1iv(target: GLenum; const v: PGLint); overload;
    procedure glMultiTexCoord1s(target: GLenum; s: GLshort); overload;
    procedure glMultiTexCoord1sv(target: GLenum; const v: PGLshort); overload;
    procedure glMultiTexCoord2d(target: GLenum; s: GLdouble; t: GLdouble); overload;
    procedure glMultiTexCoord2dv(target: GLenum; const v: PGLdouble); overload;
    procedure glMultiTexCoord2f(target: GLenum; s: GLfloat; t: GLfloat); overload;
    procedure glMultiTexCoord2fv(target: GLenum; const v: PGLfloat); overload;
    procedure glMultiTexCoord2i(target: GLenum; s: GLint; t: GLint); overload;
    procedure glMultiTexCoord2iv(target: GLenum; const v: PGLint); overload;
    procedure glMultiTexCoord2s(target: GLenum; s: GLshort; t: GLshort); overload;
    procedure glMultiTexCoord2sv(target: GLenum; const v: PGLshort); overload;
    procedure glMultiTexCoord3d(target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble); overload;
    procedure glMultiTexCoord3dv(target: GLenum; const v: PGLdouble); overload;
    procedure glMultiTexCoord3f(target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat); overload;
    procedure glMultiTexCoord3fv(target: GLenum; const v: PGLfloat); overload;
    procedure glMultiTexCoord3i(target: GLenum; s: GLint; t: GLint; r: GLint); overload;
    procedure glMultiTexCoord3iv(target: GLenum; const v: PGLint); overload;
    procedure glMultiTexCoord3s(target: GLenum; s: GLshort; t: GLshort; r: GLshort); overload;
    procedure glMultiTexCoord3sv(target: GLenum; const v: PGLshort); overload;
    procedure glMultiTexCoord4d(target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble); overload;
    procedure glMultiTexCoord4dv(target: GLenum; const v: PGLdouble); overload;
    procedure glMultiTexCoord4f(target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat); overload;
    procedure glMultiTexCoord4fv(target: GLenum; const v: PGLfloat); overload;
    procedure glMultiTexCoord4i(target: GLenum; s: GLint; t: GLint; r: GLint; q: GLint); overload;
    procedure glMultiTexCoord4iv(target: GLenum; const v: PGLint); overload;
    procedure glMultiTexCoord4s(target: GLenum; s: GLshort; t: GLshort; r: GLshort; q: GLshort); overload;
    procedure glMultiTexCoord4sv(target: GLenum; const v: PGLshort); overload;
    procedure glLoadTransposeMatrixf(const m: PGLfloat); overload;
    procedure glLoadTransposeMatrixd(const m: PGLdouble); overload;
    procedure glMultTransposeMatrixf(const m: PGLfloat); overload;
    procedure glMultTransposeMatrixd(const m: PGLdouble); overload;
  end;

  IGL_VERSION_1_4 = interface(IGL_VERSION_1_3)
    ['{25BC0B33-86DC-4F70-A757-1DA4AF2CD7FA}']
    procedure glBlendFuncSeparate(sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); overload;
    procedure glMultiDrawArrays(mode: GLenum; const First: PGLint; const Count: PGLsizei; drawcount: GLsizei); overload;
    procedure glMultiDrawElements(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: Pointer; drawcount: GLsizei); overload;
    procedure glPointParameterf(pname: GLenum; param: GLfloat); overload;
    procedure glPointParameterfv(pname: GLenum; const params: PGLfloat); overload;
    procedure glPointParameteri(pname: GLenum; param: GLint); overload;
    procedure glPointParameteriv(pname: GLenum; const params: PGLint); overload;
    procedure glFogCoordf(coord: GLfloat); overload;
    procedure glFogCoordfv(const coord: PGLfloat); overload;
    procedure glFogCoordd(coord: GLdouble); overload;
    procedure glFogCoorddv(const coord: PGLdouble); overload;
    procedure glFogCoordPointer(aType: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    procedure glSecondaryColor3b(red: GLbyte; green: GLbyte; blue: GLbyte); overload;
    procedure glSecondaryColor3bv(const v: PGLbyte); overload;
    procedure glSecondaryColor3d(red: GLdouble; green: GLdouble; blue: GLdouble); overload;
    procedure glSecondaryColor3dv(const v: PGLdouble); overload;
    procedure glSecondaryColor3f(red: GLfloat; green: GLfloat; blue: GLfloat); overload;
    procedure glSecondaryColor3fv(const v: PGLfloat); overload;
    procedure glSecondaryColor3i(red: GLint; green: GLint; blue: GLint); overload;
    procedure glSecondaryColor3iv(const v: PGLint); overload;
    procedure glSecondaryColor3s(red: GLshort; green: GLshort; blue: GLshort); overload;
    procedure glSecondaryColor3sv(const v: PGLshort); overload;
    procedure glSecondaryColor3ub(red: GLubyte; green: GLubyte; blue: GLubyte); overload;
    procedure glSecondaryColor3ubv(const v: PGLubyte); overload;
    procedure glSecondaryColor3ui(red: GLuint; green: GLuint; blue: GLuint); overload;
    procedure glSecondaryColor3uiv(const v: PGLuint); overload;
    procedure glSecondaryColor3us(red: GLushort; green: GLushort; blue: GLushort); overload;
    procedure glSecondaryColor3usv(const v: PGLushort); overload;
    procedure glSecondaryColorPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    procedure glWindowPos2d(x: GLdouble; y: GLdouble); overload;
    procedure glWindowPos2dv(const v: PGLdouble); overload;
    procedure glWindowPos2f(x: GLfloat; y: GLfloat); overload;
    procedure glWindowPos2fv(const v: PGLfloat); overload;
    procedure glWindowPos2i(x: GLint; y: GLint); overload;
    procedure glWindowPos2iv(const v: PGLint); overload;
    procedure glWindowPos2s(x: GLshort; y: GLshort); overload;
    procedure glWindowPos2sv(const v: PGLshort); overload;
    procedure glWindowPos3d(x: GLdouble; y: GLdouble; z: GLdouble); overload;
    procedure glWindowPos3dv(const v: PGLdouble); overload;
    procedure glWindowPos3f(x: GLfloat; y: GLfloat; z: GLfloat); overload;
    procedure glWindowPos3fv(const v: PGLfloat); overload;
    procedure glWindowPos3i(x: GLint; y: GLint; z: GLint); overload;
    procedure glWindowPos3iv(const v: PGLint); overload;
    procedure glWindowPos3s(x: GLshort; y: GLshort; z: GLshort); overload;
    procedure glWindowPos3sv(const v: PGLshort); overload;
    procedure glBlendColor(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); overload;
    procedure glBlendEquation(mode: GLenum); overload;
  end;

  IGL_VERSION_1_5 = interface(IGL_VERSION_1_4)
    ['{A85CB5D6-6188-45D0-963A-3D4EDB34AE1D}']
    procedure glGenQueries(n: GLsizei; ids: PGLuint); overload;
    procedure glDeleteQueries(n: GLsizei; const ids: PGLuint); overload;
    function glIsQuery(id: GLuint): GLboolean; overload;
    procedure glBeginQuery(target: GLenum; id: GLuint); overload;
    procedure glEndQuery(target: GLenum); overload;
    procedure glGetQueryiv(target: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetQueryObjectiv(id: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetQueryObjectuiv(id: GLuint; pname: GLenum; params: PGLuint); overload;
    procedure glBindBuffer(target: GLenum; buffer: GLuint); overload;
    procedure glDeleteBuffers(n: GLsizei; const buffers: PGLuint); overload;
    procedure glGenBuffers(n: GLsizei; buffers: PGLuint); overload;
    function glIsBuffer(buffer: GLuint): GLboolean; overload;
    procedure glBufferData(target: GLenum; size: GLsizeiptr; const Data: Pointer; usage: GLenum); overload;
    procedure glBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; const Data: Pointer); overload;
    procedure glGetBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: Pointer); overload;
    function glMapBuffer(target: GLenum; access: GLenum): pointer; overload;
    function glUnmapBuffer(target: GLenum): GLboolean; overload;
    procedure glGetBufferParameteriv(target: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetBufferPointerv(target: GLenum; pname: GLenum; params: Pointer); overload;
  end;

  IGL_VERSION_2_0 = interface(IGL_VERSION_1_5)
    ['{2D6A922E-29B7-4483-BD57-BB593B29EEDD}']
    procedure glBlendEquationSeparate(modeRGB: GLenum; modeAlpha: GLenum); overload;
    procedure glDrawBuffers(n: GLsizei; const bufs: PGLenum); overload;
    procedure glStencilOpSeparate(face: GLenum; sfail: GLenum; dpfail: GLenum; dppass: GLenum); overload;
    procedure glStencilFuncSeparate(face: GLenum; func: GLenum; ref: GLint; mask: GLuint); overload;
    procedure glStencilMaskSeparate(face: GLenum; mask: GLuint); overload;
    procedure glAttachShader(aProgram: GLuint; shader: GLuint); overload;
    procedure glBindAttribLocation(aProgram: GLuint; index: GLuint; const Name: PGLchar); overload;
    procedure glCompileShader(shader: GLuint); overload;
    function glCreateProgram(): GLuint; overload;
    function glCreateShader(aType: GLenum): GLuint; overload;
    procedure glDeleteProgram(aProgram: GLuint); overload;
    procedure glDeleteShader(shader: GLuint); overload;
    procedure glDetachShader(aProgram: GLuint; shader: GLuint); overload;
    procedure glDisableVertexAttribArray(index: GLuint); overload;
    procedure glEnableVertexAttribArray(index: GLuint); overload;
    procedure glGetActiveAttrib(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; aType: PGLenum; Name: PGLchar); overload;
    procedure glGetActiveUniform(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; aType: PGLenum; Name: PGLchar); overload;
    procedure glGetAttachedShaders(aProgram: GLuint; maxCount: GLsizei; Count: PGLsizei; shaders: PGLuint); overload;
    function glGetAttribLocation(aProgram: GLuint; const Name: PGLchar): GLint; overload;
    procedure glGetProgramiv(aProgram: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetProgramInfoLog(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); overload;
    procedure glGetShaderiv(shader: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetShaderInfoLog(shader: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); overload;
    procedure glGetShaderSource(shader: GLuint; bufSize: GLsizei; length: PGLsizei; Source: PGLchar); overload;
    function glGetUniformLocation(aProgram: GLuint; const Name: PGLchar): GLint; overload;
    procedure glGetUniformfv(aProgram: GLuint; location: GLint; params: PGLfloat); overload;
    procedure glGetUniformiv(aProgram: GLuint; location: GLint; params: PGLint); overload;
    procedure glGetVertexAttribdv(index: GLuint; pname: GLenum; params: PGLdouble); overload;
    procedure glGetVertexAttribfv(index: GLuint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetVertexAttribiv(index: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetVertexAttribPointerv(index: GLuint; pname: GLenum; aPointer: Pointer); overload;
    function glIsProgram(aProgram: GLuint): GLboolean; overload;
    function glIsShader(shader: GLuint): GLboolean; overload;
    procedure glLinkProgram(aProgram: GLuint); overload;
    procedure glShaderSource(shader: GLuint; Count: GLsizei; const aString: PGLchar; const length: PGLint); overload;
    procedure glUseProgram(aProgram: GLuint); overload;
    procedure glUniform1f(location: GLint; v0: GLfloat); overload;
    procedure glUniform2f(location: GLint; v0: GLfloat; v1: GLfloat); overload;
    procedure glUniform3f(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); overload;
    procedure glUniform4f(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); overload;
    procedure glUniform1i(location: GLint; v0: GLint); overload;
    procedure glUniform2i(location: GLint; v0: GLint; v1: GLint); overload;
    procedure glUniform3i(location: GLint; v0: GLint; v1: GLint; v2: GLint); overload;
    procedure glUniform4i(location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); overload;
    procedure glUniform1fv(location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glUniform2fv(location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glUniform3fv(location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glUniform4fv(location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glUniform1iv(location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glUniform2iv(location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glUniform3iv(location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glUniform4iv(location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glUniformMatrix2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glValidateProgram(aProgram: GLuint); overload;
    procedure glVertexAttrib1d(index: GLuint; x: GLdouble); overload;
    procedure glVertexAttrib1dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttrib1f(index: GLuint; x: GLfloat); overload;
    procedure glVertexAttrib1fv(index: GLuint; const v: PGLfloat); overload;
    procedure glVertexAttrib1s(index: GLuint; x: GLshort); overload;
    procedure glVertexAttrib1sv(index: GLuint; const v: PGLshort); overload;
    procedure glVertexAttrib2d(index: GLuint; x: GLdouble; y: GLdouble); overload;
    procedure glVertexAttrib2dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttrib2f(index: GLuint; x: GLfloat; y: GLfloat); overload;
    procedure glVertexAttrib2fv(index: GLuint; const v: PGLfloat); overload;
    procedure glVertexAttrib2s(index: GLuint; x: GLshort; y: GLshort); overload;
    procedure glVertexAttrib2sv(index: GLuint; const v: PGLshort); overload;
    procedure glVertexAttrib3d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); overload;
    procedure glVertexAttrib3dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttrib3f(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat); overload;
    procedure glVertexAttrib3fv(index: GLuint; const v: PGLfloat); overload;
    procedure glVertexAttrib3s(index: GLuint; x: GLshort; y: GLshort; z: GLshort); overload;
    procedure glVertexAttrib3sv(index: GLuint; const v: PGLshort); overload;
    procedure glVertexAttrib4Nbv(index: GLuint; const v: PGLbyte); overload;
    procedure glVertexAttrib4Niv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttrib4Nsv(index: GLuint; const v: PGLshort); overload;
    procedure glVertexAttrib4Nub(index: GLuint; x: GLubyte; y: GLubyte; z: GLubyte; w: GLubyte); overload;
    procedure glVertexAttrib4Nubv(index: GLuint; const v: PGLubyte); overload;
    procedure glVertexAttrib4Nuiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttrib4Nusv(index: GLuint; const v: PGLushort); overload;
    procedure glVertexAttrib4bv(index: GLuint; const v: PGLbyte); overload;
    procedure glVertexAttrib4d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); overload;
    procedure glVertexAttrib4dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttrib4f(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); overload;
    procedure glVertexAttrib4fv(index: GLuint; const v: PGLfloat); overload;
    procedure glVertexAttrib4iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttrib4s(index: GLuint; x: GLshort; y: GLshort; z: GLshort; w: GLshort); overload;
    procedure glVertexAttrib4sv(index: GLuint; const v: PGLshort); overload;
    procedure glVertexAttrib4ubv(index: GLuint; const v: PGLubyte); overload;
    procedure glVertexAttrib4uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttrib4usv(index: GLuint; const v: PGLushort); overload;
    procedure glVertexAttribPointer(index: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; stride: GLsizei; const aPointer: Pointer); overload;
  end;

  IGL_VERSION_2_1 = interface(IGL_VERSION_2_0)
    ['{8F39C680-4944-4229-AF20-974776498FD6}']
    procedure glUniformMatrix2x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix3x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix2x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix4x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix3x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix4x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
  end;

  IGL_VERSION_3_0 = interface(IGL_VERSION_2_1)
    ['{50C9BD16-67C6-4DA7-AB4F-3477543FFBFA}']
    procedure glColorMaski(index: GLuint; r: GLboolean; g: GLboolean; b: GLboolean; a: GLboolean); overload;
    procedure glGetBooleani_v(target: GLenum; index: GLuint; Data: PGLboolean); overload;
    procedure glGetIntegeri_v(target: GLenum; index: GLuint; Data: PGLint); overload;
    procedure glEnablei(target: GLenum; index: GLuint); overload;
    procedure glDisablei(target: GLenum; index: GLuint); overload;
    function glIsEnabledi(target: GLenum; index: GLuint): GLboolean; overload;
    procedure glBeginTransformFeedback(primitiveMode: GLenum); overload;
    procedure glEndTransformFeedback(); overload;
    procedure glBindBufferRange(target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glBindBufferBase(target: GLenum; index: GLuint; buffer: GLuint); overload;
    procedure glTransformFeedbackVaryings(aProgram: GLuint; Count: GLsizei; const varyings: PGLchar; bufferMode: GLenum); overload;
    procedure glGetTransformFeedbackVarying(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; aType: PGLenum; Name: PGLchar); overload;
    procedure glClampColor(target: GLenum; clamp: GLenum); overload;
    procedure glBeginConditionalRender(id: GLuint; mode: GLenum); overload;
    procedure glEndConditionalRender(); overload;
    procedure glVertexAttribIPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    procedure glGetVertexAttribIiv(index: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetVertexAttribIuiv(index: GLuint; pname: GLenum; params: PGLuint); overload;
    procedure glVertexAttribI1i(index: GLuint; x: GLint); overload;
    procedure glVertexAttribI2i(index: GLuint; x: GLint; y: GLint); overload;
    procedure glVertexAttribI3i(index: GLuint; x: GLint; y: GLint; z: GLint); overload;
    procedure glVertexAttribI4i(index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint); overload;
    procedure glVertexAttribI1ui(index: GLuint; x: GLuint); overload;
    procedure glVertexAttribI2ui(index: GLuint; x: GLuint; y: GLuint); overload;
    procedure glVertexAttribI3ui(index: GLuint; x: GLuint; y: GLuint; z: GLuint); overload;
    procedure glVertexAttribI4ui(index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint); overload;
    procedure glVertexAttribI1iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI2iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI3iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI4iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI1uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI2uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI3uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI4uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI4bv(index: GLuint; const v: PGLbyte); overload;
    procedure glVertexAttribI4sv(index: GLuint; const v: PGLshort); overload;
    procedure glVertexAttribI4ubv(index: GLuint; const v: PGLubyte); overload;
    procedure glVertexAttribI4usv(index: GLuint; const v: PGLushort); overload;
    procedure glGetUniformuiv(aProgram: GLuint; location: GLint; params: PGLuint); overload;
    procedure glBindFragDataLocation(aProgram: GLuint; color: GLuint; const Name: PGLchar); overload;
    function glGetFragDataLocation(aProgram: GLuint; const Name: PGLchar): GLint; overload;
    procedure glUniform1ui(location: GLint; v0: GLuint); overload;
    procedure glUniform2ui(location: GLint; v0: GLuint; v1: GLuint); overload;
    procedure glUniform3ui(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); overload;
    procedure glUniform4ui(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); overload;
    procedure glUniform1uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glUniform2uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glUniform3uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glUniform4uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glTexParameterIiv(target: GLenum; pname: GLenum; const params: PGLint); overload;
    procedure glTexParameterIuiv(target: GLenum; pname: GLenum; const params: PGLuint); overload;
    procedure glGetTexParameterIiv(target: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetTexParameterIuiv(target: GLenum; pname: GLenum; params: PGLuint); overload;
    procedure glClearBufferiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLint); overload;
    procedure glClearBufferuiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLuint); overload;
    procedure glClearBufferfv(buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat); overload;
    procedure glClearBufferfi(buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); overload;
    function glGetStringi(Name: GLenum; index: GLuint): PGLubyte; overload;
    function glIsRenderbuffer(renderbuffer: GLuint): GLboolean; overload;
    procedure glBindRenderbuffer(target: GLenum; renderbuffer: GLuint); overload;
    procedure glDeleteRenderbuffers(n: GLsizei; const renderbuffers: PGLuint); overload;
    procedure glGenRenderbuffers(n: GLsizei; renderbuffers: PGLuint); overload;
    procedure glRenderbufferStorage(target: GLenum; internalformat: GLenum; Width: GLsizei; Height: GLsizei); overload;
    procedure glGetRenderbufferParameteriv(target: GLenum; pname: GLenum; params: PGLint); overload;
    function glIsFramebuffer(framebuffer: GLuint): GLboolean; overload;
    procedure glBindFramebuffer(target: GLenum; framebuffer: GLuint); overload;
    procedure glDeleteFramebuffers(n: GLsizei; const framebuffers: PGLuint); overload;
    procedure glGenFramebuffers(n: GLsizei; framebuffers: PGLuint); overload;
    function glCheckFramebufferStatus(target: GLenum): GLenum; overload;
    procedure glFramebufferTexture1D(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); overload;
    procedure glFramebufferTexture2D(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); overload;
    procedure glFramebufferTexture3D(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; zoffset: GLint); overload;
    procedure glFramebufferRenderbuffer(target: GLenum; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); overload;
    procedure glGetFramebufferAttachmentParameteriv(target: GLenum; attachment: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGenerateMipmap(target: GLenum); overload;
    procedure glBlitFramebuffer(srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); overload;
    procedure glRenderbufferStorageMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); overload;
    procedure glFramebufferTextureLayer(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); overload;
    function glMapBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): pointer; overload;
    procedure glFlushMappedBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr); overload;
    procedure glBindVertexArray(aArray: GLuint); overload;
    procedure glDeleteVertexArrays(n: GLsizei; const arrays: PGLuint); overload;
    procedure glGenVertexArrays(n: GLsizei; arrays: PGLuint); overload;
    function glIsVertexArray(aArray: GLuint): GLboolean; overload;
  end;

  IGL_VERSION_3_1 = interface(IGL_VERSION_3_0)
    ['{76B3CB13-C47A-43D8-93EF-9D4DCD936DF0}']
    procedure glDrawArraysInstanced(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei); overload;
    procedure glDrawElementsInstanced(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei); overload;
    procedure glTexBuffer(target: GLenum; internalformat: GLenum; buffer: GLuint); overload;
    procedure glPrimitiveRestartIndex(index: GLuint); overload;
    procedure glCopyBufferSubData(readTarget: GLenum; writeTarget: GLenum; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); overload;
    procedure glGetUniformIndices(aProgram: GLuint; uniformCount: GLsizei; const uniformNames: PGLchar; uniformIndices: PGLuint); overload;
    procedure glGetActiveUniformsiv(aProgram: GLuint; uniformCount: GLsizei; const uniformIndices: PGLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetActiveUniformName(aProgram: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar); overload;
    function glGetUniformBlockIndex(aProgram: GLuint; const uniformBlockName: PGLchar): GLuint; overload;
    procedure glGetActiveUniformBlockiv(aProgram: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetActiveUniformBlockName(aProgram: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar); overload;
    procedure glUniformBlockBinding(aProgram: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint); overload;
  end;

  IGL_VERSION_3_2 = interface(IGL_VERSION_3_1)
    ['{97052666-F12B-475D-B672-8963A53FF2BF}']
    procedure glDrawElementsBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); overload;
    procedure glDrawRangeElementsBaseVertex(mode: GLenum; start: GLuint; aEnd: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); overload;
    procedure glDrawElementsInstancedBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint); overload;
    procedure glMultiDrawElementsBaseVertex(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: Pointer; drawcount: GLsizei; const basevertex: PGLint); overload;
    procedure glProvokingVertex(mode: GLenum); overload;
    function glFenceSync(condition: GLenum; flags: GLbitfield): GLsync; overload;
    function glIsSync(sync: GLsync): GLboolean; overload;
    procedure glDeleteSync(sync: GLsync); overload;
    function glClientWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum; overload;
    procedure glWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64); overload;
    procedure glGetInteger64v(pname: GLenum; Data: PGLint64); overload;
    procedure glGetSynciv(sync: GLsync; pname: GLenum; Count: GLsizei; length: PGLsizei; values: PGLint); overload;
    procedure glGetInteger64i_v(target: GLenum; index: GLuint; Data: PGLint64); overload;
    procedure glGetBufferParameteri64v(target: GLenum; pname: GLenum; params: PGLint64); overload;
    procedure glFramebufferTexture(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint); overload;
    procedure glTexImage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTexImage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glGetMultisamplefv(pname: GLenum; index: GLuint; val: PGLfloat); overload;
    procedure glSampleMaski(maskNumber: GLuint; mask: GLbitfield); overload;
  end;

  IGL_VERSION_3_3 = interface(IGL_VERSION_3_2)
    ['{DAA40719-2BF8-4A1C-A7A5-D68B0B37FBB5}']
    procedure glBindFragDataLocationIndexed(aProgram: GLuint; colorNumber: GLuint; index: GLuint; const Name: PGLchar); overload;
    function glGetFragDataIndex(aProgram: GLuint; const Name: PGLchar): GLint; overload;
    procedure glGenSamplers(Count: GLsizei; samplers: PGLuint); overload;
    procedure glDeleteSamplers(Count: GLsizei; const samplers: PGLuint); overload;
    function glIsSampler(sampler: GLuint): GLboolean; overload;
    procedure glBindSampler(aUnit: GLuint; sampler: GLuint); overload;
    procedure glSamplerParameteri(sampler: GLuint; pname: GLenum; param: GLint); overload;
    procedure glSamplerParameteriv(sampler: GLuint; pname: GLenum; const param: PGLint); overload;
    procedure glSamplerParameterf(sampler: GLuint; pname: GLenum; param: GLfloat); overload;
    procedure glSamplerParameterfv(sampler: GLuint; pname: GLenum; const param: PGLfloat); overload;
    procedure glSamplerParameterIiv(sampler: GLuint; pname: GLenum; const param: PGLint); overload;
    procedure glSamplerParameterIuiv(sampler: GLuint; pname: GLenum; const param: PGLuint); overload;
    procedure glGetSamplerParameteriv(sampler: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetSamplerParameterIiv(sampler: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetSamplerParameterfv(sampler: GLuint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetSamplerParameterIuiv(sampler: GLuint; pname: GLenum; params: PGLuint); overload;
    procedure glQueryCounter(id: GLuint; target: GLenum); overload;
    procedure glGetQueryObjecti64v(id: GLuint; pname: GLenum; params: PGLint64); overload;
    procedure glGetQueryObjectui64v(id: GLuint; pname: GLenum; params: PGLuint64); overload;
    procedure glVertexAttribDivisor(index: GLuint; divisor: GLuint); overload;
    procedure glVertexAttribP1ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP1uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexAttribP2ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP2uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexAttribP3ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP3uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexAttribP4ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP4uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexP2ui(aType: GLenum; Value: GLuint); overload;
    procedure glVertexP2uiv(aType: GLenum; const Value: PGLuint); overload;
    procedure glVertexP3ui(aType: GLenum; Value: GLuint); overload;
    procedure glVertexP3uiv(aType: GLenum; const Value: PGLuint); overload;
    procedure glVertexP4ui(aType: GLenum; Value: GLuint); overload;
    procedure glVertexP4uiv(aType: GLenum; const Value: PGLuint); overload;
    procedure glTexCoordP1ui(aType: GLenum; coords: GLuint); overload;
    procedure glTexCoordP1uiv(aType: GLenum; const coords: PGLuint); overload;
    procedure glTexCoordP2ui(aType: GLenum; coords: GLuint); overload;
    procedure glTexCoordP2uiv(aType: GLenum; const coords: PGLuint); overload;
    procedure glTexCoordP3ui(aType: GLenum; coords: GLuint); overload;
    procedure glTexCoordP3uiv(aType: GLenum; const coords: PGLuint); overload;
    procedure glTexCoordP4ui(aType: GLenum; coords: GLuint); overload;
    procedure glTexCoordP4uiv(aType: GLenum; const coords: PGLuint); overload;
    procedure glMultiTexCoordP1ui(texture: GLenum; aType: GLenum; coords: GLuint); overload;
    procedure glMultiTexCoordP1uiv(texture: GLenum; aType: GLenum; const coords: PGLuint); overload;
    procedure glMultiTexCoordP2ui(texture: GLenum; aType: GLenum; coords: GLuint); overload;
    procedure glMultiTexCoordP2uiv(texture: GLenum; aType: GLenum; const coords: PGLuint); overload;
    procedure glMultiTexCoordP3ui(texture: GLenum; aType: GLenum; coords: GLuint); overload;
    procedure glMultiTexCoordP3uiv(texture: GLenum; aType: GLenum; const coords: PGLuint); overload;
    procedure glMultiTexCoordP4ui(texture: GLenum; aType: GLenum; coords: GLuint); overload;
    procedure glMultiTexCoordP4uiv(texture: GLenum; aType: GLenum; const coords: PGLuint); overload;
    procedure glNormalP3ui(aType: GLenum; coords: GLuint); overload;
    procedure glNormalP3uiv(aType: GLenum; const coords: PGLuint); overload;
    procedure glColorP3ui(aType: GLenum; color: GLuint); overload;
    procedure glColorP3uiv(aType: GLenum; const color: PGLuint); overload;
    procedure glColorP4ui(aType: GLenum; color: GLuint); overload;
    procedure glColorP4uiv(aType: GLenum; const color: PGLuint); overload;
    procedure glSecondaryColorP3ui(aType: GLenum; color: GLuint); overload;
    procedure glSecondaryColorP3uiv(aType: GLenum; const color: PGLuint); overload;
  end;

  IGL_VERSION_4_0 = interface(IGL_VERSION_3_3)
    ['{A1B68013-4136-4C47-887C-04BEF294288A}']
    procedure glMinSampleShading(Value: GLfloat); overload;
    procedure glBlendEquationi(buf: GLuint; mode: GLenum); overload;
    procedure glBlendEquationSeparatei(buf: GLuint; modeRGB: GLenum; modeAlpha: GLenum); overload;
    procedure glBlendFunci(buf: GLuint; src: GLenum; dst: GLenum); overload;
    procedure glBlendFuncSeparatei(buf: GLuint; srcRGB: GLenum; dstRGB: GLenum; srcAlpha: GLenum; dstAlpha: GLenum); overload;
    procedure glDrawArraysIndirect(mode: GLenum; const indirect: Pointer); overload;
    procedure glDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer); overload;
    procedure glUniform1d(location: GLint; x: GLdouble); overload;
    procedure glUniform2d(location: GLint; x: GLdouble; y: GLdouble); overload;
    procedure glUniform3d(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble); overload;
    procedure glUniform4d(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); overload;
    procedure glUniform1dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniform2dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniform3dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniform4dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniformMatrix2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix2x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix2x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix3x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix3x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix4x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix4x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glGetUniformdv(aProgram: GLuint; location: GLint; params: PGLdouble); overload;
    function glGetSubroutineUniformLocation(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLint; overload;
    function glGetSubroutineIndex(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLuint; overload;
    procedure glGetActiveSubroutineUniformiv(aProgram: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint); overload;
    procedure glGetActiveSubroutineUniformName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); overload;
    procedure glGetActiveSubroutineName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); overload;
    procedure glUniformSubroutinesuiv(shadertype: GLenum; Count: GLsizei; const indices: PGLuint); overload;
    procedure glGetUniformSubroutineuiv(shadertype: GLenum; location: GLint; params: PGLuint); overload;
    procedure glGetProgramStageiv(aProgram: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint); overload;
    procedure glPatchParameteri(pname: GLenum; Value: GLint); overload;
    procedure glPatchParameterfv(pname: GLenum; const values: PGLfloat); overload;
    procedure glBindTransformFeedback(target: GLenum; id: GLuint); overload;
    procedure glDeleteTransformFeedbacks(n: GLsizei; const ids: PGLuint); overload;
    procedure glGenTransformFeedbacks(n: GLsizei; ids: PGLuint); overload;
    function glIsTransformFeedback(id: GLuint): GLboolean; overload;
    procedure glPauseTransformFeedback(); overload;
    procedure glResumeTransformFeedback(); overload;
    procedure glDrawTransformFeedback(mode: GLenum; id: GLuint); overload;
    procedure glDrawTransformFeedbackStream(mode: GLenum; id: GLuint; stream: GLuint); overload;
    procedure glBeginQueryIndexed(target: GLenum; index: GLuint; id: GLuint); overload;
    procedure glEndQueryIndexed(target: GLenum; index: GLuint); overload;
    procedure glGetQueryIndexediv(target: GLenum; index: GLuint; pname: GLenum; params: PGLint); overload;
  end;

  IGL_VERSION_4_1 = interface(IGL_VERSION_4_0)
    ['{743CDCEE-2133-4D7D-93D4-3F5272FA526D}']
    procedure glReleaseShaderCompiler(); overload;
    procedure glShaderBinary(Count: GLsizei; const shaders: PGLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); overload;
    procedure glGetShaderPrecisionFormat(shadertype: GLenum; precisiontype: GLenum; range: PGLint; precision: PGLint); overload;
    procedure glDepthRangef(n: GLfloat; f: GLfloat); overload;
    procedure glClearDepthf(d: GLfloat); overload;
    procedure glGetProgramBinary(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer); overload;
    procedure glProgramBinary(aProgram: GLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); overload;
    procedure glProgramParameteri(aProgram: GLuint; pname: GLenum; Value: GLint); overload;
    procedure glUseProgramStages(pipeline: GLuint; stages: GLbitfield; aProgram: GLuint); overload;
    procedure glActiveShaderProgram(pipeline: GLuint; aProgram: GLuint); overload;
    function glCreateShaderProgramv(aType: GLenum; Count: GLsizei; const strings: PGLchar): GLuint; overload;
    procedure glBindProgramPipeline(pipeline: GLuint); overload;
    procedure glDeleteProgramPipelines(n: GLsizei; const pipelines: PGLuint); overload;
    procedure glGenProgramPipelines(n: GLsizei; pipelines: PGLuint); overload;
    function glIsProgramPipeline(pipeline: GLuint): GLboolean; overload;
    procedure glGetProgramPipelineiv(pipeline: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glProgramUniform1i(aProgram: GLuint; location: GLint; v0: GLint); overload;
    procedure glProgramUniform1iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform1f(aProgram: GLuint; location: GLint; v0: GLfloat); overload;
    procedure glProgramUniform1fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform1d(aProgram: GLuint; location: GLint; v0: GLdouble); overload;
    procedure glProgramUniform1dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform1ui(aProgram: GLuint; location: GLint; v0: GLuint); overload;
    procedure glProgramUniform1uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glProgramUniform2i(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint); overload;
    procedure glProgramUniform2iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform2f(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat); overload;
    procedure glProgramUniform2fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform2d(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble); overload;
    procedure glProgramUniform2dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform2ui(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint); overload;
    procedure glProgramUniform2uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glProgramUniform3i(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint); overload;
    procedure glProgramUniform3iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform3f(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); overload;
    procedure glProgramUniform3fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform3d(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble); overload;
    procedure glProgramUniform3dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform3ui(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); overload;
    procedure glProgramUniform3uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glProgramUniform4i(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); overload;
    procedure glProgramUniform4iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform4f(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); overload;
    procedure glProgramUniform4fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform4d(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble; v3: GLdouble); overload;
    procedure glProgramUniform4dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform4ui(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); overload;
    procedure glProgramUniform4uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glProgramUniformMatrix2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix2x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix3x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix2x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix4x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix3x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix4x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix2x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix3x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix2x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix4x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix3x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix4x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glValidateProgramPipeline(pipeline: GLuint); overload;
    procedure glGetProgramPipelineInfoLog(pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); overload;
    procedure glVertexAttribL1d(index: GLuint; x: GLdouble); overload;
    procedure glVertexAttribL2d(index: GLuint; x: GLdouble; y: GLdouble); overload;
    procedure glVertexAttribL3d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); overload;
    procedure glVertexAttribL4d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); overload;
    procedure glVertexAttribL1dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribL2dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribL3dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribL4dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribLPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); overload;
    procedure glGetVertexAttribLdv(index: GLuint; pname: GLenum; params: PGLdouble); overload;
    procedure glViewportArrayv(First: GLuint; Count: GLsizei; const v: PGLfloat); overload;
    procedure glViewportIndexedf(index: GLuint; x: GLfloat; y: GLfloat; w: GLfloat; h: GLfloat); overload;
    procedure glViewportIndexedfv(index: GLuint; const v: PGLfloat); overload;
    procedure glScissorArrayv(First: GLuint; Count: GLsizei; const v: PGLint); overload;
    procedure glScissorIndexed(index: GLuint; left: GLint; bottom: GLint; Width: GLsizei; Height: GLsizei); overload;
    procedure glScissorIndexedv(index: GLuint; const v: PGLint); overload;
    procedure glDepthRangeArrayv(First: GLuint; Count: GLsizei; const v: PGLdouble); overload;
    procedure glDepthRangeIndexed(index: GLuint; n: GLdouble; f: GLdouble); overload;
    procedure glGetFloati_v(target: GLenum; index: GLuint; Data: PGLfloat); overload;
    procedure glGetDoublei_v(target: GLenum; index: GLuint; Data: PGLdouble); overload;
  end;

  IGL_VERSION_4_2 = interface(IGL_VERSION_4_1)
    ['{3E5A8345-98DA-4129-B5C8-E391572D7D86}']
    procedure glDrawArraysInstancedBaseInstance(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei; baseinstance: GLuint); overload;
    procedure glDrawElementsInstancedBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; baseinstance: GLuint); overload;
    procedure glDrawElementsInstancedBaseVertexBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint); overload;
    procedure glGetInternalformativ(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint); overload;
    procedure glGetActiveAtomicCounterBufferiv(aProgram: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glBindImageTexture(aUnit: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum); overload;
    procedure glMemoryBarrier(barriers: GLbitfield); overload;
    procedure glTexStorage1D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei); overload;
    procedure glTexStorage2D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); overload;
    procedure glTexStorage3D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei); overload;
    procedure glDrawTransformFeedbackInstanced(mode: GLenum; id: GLuint; instancecount: GLsizei); overload;
    procedure glDrawTransformFeedbackStreamInstanced(mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei); overload;
  end;

  IGL_VERSION_4_3 = interface(IGL_VERSION_4_2)
    ['{17AB5466-674F-4D94-B8CA-68FA01C391C4}']
    procedure glClearBufferData(target: GLenum; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glClearBufferSubData(target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glDispatchCompute(num_groups_x: GLuint; num_groups_y: GLuint; num_groups_z: GLuint); overload;
    procedure glDispatchComputeIndirect(indirect: GLintptr); overload;
    procedure glCopyImageSubData(srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei; srcHeight: GLsizei; srcDepth: GLsizei); overload;
    procedure glFramebufferParameteri(target: GLenum; pname: GLenum; param: GLint); overload;
    procedure glGetFramebufferParameteriv(target: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetInternalformati64v(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint64); overload;
    procedure glInvalidateTexSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei); overload;
    procedure glInvalidateTexImage(texture: GLuint; level: GLint); overload;
    procedure glInvalidateBufferSubData(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); overload;
    procedure glInvalidateBufferData(buffer: GLuint); overload;
    procedure glInvalidateFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum); overload;
    procedure glInvalidateSubFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); overload;
    procedure glMultiDrawArraysIndirect(mode: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei); overload;
    procedure glMultiDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei); overload;
    procedure glGetProgramInterfaceiv(aProgram: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint); overload;
    function glGetProgramResourceIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLuint; overload;
    procedure glGetProgramResourceName(aProgram: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); overload;
    procedure glGetProgramResourceiv(aProgram: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; const props: PGLenum; Count: GLsizei; length: PGLsizei; params: PGLint); overload;
    function glGetProgramResourceLocation(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; overload;
    function glGetProgramResourceLocationIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; overload;
    procedure glShaderStorageBlockBinding(aProgram: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint); overload;
    procedure glTexBufferRange(target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glTexStorage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTexStorage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTextureView(texture: GLuint; target: GLenum; origtexture: GLuint; internalformat: GLenum; minlevel: GLuint; numlevels: GLuint; minlayer: GLuint; numlayers: GLuint); overload;
    procedure glBindVertexBuffer(bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); overload;
    procedure glVertexAttribFormat(attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); overload;
    procedure glVertexAttribIFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexAttribLFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexAttribBinding(attribindex: GLuint; bindingindex: GLuint); overload;
    procedure glVertexBindingDivisor(bindingindex: GLuint; divisor: GLuint); overload;
    procedure glDebugMessageControl(Source: GLenum; aType: GLenum; severity: GLenum; Count: GLsizei; const ids: PGLuint; Enabled: GLboolean); overload;
    procedure glDebugMessageInsert(Source: GLenum; aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const buf: PGLchar); overload;
    procedure glDebugMessageCallback(callback: GLDEBUGPROC; const userParam: Pointer); overload;
    function glGetDebugMessageLog(Count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint; overload;
    procedure glPushDebugGroup(Source: GLenum; id: GLuint; length: GLsizei; const message: PGLchar); overload;
    procedure glPopDebugGroup(); overload;
    procedure glObjectLabel(identifier: GLenum; Name: GLuint; length: GLsizei; const aLabel: PGLchar); overload;
    procedure glGetObjectLabel(identifier: GLenum; Name: GLuint; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); overload;
    procedure glObjectPtrLabel(const ptr: Pointer; length: GLsizei; const aLabel: PGLchar); overload;
    procedure glGetObjectPtrLabel(const ptr: Pointer; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); overload;
  end;

  IGL_VERSION_4_4 = interface(IGL_VERSION_4_3)
    ['{E69A77E0-EE33-45AE-86B0-26DEE1147A03}']
    procedure glBufferStorage(target: GLenum; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); overload;
    procedure glClearTexImage(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glClearTexSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glBindBuffersBase(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint); overload;
    procedure glBindBuffersRange(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const sizes: PGLsizeiptr); overload;
    procedure glBindTextures(First: GLuint; Count: GLsizei; const textures: PGLuint); overload;
    procedure glBindSamplers(First: GLuint; Count: GLsizei; const samplers: PGLuint); overload;
    procedure glBindImageTextures(First: GLuint; Count: GLsizei; const textures: PGLuint); overload;
    procedure glBindVertexBuffers(First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); overload;
  end;

  IGL_VERSION_4_5 = interface(IGL_VERSION_4_4)
    ['{CD3188E8-9555-4B7A-B25E-19587465DC67}']
    procedure glClipControl(origin: GLenum; depth: GLenum); overload;
    procedure glCreateTransformFeedbacks(n: GLsizei; ids: PGLuint); overload;
    procedure glTransformFeedbackBufferBase(xfb: GLuint; index: GLuint; buffer: GLuint); overload;
    procedure glTransformFeedbackBufferRange(xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glGetTransformFeedbackiv(xfb: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetTransformFeedbacki_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint); overload;
    procedure glGetTransformFeedbacki64_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64); overload;
    procedure glCreateBuffers(n: GLsizei; buffers: PGLuint); overload;
    procedure glNamedBufferStorage(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); overload;
    procedure glNamedBufferData(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; usage: GLenum); overload;
    procedure glNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; const Data: Pointer); overload;
    procedure glCopyNamedBufferSubData(readBuffer: GLuint; writeBuffer: GLuint; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); overload;
    procedure glClearNamedBufferData(buffer: GLuint; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glClearNamedBufferSubData(buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    function glMapNamedBuffer(buffer: GLuint; access: GLenum): pointer; overload;
    function glMapNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): pointer; overload;
    function glUnmapNamedBuffer(buffer: GLuint): GLboolean; overload;
    procedure glFlushMappedNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); overload;
    procedure glGetNamedBufferParameteriv(buffer: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetNamedBufferParameteri64v(buffer: GLuint; pname: GLenum; params: PGLint64); overload;
    procedure glGetNamedBufferPointerv(buffer: GLuint; pname: GLenum; params: Pointer); overload;
    procedure glGetNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer); overload;
    procedure glCreateFramebuffers(n: GLsizei; framebuffers: PGLuint); overload;
    procedure glNamedFramebufferRenderbuffer(framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); overload;
    procedure glNamedFramebufferParameteri(framebuffer: GLuint; pname: GLenum; param: GLint); overload;
    procedure glNamedFramebufferTexture(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint); overload;
    procedure glNamedFramebufferTextureLayer(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); overload;
    procedure glNamedFramebufferDrawBuffer(framebuffer: GLuint; buf: GLenum); overload;
    procedure glNamedFramebufferDrawBuffers(framebuffer: GLuint; n: GLsizei; const bufs: PGLenum); overload;
    procedure glNamedFramebufferReadBuffer(framebuffer: GLuint; src: GLenum); overload;
    procedure glInvalidateNamedFramebufferData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum); overload;
    procedure glInvalidateNamedFramebufferSubData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); overload;
    procedure glClearNamedFramebufferiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLint); overload;
    procedure glClearNamedFramebufferuiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLuint); overload;
    procedure glClearNamedFramebufferfv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat); overload;
    procedure glClearNamedFramebufferfi(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); overload;
    procedure glBlitNamedFramebuffer(readFramebuffer: GLuint; drawFramebuffer: GLuint; srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); overload;
    function glCheckNamedFramebufferStatus(framebuffer: GLuint; target: GLenum): GLenum; overload;
    procedure glGetNamedFramebufferParameteriv(framebuffer: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetNamedFramebufferAttachmentParameteriv(framebuffer: GLuint; attachment: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glCreateRenderbuffers(n: GLsizei; renderbuffers: PGLuint); overload;
    procedure glNamedRenderbufferStorage(renderbuffer: GLuint; internalformat: GLenum; Width: GLsizei; Height: GLsizei); overload;
    procedure glNamedRenderbufferStorageMultisample(renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); overload;
    procedure glGetNamedRenderbufferParameteriv(renderbuffer: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glCreateTextures(target: GLenum; n: GLsizei; textures: PGLuint); overload;
    procedure glTextureBuffer(texture: GLuint; internalformat: GLenum; buffer: GLuint); overload;
    procedure glTextureBufferRange(texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glTextureStorage1D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei); overload;
    procedure glTextureStorage2D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); overload;
    procedure glTextureStorage3D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei); overload;
    procedure glTextureStorage2DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTextureStorage3DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTextureSubImage1D(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glTextureSubImage2D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glTextureSubImage3D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); overload;
    procedure glCompressedTextureSubImage1D(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTextureSubImage2D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTextureSubImage3D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCopyTextureSubImage1D(texture: GLuint; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei); overload;
    procedure glCopyTextureSubImage2D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); overload;
    procedure glCopyTextureSubImage3D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); overload;
    procedure glTextureParameterf(texture: GLuint; pname: GLenum; param: GLfloat); overload;
    procedure glTextureParameterfv(texture: GLuint; pname: GLenum; const param: PGLfloat); overload;
    procedure glTextureParameteri(texture: GLuint; pname: GLenum; param: GLint); overload;
    procedure glTextureParameterIiv(texture: GLuint; pname: GLenum; const params: PGLint); overload;
    procedure glTextureParameterIuiv(texture: GLuint; pname: GLenum; const params: PGLuint); overload;
    procedure glTextureParameteriv(texture: GLuint; pname: GLenum; const param: PGLint); overload;
    procedure glGenerateTextureMipmap(texture: GLuint); overload;
    procedure glBindTextureUnit(aUnit: GLuint; texture: GLuint); overload;
    procedure glGetTextureImage(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetCompressedTextureImage(texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetTextureLevelParameterfv(texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTextureLevelParameteriv(texture: GLuint; level: GLint; pname: GLenum; params: PGLint); overload;
    procedure glGetTextureParameterfv(texture: GLuint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTextureParameterIiv(texture: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetTextureParameterIuiv(texture: GLuint; pname: GLenum; params: PGLuint); overload;
    procedure glGetTextureParameteriv(texture: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glCreateVertexArrays(n: GLsizei; arrays: PGLuint); overload;
    procedure glDisableVertexArrayAttrib(vaobj: GLuint; index: GLuint); overload;
    procedure glEnableVertexArrayAttrib(vaobj: GLuint; index: GLuint); overload;
    procedure glVertexArrayElementBuffer(vaobj: GLuint; buffer: GLuint); overload;
    procedure glVertexArrayVertexBuffer(vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); overload;
    procedure glVertexArrayVertexBuffers(vaobj: GLuint; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); overload;
    procedure glVertexArrayAttribBinding(vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint); overload;
    procedure glVertexArrayAttribFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); overload;
    procedure glVertexArrayAttribIFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexArrayAttribLFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexArrayBindingDivisor(vaobj: GLuint; bindingindex: GLuint; divisor: GLuint); overload;
    procedure glGetVertexArrayiv(vaobj: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetVertexArrayIndexediv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetVertexArrayIndexed64iv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64); overload;
    procedure glCreateSamplers(n: GLsizei; samplers: PGLuint); overload;
    procedure glCreateProgramPipelines(n: GLsizei; pipelines: PGLuint); overload;
    procedure glCreateQueries(target: GLenum; n: GLsizei; ids: PGLuint); overload;
    procedure glGetQueryBufferObjecti64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glGetQueryBufferObjectiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glGetQueryBufferObjectui64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glGetQueryBufferObjectuiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glMemoryBarrierByRegion(barriers: GLbitfield); overload;
    procedure glGetTextureSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetCompressedTextureSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; bufSize: GLsizei; pixels: Pointer); overload;
    function glGetGraphicsResetStatus(): GLenum; overload;
    procedure glGetnCompressedTexImage(target: GLenum; lod: GLint; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetnTexImage(target: GLenum; level: GLint; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetnUniformdv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble); overload;
    procedure glGetnUniformfv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); overload;
    procedure glGetnUniformiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); overload;
    procedure glGetnUniformuiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); overload;
    procedure glReadnPixels(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; bufSize: GLsizei; Data: Pointer); overload;
    procedure glGetnMapdv(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLdouble); overload;
    procedure glGetnMapfv(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLfloat); overload;
    procedure glGetnMapiv(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLint); overload;
    procedure glGetnPixelMapfv(map: GLenum; bufSize: GLsizei; values: PGLfloat); overload;
    procedure glGetnPixelMapuiv(map: GLenum; bufSize: GLsizei; values: PGLuint); overload;
    procedure glGetnPixelMapusv(map: GLenum; bufSize: GLsizei; values: PGLushort); overload;
    procedure glGetnPolygonStipple(bufSize: GLsizei; pattern: PGLubyte); overload;
    procedure glGetnColorTable(target: GLenum; format: GLenum; aType: GLenum; bufSize: GLsizei; table: Pointer); overload;
    procedure glGetnConvolutionFilter(target: GLenum; format: GLenum; aType: GLenum; bufSize: GLsizei; image: Pointer); overload;
    procedure glGetnSeparableFilter(target: GLenum; format: GLenum; aType: GLenum; rowBufSize: GLsizei; row: Pointer; columnBufSize: GLsizei; column: Pointer; span: Pointer); overload;
    procedure glGetnHistogram(target: GLenum; reset: GLboolean; format: GLenum; aType: GLenum; bufSize: GLsizei; values: Pointer); overload;
    procedure glGetnMinmax(target: GLenum; reset: GLboolean; format: GLenum; aType: GLenum; bufSize: GLsizei; values: Pointer); overload;
    procedure glTextureBarrier(); overload;
  end;

  IGL_VERSION_4_6 = interface(IGL_VERSION_4_5)
    ['{7500A361-19DD-4351-BE1C-1F374921ADF8}']
    procedure glSpecializeShader(shader: GLuint; const pEntryPoint: PGLchar; numSpecializationConstants: GLuint; const pConstantIndex: PGLuint; const pConstantValue: PGLuint); overload;
    procedure glMultiDrawArraysIndirectCount(mode: GLenum; const indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); overload;
    procedure glMultiDrawElementsIndirectCount(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); overload;
    procedure glPolygonOffsetClamp(factor: GLfloat; units: GLfloat; clamp: GLfloat); overload;
  end;



  IOpenGL = IGL_VERSION_4_6;

function GetOpenGL: IOpenGL;

implementation

{$IfDef Windows}
uses  Windows;
{$EndIf}

type
  { TOpenGLBase }

  TOpenGLBase = class(TInterfacedObject)
  protected
    FHandle: TLibHandle;
    {$IFDEF WINDOWS}
      FTempWindow: HWND;
      FTempDC: HDC;
      FTempRC: HGLRC;
      FWGLCreateContextAttribsARB : function(hDC: HDC; hShareContext: HGLRC; attribList: PInteger): HGLRC; stdcall;
      FWGLGetProcAddress: function (ProcName: LPCSTR): Pointer;
    {$EndIf}
  protected
    function LoadProc(Name: ansistring): {$ifdef cpui8086}FarPointer{$else}Pointer{$endif};
    {$IfDef Windows}
    procedure CreateTempCoreContext;
    procedure DestroyTempContext;
    {$EndIf}
    procedure Bind(var FuncPtr: Pointer; const Name: ansistring; Mandatory: boolean = False);
    procedure bindEntry; virtual;
    function SupportsExtension(const Ext: string): boolean; virtual;
    function SupportsVersion(Major, Minor: integer): boolean; virtual;
  public
    procedure LoadLibrary;
    procedure unLoadLibrary;
    destructor Destroy; override;
  end;

var
  singleton: IGL_VERSION_4_6;
  debugFile: Text;


function ifThen(test: boolean; ifTrue, ifFalse: string): string;
begin
  if (test) then
    exit(ifTrue)
  else
    exit(ifFalse);
end;


{$IfDef WINDOWS}
procedure TOpenGLBase.CreateTempCoreContext;
var
  pfd: PIXELFORMATDESCRIPTOR;
  PixelFormat: Integer;
  attribs: array[0..8] of Integer;

  TempLegacyRC :HGLRC;
begin
  if FTempRC <> 0 then Exit; // gi creato
  // 1. Crea finestra invisibile 1x1
  FTempWindow := CreateWindowA('STATIC', 'pax.gl temp', WS_POPUP or WS_DISABLED, 0, 0, 1, 1, 0, 0, GetModuleHandle(nil), nil);
  FTempDC := GetDC(FTempWindow);

  // 2. Pixel format base (compatibile con tutti)
  FillChar(pfd, SizeOf(pfd), 0);
  pfd.nSize := SizeOf(pfd);
  pfd.nVersion := 1;
  pfd.dwFlags := PFD_DRAW_TO_WINDOW or PFD_SUPPORT_OPENGL or PFD_DOUBLEBUFFER;
  pfd.iPixelType := PFD_TYPE_RGBA;
  pfd.cColorBits := 32;
  pfd.cDepthBits := 24;
  pfd.cStencilBits := 8;

  PixelFormat := ChoosePixelFormat(FTempDC, @pfd);
  if PixelFormat = 0 then raise Exception.Create('ChoosePixelFormat fallito');
  SetPixelFormat(FTempDC, PixelFormat, @pfd);

  // 3. Crea contesto legacy temporaneo (solo per caricare wglCreateContextAttribsARB)
  TempLegacyRC := wglCreateContext(FTempDC);
  wglMakeCurrent(fTempDC, TempLegacyRC);

  // 4. Carica wglCreateContextAttribsARB tramite wglGetProcAddress
  Pointer(FwglCreateContextAttribsARB) := FWGLGetProcAddress('wglCreateContextAttribsARB');
  if not Assigned(FWGLCreateContextAttribsARB) then
  begin
    wglMakeCurrent(0, 0);
    wglDeleteContext(TempLegacyRC);
    raise Exception.Create('wglCreateContextAttribsARB non supportato  driver troppo vecchio');
  end;

  // 5. Distruggi contesto legacy
  wglMakeCurrent(0, 0);
  wglDeleteContext(TempLegacyRC);

  // 6. Crea contesto singleton 4.6 Core Profile
  FillChar(attribs, SizeOf(attribs), 0);
  attribs[0] := $2091; // WGL_CONTEXT_MAJOR_VERSION_ARB
  attribs[1] := 4;
  attribs[2] := $2092; // WGL_CONTEXT_MINOR_VERSION_ARB
  attribs[3] := 6;
  attribs[4] := $9126; // WGL_CONTEXT_PROFILE_MASK_ARB
  attribs[5] := $00000001; // WGL_CONTEXT_CORE_PROFILE_BIT_ARB
  // attribs[6] := $2094; // WGL_CONTEXT_FLAGS_ARB
  // attribs[7] := $00000002; // WGL_CONTEXT_DEBUG_BIT_ARB (opzionale)
  // attribs[8] := 0;

  FTempRC := FWGLCreateContextAttribsARB(FTempDC, 0, @attribs);
  if FTempRC = 0 then
  begin
    // Fallback: prova 4.5, 4.3, 3.3
    attribs[1] := 4; attribs[3] := 5; FTempRC := FwglCreateContextAttribsARB(FTempDC, 0, @attribs);
    if FTempRC = 0 then begin attribs[1] := 4; attribs[3] := 3; FTempRC := FwglCreateContextAttribsARB(FTempDC, 0, @attribs); end;
    if FTempRC = 0 then begin attribs[1] := 3; attribs[3] := 3; FTempRC := FwglCreateContextAttribsARB(FTempDC, 0, @attribs); end;
  end;

  if FTempRC = 0 then
    raise Exception.Create('Impossibile creare contesto OpenGL 3.3+ Core');

  // 7. Attiva il contesto core
  wglMakeCurrent(FTempDC, FTempRC);

  //Writeln('Contesto temporaneo OpenGL ', glGetString(GL_VERSION), ' creato con successo');
end;

procedure TOpenGLBase.DestroyTempContext;
begin
  if FTempRC <> 0 then
  begin
    wglMakeCurrent(0, 0);
    wglDeleteContext(FTempRC);
    FTempRC := 0;
  end;
  if FTempDC <> 0 then
  begin
    ReleaseDC(FTempWindow, FTempDC);
    FTempDC := 0;
  end;
  if FTempWindow <> 0 then
  begin
    DestroyWindow(FTempWindow);
    FTempWindow := 0;
  end;
end;
{$EndIf}

function TOpenGLBase.LoadProc(Name: ansistring): {$ifdef cpui8086}FarPointer{$else}Pointer{$endif};
var
  fileName: TFileName;
begin
  {$IfDef WINDOWS}
  Result := FWGLGetProcAddress(PChar(Name));
  if result = nil then
    Result := dynlibs.GetProcAddress(FHandle, Name);
  {$ELSE}
  Result := dynlibs.GetProcAddress(FHandle, Name);
  {$EndIf}

  fileName := ExpandFileName(ParamStr(0)) + '.opengl.log';
  AssignFile(debugFile, fileName);
  if FileExists(fileName) then
    Append(debugFile)
  else
    Rewrite(debugFile);
  Writeln(debugFile, IfThen(assigned(Result), '     found:', ' not found:'), Name);
  Flush(debugFile);
  CloseFile(debugFile);
end;

procedure TOpenGLBase.Bind(var FuncPtr: Pointer; const Name: ansistring; Mandatory: boolean = False);
begin
  Pointer(FuncPtr) := LoadProc(Name);
  if (Pointer(FuncPtr) = nil) and Mandatory then
    raise Exception.Create('OpenGL function not found: ' + Name);
end;

procedure TOpenGLBase.bindEntry;
begin
  {$IfDef WINDOWS}
  Pointer(FWGLGetProcAddress) := dynlibs.GetProcAddress(FHandle, 'wglGetProcAddress');
  Pointer(FWGLCreateContextAttribsARB) := dynlibs.GetProcAddress(FHandle, 'glCreateContextAttribsARB');
  CreateTempCoreContext;
  {$EndIf}
end;

procedure TOpenGLBase.LoadLibrary;
begin
  FHandle := dynlibs.LoadLibrary(libGL);
end;

procedure TOpenGLBase.unLoadLibrary;
begin
  dynlibs.UnloadLibrary(FHandle);
end;

destructor TOpenGLBase.Destroy;
begin
  {$IfDef WINDOWS}
  DestroyTempContext;
  {$EndIf}
  unLoadLibrary;
  inherited Destroy;
end;

function TOpenGLBase.SupportsVersion(Major, Minor: integer): boolean;
begin
  Result := False;
end;

function TOpenGLBase.SupportsExtension(const Ext: string): boolean;
begin
  Result := False;
end;

type
  TGL_VERSION_1_0 = class(TOpenGLBase, IGL_VERSION_1_0)
  protected
    FglCullFace: procedure(mode: GLenum); cdecl;
    FglFrontFace: procedure(mode: GLenum); cdecl;
    FglHint: procedure(target: GLenum; mode: GLenum); cdecl;
    FglLineWidth: procedure(Width: GLfloat); cdecl;
    FglPointSize: procedure(size: GLfloat); cdecl;
    FglPolygonMode: procedure(face: GLenum; mode: GLenum); cdecl;
    FglScissor: procedure(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); cdecl;
    FglTexParameterf: procedure(target: GLenum; pname: GLenum; param: GLfloat); cdecl;
    FglTexParameterfv: procedure(target: GLenum; pname: GLenum; const params: PGLfloat); cdecl;
    FglTexParameteri: procedure(target: GLenum; pname: GLenum; param: GLint); cdecl;
    FglTexParameteriv: procedure(target: GLenum; pname: GLenum; const params: PGLint); cdecl;
    FglTexImage1D: procedure(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglTexImage2D: procedure(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglDrawBuffer: procedure(buf: GLenum); cdecl;
    FglClear: procedure(mask: GLbitfield); cdecl;
    FglClearColor: procedure(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); cdecl;
    FglClearStencil: procedure(s: GLint); cdecl;
    FglClearDepth: procedure(depth: GLdouble); cdecl;
    FglStencilMask: procedure(mask: GLuint); cdecl;
    FglColorMask: procedure(red: GLboolean; green: GLboolean; blue: GLboolean; alpha: GLboolean); cdecl;
    FglDepthMask: procedure(flag: GLboolean); cdecl;
    FglDisable: procedure(cap: GLenum); cdecl;
    FglEnable: procedure(cap: GLenum); cdecl;
    FglFinish: procedure(); cdecl;
    FglFlush: procedure(); cdecl;
    FglBlendFunc: procedure(sfactor: GLenum; dfactor: GLenum); cdecl;
    FglLogicOp: procedure(opcode: GLenum); cdecl;
    FglStencilFunc: procedure(func: GLenum; ref: GLint; mask: GLuint); cdecl;
    FglStencilOp: procedure(fail: GLenum; zfail: GLenum; zpass: GLenum); cdecl;
    FglDepthFunc: procedure(func: GLenum); cdecl;
    FglPixelStoref: procedure(pname: GLenum; param: GLfloat); cdecl;
    FglPixelStorei: procedure(pname: GLenum; param: GLint); cdecl;
    FglReadBuffer: procedure(src: GLenum); cdecl;
    FglReadPixels: procedure(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; pixels: Pointer); cdecl;
    FglGetBooleanv: procedure(pname: GLenum; Data: PGLboolean); cdecl;
    FglGetDoublev: procedure(pname: GLenum; Data: PGLdouble); cdecl;
    FglGetError: function(): GLenum; cdecl;
    FglGetFloatv: procedure(pname: GLenum; Data: PGLfloat); cdecl;
    FglGetIntegerv: procedure(pname: GLenum; Data: PGLint); cdecl;
    FglGetString: function(Name: GLenum): PGLubyte; cdecl;
    FglGetTexImage: procedure(target: GLenum; level: GLint; format: GLenum; aType: GLenum; pixels: Pointer); cdecl;
    FglGetTexParameterfv: procedure(target: GLenum; pname: GLenum; params: PGLfloat); cdecl;
    FglGetTexParameteriv: procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGetTexLevelParameterfv: procedure(target: GLenum; level: GLint; pname: GLenum; params: PGLfloat); cdecl;
    FglGetTexLevelParameteriv: procedure(target: GLenum; level: GLint; pname: GLenum; params: PGLint); cdecl;
    FglIsEnabled: function(cap: GLenum): GLboolean; cdecl;
    FglDepthRange: procedure(n: GLdouble; f: GLdouble); cdecl;
    FglViewport: procedure(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); cdecl;
    FglNewList: procedure(list: GLuint; mode: GLenum); cdecl;
    FglEndList: procedure(); cdecl;
    FglCallList: procedure(list: GLuint); cdecl;
    FglCallLists: procedure(n: GLsizei; aType: GLenum; const lists: Pointer); cdecl;
    FglDeleteLists: procedure(list: GLuint; range: GLsizei); cdecl;
    FglGenLists: function(range: GLsizei): GLuint; cdecl;
    FglListBase: procedure(base: GLuint); cdecl;
    FglBegin: procedure(mode: GLenum); cdecl;
    FglBitmap: procedure(Width: GLsizei; Height: GLsizei; xorig: GLfloat; yorig: GLfloat; xmove: GLfloat; ymove: GLfloat; const bitmap: PGLubyte); cdecl;
    FglColor3b: procedure(red: GLbyte; green: GLbyte; blue: GLbyte); cdecl;
    FglColor3bv: procedure(const v: PGLbyte); cdecl;
    FglColor3d: procedure(red: GLdouble; green: GLdouble; blue: GLdouble); cdecl;
    FglColor3dv: procedure(const v: PGLdouble); cdecl;
    FglColor3f: procedure(red: GLfloat; green: GLfloat; blue: GLfloat); cdecl;
    FglColor3fv: procedure(const v: PGLfloat); cdecl;
    FglColor3i: procedure(red: GLint; green: GLint; blue: GLint); cdecl;
    FglColor3iv: procedure(const v: PGLint); cdecl;
    FglColor3s: procedure(red: GLshort; green: GLshort; blue: GLshort); cdecl;
    FglColor3sv: procedure(const v: PGLshort); cdecl;
    FglColor3ub: procedure(red: GLubyte; green: GLubyte; blue: GLubyte); cdecl;
    FglColor3ubv: procedure(const v: PGLubyte); cdecl;
    FglColor3ui: procedure(red: GLuint; green: GLuint; blue: GLuint); cdecl;
    FglColor3uiv: procedure(const v: PGLuint); cdecl;
    FglColor3us: procedure(red: GLushort; green: GLushort; blue: GLushort); cdecl;
    FglColor3usv: procedure(const v: PGLushort); cdecl;
    FglColor4b: procedure(red: GLbyte; green: GLbyte; blue: GLbyte; alpha: GLbyte); cdecl;
    FglColor4bv: procedure(const v: PGLbyte); cdecl;
    FglColor4d: procedure(red: GLdouble; green: GLdouble; blue: GLdouble; alpha: GLdouble); cdecl;
    FglColor4dv: procedure(const v: PGLdouble); cdecl;
    FglColor4f: procedure(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); cdecl;
    FglColor4fv: procedure(const v: PGLfloat); cdecl;
    FglColor4i: procedure(red: GLint; green: GLint; blue: GLint; alpha: GLint); cdecl;
    FglColor4iv: procedure(const v: PGLint); cdecl;
    FglColor4s: procedure(red: GLshort; green: GLshort; blue: GLshort; alpha: GLshort); cdecl;
    FglColor4sv: procedure(const v: PGLshort); cdecl;
    FglColor4ub: procedure(red: GLubyte; green: GLubyte; blue: GLubyte; alpha: GLubyte); cdecl;
    FglColor4ubv: procedure(const v: PGLubyte); cdecl;
    FglColor4ui: procedure(red: GLuint; green: GLuint; blue: GLuint; alpha: GLuint); cdecl;
    FglColor4uiv: procedure(const v: PGLuint); cdecl;
    FglColor4us: procedure(red: GLushort; green: GLushort; blue: GLushort; alpha: GLushort); cdecl;
    FglColor4usv: procedure(const v: PGLushort); cdecl;
    FglEdgeFlag: procedure(flag: GLboolean); cdecl;
    FglEdgeFlagv: procedure(const flag: PGLboolean); cdecl;
    FglEnd: procedure(); cdecl;
    FglIndexd: procedure(c: GLdouble); cdecl;
    FglIndexdv: procedure(const c: PGLdouble); cdecl;
    FglIndexf: procedure(c: GLfloat); cdecl;
    FglIndexfv: procedure(const c: PGLfloat); cdecl;
    FglIndexi: procedure(c: GLint); cdecl;
    FglIndexiv: procedure(const c: PGLint); cdecl;
    FglIndexs: procedure(c: GLshort); cdecl;
    FglIndexsv: procedure(const c: PGLshort); cdecl;
    FglNormal3b: procedure(nx: GLbyte; ny: GLbyte; nz: GLbyte); cdecl;
    FglNormal3bv: procedure(const v: PGLbyte); cdecl;
    FglNormal3d: procedure(nx: GLdouble; ny: GLdouble; nz: GLdouble); cdecl;
    FglNormal3dv: procedure(const v: PGLdouble); cdecl;
    FglNormal3f: procedure(nx: GLfloat; ny: GLfloat; nz: GLfloat); cdecl;
    FglNormal3fv: procedure(const v: PGLfloat); cdecl;
    FglNormal3i: procedure(nx: GLint; ny: GLint; nz: GLint); cdecl;
    FglNormal3iv: procedure(const v: PGLint); cdecl;
    FglNormal3s: procedure(nx: GLshort; ny: GLshort; nz: GLshort); cdecl;
    FglNormal3sv: procedure(const v: PGLshort); cdecl;
    FglRasterPos2d: procedure(x: GLdouble; y: GLdouble); cdecl;
    FglRasterPos2dv: procedure(const v: PGLdouble); cdecl;
    FglRasterPos2f: procedure(x: GLfloat; y: GLfloat); cdecl;
    FglRasterPos2fv: procedure(const v: PGLfloat); cdecl;
    FglRasterPos2i: procedure(x: GLint; y: GLint); cdecl;
    FglRasterPos2iv: procedure(const v: PGLint); cdecl;
    FglRasterPos2s: procedure(x: GLshort; y: GLshort); cdecl;
    FglRasterPos2sv: procedure(const v: PGLshort); cdecl;
    FglRasterPos3d: procedure(x: GLdouble; y: GLdouble; z: GLdouble); cdecl;
    FglRasterPos3dv: procedure(const v: PGLdouble); cdecl;
    FglRasterPos3f: procedure(x: GLfloat; y: GLfloat; z: GLfloat); cdecl;
    FglRasterPos3fv: procedure(const v: PGLfloat); cdecl;
    FglRasterPos3i: procedure(x: GLint; y: GLint; z: GLint); cdecl;
    FglRasterPos3iv: procedure(const v: PGLint); cdecl;
    FglRasterPos3s: procedure(x: GLshort; y: GLshort; z: GLshort); cdecl;
    FglRasterPos3sv: procedure(const v: PGLshort); cdecl;
    FglRasterPos4d: procedure(x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); cdecl;
    FglRasterPos4dv: procedure(const v: PGLdouble); cdecl;
    FglRasterPos4f: procedure(x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); cdecl;
    FglRasterPos4fv: procedure(const v: PGLfloat); cdecl;
    FglRasterPos4i: procedure(x: GLint; y: GLint; z: GLint; w: GLint); cdecl;
    FglRasterPos4iv: procedure(const v: PGLint); cdecl;
    FglRasterPos4s: procedure(x: GLshort; y: GLshort; z: GLshort; w: GLshort); cdecl;
    FglRasterPos4sv: procedure(const v: PGLshort); cdecl;
    FglRectd: procedure(x1: GLdouble; y1: GLdouble; x2: GLdouble; y2: GLdouble); cdecl;
    FglRectdv: procedure(const v1: PGLdouble; const v2: PGLdouble); cdecl;
    FglRectf: procedure(x1: GLfloat; y1: GLfloat; x2: GLfloat; y2: GLfloat); cdecl;
    FglRectfv: procedure(const v1: PGLfloat; const v2: PGLfloat); cdecl;
    FglRecti: procedure(x1: GLint; y1: GLint; x2: GLint; y2: GLint); cdecl;
    FglRectiv: procedure(const v1: PGLint; const v2: PGLint); cdecl;
    FglRects: procedure(x1: GLshort; y1: GLshort; x2: GLshort; y2: GLshort); cdecl;
    FglRectsv: procedure(const v1: PGLshort; const v2: PGLshort); cdecl;
    FglTexCoord1d: procedure(s: GLdouble); cdecl;
    FglTexCoord1dv: procedure(const v: PGLdouble); cdecl;
    FglTexCoord1f: procedure(s: GLfloat); cdecl;
    FglTexCoord1fv: procedure(const v: PGLfloat); cdecl;
    FglTexCoord1i: procedure(s: GLint); cdecl;
    FglTexCoord1iv: procedure(const v: PGLint); cdecl;
    FglTexCoord1s: procedure(s: GLshort); cdecl;
    FglTexCoord1sv: procedure(const v: PGLshort); cdecl;
    FglTexCoord2d: procedure(s: GLdouble; t: GLdouble); cdecl;
    FglTexCoord2dv: procedure(const v: PGLdouble); cdecl;
    FglTexCoord2f: procedure(s: GLfloat; t: GLfloat); cdecl;
    FglTexCoord2fv: procedure(const v: PGLfloat); cdecl;
    FglTexCoord2i: procedure(s: GLint; t: GLint); cdecl;
    FglTexCoord2iv: procedure(const v: PGLint); cdecl;
    FglTexCoord2s: procedure(s: GLshort; t: GLshort); cdecl;
    FglTexCoord2sv: procedure(const v: PGLshort); cdecl;
    FglTexCoord3d: procedure(s: GLdouble; t: GLdouble; r: GLdouble); cdecl;
    FglTexCoord3dv: procedure(const v: PGLdouble); cdecl;
    FglTexCoord3f: procedure(s: GLfloat; t: GLfloat; r: GLfloat); cdecl;
    FglTexCoord3fv: procedure(const v: PGLfloat); cdecl;
    FglTexCoord3i: procedure(s: GLint; t: GLint; r: GLint); cdecl;
    FglTexCoord3iv: procedure(const v: PGLint); cdecl;
    FglTexCoord3s: procedure(s: GLshort; t: GLshort; r: GLshort); cdecl;
    FglTexCoord3sv: procedure(const v: PGLshort); cdecl;
    FglTexCoord4d: procedure(s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble); cdecl;
    FglTexCoord4dv: procedure(const v: PGLdouble); cdecl;
    FglTexCoord4f: procedure(s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat); cdecl;
    FglTexCoord4fv: procedure(const v: PGLfloat); cdecl;
    FglTexCoord4i: procedure(s: GLint; t: GLint; r: GLint; q: GLint); cdecl;
    FglTexCoord4iv: procedure(const v: PGLint); cdecl;
    FglTexCoord4s: procedure(s: GLshort; t: GLshort; r: GLshort; q: GLshort); cdecl;
    FglTexCoord4sv: procedure(const v: PGLshort); cdecl;
    FglVertex2d: procedure(x: GLdouble; y: GLdouble); cdecl;
    FglVertex2dv: procedure(const v: PGLdouble); cdecl;
    FglVertex2f: procedure(x: GLfloat; y: GLfloat); cdecl;
    FglVertex2fv: procedure(const v: PGLfloat); cdecl;
    FglVertex2i: procedure(x: GLint; y: GLint); cdecl;
    FglVertex2iv: procedure(const v: PGLint); cdecl;
    FglVertex2s: procedure(x: GLshort; y: GLshort); cdecl;
    FglVertex2sv: procedure(const v: PGLshort); cdecl;
    FglVertex3d: procedure(x: GLdouble; y: GLdouble; z: GLdouble); cdecl;
    FglVertex3dv: procedure(const v: PGLdouble); cdecl;
    FglVertex3f: procedure(x: GLfloat; y: GLfloat; z: GLfloat); cdecl;
    FglVertex3fv: procedure(const v: PGLfloat); cdecl;
    FglVertex3i: procedure(x: GLint; y: GLint; z: GLint); cdecl;
    FglVertex3iv: procedure(const v: PGLint); cdecl;
    FglVertex3s: procedure(x: GLshort; y: GLshort; z: GLshort); cdecl;
    FglVertex3sv: procedure(const v: PGLshort); cdecl;
    FglVertex4d: procedure(x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); cdecl;
    FglVertex4dv: procedure(const v: PGLdouble); cdecl;
    FglVertex4f: procedure(x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); cdecl;
    FglVertex4fv: procedure(const v: PGLfloat); cdecl;
    FglVertex4i: procedure(x: GLint; y: GLint; z: GLint; w: GLint); cdecl;
    FglVertex4iv: procedure(const v: PGLint); cdecl;
    FglVertex4s: procedure(x: GLshort; y: GLshort; z: GLshort; w: GLshort); cdecl;
    FglVertex4sv: procedure(const v: PGLshort); cdecl;
    FglClipPlane: procedure(plane: GLenum; const equation: PGLdouble); cdecl;
    FglColorMaterial: procedure(face: GLenum; mode: GLenum); cdecl;
    FglFogf: procedure(pname: GLenum; param: GLfloat); cdecl;
    FglFogfv: procedure(pname: GLenum; const params: PGLfloat); cdecl;
    FglFogi: procedure(pname: GLenum; param: GLint); cdecl;
    FglFogiv: procedure(pname: GLenum; const params: PGLint); cdecl;
    FglLightf: procedure(light: GLenum; pname: GLenum; param: GLfloat); cdecl;
    FglLightfv: procedure(light: GLenum; pname: GLenum; const params: PGLfloat); cdecl;
    FglLighti: procedure(light: GLenum; pname: GLenum; param: GLint); cdecl;
    FglLightiv: procedure(light: GLenum; pname: GLenum; const params: PGLint); cdecl;
    FglLightModelf: procedure(pname: GLenum; param: GLfloat); cdecl;
    FglLightModelfv: procedure(pname: GLenum; const params: PGLfloat); cdecl;
    FglLightModeli: procedure(pname: GLenum; param: GLint); cdecl;
    FglLightModeliv: procedure(pname: GLenum; const params: PGLint); cdecl;
    FglLineStipple: procedure(factor: GLint; pattern: GLushort); cdecl;
    FglMaterialf: procedure(face: GLenum; pname: GLenum; param: GLfloat); cdecl;
    FglMaterialfv: procedure(face: GLenum; pname: GLenum; const params: PGLfloat); cdecl;
    FglMateriali: procedure(face: GLenum; pname: GLenum; param: GLint); cdecl;
    FglMaterialiv: procedure(face: GLenum; pname: GLenum; const params: PGLint); cdecl;
    FglPolygonStipple: procedure(const mask: PGLubyte); cdecl;
    FglShadeModel: procedure(mode: GLenum); cdecl;
    FglTexEnvf: procedure(target: GLenum; pname: GLenum; param: GLfloat); cdecl;
    FglTexEnvfv: procedure(target: GLenum; pname: GLenum; const params: PGLfloat); cdecl;
    FglTexEnvi: procedure(target: GLenum; pname: GLenum; param: GLint); cdecl;
    FglTexEnviv: procedure(target: GLenum; pname: GLenum; const params: PGLint); cdecl;
    FglTexGend: procedure(coord: GLenum; pname: GLenum; param: GLdouble); cdecl;
    FglTexGendv: procedure(coord: GLenum; pname: GLenum; const params: PGLdouble); cdecl;
    FglTexGenf: procedure(coord: GLenum; pname: GLenum; param: GLfloat); cdecl;
    FglTexGenfv: procedure(coord: GLenum; pname: GLenum; const params: PGLfloat); cdecl;
    FglTexGeni: procedure(coord: GLenum; pname: GLenum; param: GLint); cdecl;
    FglTexGeniv: procedure(coord: GLenum; pname: GLenum; const params: PGLint); cdecl;
    FglFeedbackBuffer: procedure(size: GLsizei; aType: GLenum; buffer: PGLfloat); cdecl;
    FglSelectBuffer: procedure(size: GLsizei; buffer: PGLuint); cdecl;
    FglRenderMode: function(mode: GLenum): GLint; cdecl;
    FglInitNames: procedure(); cdecl;
    FglLoadName: procedure(Name: GLuint); cdecl;
    FglPassThrough: procedure(token: GLfloat); cdecl;
    FglPopName: procedure(); cdecl;
    FglPushName: procedure(Name: GLuint); cdecl;
    FglClearAccum: procedure(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); cdecl;
    FglClearIndex: procedure(c: GLfloat); cdecl;
    FglIndexMask: procedure(mask: GLuint); cdecl;
    FglAccum: procedure(op: GLenum; Value: GLfloat); cdecl;
    FglPopAttrib: procedure(); cdecl;
    FglPushAttrib: procedure(mask: GLbitfield); cdecl;
    FglMap1d: procedure(target: GLenum; u1: GLdouble; u2: GLdouble; stride: GLint; order: GLint; const points: PGLdouble); cdecl;
    FglMap1f: procedure(target: GLenum; u1: GLfloat; u2: GLfloat; stride: GLint; order: GLint; const points: PGLfloat); cdecl;
    FglMap2d: procedure(target: GLenum; u1: GLdouble; u2: GLdouble; ustride: GLint; uorder: GLint; v1: GLdouble; v2: GLdouble; vstride: GLint; vorder: GLint; const points: PGLdouble); cdecl;
    FglMap2f: procedure(target: GLenum; u1: GLfloat; u2: GLfloat; ustride: GLint; uorder: GLint; v1: GLfloat; v2: GLfloat; vstride: GLint; vorder: GLint; const points: PGLfloat); cdecl;
    FglMapGrid1d: procedure(un: GLint; u1: GLdouble; u2: GLdouble); cdecl;
    FglMapGrid1f: procedure(un: GLint; u1: GLfloat; u2: GLfloat); cdecl;
    FglMapGrid2d: procedure(un: GLint; u1: GLdouble; u2: GLdouble; vn: GLint; v1: GLdouble; v2: GLdouble); cdecl;
    FglMapGrid2f: procedure(un: GLint; u1: GLfloat; u2: GLfloat; vn: GLint; v1: GLfloat; v2: GLfloat); cdecl;
    FglEvalCoord1d: procedure(u: GLdouble); cdecl;
    FglEvalCoord1dv: procedure(const u: PGLdouble); cdecl;
    FglEvalCoord1f: procedure(u: GLfloat); cdecl;
    FglEvalCoord1fv: procedure(const u: PGLfloat); cdecl;
    FglEvalCoord2d: procedure(u: GLdouble; v: GLdouble); cdecl;
    FglEvalCoord2dv: procedure(const u: PGLdouble); cdecl;
    FglEvalCoord2f: procedure(u: GLfloat; v: GLfloat); cdecl;
    FglEvalCoord2fv: procedure(const u: PGLfloat); cdecl;
    FglEvalMesh1: procedure(mode: GLenum; i1: GLint; i2: GLint); cdecl;
    FglEvalPoint1: procedure(i: GLint); cdecl;
    FglEvalMesh2: procedure(mode: GLenum; i1: GLint; i2: GLint; j1: GLint; j2: GLint); cdecl;
    FglEvalPoint2: procedure(i: GLint; j: GLint); cdecl;
    FglAlphaFunc: procedure(func: GLenum; ref: GLfloat); cdecl;
    FglPixelZoom: procedure(xfactor: GLfloat; yfactor: GLfloat); cdecl;
    FglPixelTransferf: procedure(pname: GLenum; param: GLfloat); cdecl;
    FglPixelTransferi: procedure(pname: GLenum; param: GLint); cdecl;
    FglPixelMapfv: procedure(map: GLenum; mapsize: GLsizei; const values: PGLfloat); cdecl;
    FglPixelMapuiv: procedure(map: GLenum; mapsize: GLsizei; const values: PGLuint); cdecl;
    FglPixelMapusv: procedure(map: GLenum; mapsize: GLsizei; const values: PGLushort); cdecl;
    FglCopyPixels: procedure(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; aType: GLenum); cdecl;
    FglDrawPixels: procedure(Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglGetClipPlane: procedure(plane: GLenum; equation: PGLdouble); cdecl;
    FglGetLightfv: procedure(light: GLenum; pname: GLenum; params: PGLfloat); cdecl;
    FglGetLightiv: procedure(light: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGetMapdv: procedure(target: GLenum; query: GLenum; v: PGLdouble); cdecl;
    FglGetMapfv: procedure(target: GLenum; query: GLenum; v: PGLfloat); cdecl;
    FglGetMapiv: procedure(target: GLenum; query: GLenum; v: PGLint); cdecl;
    FglGetMaterialfv: procedure(face: GLenum; pname: GLenum; params: PGLfloat); cdecl;
    FglGetMaterialiv: procedure(face: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGetPixelMapfv: procedure(map: GLenum; values: PGLfloat); cdecl;
    FglGetPixelMapuiv: procedure(map: GLenum; values: PGLuint); cdecl;
    FglGetPixelMapusv: procedure(map: GLenum; values: PGLushort); cdecl;
    FglGetPolygonStipple: procedure(mask: PGLubyte); cdecl;
    FglGetTexEnvfv: procedure(target: GLenum; pname: GLenum; params: PGLfloat); cdecl;
    FglGetTexEnviv: procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGetTexGendv: procedure(coord: GLenum; pname: GLenum; params: PGLdouble); cdecl;
    FglGetTexGenfv: procedure(coord: GLenum; pname: GLenum; params: PGLfloat); cdecl;
    FglGetTexGeniv: procedure(coord: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglIsList: function(list: GLuint): GLboolean; cdecl;
    FglFrustum: procedure(left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); cdecl;
    FglLoadIdentity: procedure(); cdecl;
    FglLoadMatrixf: procedure(const m: PGLfloat); cdecl;
    FglLoadMatrixd: procedure(const m: PGLdouble); cdecl;
    FglMatrixMode: procedure(mode: GLenum); cdecl;
    FglMultMatrixf: procedure(const m: PGLfloat); cdecl;
    FglMultMatrixd: procedure(const m: PGLdouble); cdecl;
    FglOrtho: procedure(left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); cdecl;
    FglPopMatrix: procedure(); cdecl;
    FglPushMatrix: procedure(); cdecl;
    FglRotated: procedure(angle: GLdouble; x: GLdouble; y: GLdouble; z: GLdouble); cdecl;
    FglRotatef: procedure(angle: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); cdecl;
    FglScaled: procedure(x: GLdouble; y: GLdouble; z: GLdouble); cdecl;
    FglScalef: procedure(x: GLfloat; y: GLfloat; z: GLfloat); cdecl;
    FglTranslated: procedure(x: GLdouble; y: GLdouble; z: GLdouble); cdecl;
    FglTranslatef: procedure(x: GLfloat; y: GLfloat; z: GLfloat); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glCullFace(mode: GLenum);
    procedure glFrontFace(mode: GLenum);
    procedure glHint(target: GLenum; mode: GLenum);
    procedure glLineWidth(Width: GLfloat);
    procedure glPointSize(size: GLfloat);
    procedure glPolygonMode(face: GLenum; mode: GLenum);
    procedure glScissor(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
    procedure glTexParameterf(target: GLenum; pname: GLenum; param: GLfloat);
    procedure glTexParameterfv(target: GLenum; pname: GLenum; const params: PGLfloat);
    procedure glTexParameteri(target: GLenum; pname: GLenum; param: GLint);
    procedure glTexParameteriv(target: GLenum; pname: GLenum; const params: PGLint);
    procedure glTexImage1D(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glTexImage2D(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glDrawBuffer(buf: GLenum);
    procedure glClear(mask: GLbitfield);
    procedure glClearColor(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat);
    procedure glClearStencil(s: GLint);
    procedure glClearDepth(depth: GLdouble);
    procedure glStencilMask(mask: GLuint);
    procedure glColorMask(red: GLboolean; green: GLboolean; blue: GLboolean; alpha: GLboolean);
    procedure glDepthMask(flag: GLboolean);
    procedure glDisable(cap: GLenum);
    procedure glEnable(cap: GLenum);
    procedure glFinish();
    procedure glFlush();
    procedure glBlendFunc(sfactor: GLenum; dfactor: GLenum);
    procedure glLogicOp(opcode: GLenum);
    procedure glStencilFunc(func: GLenum; ref: GLint; mask: GLuint);
    procedure glStencilOp(fail: GLenum; zfail: GLenum; zpass: GLenum);
    procedure glDepthFunc(func: GLenum);
    procedure glPixelStoref(pname: GLenum; param: GLfloat);
    procedure glPixelStorei(pname: GLenum; param: GLint);
    procedure glReadBuffer(src: GLenum);
    procedure glReadPixels(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; pixels: Pointer);
    procedure glGetBooleanv(pname: GLenum; Data: PGLboolean);
    procedure glGetDoublev(pname: GLenum; Data: PGLdouble);
    function glGetError(): GLenum;
    procedure glGetFloatv(pname: GLenum; Data: PGLfloat);
    procedure glGetIntegerv(pname: GLenum; Data: PGLint);
    function glGetString(Name: GLenum): PGLubyte;
    procedure glGetTexImage(target: GLenum; level: GLint; format: GLenum; aType: GLenum; pixels: Pointer);
    procedure glGetTexParameterfv(target: GLenum; pname: GLenum; params: PGLfloat);
    procedure glGetTexParameteriv(target: GLenum; pname: GLenum; params: PGLint);
    procedure glGetTexLevelParameterfv(target: GLenum; level: GLint; pname: GLenum; params: PGLfloat);
    procedure glGetTexLevelParameteriv(target: GLenum; level: GLint; pname: GLenum; params: PGLint);
    function glIsEnabled(cap: GLenum): GLboolean;
    procedure glDepthRange(n: GLdouble; f: GLdouble);
    procedure glViewport(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
    procedure glNewList(list: GLuint; mode: GLenum);
    procedure glEndList();
    procedure glCallList(list: GLuint);
    procedure glCallLists(n: GLsizei; aType: GLenum; const lists: Pointer);
    procedure glDeleteLists(list: GLuint; range: GLsizei);
    function glGenLists(range: GLsizei): GLuint;
    procedure glListBase(base: GLuint);
    procedure glBegin(mode: GLenum);
    procedure glBitmap(Width: GLsizei; Height: GLsizei; xorig: GLfloat; yorig: GLfloat; xmove: GLfloat; ymove: GLfloat; const bitmap: PGLubyte);
    procedure glColor3b(red: GLbyte; green: GLbyte; blue: GLbyte);
    procedure glColor3bv(const v: PGLbyte);
    procedure glColor3d(red: GLdouble; green: GLdouble; blue: GLdouble);
    procedure glColor3dv(const v: PGLdouble);
    procedure glColor3f(red: GLfloat; green: GLfloat; blue: GLfloat);
    procedure glColor3fv(const v: PGLfloat);
    procedure glColor3i(red: GLint; green: GLint; blue: GLint);
    procedure glColor3iv(const v: PGLint);
    procedure glColor3s(red: GLshort; green: GLshort; blue: GLshort);
    procedure glColor3sv(const v: PGLshort);
    procedure glColor3ub(red: GLubyte; green: GLubyte; blue: GLubyte);
    procedure glColor3ubv(const v: PGLubyte);
    procedure glColor3ui(red: GLuint; green: GLuint; blue: GLuint);
    procedure glColor3uiv(const v: PGLuint);
    procedure glColor3us(red: GLushort; green: GLushort; blue: GLushort);
    procedure glColor3usv(const v: PGLushort);
    procedure glColor4b(red: GLbyte; green: GLbyte; blue: GLbyte; alpha: GLbyte);
    procedure glColor4bv(const v: PGLbyte);
    procedure glColor4d(red: GLdouble; green: GLdouble; blue: GLdouble; alpha: GLdouble);
    procedure glColor4dv(const v: PGLdouble);
    procedure glColor4f(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat);
    procedure glColor4fv(const v: PGLfloat);
    procedure glColor4i(red: GLint; green: GLint; blue: GLint; alpha: GLint);
    procedure glColor4iv(const v: PGLint);
    procedure glColor4s(red: GLshort; green: GLshort; blue: GLshort; alpha: GLshort);
    procedure glColor4sv(const v: PGLshort);
    procedure glColor4ub(red: GLubyte; green: GLubyte; blue: GLubyte; alpha: GLubyte);
    procedure glColor4ubv(const v: PGLubyte);
    procedure glColor4ui(red: GLuint; green: GLuint; blue: GLuint; alpha: GLuint);
    procedure glColor4uiv(const v: PGLuint);
    procedure glColor4us(red: GLushort; green: GLushort; blue: GLushort; alpha: GLushort);
    procedure glColor4usv(const v: PGLushort);
    procedure glEdgeFlag(flag: GLboolean);
    procedure glEdgeFlagv(const flag: PGLboolean);
    procedure glEnd();
    procedure glIndexd(c: GLdouble);
    procedure glIndexdv(const c: PGLdouble);
    procedure glIndexf(c: GLfloat);
    procedure glIndexfv(const c: PGLfloat);
    procedure glIndexi(c: GLint);
    procedure glIndexiv(const c: PGLint);
    procedure glIndexs(c: GLshort);
    procedure glIndexsv(const c: PGLshort);
    procedure glNormal3b(nx: GLbyte; ny: GLbyte; nz: GLbyte);
    procedure glNormal3bv(const v: PGLbyte);
    procedure glNormal3d(nx: GLdouble; ny: GLdouble; nz: GLdouble);
    procedure glNormal3dv(const v: PGLdouble);
    procedure glNormal3f(nx: GLfloat; ny: GLfloat; nz: GLfloat);
    procedure glNormal3fv(const v: PGLfloat);
    procedure glNormal3i(nx: GLint; ny: GLint; nz: GLint);
    procedure glNormal3iv(const v: PGLint);
    procedure glNormal3s(nx: GLshort; ny: GLshort; nz: GLshort);
    procedure glNormal3sv(const v: PGLshort);
    procedure glRasterPos2d(x: GLdouble; y: GLdouble);
    procedure glRasterPos2dv(const v: PGLdouble);
    procedure glRasterPos2f(x: GLfloat; y: GLfloat);
    procedure glRasterPos2fv(const v: PGLfloat);
    procedure glRasterPos2i(x: GLint; y: GLint);
    procedure glRasterPos2iv(const v: PGLint);
    procedure glRasterPos2s(x: GLshort; y: GLshort);
    procedure glRasterPos2sv(const v: PGLshort);
    procedure glRasterPos3d(x: GLdouble; y: GLdouble; z: GLdouble);
    procedure glRasterPos3dv(const v: PGLdouble);
    procedure glRasterPos3f(x: GLfloat; y: GLfloat; z: GLfloat);
    procedure glRasterPos3fv(const v: PGLfloat);
    procedure glRasterPos3i(x: GLint; y: GLint; z: GLint);
    procedure glRasterPos3iv(const v: PGLint);
    procedure glRasterPos3s(x: GLshort; y: GLshort; z: GLshort);
    procedure glRasterPos3sv(const v: PGLshort);
    procedure glRasterPos4d(x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
    procedure glRasterPos4dv(const v: PGLdouble);
    procedure glRasterPos4f(x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat);
    procedure glRasterPos4fv(const v: PGLfloat);
    procedure glRasterPos4i(x: GLint; y: GLint; z: GLint; w: GLint);
    procedure glRasterPos4iv(const v: PGLint);
    procedure glRasterPos4s(x: GLshort; y: GLshort; z: GLshort; w: GLshort);
    procedure glRasterPos4sv(const v: PGLshort);
    procedure glRectd(x1: GLdouble; y1: GLdouble; x2: GLdouble; y2: GLdouble);
    procedure glRectdv(const v1: PGLdouble; const v2: PGLdouble);
    procedure glRectf(x1: GLfloat; y1: GLfloat; x2: GLfloat; y2: GLfloat);
    procedure glRectfv(const v1: PGLfloat; const v2: PGLfloat);
    procedure glRecti(x1: GLint; y1: GLint; x2: GLint; y2: GLint);
    procedure glRectiv(const v1: PGLint; const v2: PGLint);
    procedure glRects(x1: GLshort; y1: GLshort; x2: GLshort; y2: GLshort);
    procedure glRectsv(const v1: PGLshort; const v2: PGLshort);
    procedure glTexCoord1d(s: GLdouble);
    procedure glTexCoord1dv(const v: PGLdouble);
    procedure glTexCoord1f(s: GLfloat);
    procedure glTexCoord1fv(const v: PGLfloat);
    procedure glTexCoord1i(s: GLint);
    procedure glTexCoord1iv(const v: PGLint);
    procedure glTexCoord1s(s: GLshort);
    procedure glTexCoord1sv(const v: PGLshort);
    procedure glTexCoord2d(s: GLdouble; t: GLdouble);
    procedure glTexCoord2dv(const v: PGLdouble);
    procedure glTexCoord2f(s: GLfloat; t: GLfloat);
    procedure glTexCoord2fv(const v: PGLfloat);
    procedure glTexCoord2i(s: GLint; t: GLint);
    procedure glTexCoord2iv(const v: PGLint);
    procedure glTexCoord2s(s: GLshort; t: GLshort);
    procedure glTexCoord2sv(const v: PGLshort);
    procedure glTexCoord3d(s: GLdouble; t: GLdouble; r: GLdouble);
    procedure glTexCoord3dv(const v: PGLdouble);
    procedure glTexCoord3f(s: GLfloat; t: GLfloat; r: GLfloat);
    procedure glTexCoord3fv(const v: PGLfloat);
    procedure glTexCoord3i(s: GLint; t: GLint; r: GLint);
    procedure glTexCoord3iv(const v: PGLint);
    procedure glTexCoord3s(s: GLshort; t: GLshort; r: GLshort);
    procedure glTexCoord3sv(const v: PGLshort);
    procedure glTexCoord4d(s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble);
    procedure glTexCoord4dv(const v: PGLdouble);
    procedure glTexCoord4f(s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat);
    procedure glTexCoord4fv(const v: PGLfloat);
    procedure glTexCoord4i(s: GLint; t: GLint; r: GLint; q: GLint);
    procedure glTexCoord4iv(const v: PGLint);
    procedure glTexCoord4s(s: GLshort; t: GLshort; r: GLshort; q: GLshort);
    procedure glTexCoord4sv(const v: PGLshort);
    procedure glVertex2d(x: GLdouble; y: GLdouble);
    procedure glVertex2dv(const v: PGLdouble);
    procedure glVertex2f(x: GLfloat; y: GLfloat);
    procedure glVertex2fv(const v: PGLfloat);
    procedure glVertex2i(x: GLint; y: GLint);
    procedure glVertex2iv(const v: PGLint);
    procedure glVertex2s(x: GLshort; y: GLshort);
    procedure glVertex2sv(const v: PGLshort);
    procedure glVertex3d(x: GLdouble; y: GLdouble; z: GLdouble);
    procedure glVertex3dv(const v: PGLdouble);
    procedure glVertex3f(x: GLfloat; y: GLfloat; z: GLfloat);
    procedure glVertex3fv(const v: PGLfloat);
    procedure glVertex3i(x: GLint; y: GLint; z: GLint);
    procedure glVertex3iv(const v: PGLint);
    procedure glVertex3s(x: GLshort; y: GLshort; z: GLshort);
    procedure glVertex3sv(const v: PGLshort);
    procedure glVertex4d(x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
    procedure glVertex4dv(const v: PGLdouble);
    procedure glVertex4f(x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat);
    procedure glVertex4fv(const v: PGLfloat);
    procedure glVertex4i(x: GLint; y: GLint; z: GLint; w: GLint);
    procedure glVertex4iv(const v: PGLint);
    procedure glVertex4s(x: GLshort; y: GLshort; z: GLshort; w: GLshort);
    procedure glVertex4sv(const v: PGLshort);
    procedure glClipPlane(plane: GLenum; const equation: PGLdouble);
    procedure glColorMaterial(face: GLenum; mode: GLenum);
    procedure glFogf(pname: GLenum; param: GLfloat);
    procedure glFogfv(pname: GLenum; const params: PGLfloat);
    procedure glFogi(pname: GLenum; param: GLint);
    procedure glFogiv(pname: GLenum; const params: PGLint);
    procedure glLightf(light: GLenum; pname: GLenum; param: GLfloat);
    procedure glLightfv(light: GLenum; pname: GLenum; const params: PGLfloat);
    procedure glLighti(light: GLenum; pname: GLenum; param: GLint);
    procedure glLightiv(light: GLenum; pname: GLenum; const params: PGLint);
    procedure glLightModelf(pname: GLenum; param: GLfloat);
    procedure glLightModelfv(pname: GLenum; const params: PGLfloat);
    procedure glLightModeli(pname: GLenum; param: GLint);
    procedure glLightModeliv(pname: GLenum; const params: PGLint);
    procedure glLineStipple(factor: GLint; pattern: GLushort);
    procedure glMaterialf(face: GLenum; pname: GLenum; param: GLfloat);
    procedure glMaterialfv(face: GLenum; pname: GLenum; const params: PGLfloat);
    procedure glMateriali(face: GLenum; pname: GLenum; param: GLint);
    procedure glMaterialiv(face: GLenum; pname: GLenum; const params: PGLint);
    procedure glPolygonStipple(const mask: PGLubyte);
    procedure glShadeModel(mode: GLenum);
    procedure glTexEnvf(target: GLenum; pname: GLenum; param: GLfloat);
    procedure glTexEnvfv(target: GLenum; pname: GLenum; const params: PGLfloat);
    procedure glTexEnvi(target: GLenum; pname: GLenum; param: GLint);
    procedure glTexEnviv(target: GLenum; pname: GLenum; const params: PGLint);
    procedure glTexGend(coord: GLenum; pname: GLenum; param: GLdouble);
    procedure glTexGendv(coord: GLenum; pname: GLenum; const params: PGLdouble);
    procedure glTexGenf(coord: GLenum; pname: GLenum; param: GLfloat);
    procedure glTexGenfv(coord: GLenum; pname: GLenum; const params: PGLfloat);
    procedure glTexGeni(coord: GLenum; pname: GLenum; param: GLint);
    procedure glTexGeniv(coord: GLenum; pname: GLenum; const params: PGLint);
    procedure glFeedbackBuffer(size: GLsizei; aType: GLenum; buffer: PGLfloat);
    procedure glSelectBuffer(size: GLsizei; buffer: PGLuint);
    function glRenderMode(mode: GLenum): GLint;
    procedure glInitNames();
    procedure glLoadName(Name: GLuint);
    procedure glPassThrough(token: GLfloat);
    procedure glPopName();
    procedure glPushName(Name: GLuint);
    procedure glClearAccum(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat);
    procedure glClearIndex(c: GLfloat);
    procedure glIndexMask(mask: GLuint);
    procedure glAccum(op: GLenum; Value: GLfloat);
    procedure glPopAttrib();
    procedure glPushAttrib(mask: GLbitfield);
    procedure glMap1d(target: GLenum; u1: GLdouble; u2: GLdouble; stride: GLint; order: GLint; const points: PGLdouble);
    procedure glMap1f(target: GLenum; u1: GLfloat; u2: GLfloat; stride: GLint; order: GLint; const points: PGLfloat);
    procedure glMap2d(target: GLenum; u1: GLdouble; u2: GLdouble; ustride: GLint; uorder: GLint; v1: GLdouble; v2: GLdouble; vstride: GLint; vorder: GLint; const points: PGLdouble);
    procedure glMap2f(target: GLenum; u1: GLfloat; u2: GLfloat; ustride: GLint; uorder: GLint; v1: GLfloat; v2: GLfloat; vstride: GLint; vorder: GLint; const points: PGLfloat);
    procedure glMapGrid1d(un: GLint; u1: GLdouble; u2: GLdouble);
    procedure glMapGrid1f(un: GLint; u1: GLfloat; u2: GLfloat);
    procedure glMapGrid2d(un: GLint; u1: GLdouble; u2: GLdouble; vn: GLint; v1: GLdouble; v2: GLdouble);
    procedure glMapGrid2f(un: GLint; u1: GLfloat; u2: GLfloat; vn: GLint; v1: GLfloat; v2: GLfloat);
    procedure glEvalCoord1d(u: GLdouble);
    procedure glEvalCoord1dv(const u: PGLdouble);
    procedure glEvalCoord1f(u: GLfloat);
    procedure glEvalCoord1fv(const u: PGLfloat);
    procedure glEvalCoord2d(u: GLdouble; v: GLdouble);
    procedure glEvalCoord2dv(const u: PGLdouble);
    procedure glEvalCoord2f(u: GLfloat; v: GLfloat);
    procedure glEvalCoord2fv(const u: PGLfloat);
    procedure glEvalMesh1(mode: GLenum; i1: GLint; i2: GLint);
    procedure glEvalPoint1(i: GLint);
    procedure glEvalMesh2(mode: GLenum; i1: GLint; i2: GLint; j1: GLint; j2: GLint);
    procedure glEvalPoint2(i: GLint; j: GLint);
    procedure glAlphaFunc(func: GLenum; ref: GLfloat);
    procedure glPixelZoom(xfactor: GLfloat; yfactor: GLfloat);
    procedure glPixelTransferf(pname: GLenum; param: GLfloat);
    procedure glPixelTransferi(pname: GLenum; param: GLint);
    procedure glPixelMapfv(map: GLenum; mapsize: GLsizei; const values: PGLfloat);
    procedure glPixelMapuiv(map: GLenum; mapsize: GLsizei; const values: PGLuint);
    procedure glPixelMapusv(map: GLenum; mapsize: GLsizei; const values: PGLushort);
    procedure glCopyPixels(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; aType: GLenum);
    procedure glDrawPixels(Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glGetClipPlane(plane: GLenum; equation: PGLdouble);
    procedure glGetLightfv(light: GLenum; pname: GLenum; params: PGLfloat);
    procedure glGetLightiv(light: GLenum; pname: GLenum; params: PGLint);
    procedure glGetMapdv(target: GLenum; query: GLenum; v: PGLdouble);
    procedure glGetMapfv(target: GLenum; query: GLenum; v: PGLfloat);
    procedure glGetMapiv(target: GLenum; query: GLenum; v: PGLint);
    procedure glGetMaterialfv(face: GLenum; pname: GLenum; params: PGLfloat);
    procedure glGetMaterialiv(face: GLenum; pname: GLenum; params: PGLint);
    procedure glGetPixelMapfv(map: GLenum; values: PGLfloat);
    procedure glGetPixelMapuiv(map: GLenum; values: PGLuint);
    procedure glGetPixelMapusv(map: GLenum; values: PGLushort);
    procedure glGetPolygonStipple(mask: PGLubyte);
    procedure glGetTexEnvfv(target: GLenum; pname: GLenum; params: PGLfloat);
    procedure glGetTexEnviv(target: GLenum; pname: GLenum; params: PGLint);
    procedure glGetTexGendv(coord: GLenum; pname: GLenum; params: PGLdouble);
    procedure glGetTexGenfv(coord: GLenum; pname: GLenum; params: PGLfloat);
    procedure glGetTexGeniv(coord: GLenum; pname: GLenum; params: PGLint);
    function glIsList(list: GLuint): GLboolean;
    procedure glFrustum(left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble);
    procedure glLoadIdentity();
    procedure glLoadMatrixf(const m: PGLfloat);
    procedure glLoadMatrixd(const m: PGLdouble);
    procedure glMatrixMode(mode: GLenum);
    procedure glMultMatrixf(const m: PGLfloat);
    procedure glMultMatrixd(const m: PGLdouble);
    procedure glOrtho(left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble);
    procedure glPopMatrix();
    procedure glPushMatrix();
    procedure glRotated(angle: GLdouble; x: GLdouble; y: GLdouble; z: GLdouble);
    procedure glRotatef(angle: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat);
    procedure glScaled(x: GLdouble; y: GLdouble; z: GLdouble);
    procedure glScalef(x: GLfloat; y: GLfloat; z: GLfloat);
    procedure glTranslated(x: GLdouble; y: GLdouble; z: GLdouble);
    procedure glTranslatef(x: GLfloat; y: GLfloat; z: GLfloat);
  end;

  TGL_VERSION_1_1 = class(TGL_VERSION_1_0, IGL_VERSION_1_1)
  protected
    FglDrawArrays: procedure(mode: GLenum; First: GLint; Count: GLsizei); cdecl;
    FglDrawElements: procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer); cdecl;
    FglGetPointerv: procedure(pname: GLenum; params: Pointer); cdecl;
    FglPolygonOffset: procedure(factor: GLfloat; units: GLfloat); cdecl;
    FglCopyTexImage1D: procedure(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; border: GLint); cdecl;
    FglCopyTexImage2D: procedure(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; border: GLint); cdecl;
    FglCopyTexSubImage1D: procedure(target: GLenum; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei); cdecl;
    FglCopyTexSubImage2D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); cdecl;
    FglTexSubImage1D: procedure(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglTexSubImage2D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglBindTexture: procedure(target: GLenum; texture: GLuint); cdecl;
    FglDeleteTextures: procedure(n: GLsizei; const textures: PGLuint); cdecl;
    FglGenTextures: procedure(n: GLsizei; textures: PGLuint); cdecl;
    FglIsTexture: function(texture: GLuint): GLboolean; cdecl;
    FglArrayElement: procedure(i: GLint); cdecl;
    FglColorPointer: procedure(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglDisableClientState: procedure(aArray: GLenum); cdecl;
    FglEdgeFlagPointer: procedure(stride: GLsizei; const aPointer: Pointer); cdecl;
    FglEnableClientState: procedure(aArray: GLenum); cdecl;
    FglIndexPointer: procedure(aType: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglInterleavedArrays: procedure(format: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglNormalPointer: procedure(aType: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglTexCoordPointer: procedure(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglVertexPointer: procedure(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglAreTexturesResident: function(n: GLsizei; const textures: PGLuint; residences: PGLboolean): GLboolean; cdecl;
    FglPrioritizeTextures: procedure(n: GLsizei; const textures: PGLuint; const priorities: PGLfloat); cdecl;
    FglIndexub: procedure(c: GLubyte); cdecl;
    FglIndexubv: procedure(const c: PGLubyte); cdecl;
    FglPopClientAttrib: procedure(); cdecl;
    FglPushClientAttrib: procedure(mask: GLbitfield); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glDrawArrays(mode: GLenum; First: GLint; Count: GLsizei);
    procedure glDrawElements(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer);
    procedure glGetPointerv(pname: GLenum; params: Pointer);
    procedure glPolygonOffset(factor: GLfloat; units: GLfloat);
    procedure glCopyTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; border: GLint);
    procedure glCopyTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; border: GLint);
    procedure glCopyTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei);
    procedure glCopyTexSubImage2D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
    procedure glTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glTexSubImage2D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glBindTexture(target: GLenum; texture: GLuint);
    procedure glDeleteTextures(n: GLsizei; const textures: PGLuint);
    procedure glGenTextures(n: GLsizei; textures: PGLuint);
    function glIsTexture(texture: GLuint): GLboolean;
    procedure glArrayElement(i: GLint);
    procedure glColorPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
    procedure glDisableClientState(aArray: GLenum);
    procedure glEdgeFlagPointer(stride: GLsizei; const aPointer: Pointer);
    procedure glEnableClientState(aArray: GLenum);
    procedure glIndexPointer(aType: GLenum; stride: GLsizei; const aPointer: Pointer);
    procedure glInterleavedArrays(format: GLenum; stride: GLsizei; const aPointer: Pointer);
    procedure glNormalPointer(aType: GLenum; stride: GLsizei; const aPointer: Pointer);
    procedure glTexCoordPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
    procedure glVertexPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
    function glAreTexturesResident(n: GLsizei; const textures: PGLuint; residences: PGLboolean): GLboolean;
    procedure glPrioritizeTextures(n: GLsizei; const textures: PGLuint; const priorities: PGLfloat);
    procedure glIndexub(c: GLubyte);
    procedure glIndexubv(const c: PGLubyte);
    procedure glPopClientAttrib();
    procedure glPushClientAttrib(mask: GLbitfield);
  end;

  TGL_VERSION_1_2 = class(TGL_VERSION_1_1, IGL_VERSION_1_2)
  protected
    FglDrawRangeElements: procedure(mode: GLenum; start: GLuint; aEnd: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer); cdecl;
    FglTexImage3D: procedure(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglTexSubImage3D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglCopyTexSubImage3D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glDrawRangeElements(mode: GLenum; start: GLuint; aEnd: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer);
    procedure glTexImage3D(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glTexSubImage3D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glCopyTexSubImage3D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
  end;

  TGL_VERSION_1_3 = class(TGL_VERSION_1_2, IGL_VERSION_1_3)
  protected
    FglActiveTexture: procedure(texture: GLenum); cdecl;
    FglSampleCoverage: procedure(Value: GLfloat; invert: GLboolean); cdecl;
    FglCompressedTexImage3D: procedure(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer); cdecl;
    FglCompressedTexImage2D: procedure(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer); cdecl;
    FglCompressedTexImage1D: procedure(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer); cdecl;
    FglCompressedTexSubImage3D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); cdecl;
    FglCompressedTexSubImage2D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); cdecl;
    FglCompressedTexSubImage1D: procedure(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); cdecl;
    FglGetCompressedTexImage: procedure(target: GLenum; level: GLint; img: Pointer); cdecl;
    FglClientActiveTexture: procedure(texture: GLenum); cdecl;
    FglMultiTexCoord1d: procedure(target: GLenum; s: GLdouble); cdecl;
    FglMultiTexCoord1dv: procedure(target: GLenum; const v: PGLdouble); cdecl;
    FglMultiTexCoord1f: procedure(target: GLenum; s: GLfloat); cdecl;
    FglMultiTexCoord1fv: procedure(target: GLenum; const v: PGLfloat); cdecl;
    FglMultiTexCoord1i: procedure(target: GLenum; s: GLint); cdecl;
    FglMultiTexCoord1iv: procedure(target: GLenum; const v: PGLint); cdecl;
    FglMultiTexCoord1s: procedure(target: GLenum; s: GLshort); cdecl;
    FglMultiTexCoord1sv: procedure(target: GLenum; const v: PGLshort); cdecl;
    FglMultiTexCoord2d: procedure(target: GLenum; s: GLdouble; t: GLdouble); cdecl;
    FglMultiTexCoord2dv: procedure(target: GLenum; const v: PGLdouble); cdecl;
    FglMultiTexCoord2f: procedure(target: GLenum; s: GLfloat; t: GLfloat); cdecl;
    FglMultiTexCoord2fv: procedure(target: GLenum; const v: PGLfloat); cdecl;
    FglMultiTexCoord2i: procedure(target: GLenum; s: GLint; t: GLint); cdecl;
    FglMultiTexCoord2iv: procedure(target: GLenum; const v: PGLint); cdecl;
    FglMultiTexCoord2s: procedure(target: GLenum; s: GLshort; t: GLshort); cdecl;
    FglMultiTexCoord2sv: procedure(target: GLenum; const v: PGLshort); cdecl;
    FglMultiTexCoord3d: procedure(target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble); cdecl;
    FglMultiTexCoord3dv: procedure(target: GLenum; const v: PGLdouble); cdecl;
    FglMultiTexCoord3f: procedure(target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat); cdecl;
    FglMultiTexCoord3fv: procedure(target: GLenum; const v: PGLfloat); cdecl;
    FglMultiTexCoord3i: procedure(target: GLenum; s: GLint; t: GLint; r: GLint); cdecl;
    FglMultiTexCoord3iv: procedure(target: GLenum; const v: PGLint); cdecl;
    FglMultiTexCoord3s: procedure(target: GLenum; s: GLshort; t: GLshort; r: GLshort); cdecl;
    FglMultiTexCoord3sv: procedure(target: GLenum; const v: PGLshort); cdecl;
    FglMultiTexCoord4d: procedure(target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble); cdecl;
    FglMultiTexCoord4dv: procedure(target: GLenum; const v: PGLdouble); cdecl;
    FglMultiTexCoord4f: procedure(target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat); cdecl;
    FglMultiTexCoord4fv: procedure(target: GLenum; const v: PGLfloat); cdecl;
    FglMultiTexCoord4i: procedure(target: GLenum; s: GLint; t: GLint; r: GLint; q: GLint); cdecl;
    FglMultiTexCoord4iv: procedure(target: GLenum; const v: PGLint); cdecl;
    FglMultiTexCoord4s: procedure(target: GLenum; s: GLshort; t: GLshort; r: GLshort; q: GLshort); cdecl;
    FglMultiTexCoord4sv: procedure(target: GLenum; const v: PGLshort); cdecl;
    FglLoadTransposeMatrixf: procedure(const m: PGLfloat); cdecl;
    FglLoadTransposeMatrixd: procedure(const m: PGLdouble); cdecl;
    FglMultTransposeMatrixf: procedure(const m: PGLfloat); cdecl;
    FglMultTransposeMatrixd: procedure(const m: PGLdouble); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glActiveTexture(texture: GLenum);
    procedure glSampleCoverage(Value: GLfloat; invert: GLboolean);
    procedure glCompressedTexImage3D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer);
    procedure glCompressedTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer);
    procedure glCompressedTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer);
    procedure glCompressedTexSubImage3D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
    procedure glCompressedTexSubImage2D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
    procedure glCompressedTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
    procedure glGetCompressedTexImage(target: GLenum; level: GLint; img: Pointer);
    procedure glClientActiveTexture(texture: GLenum);
    procedure glMultiTexCoord1d(target: GLenum; s: GLdouble);
    procedure glMultiTexCoord1dv(target: GLenum; const v: PGLdouble);
    procedure glMultiTexCoord1f(target: GLenum; s: GLfloat);
    procedure glMultiTexCoord1fv(target: GLenum; const v: PGLfloat);
    procedure glMultiTexCoord1i(target: GLenum; s: GLint);
    procedure glMultiTexCoord1iv(target: GLenum; const v: PGLint);
    procedure glMultiTexCoord1s(target: GLenum; s: GLshort);
    procedure glMultiTexCoord1sv(target: GLenum; const v: PGLshort);
    procedure glMultiTexCoord2d(target: GLenum; s: GLdouble; t: GLdouble);
    procedure glMultiTexCoord2dv(target: GLenum; const v: PGLdouble);
    procedure glMultiTexCoord2f(target: GLenum; s: GLfloat; t: GLfloat);
    procedure glMultiTexCoord2fv(target: GLenum; const v: PGLfloat);
    procedure glMultiTexCoord2i(target: GLenum; s: GLint; t: GLint);
    procedure glMultiTexCoord2iv(target: GLenum; const v: PGLint);
    procedure glMultiTexCoord2s(target: GLenum; s: GLshort; t: GLshort);
    procedure glMultiTexCoord2sv(target: GLenum; const v: PGLshort);
    procedure glMultiTexCoord3d(target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble);
    procedure glMultiTexCoord3dv(target: GLenum; const v: PGLdouble);
    procedure glMultiTexCoord3f(target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat);
    procedure glMultiTexCoord3fv(target: GLenum; const v: PGLfloat);
    procedure glMultiTexCoord3i(target: GLenum; s: GLint; t: GLint; r: GLint);
    procedure glMultiTexCoord3iv(target: GLenum; const v: PGLint);
    procedure glMultiTexCoord3s(target: GLenum; s: GLshort; t: GLshort; r: GLshort);
    procedure glMultiTexCoord3sv(target: GLenum; const v: PGLshort);
    procedure glMultiTexCoord4d(target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble);
    procedure glMultiTexCoord4dv(target: GLenum; const v: PGLdouble);
    procedure glMultiTexCoord4f(target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat);
    procedure glMultiTexCoord4fv(target: GLenum; const v: PGLfloat);
    procedure glMultiTexCoord4i(target: GLenum; s: GLint; t: GLint; r: GLint; q: GLint);
    procedure glMultiTexCoord4iv(target: GLenum; const v: PGLint);
    procedure glMultiTexCoord4s(target: GLenum; s: GLshort; t: GLshort; r: GLshort; q: GLshort);
    procedure glMultiTexCoord4sv(target: GLenum; const v: PGLshort);
    procedure glLoadTransposeMatrixf(const m: PGLfloat);
    procedure glLoadTransposeMatrixd(const m: PGLdouble);
    procedure glMultTransposeMatrixf(const m: PGLfloat);
    procedure glMultTransposeMatrixd(const m: PGLdouble);
  end;

  TGL_VERSION_1_4 = class(TGL_VERSION_1_3, IGL_VERSION_1_4)
  protected
    FglBlendFuncSeparate: procedure(sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); cdecl;
    FglMultiDrawArrays: procedure(mode: GLenum; const First: PGLint; const Count: PGLsizei; drawcount: GLsizei); cdecl;
    FglMultiDrawElements: procedure(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: Pointer; drawcount: GLsizei); cdecl;
    FglPointParameterf: procedure(pname: GLenum; param: GLfloat); cdecl;
    FglPointParameterfv: procedure(pname: GLenum; const params: PGLfloat); cdecl;
    FglPointParameteri: procedure(pname: GLenum; param: GLint); cdecl;
    FglPointParameteriv: procedure(pname: GLenum; const params: PGLint); cdecl;
    FglFogCoordf: procedure(coord: GLfloat); cdecl;
    FglFogCoordfv: procedure(const coord: PGLfloat); cdecl;
    FglFogCoordd: procedure(coord: GLdouble); cdecl;
    FglFogCoorddv: procedure(const coord: PGLdouble); cdecl;
    FglFogCoordPointer: procedure(aType: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglSecondaryColor3b: procedure(red: GLbyte; green: GLbyte; blue: GLbyte); cdecl;
    FglSecondaryColor3bv: procedure(const v: PGLbyte); cdecl;
    FglSecondaryColor3d: procedure(red: GLdouble; green: GLdouble; blue: GLdouble); cdecl;
    FglSecondaryColor3dv: procedure(const v: PGLdouble); cdecl;
    FglSecondaryColor3f: procedure(red: GLfloat; green: GLfloat; blue: GLfloat); cdecl;
    FglSecondaryColor3fv: procedure(const v: PGLfloat); cdecl;
    FglSecondaryColor3i: procedure(red: GLint; green: GLint; blue: GLint); cdecl;
    FglSecondaryColor3iv: procedure(const v: PGLint); cdecl;
    FglSecondaryColor3s: procedure(red: GLshort; green: GLshort; blue: GLshort); cdecl;
    FglSecondaryColor3sv: procedure(const v: PGLshort); cdecl;
    FglSecondaryColor3ub: procedure(red: GLubyte; green: GLubyte; blue: GLubyte); cdecl;
    FglSecondaryColor3ubv: procedure(const v: PGLubyte); cdecl;
    FglSecondaryColor3ui: procedure(red: GLuint; green: GLuint; blue: GLuint); cdecl;
    FglSecondaryColor3uiv: procedure(const v: PGLuint); cdecl;
    FglSecondaryColor3us: procedure(red: GLushort; green: GLushort; blue: GLushort); cdecl;
    FglSecondaryColor3usv: procedure(const v: PGLushort); cdecl;
    FglSecondaryColorPointer: procedure(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglWindowPos2d: procedure(x: GLdouble; y: GLdouble); cdecl;
    FglWindowPos2dv: procedure(const v: PGLdouble); cdecl;
    FglWindowPos2f: procedure(x: GLfloat; y: GLfloat); cdecl;
    FglWindowPos2fv: procedure(const v: PGLfloat); cdecl;
    FglWindowPos2i: procedure(x: GLint; y: GLint); cdecl;
    FglWindowPos2iv: procedure(const v: PGLint); cdecl;
    FglWindowPos2s: procedure(x: GLshort; y: GLshort); cdecl;
    FglWindowPos2sv: procedure(const v: PGLshort); cdecl;
    FglWindowPos3d: procedure(x: GLdouble; y: GLdouble; z: GLdouble); cdecl;
    FglWindowPos3dv: procedure(const v: PGLdouble); cdecl;
    FglWindowPos3f: procedure(x: GLfloat; y: GLfloat; z: GLfloat); cdecl;
    FglWindowPos3fv: procedure(const v: PGLfloat); cdecl;
    FglWindowPos3i: procedure(x: GLint; y: GLint; z: GLint); cdecl;
    FglWindowPos3iv: procedure(const v: PGLint); cdecl;
    FglWindowPos3s: procedure(x: GLshort; y: GLshort; z: GLshort); cdecl;
    FglWindowPos3sv: procedure(const v: PGLshort); cdecl;
    FglBlendColor: procedure(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); cdecl;
    FglBlendEquation: procedure(mode: GLenum); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glBlendFuncSeparate(sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum);
    procedure glMultiDrawArrays(mode: GLenum; const First: PGLint; const Count: PGLsizei; drawcount: GLsizei);
    procedure glMultiDrawElements(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: Pointer; drawcount: GLsizei);
    procedure glPointParameterf(pname: GLenum; param: GLfloat);
    procedure glPointParameterfv(pname: GLenum; const params: PGLfloat);
    procedure glPointParameteri(pname: GLenum; param: GLint);
    procedure glPointParameteriv(pname: GLenum; const params: PGLint);
    procedure glFogCoordf(coord: GLfloat);
    procedure glFogCoordfv(const coord: PGLfloat);
    procedure glFogCoordd(coord: GLdouble);
    procedure glFogCoorddv(const coord: PGLdouble);
    procedure glFogCoordPointer(aType: GLenum; stride: GLsizei; const aPointer: Pointer);
    procedure glSecondaryColor3b(red: GLbyte; green: GLbyte; blue: GLbyte);
    procedure glSecondaryColor3bv(const v: PGLbyte);
    procedure glSecondaryColor3d(red: GLdouble; green: GLdouble; blue: GLdouble);
    procedure glSecondaryColor3dv(const v: PGLdouble);
    procedure glSecondaryColor3f(red: GLfloat; green: GLfloat; blue: GLfloat);
    procedure glSecondaryColor3fv(const v: PGLfloat);
    procedure glSecondaryColor3i(red: GLint; green: GLint; blue: GLint);
    procedure glSecondaryColor3iv(const v: PGLint);
    procedure glSecondaryColor3s(red: GLshort; green: GLshort; blue: GLshort);
    procedure glSecondaryColor3sv(const v: PGLshort);
    procedure glSecondaryColor3ub(red: GLubyte; green: GLubyte; blue: GLubyte);
    procedure glSecondaryColor3ubv(const v: PGLubyte);
    procedure glSecondaryColor3ui(red: GLuint; green: GLuint; blue: GLuint);
    procedure glSecondaryColor3uiv(const v: PGLuint);
    procedure glSecondaryColor3us(red: GLushort; green: GLushort; blue: GLushort);
    procedure glSecondaryColor3usv(const v: PGLushort);
    procedure glSecondaryColorPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
    procedure glWindowPos2d(x: GLdouble; y: GLdouble);
    procedure glWindowPos2dv(const v: PGLdouble);
    procedure glWindowPos2f(x: GLfloat; y: GLfloat);
    procedure glWindowPos2fv(const v: PGLfloat);
    procedure glWindowPos2i(x: GLint; y: GLint);
    procedure glWindowPos2iv(const v: PGLint);
    procedure glWindowPos2s(x: GLshort; y: GLshort);
    procedure glWindowPos2sv(const v: PGLshort);
    procedure glWindowPos3d(x: GLdouble; y: GLdouble; z: GLdouble);
    procedure glWindowPos3dv(const v: PGLdouble);
    procedure glWindowPos3f(x: GLfloat; y: GLfloat; z: GLfloat);
    procedure glWindowPos3fv(const v: PGLfloat);
    procedure glWindowPos3i(x: GLint; y: GLint; z: GLint);
    procedure glWindowPos3iv(const v: PGLint);
    procedure glWindowPos3s(x: GLshort; y: GLshort; z: GLshort);
    procedure glWindowPos3sv(const v: PGLshort);
    procedure glBlendColor(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat);
    procedure glBlendEquation(mode: GLenum);
  end;

  TGL_VERSION_1_5 = class(TGL_VERSION_1_4, IGL_VERSION_1_5)
  protected
    FglGenQueries: procedure(n: GLsizei; ids: PGLuint); cdecl;
    FglDeleteQueries: procedure(n: GLsizei; const ids: PGLuint); cdecl;
    FglIsQuery: function(id: GLuint): GLboolean; cdecl;
    FglBeginQuery: procedure(target: GLenum; id: GLuint); cdecl;
    FglEndQuery: procedure(target: GLenum); cdecl;
    FglGetQueryiv: procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGetQueryObjectiv: procedure(id: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetQueryObjectuiv: procedure(id: GLuint; pname: GLenum; params: PGLuint); cdecl;
    FglBindBuffer: procedure(target: GLenum; buffer: GLuint); cdecl;
    FglDeleteBuffers: procedure(n: GLsizei; const buffers: PGLuint); cdecl;
    FglGenBuffers: procedure(n: GLsizei; buffers: PGLuint); cdecl;
    FglIsBuffer: function(buffer: GLuint): GLboolean; cdecl;
    FglBufferData: procedure(target: GLenum; size: GLsizeiptr; const Data: Pointer; usage: GLenum); cdecl;
    FglBufferSubData: procedure(target: GLenum; offset: GLintptr; size: GLsizeiptr; const Data: Pointer); cdecl;
    FglGetBufferSubData: procedure(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: Pointer); cdecl;
    FglMapBuffer: function(target: GLenum; access: GLenum): pointer; cdecl;
    FglUnmapBuffer: function(target: GLenum): GLboolean; cdecl;
    FglGetBufferParameteriv: procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGetBufferPointerv: procedure(target: GLenum; pname: GLenum; params: Pointer); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glGenQueries(n: GLsizei; ids: PGLuint);
    procedure glDeleteQueries(n: GLsizei; const ids: PGLuint);
    function glIsQuery(id: GLuint): GLboolean;
    procedure glBeginQuery(target: GLenum; id: GLuint);
    procedure glEndQuery(target: GLenum);
    procedure glGetQueryiv(target: GLenum; pname: GLenum; params: PGLint);
    procedure glGetQueryObjectiv(id: GLuint; pname: GLenum; params: PGLint);
    procedure glGetQueryObjectuiv(id: GLuint; pname: GLenum; params: PGLuint);
    procedure glBindBuffer(target: GLenum; buffer: GLuint);
    procedure glDeleteBuffers(n: GLsizei; const buffers: PGLuint);
    procedure glGenBuffers(n: GLsizei; buffers: PGLuint);
    function glIsBuffer(buffer: GLuint): GLboolean;
    procedure glBufferData(target: GLenum; size: GLsizeiptr; const Data: Pointer; usage: GLenum);
    procedure glBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; const Data: Pointer);
    procedure glGetBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: Pointer);
    function glMapBuffer(target: GLenum; access: GLenum): pointer;
    function glUnmapBuffer(target: GLenum): GLboolean;
    procedure glGetBufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);
    procedure glGetBufferPointerv(target: GLenum; pname: GLenum; params: Pointer);
  end;

  TGL_VERSION_2_0 = class(TGL_VERSION_1_5, IGL_VERSION_2_0)
  protected
    FglBlendEquationSeparate: procedure(modeRGB: GLenum; modeAlpha: GLenum); cdecl;
    FglDrawBuffers: procedure(n: GLsizei; const bufs: PGLenum); cdecl;
    FglStencilOpSeparate: procedure(face: GLenum; sfail: GLenum; dpfail: GLenum; dppass: GLenum); cdecl;
    FglStencilFuncSeparate: procedure(face: GLenum; func: GLenum; ref: GLint; mask: GLuint); cdecl;
    FglStencilMaskSeparate: procedure(face: GLenum; mask: GLuint); cdecl;
    FglAttachShader: procedure(aProgram: GLuint; shader: GLuint); cdecl;
    FglBindAttribLocation: procedure(aProgram: GLuint; index: GLuint; const Name: PGLchar); cdecl;
    FglCompileShader: procedure(shader: GLuint); cdecl;
    FglCreateProgram: function(): GLuint; cdecl;
    FglCreateShader: function(aType: GLenum): GLuint; cdecl;
    FglDeleteProgram: procedure(aProgram: GLuint); cdecl;
    FglDeleteShader: procedure(shader: GLuint); cdecl;
    FglDetachShader: procedure(aProgram: GLuint; shader: GLuint); cdecl;
    FglDisableVertexAttribArray: procedure(index: GLuint); cdecl;
    FglEnableVertexAttribArray: procedure(index: GLuint); cdecl;
    FglGetActiveAttrib: procedure(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; aType: PGLenum; Name: PGLchar); cdecl;
    FglGetActiveUniform: procedure(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; aType: PGLenum; Name: PGLchar); cdecl;
    FglGetAttachedShaders: procedure(aProgram: GLuint; maxCount: GLsizei; Count: PGLsizei; shaders: PGLuint); cdecl;
    FglGetAttribLocation: function(aProgram: GLuint; const Name: PGLchar): GLint; cdecl;
    FglGetProgramiv: procedure(aProgram: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetProgramInfoLog: procedure(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); cdecl;
    FglGetShaderiv: procedure(shader: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetShaderInfoLog: procedure(shader: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); cdecl;
    FglGetShaderSource: procedure(shader: GLuint; bufSize: GLsizei; length: PGLsizei; Source: PGLchar); cdecl;
    FglGetUniformLocation: function(aProgram: GLuint; const Name: PGLchar): GLint; cdecl;
    FglGetUniformfv: procedure(aProgram: GLuint; location: GLint; params: PGLfloat); cdecl;
    FglGetUniformiv: procedure(aProgram: GLuint; location: GLint; params: PGLint); cdecl;
    FglGetVertexAttribdv: procedure(index: GLuint; pname: GLenum; params: PGLdouble); cdecl;
    FglGetVertexAttribfv: procedure(index: GLuint; pname: GLenum; params: PGLfloat); cdecl;
    FglGetVertexAttribiv: procedure(index: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetVertexAttribPointerv: procedure(index: GLuint; pname: GLenum; aPointer: Pointer); cdecl;
    FglIsProgram: function(aProgram: GLuint): GLboolean; cdecl;
    FglIsShader: function(shader: GLuint): GLboolean; cdecl;
    FglLinkProgram: procedure(aProgram: GLuint); cdecl;
    FglShaderSource: procedure(shader: GLuint; Count: GLsizei; const aString: PGLchar; const length: PGLint); cdecl;
    FglUseProgram: procedure(aProgram: GLuint); cdecl;
    FglUniform1f: procedure(location: GLint; v0: GLfloat); cdecl;
    FglUniform2f: procedure(location: GLint; v0: GLfloat; v1: GLfloat); cdecl;
    FglUniform3f: procedure(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); cdecl;
    FglUniform4f: procedure(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); cdecl;
    FglUniform1i: procedure(location: GLint; v0: GLint); cdecl;
    FglUniform2i: procedure(location: GLint; v0: GLint; v1: GLint); cdecl;
    FglUniform3i: procedure(location: GLint; v0: GLint; v1: GLint; v2: GLint); cdecl;
    FglUniform4i: procedure(location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); cdecl;
    FglUniform1fv: procedure(location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    FglUniform2fv: procedure(location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    FglUniform3fv: procedure(location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    FglUniform4fv: procedure(location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    FglUniform1iv: procedure(location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    FglUniform2iv: procedure(location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    FglUniform3iv: procedure(location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    FglUniform4iv: procedure(location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    FglUniformMatrix2fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglUniformMatrix3fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglUniformMatrix4fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglValidateProgram: procedure(aProgram: GLuint); cdecl;
    FglVertexAttrib1d: procedure(index: GLuint; x: GLdouble); cdecl;
    FglVertexAttrib1dv: procedure(index: GLuint; const v: PGLdouble); cdecl;
    FglVertexAttrib1f: procedure(index: GLuint; x: GLfloat); cdecl;
    FglVertexAttrib1fv: procedure(index: GLuint; const v: PGLfloat); cdecl;
    FglVertexAttrib1s: procedure(index: GLuint; x: GLshort); cdecl;
    FglVertexAttrib1sv: procedure(index: GLuint; const v: PGLshort); cdecl;
    FglVertexAttrib2d: procedure(index: GLuint; x: GLdouble; y: GLdouble); cdecl;
    FglVertexAttrib2dv: procedure(index: GLuint; const v: PGLdouble); cdecl;
    FglVertexAttrib2f: procedure(index: GLuint; x: GLfloat; y: GLfloat); cdecl;
    FglVertexAttrib2fv: procedure(index: GLuint; const v: PGLfloat); cdecl;
    FglVertexAttrib2s: procedure(index: GLuint; x: GLshort; y: GLshort); cdecl;
    FglVertexAttrib2sv: procedure(index: GLuint; const v: PGLshort); cdecl;
    FglVertexAttrib3d: procedure(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); cdecl;
    FglVertexAttrib3dv: procedure(index: GLuint; const v: PGLdouble); cdecl;
    FglVertexAttrib3f: procedure(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat); cdecl;
    FglVertexAttrib3fv: procedure(index: GLuint; const v: PGLfloat); cdecl;
    FglVertexAttrib3s: procedure(index: GLuint; x: GLshort; y: GLshort; z: GLshort); cdecl;
    FglVertexAttrib3sv: procedure(index: GLuint; const v: PGLshort); cdecl;
    FglVertexAttrib4Nbv: procedure(index: GLuint; const v: PGLbyte); cdecl;
    FglVertexAttrib4Niv: procedure(index: GLuint; const v: PGLint); cdecl;
    FglVertexAttrib4Nsv: procedure(index: GLuint; const v: PGLshort); cdecl;
    FglVertexAttrib4Nub: procedure(index: GLuint; x: GLubyte; y: GLubyte; z: GLubyte; w: GLubyte); cdecl;
    FglVertexAttrib4Nubv: procedure(index: GLuint; const v: PGLubyte); cdecl;
    FglVertexAttrib4Nuiv: procedure(index: GLuint; const v: PGLuint); cdecl;
    FglVertexAttrib4Nusv: procedure(index: GLuint; const v: PGLushort); cdecl;
    FglVertexAttrib4bv: procedure(index: GLuint; const v: PGLbyte); cdecl;
    FglVertexAttrib4d: procedure(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); cdecl;
    FglVertexAttrib4dv: procedure(index: GLuint; const v: PGLdouble); cdecl;
    FglVertexAttrib4f: procedure(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); cdecl;
    FglVertexAttrib4fv: procedure(index: GLuint; const v: PGLfloat); cdecl;
    FglVertexAttrib4iv: procedure(index: GLuint; const v: PGLint); cdecl;
    FglVertexAttrib4s: procedure(index: GLuint; x: GLshort; y: GLshort; z: GLshort; w: GLshort); cdecl;
    FglVertexAttrib4sv: procedure(index: GLuint; const v: PGLshort); cdecl;
    FglVertexAttrib4ubv: procedure(index: GLuint; const v: PGLubyte); cdecl;
    FglVertexAttrib4uiv: procedure(index: GLuint; const v: PGLuint); cdecl;
    FglVertexAttrib4usv: procedure(index: GLuint; const v: PGLushort); cdecl;
    FglVertexAttribPointer: procedure(index: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; stride: GLsizei; const aPointer: Pointer); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glBlendEquationSeparate(modeRGB: GLenum; modeAlpha: GLenum);
    procedure glDrawBuffers(n: GLsizei; const bufs: PGLenum);
    procedure glStencilOpSeparate(face: GLenum; sfail: GLenum; dpfail: GLenum; dppass: GLenum);
    procedure glStencilFuncSeparate(face: GLenum; func: GLenum; ref: GLint; mask: GLuint);
    procedure glStencilMaskSeparate(face: GLenum; mask: GLuint);
    procedure glAttachShader(aProgram: GLuint; shader: GLuint);
    procedure glBindAttribLocation(aProgram: GLuint; index: GLuint; const Name: PGLchar);
    procedure glCompileShader(shader: GLuint);
    function glCreateProgram(): GLuint;
    function glCreateShader(aType: GLenum): GLuint;
    procedure glDeleteProgram(aProgram: GLuint);
    procedure glDeleteShader(shader: GLuint);
    procedure glDetachShader(aProgram: GLuint; shader: GLuint);
    procedure glDisableVertexAttribArray(index: GLuint);
    procedure glEnableVertexAttribArray(index: GLuint);
    procedure glGetActiveAttrib(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; aType: PGLenum; Name: PGLchar);
    procedure glGetActiveUniform(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; aType: PGLenum; Name: PGLchar);
    procedure glGetAttachedShaders(aProgram: GLuint; maxCount: GLsizei; Count: PGLsizei; shaders: PGLuint);
    function glGetAttribLocation(aProgram: GLuint; const Name: PGLchar): GLint;
    procedure glGetProgramiv(aProgram: GLuint; pname: GLenum; params: PGLint);
    procedure glGetProgramInfoLog(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar);
    procedure glGetShaderiv(shader: GLuint; pname: GLenum; params: PGLint);
    procedure glGetShaderInfoLog(shader: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar);
    procedure glGetShaderSource(shader: GLuint; bufSize: GLsizei; length: PGLsizei; Source: PGLchar);
    function glGetUniformLocation(aProgram: GLuint; const Name: PGLchar): GLint;
    procedure glGetUniformfv(aProgram: GLuint; location: GLint; params: PGLfloat);
    procedure glGetUniformiv(aProgram: GLuint; location: GLint; params: PGLint);
    procedure glGetVertexAttribdv(index: GLuint; pname: GLenum; params: PGLdouble);
    procedure glGetVertexAttribfv(index: GLuint; pname: GLenum; params: PGLfloat);
    procedure glGetVertexAttribiv(index: GLuint; pname: GLenum; params: PGLint);
    procedure glGetVertexAttribPointerv(index: GLuint; pname: GLenum; aPointer: Pointer);
    function glIsProgram(aProgram: GLuint): GLboolean;
    function glIsShader(shader: GLuint): GLboolean;
    procedure glLinkProgram(aProgram: GLuint);
    procedure glShaderSource(shader: GLuint; Count: GLsizei; const aString: PGLchar; const length: PGLint);
    procedure glUseProgram(aProgram: GLuint);
    procedure glUniform1f(location: GLint; v0: GLfloat);
    procedure glUniform2f(location: GLint; v0: GLfloat; v1: GLfloat);
    procedure glUniform3f(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat);
    procedure glUniform4f(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat);
    procedure glUniform1i(location: GLint; v0: GLint);
    procedure glUniform2i(location: GLint; v0: GLint; v1: GLint);
    procedure glUniform3i(location: GLint; v0: GLint; v1: GLint; v2: GLint);
    procedure glUniform4i(location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint);
    procedure glUniform1fv(location: GLint; Count: GLsizei; const Value: PGLfloat);
    procedure glUniform2fv(location: GLint; Count: GLsizei; const Value: PGLfloat);
    procedure glUniform3fv(location: GLint; Count: GLsizei; const Value: PGLfloat);
    procedure glUniform4fv(location: GLint; Count: GLsizei; const Value: PGLfloat);
    procedure glUniform1iv(location: GLint; Count: GLsizei; const Value: PGLint);
    procedure glUniform2iv(location: GLint; Count: GLsizei; const Value: PGLint);
    procedure glUniform3iv(location: GLint; Count: GLsizei; const Value: PGLint);
    procedure glUniform4iv(location: GLint; Count: GLsizei; const Value: PGLint);
    procedure glUniformMatrix2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glUniformMatrix3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glUniformMatrix4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glValidateProgram(aProgram: GLuint);
    procedure glVertexAttrib1d(index: GLuint; x: GLdouble);
    procedure glVertexAttrib1dv(index: GLuint; const v: PGLdouble);
    procedure glVertexAttrib1f(index: GLuint; x: GLfloat);
    procedure glVertexAttrib1fv(index: GLuint; const v: PGLfloat);
    procedure glVertexAttrib1s(index: GLuint; x: GLshort);
    procedure glVertexAttrib1sv(index: GLuint; const v: PGLshort);
    procedure glVertexAttrib2d(index: GLuint; x: GLdouble; y: GLdouble);
    procedure glVertexAttrib2dv(index: GLuint; const v: PGLdouble);
    procedure glVertexAttrib2f(index: GLuint; x: GLfloat; y: GLfloat);
    procedure glVertexAttrib2fv(index: GLuint; const v: PGLfloat);
    procedure glVertexAttrib2s(index: GLuint; x: GLshort; y: GLshort);
    procedure glVertexAttrib2sv(index: GLuint; const v: PGLshort);
    procedure glVertexAttrib3d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble);
    procedure glVertexAttrib3dv(index: GLuint; const v: PGLdouble);
    procedure glVertexAttrib3f(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat);
    procedure glVertexAttrib3fv(index: GLuint; const v: PGLfloat);
    procedure glVertexAttrib3s(index: GLuint; x: GLshort; y: GLshort; z: GLshort);
    procedure glVertexAttrib3sv(index: GLuint; const v: PGLshort);
    procedure glVertexAttrib4Nbv(index: GLuint; const v: PGLbyte);
    procedure glVertexAttrib4Niv(index: GLuint; const v: PGLint);
    procedure glVertexAttrib4Nsv(index: GLuint; const v: PGLshort);
    procedure glVertexAttrib4Nub(index: GLuint; x: GLubyte; y: GLubyte; z: GLubyte; w: GLubyte);
    procedure glVertexAttrib4Nubv(index: GLuint; const v: PGLubyte);
    procedure glVertexAttrib4Nuiv(index: GLuint; const v: PGLuint);
    procedure glVertexAttrib4Nusv(index: GLuint; const v: PGLushort);
    procedure glVertexAttrib4bv(index: GLuint; const v: PGLbyte);
    procedure glVertexAttrib4d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
    procedure glVertexAttrib4dv(index: GLuint; const v: PGLdouble);
    procedure glVertexAttrib4f(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat);
    procedure glVertexAttrib4fv(index: GLuint; const v: PGLfloat);
    procedure glVertexAttrib4iv(index: GLuint; const v: PGLint);
    procedure glVertexAttrib4s(index: GLuint; x: GLshort; y: GLshort; z: GLshort; w: GLshort);
    procedure glVertexAttrib4sv(index: GLuint; const v: PGLshort);
    procedure glVertexAttrib4ubv(index: GLuint; const v: PGLubyte);
    procedure glVertexAttrib4uiv(index: GLuint; const v: PGLuint);
    procedure glVertexAttrib4usv(index: GLuint; const v: PGLushort);
    procedure glVertexAttribPointer(index: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; stride: GLsizei; const aPointer: Pointer);
  end;

  TGL_VERSION_2_1 = class(TGL_VERSION_2_0, IGL_VERSION_2_1)
  protected
    FglUniformMatrix2x3fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglUniformMatrix3x2fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglUniformMatrix2x4fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglUniformMatrix4x2fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglUniformMatrix3x4fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglUniformMatrix4x3fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glUniformMatrix2x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glUniformMatrix3x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glUniformMatrix2x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glUniformMatrix4x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glUniformMatrix3x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glUniformMatrix4x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
  end;

  TGL_VERSION_3_0 = class(TGL_VERSION_2_1, IGL_VERSION_3_0)
  protected
    FglColorMaski: procedure(index: GLuint; r: GLboolean; g: GLboolean; b: GLboolean; a: GLboolean); cdecl;
    FglGetBooleani_v: procedure(target: GLenum; index: GLuint; Data: PGLboolean); cdecl;
    FglGetIntegeri_v: procedure(target: GLenum; index: GLuint; Data: PGLint); cdecl;
    FglEnablei: procedure(target: GLenum; index: GLuint); cdecl;
    FglDisablei: procedure(target: GLenum; index: GLuint); cdecl;
    FglIsEnabledi: function(target: GLenum; index: GLuint): GLboolean; cdecl;
    FglBeginTransformFeedback: procedure(primitiveMode: GLenum); cdecl;
    FglEndTransformFeedback: procedure(); cdecl;
    FglBindBufferRange: procedure(target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); cdecl;
    FglBindBufferBase: procedure(target: GLenum; index: GLuint; buffer: GLuint); cdecl;
    FglTransformFeedbackVaryings: procedure(aProgram: GLuint; Count: GLsizei; const varyings: PGLchar; bufferMode: GLenum); cdecl;
    FglGetTransformFeedbackVarying: procedure(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; aType: PGLenum; Name: PGLchar); cdecl;
    FglClampColor: procedure(target: GLenum; clamp: GLenum); cdecl;
    FglBeginConditionalRender: procedure(id: GLuint; mode: GLenum); cdecl;
    FglEndConditionalRender: procedure(); cdecl;
    FglVertexAttribIPointer: procedure(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglGetVertexAttribIiv: procedure(index: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetVertexAttribIuiv: procedure(index: GLuint; pname: GLenum; params: PGLuint); cdecl;
    FglVertexAttribI1i: procedure(index: GLuint; x: GLint); cdecl;
    FglVertexAttribI2i: procedure(index: GLuint; x: GLint; y: GLint); cdecl;
    FglVertexAttribI3i: procedure(index: GLuint; x: GLint; y: GLint; z: GLint); cdecl;
    FglVertexAttribI4i: procedure(index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint); cdecl;
    FglVertexAttribI1ui: procedure(index: GLuint; x: GLuint); cdecl;
    FglVertexAttribI2ui: procedure(index: GLuint; x: GLuint; y: GLuint); cdecl;
    FglVertexAttribI3ui: procedure(index: GLuint; x: GLuint; y: GLuint; z: GLuint); cdecl;
    FglVertexAttribI4ui: procedure(index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint); cdecl;
    FglVertexAttribI1iv: procedure(index: GLuint; const v: PGLint); cdecl;
    FglVertexAttribI2iv: procedure(index: GLuint; const v: PGLint); cdecl;
    FglVertexAttribI3iv: procedure(index: GLuint; const v: PGLint); cdecl;
    FglVertexAttribI4iv: procedure(index: GLuint; const v: PGLint); cdecl;
    FglVertexAttribI1uiv: procedure(index: GLuint; const v: PGLuint); cdecl;
    FglVertexAttribI2uiv: procedure(index: GLuint; const v: PGLuint); cdecl;
    FglVertexAttribI3uiv: procedure(index: GLuint; const v: PGLuint); cdecl;
    FglVertexAttribI4uiv: procedure(index: GLuint; const v: PGLuint); cdecl;
    FglVertexAttribI4bv: procedure(index: GLuint; const v: PGLbyte); cdecl;
    FglVertexAttribI4sv: procedure(index: GLuint; const v: PGLshort); cdecl;
    FglVertexAttribI4ubv: procedure(index: GLuint; const v: PGLubyte); cdecl;
    FglVertexAttribI4usv: procedure(index: GLuint; const v: PGLushort); cdecl;
    FglGetUniformuiv: procedure(aProgram: GLuint; location: GLint; params: PGLuint); cdecl;
    FglBindFragDataLocation: procedure(aProgram: GLuint; color: GLuint; const Name: PGLchar); cdecl;
    FglGetFragDataLocation: function(aProgram: GLuint; const Name: PGLchar): GLint; cdecl;
    FglUniform1ui: procedure(location: GLint; v0: GLuint); cdecl;
    FglUniform2ui: procedure(location: GLint; v0: GLuint; v1: GLuint); cdecl;
    FglUniform3ui: procedure(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); cdecl;
    FglUniform4ui: procedure(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); cdecl;
    FglUniform1uiv: procedure(location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    FglUniform2uiv: procedure(location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    FglUniform3uiv: procedure(location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    FglUniform4uiv: procedure(location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    FglTexParameterIiv: procedure(target: GLenum; pname: GLenum; const params: PGLint); cdecl;
    FglTexParameterIuiv: procedure(target: GLenum; pname: GLenum; const params: PGLuint); cdecl;
    FglGetTexParameterIiv: procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGetTexParameterIuiv: procedure(target: GLenum; pname: GLenum; params: PGLuint); cdecl;
    FglClearBufferiv: procedure(buffer: GLenum; drawbuffer: GLint; const Value: PGLint); cdecl;
    FglClearBufferuiv: procedure(buffer: GLenum; drawbuffer: GLint; const Value: PGLuint); cdecl;
    FglClearBufferfv: procedure(buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat); cdecl;
    FglClearBufferfi: procedure(buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); cdecl;
    FglGetStringi: function(Name: GLenum; index: GLuint): PGLubyte; cdecl;
    FglIsRenderbuffer: function(renderbuffer: GLuint): GLboolean; cdecl;
    FglBindRenderbuffer: procedure(target: GLenum; renderbuffer: GLuint); cdecl;
    FglDeleteRenderbuffers: procedure(n: GLsizei; const renderbuffers: PGLuint); cdecl;
    FglGenRenderbuffers: procedure(n: GLsizei; renderbuffers: PGLuint); cdecl;
    FglRenderbufferStorage: procedure(target: GLenum; internalformat: GLenum; Width: GLsizei; Height: GLsizei); cdecl;
    FglGetRenderbufferParameteriv: procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglIsFramebuffer: function(framebuffer: GLuint): GLboolean; cdecl;
    FglBindFramebuffer: procedure(target: GLenum; framebuffer: GLuint); cdecl;
    FglDeleteFramebuffers: procedure(n: GLsizei; const framebuffers: PGLuint); cdecl;
    FglGenFramebuffers: procedure(n: GLsizei; framebuffers: PGLuint); cdecl;
    FglCheckFramebufferStatus: function(target: GLenum): GLenum; cdecl;
    FglFramebufferTexture1D: procedure(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); cdecl;
    FglFramebufferTexture2D: procedure(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); cdecl;
    FglFramebufferTexture3D: procedure(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; zoffset: GLint); cdecl;
    FglFramebufferRenderbuffer: procedure(target: GLenum; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); cdecl;
    FglGetFramebufferAttachmentParameteriv: procedure(target: GLenum; attachment: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGenerateMipmap: procedure(target: GLenum); cdecl;
    FglBlitFramebuffer: procedure(srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); cdecl;
    FglRenderbufferStorageMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); cdecl;
    FglFramebufferTextureLayer: procedure(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); cdecl;
    FglMapBufferRange: function(target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): pointer; cdecl;
    FglFlushMappedBufferRange: procedure(target: GLenum; offset: GLintptr; length: GLsizeiptr); cdecl;
    FglBindVertexArray: procedure(aArray: GLuint); cdecl;
    FglDeleteVertexArrays: procedure(n: GLsizei; const arrays: PGLuint); cdecl;
    FglGenVertexArrays: procedure(n: GLsizei; arrays: PGLuint); cdecl;
    FglIsVertexArray: function(aArray: GLuint): GLboolean; cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glColorMaski(index: GLuint; r: GLboolean; g: GLboolean; b: GLboolean; a: GLboolean);
    procedure glGetBooleani_v(target: GLenum; index: GLuint; Data: PGLboolean);
    procedure glGetIntegeri_v(target: GLenum; index: GLuint; Data: PGLint);
    procedure glEnablei(target: GLenum; index: GLuint);
    procedure glDisablei(target: GLenum; index: GLuint);
    function glIsEnabledi(target: GLenum; index: GLuint): GLboolean;
    procedure glBeginTransformFeedback(primitiveMode: GLenum);
    procedure glEndTransformFeedback();
    procedure glBindBufferRange(target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
    procedure glBindBufferBase(target: GLenum; index: GLuint; buffer: GLuint);
    procedure glTransformFeedbackVaryings(aProgram: GLuint; Count: GLsizei; const varyings: PGLchar; bufferMode: GLenum);
    procedure glGetTransformFeedbackVarying(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; aType: PGLenum; Name: PGLchar);
    procedure glClampColor(target: GLenum; clamp: GLenum);
    procedure glBeginConditionalRender(id: GLuint; mode: GLenum);
    procedure glEndConditionalRender();
    procedure glVertexAttribIPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
    procedure glGetVertexAttribIiv(index: GLuint; pname: GLenum; params: PGLint);
    procedure glGetVertexAttribIuiv(index: GLuint; pname: GLenum; params: PGLuint);
    procedure glVertexAttribI1i(index: GLuint; x: GLint);
    procedure glVertexAttribI2i(index: GLuint; x: GLint; y: GLint);
    procedure glVertexAttribI3i(index: GLuint; x: GLint; y: GLint; z: GLint);
    procedure glVertexAttribI4i(index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint);
    procedure glVertexAttribI1ui(index: GLuint; x: GLuint);
    procedure glVertexAttribI2ui(index: GLuint; x: GLuint; y: GLuint);
    procedure glVertexAttribI3ui(index: GLuint; x: GLuint; y: GLuint; z: GLuint);
    procedure glVertexAttribI4ui(index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint);
    procedure glVertexAttribI1iv(index: GLuint; const v: PGLint);
    procedure glVertexAttribI2iv(index: GLuint; const v: PGLint);
    procedure glVertexAttribI3iv(index: GLuint; const v: PGLint);
    procedure glVertexAttribI4iv(index: GLuint; const v: PGLint);
    procedure glVertexAttribI1uiv(index: GLuint; const v: PGLuint);
    procedure glVertexAttribI2uiv(index: GLuint; const v: PGLuint);
    procedure glVertexAttribI3uiv(index: GLuint; const v: PGLuint);
    procedure glVertexAttribI4uiv(index: GLuint; const v: PGLuint);
    procedure glVertexAttribI4bv(index: GLuint; const v: PGLbyte);
    procedure glVertexAttribI4sv(index: GLuint; const v: PGLshort);
    procedure glVertexAttribI4ubv(index: GLuint; const v: PGLubyte);
    procedure glVertexAttribI4usv(index: GLuint; const v: PGLushort);
    procedure glGetUniformuiv(aProgram: GLuint; location: GLint; params: PGLuint);
    procedure glBindFragDataLocation(aProgram: GLuint; color: GLuint; const Name: PGLchar);
    function glGetFragDataLocation(aProgram: GLuint; const Name: PGLchar): GLint;
    procedure glUniform1ui(location: GLint; v0: GLuint);
    procedure glUniform2ui(location: GLint; v0: GLuint; v1: GLuint);
    procedure glUniform3ui(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint);
    procedure glUniform4ui(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint);
    procedure glUniform1uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
    procedure glUniform2uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
    procedure glUniform3uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
    procedure glUniform4uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
    procedure glTexParameterIiv(target: GLenum; pname: GLenum; const params: PGLint);
    procedure glTexParameterIuiv(target: GLenum; pname: GLenum; const params: PGLuint);
    procedure glGetTexParameterIiv(target: GLenum; pname: GLenum; params: PGLint);
    procedure glGetTexParameterIuiv(target: GLenum; pname: GLenum; params: PGLuint);
    procedure glClearBufferiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLint);
    procedure glClearBufferuiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLuint);
    procedure glClearBufferfv(buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat);
    procedure glClearBufferfi(buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint);
    function glGetStringi(Name: GLenum; index: GLuint): PGLubyte;
    function glIsRenderbuffer(renderbuffer: GLuint): GLboolean;
    procedure glBindRenderbuffer(target: GLenum; renderbuffer: GLuint);
    procedure glDeleteRenderbuffers(n: GLsizei; const renderbuffers: PGLuint);
    procedure glGenRenderbuffers(n: GLsizei; renderbuffers: PGLuint);
    procedure glRenderbufferStorage(target: GLenum; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
    procedure glGetRenderbufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);
    function glIsFramebuffer(framebuffer: GLuint): GLboolean;
    procedure glBindFramebuffer(target: GLenum; framebuffer: GLuint);
    procedure glDeleteFramebuffers(n: GLsizei; const framebuffers: PGLuint);
    procedure glGenFramebuffers(n: GLsizei; framebuffers: PGLuint);
    function glCheckFramebufferStatus(target: GLenum): GLenum;
    procedure glFramebufferTexture1D(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint);
    procedure glFramebufferTexture2D(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint);
    procedure glFramebufferTexture3D(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; zoffset: GLint);
    procedure glFramebufferRenderbuffer(target: GLenum; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint);
    procedure glGetFramebufferAttachmentParameteriv(target: GLenum; attachment: GLenum; pname: GLenum; params: PGLint);
    procedure glGenerateMipmap(target: GLenum);
    procedure glBlitFramebuffer(srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum);
    procedure glRenderbufferStorageMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
    procedure glFramebufferTextureLayer(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint);
    function glMapBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): pointer;
    procedure glFlushMappedBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr);
    procedure glBindVertexArray(aArray: GLuint);
    procedure glDeleteVertexArrays(n: GLsizei; const arrays: PGLuint);
    procedure glGenVertexArrays(n: GLsizei; arrays: PGLuint);
    function glIsVertexArray(aArray: GLuint): GLboolean;
  end;

  TGL_VERSION_3_1 = class(TGL_VERSION_3_0, IGL_VERSION_3_1)
  protected
    FglDrawArraysInstanced: procedure(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei); cdecl;
    FglDrawElementsInstanced: procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei); cdecl;
    FglTexBuffer: procedure(target: GLenum; internalformat: GLenum; buffer: GLuint); cdecl;
    FglPrimitiveRestartIndex: procedure(index: GLuint); cdecl;
    FglCopyBufferSubData: procedure(readTarget: GLenum; writeTarget: GLenum; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); cdecl;
    FglGetUniformIndices: procedure(aProgram: GLuint; uniformCount: GLsizei; const uniformNames: PGLchar; uniformIndices: PGLuint); cdecl;
    FglGetActiveUniformsiv: procedure(aProgram: GLuint; uniformCount: GLsizei; const uniformIndices: PGLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetActiveUniformName: procedure(aProgram: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar); cdecl;
    FglGetUniformBlockIndex: function(aProgram: GLuint; const uniformBlockName: PGLchar): GLuint; cdecl;
    FglGetActiveUniformBlockiv: procedure(aProgram: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetActiveUniformBlockName: procedure(aProgram: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar); cdecl;
    FglUniformBlockBinding: procedure(aProgram: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glDrawArraysInstanced(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei);
    procedure glDrawElementsInstanced(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei);
    procedure glTexBuffer(target: GLenum; internalformat: GLenum; buffer: GLuint);
    procedure glPrimitiveRestartIndex(index: GLuint);
    procedure glCopyBufferSubData(readTarget: GLenum; writeTarget: GLenum; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr);
    procedure glGetUniformIndices(aProgram: GLuint; uniformCount: GLsizei; const uniformNames: PGLchar; uniformIndices: PGLuint);
    procedure glGetActiveUniformsiv(aProgram: GLuint; uniformCount: GLsizei; const uniformIndices: PGLuint; pname: GLenum; params: PGLint);
    procedure glGetActiveUniformName(aProgram: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar);
    function glGetUniformBlockIndex(aProgram: GLuint; const uniformBlockName: PGLchar): GLuint;
    procedure glGetActiveUniformBlockiv(aProgram: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint);
    procedure glGetActiveUniformBlockName(aProgram: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar);
    procedure glUniformBlockBinding(aProgram: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint);
  end;

  TGL_VERSION_3_2 = class(TGL_VERSION_3_1, IGL_VERSION_3_2)
  protected
    FglDrawElementsBaseVertex: procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); cdecl;
    FglDrawRangeElementsBaseVertex: procedure(mode: GLenum; start: GLuint; aEnd: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); cdecl;
    FglDrawElementsInstancedBaseVertex: procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint); cdecl;
    FglMultiDrawElementsBaseVertex: procedure(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: Pointer; drawcount: GLsizei; const basevertex: PGLint); cdecl;
    FglProvokingVertex: procedure(mode: GLenum); cdecl;
    FglFenceSync: function(condition: GLenum; flags: GLbitfield): GLsync; cdecl;
    FglIsSync: function(sync: GLsync): GLboolean; cdecl;
    FglDeleteSync: procedure(sync: GLsync); cdecl;
    FglClientWaitSync: function(sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum; cdecl;
    FglWaitSync: procedure(sync: GLsync; flags: GLbitfield; timeout: GLuint64); cdecl;
    FglGetInteger64v: procedure(pname: GLenum; Data: PGLint64); cdecl;
    FglGetSynciv: procedure(sync: GLsync; pname: GLenum; Count: GLsizei; length: PGLsizei; values: PGLint); cdecl;
    FglGetInteger64i_v: procedure(target: GLenum; index: GLuint; Data: PGLint64); cdecl;
    FglGetBufferParameteri64v: procedure(target: GLenum; pname: GLenum; params: PGLint64); cdecl;
    FglFramebufferTexture: procedure(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint); cdecl;
    FglTexImage2DMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    FglTexImage3DMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    FglGetMultisamplefv: procedure(pname: GLenum; index: GLuint; val: PGLfloat); cdecl;
    FglSampleMaski: procedure(maskNumber: GLuint; mask: GLbitfield); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glDrawElementsBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint);
    procedure glDrawRangeElementsBaseVertex(mode: GLenum; start: GLuint; aEnd: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint);
    procedure glDrawElementsInstancedBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint);
    procedure glMultiDrawElementsBaseVertex(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: Pointer; drawcount: GLsizei; const basevertex: PGLint);
    procedure glProvokingVertex(mode: GLenum);
    function glFenceSync(condition: GLenum; flags: GLbitfield): GLsync;
    function glIsSync(sync: GLsync): GLboolean;
    procedure glDeleteSync(sync: GLsync);
    function glClientWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum;
    procedure glWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64);
    procedure glGetInteger64v(pname: GLenum; Data: PGLint64);
    procedure glGetSynciv(sync: GLsync; pname: GLenum; Count: GLsizei; length: PGLsizei; values: PGLint);
    procedure glGetInteger64i_v(target: GLenum; index: GLuint; Data: PGLint64);
    procedure glGetBufferParameteri64v(target: GLenum; pname: GLenum; params: PGLint64);
    procedure glFramebufferTexture(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint);
    procedure glTexImage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean);
    procedure glTexImage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean);
    procedure glGetMultisamplefv(pname: GLenum; index: GLuint; val: PGLfloat);
    procedure glSampleMaski(maskNumber: GLuint; mask: GLbitfield);
  end;

  TGL_VERSION_3_3 = class(TGL_VERSION_3_2, IGL_VERSION_3_3)
  protected
    FglBindFragDataLocationIndexed: procedure(aProgram: GLuint; colorNumber: GLuint; index: GLuint; const Name: PGLchar); cdecl;
    FglGetFragDataIndex: function(aProgram: GLuint; const Name: PGLchar): GLint; cdecl;
    FglGenSamplers: procedure(Count: GLsizei; samplers: PGLuint); cdecl;
    FglDeleteSamplers: procedure(Count: GLsizei; const samplers: PGLuint); cdecl;
    FglIsSampler: function(sampler: GLuint): GLboolean; cdecl;
    FglBindSampler: procedure(aUnit: GLuint; sampler: GLuint); cdecl;
    FglSamplerParameteri: procedure(sampler: GLuint; pname: GLenum; param: GLint); cdecl;
    FglSamplerParameteriv: procedure(sampler: GLuint; pname: GLenum; const param: PGLint); cdecl;
    FglSamplerParameterf: procedure(sampler: GLuint; pname: GLenum; param: GLfloat); cdecl;
    FglSamplerParameterfv: procedure(sampler: GLuint; pname: GLenum; const param: PGLfloat); cdecl;
    FglSamplerParameterIiv: procedure(sampler: GLuint; pname: GLenum; const param: PGLint); cdecl;
    FglSamplerParameterIuiv: procedure(sampler: GLuint; pname: GLenum; const param: PGLuint); cdecl;
    FglGetSamplerParameteriv: procedure(sampler: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetSamplerParameterIiv: procedure(sampler: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetSamplerParameterfv: procedure(sampler: GLuint; pname: GLenum; params: PGLfloat); cdecl;
    FglGetSamplerParameterIuiv: procedure(sampler: GLuint; pname: GLenum; params: PGLuint); cdecl;
    FglQueryCounter: procedure(id: GLuint; target: GLenum); cdecl;
    FglGetQueryObjecti64v: procedure(id: GLuint; pname: GLenum; params: PGLint64); cdecl;
    FglGetQueryObjectui64v: procedure(id: GLuint; pname: GLenum; params: PGLuint64); cdecl;
    FglVertexAttribDivisor: procedure(index: GLuint; divisor: GLuint); cdecl;
    FglVertexAttribP1ui: procedure(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); cdecl;
    FglVertexAttribP1uiv: procedure(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); cdecl;
    FglVertexAttribP2ui: procedure(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); cdecl;
    FglVertexAttribP2uiv: procedure(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); cdecl;
    FglVertexAttribP3ui: procedure(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); cdecl;
    FglVertexAttribP3uiv: procedure(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); cdecl;
    FglVertexAttribP4ui: procedure(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); cdecl;
    FglVertexAttribP4uiv: procedure(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); cdecl;
    FglVertexP2ui: procedure(aType: GLenum; Value: GLuint); cdecl;
    FglVertexP2uiv: procedure(aType: GLenum; const Value: PGLuint); cdecl;
    FglVertexP3ui: procedure(aType: GLenum; Value: GLuint); cdecl;
    FglVertexP3uiv: procedure(aType: GLenum; const Value: PGLuint); cdecl;
    FglVertexP4ui: procedure(aType: GLenum; Value: GLuint); cdecl;
    FglVertexP4uiv: procedure(aType: GLenum; const Value: PGLuint); cdecl;
    FglTexCoordP1ui: procedure(aType: GLenum; coords: GLuint); cdecl;
    FglTexCoordP1uiv: procedure(aType: GLenum; const coords: PGLuint); cdecl;
    FglTexCoordP2ui: procedure(aType: GLenum; coords: GLuint); cdecl;
    FglTexCoordP2uiv: procedure(aType: GLenum; const coords: PGLuint); cdecl;
    FglTexCoordP3ui: procedure(aType: GLenum; coords: GLuint); cdecl;
    FglTexCoordP3uiv: procedure(aType: GLenum; const coords: PGLuint); cdecl;
    FglTexCoordP4ui: procedure(aType: GLenum; coords: GLuint); cdecl;
    FglTexCoordP4uiv: procedure(aType: GLenum; const coords: PGLuint); cdecl;
    FglMultiTexCoordP1ui: procedure(texture: GLenum; aType: GLenum; coords: GLuint); cdecl;
    FglMultiTexCoordP1uiv: procedure(texture: GLenum; aType: GLenum; const coords: PGLuint); cdecl;
    FglMultiTexCoordP2ui: procedure(texture: GLenum; aType: GLenum; coords: GLuint); cdecl;
    FglMultiTexCoordP2uiv: procedure(texture: GLenum; aType: GLenum; const coords: PGLuint); cdecl;
    FglMultiTexCoordP3ui: procedure(texture: GLenum; aType: GLenum; coords: GLuint); cdecl;
    FglMultiTexCoordP3uiv: procedure(texture: GLenum; aType: GLenum; const coords: PGLuint); cdecl;
    FglMultiTexCoordP4ui: procedure(texture: GLenum; aType: GLenum; coords: GLuint); cdecl;
    FglMultiTexCoordP4uiv: procedure(texture: GLenum; aType: GLenum; const coords: PGLuint); cdecl;
    FglNormalP3ui: procedure(aType: GLenum; coords: GLuint); cdecl;
    FglNormalP3uiv: procedure(aType: GLenum; const coords: PGLuint); cdecl;
    FglColorP3ui: procedure(aType: GLenum; color: GLuint); cdecl;
    FglColorP3uiv: procedure(aType: GLenum; const color: PGLuint); cdecl;
    FglColorP4ui: procedure(aType: GLenum; color: GLuint); cdecl;
    FglColorP4uiv: procedure(aType: GLenum; const color: PGLuint); cdecl;
    FglSecondaryColorP3ui: procedure(aType: GLenum; color: GLuint); cdecl;
    FglSecondaryColorP3uiv: procedure(aType: GLenum; const color: PGLuint); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glBindFragDataLocationIndexed(aProgram: GLuint; colorNumber: GLuint; index: GLuint; const Name: PGLchar);
    function glGetFragDataIndex(aProgram: GLuint; const Name: PGLchar): GLint;
    procedure glGenSamplers(Count: GLsizei; samplers: PGLuint);
    procedure glDeleteSamplers(Count: GLsizei; const samplers: PGLuint);
    function glIsSampler(sampler: GLuint): GLboolean;
    procedure glBindSampler(aUnit: GLuint; sampler: GLuint);
    procedure glSamplerParameteri(sampler: GLuint; pname: GLenum; param: GLint);
    procedure glSamplerParameteriv(sampler: GLuint; pname: GLenum; const param: PGLint);
    procedure glSamplerParameterf(sampler: GLuint; pname: GLenum; param: GLfloat);
    procedure glSamplerParameterfv(sampler: GLuint; pname: GLenum; const param: PGLfloat);
    procedure glSamplerParameterIiv(sampler: GLuint; pname: GLenum; const param: PGLint);
    procedure glSamplerParameterIuiv(sampler: GLuint; pname: GLenum; const param: PGLuint);
    procedure glGetSamplerParameteriv(sampler: GLuint; pname: GLenum; params: PGLint);
    procedure glGetSamplerParameterIiv(sampler: GLuint; pname: GLenum; params: PGLint);
    procedure glGetSamplerParameterfv(sampler: GLuint; pname: GLenum; params: PGLfloat);
    procedure glGetSamplerParameterIuiv(sampler: GLuint; pname: GLenum; params: PGLuint);
    procedure glQueryCounter(id: GLuint; target: GLenum);
    procedure glGetQueryObjecti64v(id: GLuint; pname: GLenum; params: PGLint64);
    procedure glGetQueryObjectui64v(id: GLuint; pname: GLenum; params: PGLuint64);
    procedure glVertexAttribDivisor(index: GLuint; divisor: GLuint);
    procedure glVertexAttribP1ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
    procedure glVertexAttribP1uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
    procedure glVertexAttribP2ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
    procedure glVertexAttribP2uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
    procedure glVertexAttribP3ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
    procedure glVertexAttribP3uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
    procedure glVertexAttribP4ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
    procedure glVertexAttribP4uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
    procedure glVertexP2ui(aType: GLenum; Value: GLuint);
    procedure glVertexP2uiv(aType: GLenum; const Value: PGLuint);
    procedure glVertexP3ui(aType: GLenum; Value: GLuint);
    procedure glVertexP3uiv(aType: GLenum; const Value: PGLuint);
    procedure glVertexP4ui(aType: GLenum; Value: GLuint);
    procedure glVertexP4uiv(aType: GLenum; const Value: PGLuint);
    procedure glTexCoordP1ui(aType: GLenum; coords: GLuint);
    procedure glTexCoordP1uiv(aType: GLenum; const coords: PGLuint);
    procedure glTexCoordP2ui(aType: GLenum; coords: GLuint);
    procedure glTexCoordP2uiv(aType: GLenum; const coords: PGLuint);
    procedure glTexCoordP3ui(aType: GLenum; coords: GLuint);
    procedure glTexCoordP3uiv(aType: GLenum; const coords: PGLuint);
    procedure glTexCoordP4ui(aType: GLenum; coords: GLuint);
    procedure glTexCoordP4uiv(aType: GLenum; const coords: PGLuint);
    procedure glMultiTexCoordP1ui(texture: GLenum; aType: GLenum; coords: GLuint);
    procedure glMultiTexCoordP1uiv(texture: GLenum; aType: GLenum; const coords: PGLuint);
    procedure glMultiTexCoordP2ui(texture: GLenum; aType: GLenum; coords: GLuint);
    procedure glMultiTexCoordP2uiv(texture: GLenum; aType: GLenum; const coords: PGLuint);
    procedure glMultiTexCoordP3ui(texture: GLenum; aType: GLenum; coords: GLuint);
    procedure glMultiTexCoordP3uiv(texture: GLenum; aType: GLenum; const coords: PGLuint);
    procedure glMultiTexCoordP4ui(texture: GLenum; aType: GLenum; coords: GLuint);
    procedure glMultiTexCoordP4uiv(texture: GLenum; aType: GLenum; const coords: PGLuint);
    procedure glNormalP3ui(aType: GLenum; coords: GLuint);
    procedure glNormalP3uiv(aType: GLenum; const coords: PGLuint);
    procedure glColorP3ui(aType: GLenum; color: GLuint);
    procedure glColorP3uiv(aType: GLenum; const color: PGLuint);
    procedure glColorP4ui(aType: GLenum; color: GLuint);
    procedure glColorP4uiv(aType: GLenum; const color: PGLuint);
    procedure glSecondaryColorP3ui(aType: GLenum; color: GLuint);
    procedure glSecondaryColorP3uiv(aType: GLenum; const color: PGLuint);
  end;

  TGL_VERSION_4_0 = class(TGL_VERSION_3_3, IGL_VERSION_4_0)
  protected
    FglMinSampleShading: procedure(Value: GLfloat); cdecl;
    FglBlendEquationi: procedure(buf: GLuint; mode: GLenum); cdecl;
    FglBlendEquationSeparatei: procedure(buf: GLuint; modeRGB: GLenum; modeAlpha: GLenum); cdecl;
    FglBlendFunci: procedure(buf: GLuint; src: GLenum; dst: GLenum); cdecl;
    FglBlendFuncSeparatei: procedure(buf: GLuint; srcRGB: GLenum; dstRGB: GLenum; srcAlpha: GLenum; dstAlpha: GLenum); cdecl;
    FglDrawArraysIndirect: procedure(mode: GLenum; const indirect: Pointer); cdecl;
    FglDrawElementsIndirect: procedure(mode: GLenum; aType: GLenum; const indirect: Pointer); cdecl;
    FglUniform1d: procedure(location: GLint; x: GLdouble); cdecl;
    FglUniform2d: procedure(location: GLint; x: GLdouble; y: GLdouble); cdecl;
    FglUniform3d: procedure(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble); cdecl;
    FglUniform4d: procedure(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); cdecl;
    FglUniform1dv: procedure(location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    FglUniform2dv: procedure(location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    FglUniform3dv: procedure(location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    FglUniform4dv: procedure(location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    FglUniformMatrix2dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglUniformMatrix3dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglUniformMatrix4dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglUniformMatrix2x3dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglUniformMatrix2x4dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglUniformMatrix3x2dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglUniformMatrix3x4dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglUniformMatrix4x2dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglUniformMatrix4x3dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglGetUniformdv: procedure(aProgram: GLuint; location: GLint; params: PGLdouble); cdecl;
    FglGetSubroutineUniformLocation: function(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLint; cdecl;
    FglGetSubroutineIndex: function(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLuint; cdecl;
    FglGetActiveSubroutineUniformiv: procedure(aProgram: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint); cdecl;
    FglGetActiveSubroutineUniformName: procedure(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); cdecl;
    FglGetActiveSubroutineName: procedure(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); cdecl;
    FglUniformSubroutinesuiv: procedure(shadertype: GLenum; Count: GLsizei; const indices: PGLuint); cdecl;
    FglGetUniformSubroutineuiv: procedure(shadertype: GLenum; location: GLint; params: PGLuint); cdecl;
    FglGetProgramStageiv: procedure(aProgram: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint); cdecl;
    FglPatchParameteri: procedure(pname: GLenum; Value: GLint); cdecl;
    FglPatchParameterfv: procedure(pname: GLenum; const values: PGLfloat); cdecl;
    FglBindTransformFeedback: procedure(target: GLenum; id: GLuint); cdecl;
    FglDeleteTransformFeedbacks: procedure(n: GLsizei; const ids: PGLuint); cdecl;
    FglGenTransformFeedbacks: procedure(n: GLsizei; ids: PGLuint); cdecl;
    FglIsTransformFeedback: function(id: GLuint): GLboolean; cdecl;
    FglPauseTransformFeedback: procedure(); cdecl;
    FglResumeTransformFeedback: procedure(); cdecl;
    FglDrawTransformFeedback: procedure(mode: GLenum; id: GLuint); cdecl;
    FglDrawTransformFeedbackStream: procedure(mode: GLenum; id: GLuint; stream: GLuint); cdecl;
    FglBeginQueryIndexed: procedure(target: GLenum; index: GLuint; id: GLuint); cdecl;
    FglEndQueryIndexed: procedure(target: GLenum; index: GLuint); cdecl;
    FglGetQueryIndexediv: procedure(target: GLenum; index: GLuint; pname: GLenum; params: PGLint); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glMinSampleShading(Value: GLfloat);
    procedure glBlendEquationi(buf: GLuint; mode: GLenum);
    procedure glBlendEquationSeparatei(buf: GLuint; modeRGB: GLenum; modeAlpha: GLenum);
    procedure glBlendFunci(buf: GLuint; src: GLenum; dst: GLenum);
    procedure glBlendFuncSeparatei(buf: GLuint; srcRGB: GLenum; dstRGB: GLenum; srcAlpha: GLenum; dstAlpha: GLenum);
    procedure glDrawArraysIndirect(mode: GLenum; const indirect: Pointer);
    procedure glDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer);
    procedure glUniform1d(location: GLint; x: GLdouble);
    procedure glUniform2d(location: GLint; x: GLdouble; y: GLdouble);
    procedure glUniform3d(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble);
    procedure glUniform4d(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
    procedure glUniform1dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
    procedure glUniform2dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
    procedure glUniform3dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
    procedure glUniform4dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
    procedure glUniformMatrix2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glUniformMatrix3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glUniformMatrix4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glUniformMatrix2x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glUniformMatrix2x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glUniformMatrix3x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glUniformMatrix3x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glUniformMatrix4x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glUniformMatrix4x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glGetUniformdv(aProgram: GLuint; location: GLint; params: PGLdouble);
    function glGetSubroutineUniformLocation(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLint;
    function glGetSubroutineIndex(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLuint;
    procedure glGetActiveSubroutineUniformiv(aProgram: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint);
    procedure glGetActiveSubroutineUniformName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar);
    procedure glGetActiveSubroutineName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar);
    procedure glUniformSubroutinesuiv(shadertype: GLenum; Count: GLsizei; const indices: PGLuint);
    procedure glGetUniformSubroutineuiv(shadertype: GLenum; location: GLint; params: PGLuint);
    procedure glGetProgramStageiv(aProgram: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint);
    procedure glPatchParameteri(pname: GLenum; Value: GLint);
    procedure glPatchParameterfv(pname: GLenum; const values: PGLfloat);
    procedure glBindTransformFeedback(target: GLenum; id: GLuint);
    procedure glDeleteTransformFeedbacks(n: GLsizei; const ids: PGLuint);
    procedure glGenTransformFeedbacks(n: GLsizei; ids: PGLuint);
    function glIsTransformFeedback(id: GLuint): GLboolean;
    procedure glPauseTransformFeedback();
    procedure glResumeTransformFeedback();
    procedure glDrawTransformFeedback(mode: GLenum; id: GLuint);
    procedure glDrawTransformFeedbackStream(mode: GLenum; id: GLuint; stream: GLuint);
    procedure glBeginQueryIndexed(target: GLenum; index: GLuint; id: GLuint);
    procedure glEndQueryIndexed(target: GLenum; index: GLuint);
    procedure glGetQueryIndexediv(target: GLenum; index: GLuint; pname: GLenum; params: PGLint);
  end;

  TGL_VERSION_4_1 = class(TGL_VERSION_4_0, IGL_VERSION_4_1)
  protected
    FglReleaseShaderCompiler: procedure(); cdecl;
    FglShaderBinary: procedure(Count: GLsizei; const shaders: PGLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); cdecl;
    FglGetShaderPrecisionFormat: procedure(shadertype: GLenum; precisiontype: GLenum; range: PGLint; precision: PGLint); cdecl;
    FglDepthRangef: procedure(n: GLfloat; f: GLfloat); cdecl;
    FglClearDepthf: procedure(d: GLfloat); cdecl;
    FglGetProgramBinary: procedure(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer); cdecl;
    FglProgramBinary: procedure(aProgram: GLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); cdecl;
    FglProgramParameteri: procedure(aProgram: GLuint; pname: GLenum; Value: GLint); cdecl;
    FglUseProgramStages: procedure(pipeline: GLuint; stages: GLbitfield; aProgram: GLuint); cdecl;
    FglActiveShaderProgram: procedure(pipeline: GLuint; aProgram: GLuint); cdecl;
    FglCreateShaderProgramv: function(aType: GLenum; Count: GLsizei; const strings: PGLchar): GLuint; cdecl;
    FglBindProgramPipeline: procedure(pipeline: GLuint); cdecl;
    FglDeleteProgramPipelines: procedure(n: GLsizei; const pipelines: PGLuint); cdecl;
    FglGenProgramPipelines: procedure(n: GLsizei; pipelines: PGLuint); cdecl;
    FglIsProgramPipeline: function(pipeline: GLuint): GLboolean; cdecl;
    FglGetProgramPipelineiv: procedure(pipeline: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglProgramUniform1i: procedure(aProgram: GLuint; location: GLint; v0: GLint); cdecl;
    FglProgramUniform1iv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    FglProgramUniform1f: procedure(aProgram: GLuint; location: GLint; v0: GLfloat); cdecl;
    FglProgramUniform1fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    FglProgramUniform1d: procedure(aProgram: GLuint; location: GLint; v0: GLdouble); cdecl;
    FglProgramUniform1dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    FglProgramUniform1ui: procedure(aProgram: GLuint; location: GLint; v0: GLuint); cdecl;
    FglProgramUniform1uiv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    FglProgramUniform2i: procedure(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint); cdecl;
    FglProgramUniform2iv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    FglProgramUniform2f: procedure(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat); cdecl;
    FglProgramUniform2fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    FglProgramUniform2d: procedure(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble); cdecl;
    FglProgramUniform2dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    FglProgramUniform2ui: procedure(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint); cdecl;
    FglProgramUniform2uiv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    FglProgramUniform3i: procedure(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint); cdecl;
    FglProgramUniform3iv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    FglProgramUniform3f: procedure(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); cdecl;
    FglProgramUniform3fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    FglProgramUniform3d: procedure(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble); cdecl;
    FglProgramUniform3dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    FglProgramUniform3ui: procedure(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); cdecl;
    FglProgramUniform3uiv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    FglProgramUniform4i: procedure(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); cdecl;
    FglProgramUniform4iv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    FglProgramUniform4f: procedure(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); cdecl;
    FglProgramUniform4fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    FglProgramUniform4d: procedure(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble; v3: GLdouble); cdecl;
    FglProgramUniform4dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    FglProgramUniform4ui: procedure(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); cdecl;
    FglProgramUniform4uiv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    FglProgramUniformMatrix2fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglProgramUniformMatrix3fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglProgramUniformMatrix4fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglProgramUniformMatrix2dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglProgramUniformMatrix3dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglProgramUniformMatrix4dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglProgramUniformMatrix2x3fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglProgramUniformMatrix3x2fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglProgramUniformMatrix2x4fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglProgramUniformMatrix4x2fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglProgramUniformMatrix3x4fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglProgramUniformMatrix4x3fv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    FglProgramUniformMatrix2x3dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglProgramUniformMatrix3x2dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglProgramUniformMatrix2x4dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglProgramUniformMatrix4x2dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglProgramUniformMatrix3x4dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglProgramUniformMatrix4x3dv: procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    FglValidateProgramPipeline: procedure(pipeline: GLuint); cdecl;
    FglGetProgramPipelineInfoLog: procedure(pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); cdecl;
    FglVertexAttribL1d: procedure(index: GLuint; x: GLdouble); cdecl;
    FglVertexAttribL2d: procedure(index: GLuint; x: GLdouble; y: GLdouble); cdecl;
    FglVertexAttribL3d: procedure(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); cdecl;
    FglVertexAttribL4d: procedure(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); cdecl;
    FglVertexAttribL1dv: procedure(index: GLuint; const v: PGLdouble); cdecl;
    FglVertexAttribL2dv: procedure(index: GLuint; const v: PGLdouble); cdecl;
    FglVertexAttribL3dv: procedure(index: GLuint; const v: PGLdouble); cdecl;
    FglVertexAttribL4dv: procedure(index: GLuint; const v: PGLdouble); cdecl;
    FglVertexAttribLPointer: procedure(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer); cdecl;
    FglGetVertexAttribLdv: procedure(index: GLuint; pname: GLenum; params: PGLdouble); cdecl;
    FglViewportArrayv: procedure(First: GLuint; Count: GLsizei; const v: PGLfloat); cdecl;
    FglViewportIndexedf: procedure(index: GLuint; x: GLfloat; y: GLfloat; w: GLfloat; h: GLfloat); cdecl;
    FglViewportIndexedfv: procedure(index: GLuint; const v: PGLfloat); cdecl;
    FglScissorArrayv: procedure(First: GLuint; Count: GLsizei; const v: PGLint); cdecl;
    FglScissorIndexed: procedure(index: GLuint; left: GLint; bottom: GLint; Width: GLsizei; Height: GLsizei); cdecl;
    FglScissorIndexedv: procedure(index: GLuint; const v: PGLint); cdecl;
    FglDepthRangeArrayv: procedure(First: GLuint; Count: GLsizei; const v: PGLdouble); cdecl;
    FglDepthRangeIndexed: procedure(index: GLuint; n: GLdouble; f: GLdouble); cdecl;
    FglGetFloati_v: procedure(target: GLenum; index: GLuint; Data: PGLfloat); cdecl;
    FglGetDoublei_v: procedure(target: GLenum; index: GLuint; Data: PGLdouble); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glReleaseShaderCompiler();
    procedure glShaderBinary(Count: GLsizei; const shaders: PGLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei);
    procedure glGetShaderPrecisionFormat(shadertype: GLenum; precisiontype: GLenum; range: PGLint; precision: PGLint);
    procedure glDepthRangef(n: GLfloat; f: GLfloat);
    procedure glClearDepthf(d: GLfloat);
    procedure glGetProgramBinary(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer);
    procedure glProgramBinary(aProgram: GLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei);
    procedure glProgramParameteri(aProgram: GLuint; pname: GLenum; Value: GLint);
    procedure glUseProgramStages(pipeline: GLuint; stages: GLbitfield; aProgram: GLuint);
    procedure glActiveShaderProgram(pipeline: GLuint; aProgram: GLuint);
    function glCreateShaderProgramv(aType: GLenum; Count: GLsizei; const strings: PGLchar): GLuint;
    procedure glBindProgramPipeline(pipeline: GLuint);
    procedure glDeleteProgramPipelines(n: GLsizei; const pipelines: PGLuint);
    procedure glGenProgramPipelines(n: GLsizei; pipelines: PGLuint);
    function glIsProgramPipeline(pipeline: GLuint): GLboolean;
    procedure glGetProgramPipelineiv(pipeline: GLuint; pname: GLenum; params: PGLint);
    procedure glProgramUniform1i(aProgram: GLuint; location: GLint; v0: GLint);
    procedure glProgramUniform1iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
    procedure glProgramUniform1f(aProgram: GLuint; location: GLint; v0: GLfloat);
    procedure glProgramUniform1fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
    procedure glProgramUniform1d(aProgram: GLuint; location: GLint; v0: GLdouble);
    procedure glProgramUniform1dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
    procedure glProgramUniform1ui(aProgram: GLuint; location: GLint; v0: GLuint);
    procedure glProgramUniform1uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
    procedure glProgramUniform2i(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint);
    procedure glProgramUniform2iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
    procedure glProgramUniform2f(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat);
    procedure glProgramUniform2fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
    procedure glProgramUniform2d(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble);
    procedure glProgramUniform2dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
    procedure glProgramUniform2ui(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint);
    procedure glProgramUniform2uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
    procedure glProgramUniform3i(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint);
    procedure glProgramUniform3iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
    procedure glProgramUniform3f(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat);
    procedure glProgramUniform3fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
    procedure glProgramUniform3d(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble);
    procedure glProgramUniform3dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
    procedure glProgramUniform3ui(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint);
    procedure glProgramUniform3uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
    procedure glProgramUniform4i(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint);
    procedure glProgramUniform4iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
    procedure glProgramUniform4f(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat);
    procedure glProgramUniform4fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
    procedure glProgramUniform4d(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble; v3: GLdouble);
    procedure glProgramUniform4dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
    procedure glProgramUniform4ui(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint);
    procedure glProgramUniform4uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
    procedure glProgramUniformMatrix2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glProgramUniformMatrix3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glProgramUniformMatrix4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glProgramUniformMatrix2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glProgramUniformMatrix3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glProgramUniformMatrix4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glProgramUniformMatrix2x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glProgramUniformMatrix3x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glProgramUniformMatrix2x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glProgramUniformMatrix4x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glProgramUniformMatrix3x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glProgramUniformMatrix4x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    procedure glProgramUniformMatrix2x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glProgramUniformMatrix3x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glProgramUniformMatrix2x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glProgramUniformMatrix4x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glProgramUniformMatrix3x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glProgramUniformMatrix4x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
    procedure glValidateProgramPipeline(pipeline: GLuint);
    procedure glGetProgramPipelineInfoLog(pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar);
    procedure glVertexAttribL1d(index: GLuint; x: GLdouble);
    procedure glVertexAttribL2d(index: GLuint; x: GLdouble; y: GLdouble);
    procedure glVertexAttribL3d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble);
    procedure glVertexAttribL4d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
    procedure glVertexAttribL1dv(index: GLuint; const v: PGLdouble);
    procedure glVertexAttribL2dv(index: GLuint; const v: PGLdouble);
    procedure glVertexAttribL3dv(index: GLuint; const v: PGLdouble);
    procedure glVertexAttribL4dv(index: GLuint; const v: PGLdouble);
    procedure glVertexAttribLPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
    procedure glGetVertexAttribLdv(index: GLuint; pname: GLenum; params: PGLdouble);
    procedure glViewportArrayv(First: GLuint; Count: GLsizei; const v: PGLfloat);
    procedure glViewportIndexedf(index: GLuint; x: GLfloat; y: GLfloat; w: GLfloat; h: GLfloat);
    procedure glViewportIndexedfv(index: GLuint; const v: PGLfloat);
    procedure glScissorArrayv(First: GLuint; Count: GLsizei; const v: PGLint);
    procedure glScissorIndexed(index: GLuint; left: GLint; bottom: GLint; Width: GLsizei; Height: GLsizei);
    procedure glScissorIndexedv(index: GLuint; const v: PGLint);
    procedure glDepthRangeArrayv(First: GLuint; Count: GLsizei; const v: PGLdouble);
    procedure glDepthRangeIndexed(index: GLuint; n: GLdouble; f: GLdouble);
    procedure glGetFloati_v(target: GLenum; index: GLuint; Data: PGLfloat);
    procedure glGetDoublei_v(target: GLenum; index: GLuint; Data: PGLdouble);
  end;

  TGL_VERSION_4_2 = class(TGL_VERSION_4_1, IGL_VERSION_4_2)
  protected
    FglDrawArraysInstancedBaseInstance: procedure(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei; baseinstance: GLuint); cdecl;
    FglDrawElementsInstancedBaseInstance: procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; baseinstance: GLuint); cdecl;
    FglDrawElementsInstancedBaseVertexBaseInstance: procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint); cdecl;
    FglGetInternalformativ: procedure(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint); cdecl;
    FglGetActiveAtomicCounterBufferiv: procedure(aProgram: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglBindImageTexture: procedure(aUnit: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum); cdecl;
    FglMemoryBarrier: procedure(barriers: GLbitfield); cdecl;
    FglTexStorage1D: procedure(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei); cdecl;
    FglTexStorage2D: procedure(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); cdecl;
    FglTexStorage3D: procedure(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei); cdecl;
    FglDrawTransformFeedbackInstanced: procedure(mode: GLenum; id: GLuint; instancecount: GLsizei); cdecl;
    FglDrawTransformFeedbackStreamInstanced: procedure(mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glDrawArraysInstancedBaseInstance(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei; baseinstance: GLuint);
    procedure glDrawElementsInstancedBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; baseinstance: GLuint);
    procedure glDrawElementsInstancedBaseVertexBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint);
    procedure glGetInternalformativ(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint);
    procedure glGetActiveAtomicCounterBufferiv(aProgram: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint);
    procedure glBindImageTexture(aUnit: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum);
    procedure glMemoryBarrier(barriers: GLbitfield);
    procedure glTexStorage1D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei);
    procedure glTexStorage2D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
    procedure glTexStorage3D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei);
    procedure glDrawTransformFeedbackInstanced(mode: GLenum; id: GLuint; instancecount: GLsizei);
    procedure glDrawTransformFeedbackStreamInstanced(mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei);
  end;

  TGL_VERSION_4_3 = class(TGL_VERSION_4_2, IGL_VERSION_4_3)
  protected
    FglClearBufferData: procedure(target: GLenum; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;
    FglClearBufferSubData: procedure(target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;
    FglDispatchCompute: procedure(num_groups_x: GLuint; num_groups_y: GLuint; num_groups_z: GLuint); cdecl;
    FglDispatchComputeIndirect: procedure(indirect: GLintptr); cdecl;
    FglCopyImageSubData: procedure(srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei; srcHeight: GLsizei; srcDepth: GLsizei); cdecl;
    FglFramebufferParameteri: procedure(target: GLenum; pname: GLenum; param: GLint); cdecl;
    FglGetFramebufferParameteriv: procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGetInternalformati64v: procedure(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint64); cdecl;
    FglInvalidateTexSubImage: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei); cdecl;
    FglInvalidateTexImage: procedure(texture: GLuint; level: GLint); cdecl;
    FglInvalidateBufferSubData: procedure(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); cdecl;
    FglInvalidateBufferData: procedure(buffer: GLuint); cdecl;
    FglInvalidateFramebuffer: procedure(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum); cdecl;
    FglInvalidateSubFramebuffer: procedure(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); cdecl;
    FglMultiDrawArraysIndirect: procedure(mode: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei); cdecl;
    FglMultiDrawElementsIndirect: procedure(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei); cdecl;
    FglGetProgramInterfaceiv: procedure(aProgram: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglGetProgramResourceIndex: function(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLuint; cdecl;
    FglGetProgramResourceName: procedure(aProgram: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); cdecl;
    FglGetProgramResourceiv: procedure(aProgram: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; const props: PGLenum; Count: GLsizei; length: PGLsizei; params: PGLint); cdecl;
    FglGetProgramResourceLocation: function(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; cdecl;
    FglGetProgramResourceLocationIndex: function(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; cdecl;
    FglShaderStorageBlockBinding: procedure(aProgram: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint); cdecl;
    FglTexBufferRange: procedure(target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); cdecl;
    FglTexStorage2DMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    FglTexStorage3DMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    FglTextureView: procedure(texture: GLuint; target: GLenum; origtexture: GLuint; internalformat: GLenum; minlevel: GLuint; numlevels: GLuint; minlayer: GLuint; numlayers: GLuint); cdecl;
    FglBindVertexBuffer: procedure(bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); cdecl;
    FglVertexAttribFormat: procedure(attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); cdecl;
    FglVertexAttribIFormat: procedure(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); cdecl;
    FglVertexAttribLFormat: procedure(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); cdecl;
    FglVertexAttribBinding: procedure(attribindex: GLuint; bindingindex: GLuint); cdecl;
    FglVertexBindingDivisor: procedure(bindingindex: GLuint; divisor: GLuint); cdecl;
    FglDebugMessageControl: procedure(Source: GLenum; aType: GLenum; severity: GLenum; Count: GLsizei; const ids: PGLuint; Enabled: GLboolean); cdecl;
    FglDebugMessageInsert: procedure(Source: GLenum; aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const buf: PGLchar); cdecl;
    FglDebugMessageCallback: procedure(callback: GLDEBUGPROC; const userParam: Pointer); cdecl;
    FglGetDebugMessageLog: function(Count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint; cdecl;
    FglPushDebugGroup: procedure(Source: GLenum; id: GLuint; length: GLsizei; const message: PGLchar); cdecl;
    FglPopDebugGroup: procedure(); cdecl;
    FglObjectLabel: procedure(identifier: GLenum; Name: GLuint; length: GLsizei; const aLabel: PGLchar); cdecl;
    FglGetObjectLabel: procedure(identifier: GLenum; Name: GLuint; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); cdecl;
    FglObjectPtrLabel: procedure(const ptr: Pointer; length: GLsizei; const aLabel: PGLchar); cdecl;
    FglGetObjectPtrLabel: procedure(const ptr: Pointer; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glClearBufferData(target: GLenum; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer);
    procedure glClearBufferSubData(target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer);
    procedure glDispatchCompute(num_groups_x: GLuint; num_groups_y: GLuint; num_groups_z: GLuint);
    procedure glDispatchComputeIndirect(indirect: GLintptr);
    procedure glCopyImageSubData(srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei; srcHeight: GLsizei; srcDepth: GLsizei);
    procedure glFramebufferParameteri(target: GLenum; pname: GLenum; param: GLint);
    procedure glGetFramebufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);
    procedure glGetInternalformati64v(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint64);
    procedure glInvalidateTexSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei);
    procedure glInvalidateTexImage(texture: GLuint; level: GLint);
    procedure glInvalidateBufferSubData(buffer: GLuint; offset: GLintptr; length: GLsizeiptr);
    procedure glInvalidateBufferData(buffer: GLuint);
    procedure glInvalidateFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum);
    procedure glInvalidateSubFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
    procedure glMultiDrawArraysIndirect(mode: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei);
    procedure glMultiDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei);
    procedure glGetProgramInterfaceiv(aProgram: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint);
    function glGetProgramResourceIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLuint;
    procedure glGetProgramResourceName(aProgram: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar);
    procedure glGetProgramResourceiv(aProgram: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; const props: PGLenum; Count: GLsizei; length: PGLsizei; params: PGLint);
    function glGetProgramResourceLocation(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint;
    function glGetProgramResourceLocationIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint;
    procedure glShaderStorageBlockBinding(aProgram: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint);
    procedure glTexBufferRange(target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
    procedure glTexStorage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean);
    procedure glTexStorage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean);
    procedure glTextureView(texture: GLuint; target: GLenum; origtexture: GLuint; internalformat: GLenum; minlevel: GLuint; numlevels: GLuint; minlayer: GLuint; numlayers: GLuint);
    procedure glBindVertexBuffer(bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei);
    procedure glVertexAttribFormat(attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint);
    procedure glVertexAttribIFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
    procedure glVertexAttribLFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
    procedure glVertexAttribBinding(attribindex: GLuint; bindingindex: GLuint);
    procedure glVertexBindingDivisor(bindingindex: GLuint; divisor: GLuint);
    procedure glDebugMessageControl(Source: GLenum; aType: GLenum; severity: GLenum; Count: GLsizei; const ids: PGLuint; Enabled: GLboolean);
    procedure glDebugMessageInsert(Source: GLenum; aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const buf: PGLchar);
    procedure glDebugMessageCallback(callback: GLDEBUGPROC; const userParam: Pointer);
    function glGetDebugMessageLog(Count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint;
    procedure glPushDebugGroup(Source: GLenum; id: GLuint; length: GLsizei; const message: PGLchar);
    procedure glPopDebugGroup();
    procedure glObjectLabel(identifier: GLenum; Name: GLuint; length: GLsizei; const aLabel: PGLchar);
    procedure glGetObjectLabel(identifier: GLenum; Name: GLuint; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar);
    procedure glObjectPtrLabel(const ptr: Pointer; length: GLsizei; const aLabel: PGLchar);
    procedure glGetObjectPtrLabel(const ptr: Pointer; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar);
  end;

  TGL_VERSION_4_4 = class(TGL_VERSION_4_3, IGL_VERSION_4_4)
  protected
    FglBufferStorage: procedure(target: GLenum; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); cdecl;
    FglClearTexImage: procedure(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;
    FglClearTexSubImage: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;
    FglBindBuffersBase: procedure(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint); cdecl;
    FglBindBuffersRange: procedure(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const sizes: PGLsizeiptr); cdecl;
    FglBindTextures: procedure(First: GLuint; Count: GLsizei; const textures: PGLuint); cdecl;
    FglBindSamplers: procedure(First: GLuint; Count: GLsizei; const samplers: PGLuint); cdecl;
    FglBindImageTextures: procedure(First: GLuint; Count: GLsizei; const textures: PGLuint); cdecl;
    FglBindVertexBuffers: procedure(First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glBufferStorage(target: GLenum; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield);
    procedure glClearTexImage(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; const Data: Pointer);
    procedure glClearTexSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const Data: Pointer);
    procedure glBindBuffersBase(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint);
    procedure glBindBuffersRange(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const sizes: PGLsizeiptr);
    procedure glBindTextures(First: GLuint; Count: GLsizei; const textures: PGLuint);
    procedure glBindSamplers(First: GLuint; Count: GLsizei; const samplers: PGLuint);
    procedure glBindImageTextures(First: GLuint; Count: GLsizei; const textures: PGLuint);
    procedure glBindVertexBuffers(First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei);
  end;

  TGL_VERSION_4_5 = class(TGL_VERSION_4_4, IGL_VERSION_4_5)
  protected
    FglClipControl: procedure(origin: GLenum; depth: GLenum); cdecl;
    FglCreateTransformFeedbacks: procedure(n: GLsizei; ids: PGLuint); cdecl;
    FglTransformFeedbackBufferBase: procedure(xfb: GLuint; index: GLuint; buffer: GLuint); cdecl;
    FglTransformFeedbackBufferRange: procedure(xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); cdecl;
    FglGetTransformFeedbackiv: procedure(xfb: GLuint; pname: GLenum; param: PGLint); cdecl;
    FglGetTransformFeedbacki_v: procedure(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint); cdecl;
    FglGetTransformFeedbacki64_v: procedure(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64); cdecl;
    FglCreateBuffers: procedure(n: GLsizei; buffers: PGLuint); cdecl;
    FglNamedBufferStorage: procedure(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); cdecl;
    FglNamedBufferData: procedure(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; usage: GLenum); cdecl;
    FglNamedBufferSubData: procedure(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; const Data: Pointer); cdecl;
    FglCopyNamedBufferSubData: procedure(readBuffer: GLuint; writeBuffer: GLuint; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); cdecl;
    FglClearNamedBufferData: procedure(buffer: GLuint; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;
    FglClearNamedBufferSubData: procedure(buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;
    FglMapNamedBuffer: function(buffer: GLuint; access: GLenum): pointer; cdecl;
    FglMapNamedBufferRange: function(buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): pointer; cdecl;
    FglUnmapNamedBuffer: function(buffer: GLuint): GLboolean; cdecl;
    FglFlushMappedNamedBufferRange: procedure(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); cdecl;
    FglGetNamedBufferParameteriv: procedure(buffer: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetNamedBufferParameteri64v: procedure(buffer: GLuint; pname: GLenum; params: PGLint64); cdecl;
    FglGetNamedBufferPointerv: procedure(buffer: GLuint; pname: GLenum; params: Pointer); cdecl;
    FglGetNamedBufferSubData: procedure(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer); cdecl;
    FglCreateFramebuffers: procedure(n: GLsizei; framebuffers: PGLuint); cdecl;
    FglNamedFramebufferRenderbuffer: procedure(framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); cdecl;
    FglNamedFramebufferParameteri: procedure(framebuffer: GLuint; pname: GLenum; param: GLint); cdecl;
    FglNamedFramebufferTexture: procedure(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint); cdecl;
    FglNamedFramebufferTextureLayer: procedure(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); cdecl;
    FglNamedFramebufferDrawBuffer: procedure(framebuffer: GLuint; buf: GLenum); cdecl;
    FglNamedFramebufferDrawBuffers: procedure(framebuffer: GLuint; n: GLsizei; const bufs: PGLenum); cdecl;
    FglNamedFramebufferReadBuffer: procedure(framebuffer: GLuint; src: GLenum); cdecl;
    FglInvalidateNamedFramebufferData: procedure(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum); cdecl;
    FglInvalidateNamedFramebufferSubData: procedure(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); cdecl;
    FglClearNamedFramebufferiv: procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLint); cdecl;
    FglClearNamedFramebufferuiv: procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLuint); cdecl;
    FglClearNamedFramebufferfv: procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat); cdecl;
    FglClearNamedFramebufferfi: procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); cdecl;
    FglBlitNamedFramebuffer: procedure(readFramebuffer: GLuint; drawFramebuffer: GLuint; srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); cdecl;
    FglCheckNamedFramebufferStatus: function(framebuffer: GLuint; target: GLenum): GLenum; cdecl;
    FglGetNamedFramebufferParameteriv: procedure(framebuffer: GLuint; pname: GLenum; param: PGLint); cdecl;
    FglGetNamedFramebufferAttachmentParameteriv: procedure(framebuffer: GLuint; attachment: GLenum; pname: GLenum; params: PGLint); cdecl;
    FglCreateRenderbuffers: procedure(n: GLsizei; renderbuffers: PGLuint); cdecl;
    FglNamedRenderbufferStorage: procedure(renderbuffer: GLuint; internalformat: GLenum; Width: GLsizei; Height: GLsizei); cdecl;
    FglNamedRenderbufferStorageMultisample: procedure(renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); cdecl;
    FglGetNamedRenderbufferParameteriv: procedure(renderbuffer: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglCreateTextures: procedure(target: GLenum; n: GLsizei; textures: PGLuint); cdecl;
    FglTextureBuffer: procedure(texture: GLuint; internalformat: GLenum; buffer: GLuint); cdecl;
    FglTextureBufferRange: procedure(texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); cdecl;
    FglTextureStorage1D: procedure(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei); cdecl;
    FglTextureStorage2D: procedure(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); cdecl;
    FglTextureStorage3D: procedure(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei); cdecl;
    FglTextureStorage2DMultisample: procedure(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    FglTextureStorage3DMultisample: procedure(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    FglTextureSubImage1D: procedure(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglTextureSubImage2D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglTextureSubImage3D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer); cdecl;
    FglCompressedTextureSubImage1D: procedure(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); cdecl;
    FglCompressedTextureSubImage2D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); cdecl;
    FglCompressedTextureSubImage3D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); cdecl;
    FglCopyTextureSubImage1D: procedure(texture: GLuint; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei); cdecl;
    FglCopyTextureSubImage2D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); cdecl;
    FglCopyTextureSubImage3D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); cdecl;
    FglTextureParameterf: procedure(texture: GLuint; pname: GLenum; param: GLfloat); cdecl;
    FglTextureParameterfv: procedure(texture: GLuint; pname: GLenum; const param: PGLfloat); cdecl;
    FglTextureParameteri: procedure(texture: GLuint; pname: GLenum; param: GLint); cdecl;
    FglTextureParameterIiv: procedure(texture: GLuint; pname: GLenum; const params: PGLint); cdecl;
    FglTextureParameterIuiv: procedure(texture: GLuint; pname: GLenum; const params: PGLuint); cdecl;
    FglTextureParameteriv: procedure(texture: GLuint; pname: GLenum; const param: PGLint); cdecl;
    FglGenerateTextureMipmap: procedure(texture: GLuint); cdecl;
    FglBindTextureUnit: procedure(aUnit: GLuint; texture: GLuint); cdecl;
    FglGetTextureImage: procedure(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer); cdecl;
    FglGetCompressedTextureImage: procedure(texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer); cdecl;
    FglGetTextureLevelParameterfv: procedure(texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat); cdecl;
    FglGetTextureLevelParameteriv: procedure(texture: GLuint; level: GLint; pname: GLenum; params: PGLint); cdecl;
    FglGetTextureParameterfv: procedure(texture: GLuint; pname: GLenum; params: PGLfloat); cdecl;
    FglGetTextureParameterIiv: procedure(texture: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglGetTextureParameterIuiv: procedure(texture: GLuint; pname: GLenum; params: PGLuint); cdecl;
    FglGetTextureParameteriv: procedure(texture: GLuint; pname: GLenum; params: PGLint); cdecl;
    FglCreateVertexArrays: procedure(n: GLsizei; arrays: PGLuint); cdecl;
    FglDisableVertexArrayAttrib: procedure(vaobj: GLuint; index: GLuint); cdecl;
    FglEnableVertexArrayAttrib: procedure(vaobj: GLuint; index: GLuint); cdecl;
    FglVertexArrayElementBuffer: procedure(vaobj: GLuint; buffer: GLuint); cdecl;
    FglVertexArrayVertexBuffer: procedure(vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); cdecl;
    FglVertexArrayVertexBuffers: procedure(vaobj: GLuint; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); cdecl;
    FglVertexArrayAttribBinding: procedure(vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint); cdecl;
    FglVertexArrayAttribFormat: procedure(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); cdecl;
    FglVertexArrayAttribIFormat: procedure(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); cdecl;
    FglVertexArrayAttribLFormat: procedure(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); cdecl;
    FglVertexArrayBindingDivisor: procedure(vaobj: GLuint; bindingindex: GLuint; divisor: GLuint); cdecl;
    FglGetVertexArrayiv: procedure(vaobj: GLuint; pname: GLenum; param: PGLint); cdecl;
    FglGetVertexArrayIndexediv: procedure(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint); cdecl;
    FglGetVertexArrayIndexed64iv: procedure(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64); cdecl;
    FglCreateSamplers: procedure(n: GLsizei; samplers: PGLuint); cdecl;
    FglCreateProgramPipelines: procedure(n: GLsizei; pipelines: PGLuint); cdecl;
    FglCreateQueries: procedure(target: GLenum; n: GLsizei; ids: PGLuint); cdecl;
    FglGetQueryBufferObjecti64v: procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); cdecl;
    FglGetQueryBufferObjectiv: procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); cdecl;
    FglGetQueryBufferObjectui64v: procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); cdecl;
    FglGetQueryBufferObjectuiv: procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); cdecl;
    FglMemoryBarrierByRegion: procedure(barriers: GLbitfield); cdecl;
    FglGetTextureSubImage: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer); cdecl;
    FglGetCompressedTextureSubImage: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; bufSize: GLsizei; pixels: Pointer); cdecl;
    FglGetGraphicsResetStatus: function(): GLenum; cdecl;
    FglGetnCompressedTexImage: procedure(target: GLenum; lod: GLint; bufSize: GLsizei; pixels: Pointer); cdecl;
    FglGetnTexImage: procedure(target: GLenum; level: GLint; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer); cdecl;
    FglGetnUniformdv: procedure(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble); cdecl;
    FglGetnUniformfv: procedure(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); cdecl;
    FglGetnUniformiv: procedure(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); cdecl;
    FglGetnUniformuiv: procedure(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); cdecl;
    FglReadnPixels: procedure(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; bufSize: GLsizei; Data: Pointer); cdecl;
    FglGetnMapdv: procedure(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLdouble); cdecl;
    FglGetnMapfv: procedure(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLfloat); cdecl;
    FglGetnMapiv: procedure(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLint); cdecl;
    FglGetnPixelMapfv: procedure(map: GLenum; bufSize: GLsizei; values: PGLfloat); cdecl;
    FglGetnPixelMapuiv: procedure(map: GLenum; bufSize: GLsizei; values: PGLuint); cdecl;
    FglGetnPixelMapusv: procedure(map: GLenum; bufSize: GLsizei; values: PGLushort); cdecl;
    FglGetnPolygonStipple: procedure(bufSize: GLsizei; pattern: PGLubyte); cdecl;
    FglGetnColorTable: procedure(target: GLenum; format: GLenum; aType: GLenum; bufSize: GLsizei; table: Pointer); cdecl;
    FglGetnConvolutionFilter: procedure(target: GLenum; format: GLenum; aType: GLenum; bufSize: GLsizei; image: Pointer); cdecl;
    FglGetnSeparableFilter: procedure(target: GLenum; format: GLenum; aType: GLenum; rowBufSize: GLsizei; row: Pointer; columnBufSize: GLsizei; column: Pointer; span: Pointer); cdecl;
    FglGetnHistogram: procedure(target: GLenum; reset: GLboolean; format: GLenum; aType: GLenum; bufSize: GLsizei; values: Pointer); cdecl;
    FglGetnMinmax: procedure(target: GLenum; reset: GLboolean; format: GLenum; aType: GLenum; bufSize: GLsizei; values: Pointer); cdecl;
    FglTextureBarrier: procedure(); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glClipControl(origin: GLenum; depth: GLenum);
    procedure glCreateTransformFeedbacks(n: GLsizei; ids: PGLuint);
    procedure glTransformFeedbackBufferBase(xfb: GLuint; index: GLuint; buffer: GLuint);
    procedure glTransformFeedbackBufferRange(xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
    procedure glGetTransformFeedbackiv(xfb: GLuint; pname: GLenum; param: PGLint);
    procedure glGetTransformFeedbacki_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint);
    procedure glGetTransformFeedbacki64_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64);
    procedure glCreateBuffers(n: GLsizei; buffers: PGLuint);
    procedure glNamedBufferStorage(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield);
    procedure glNamedBufferData(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; usage: GLenum);
    procedure glNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; const Data: Pointer);
    procedure glCopyNamedBufferSubData(readBuffer: GLuint; writeBuffer: GLuint; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr);
    procedure glClearNamedBufferData(buffer: GLuint; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer);
    procedure glClearNamedBufferSubData(buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer);
    function glMapNamedBuffer(buffer: GLuint; access: GLenum): pointer;
    function glMapNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): pointer;
    function glUnmapNamedBuffer(buffer: GLuint): GLboolean;
    procedure glFlushMappedNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr);
    procedure glGetNamedBufferParameteriv(buffer: GLuint; pname: GLenum; params: PGLint);
    procedure glGetNamedBufferParameteri64v(buffer: GLuint; pname: GLenum; params: PGLint64);
    procedure glGetNamedBufferPointerv(buffer: GLuint; pname: GLenum; params: Pointer);
    procedure glGetNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer);
    procedure glCreateFramebuffers(n: GLsizei; framebuffers: PGLuint);
    procedure glNamedFramebufferRenderbuffer(framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint);
    procedure glNamedFramebufferParameteri(framebuffer: GLuint; pname: GLenum; param: GLint);
    procedure glNamedFramebufferTexture(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint);
    procedure glNamedFramebufferTextureLayer(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint);
    procedure glNamedFramebufferDrawBuffer(framebuffer: GLuint; buf: GLenum);
    procedure glNamedFramebufferDrawBuffers(framebuffer: GLuint; n: GLsizei; const bufs: PGLenum);
    procedure glNamedFramebufferReadBuffer(framebuffer: GLuint; src: GLenum);
    procedure glInvalidateNamedFramebufferData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum);
    procedure glInvalidateNamedFramebufferSubData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
    procedure glClearNamedFramebufferiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLint);
    procedure glClearNamedFramebufferuiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLuint);
    procedure glClearNamedFramebufferfv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat);
    procedure glClearNamedFramebufferfi(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint);
    procedure glBlitNamedFramebuffer(readFramebuffer: GLuint; drawFramebuffer: GLuint; srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum);
    function glCheckNamedFramebufferStatus(framebuffer: GLuint; target: GLenum): GLenum;
    procedure glGetNamedFramebufferParameteriv(framebuffer: GLuint; pname: GLenum; param: PGLint);
    procedure glGetNamedFramebufferAttachmentParameteriv(framebuffer: GLuint; attachment: GLenum; pname: GLenum; params: PGLint);
    procedure glCreateRenderbuffers(n: GLsizei; renderbuffers: PGLuint);
    procedure glNamedRenderbufferStorage(renderbuffer: GLuint; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
    procedure glNamedRenderbufferStorageMultisample(renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
    procedure glGetNamedRenderbufferParameteriv(renderbuffer: GLuint; pname: GLenum; params: PGLint);
    procedure glCreateTextures(target: GLenum; n: GLsizei; textures: PGLuint);
    procedure glTextureBuffer(texture: GLuint; internalformat: GLenum; buffer: GLuint);
    procedure glTextureBufferRange(texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
    procedure glTextureStorage1D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei);
    procedure glTextureStorage2D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
    procedure glTextureStorage3D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei);
    procedure glTextureStorage2DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean);
    procedure glTextureStorage3DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean);
    procedure glTextureSubImage1D(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glTextureSubImage2D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glTextureSubImage3D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
    procedure glCompressedTextureSubImage1D(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
    procedure glCompressedTextureSubImage2D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
    procedure glCompressedTextureSubImage3D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
    procedure glCopyTextureSubImage1D(texture: GLuint; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei);
    procedure glCopyTextureSubImage2D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
    procedure glCopyTextureSubImage3D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
    procedure glTextureParameterf(texture: GLuint; pname: GLenum; param: GLfloat);
    procedure glTextureParameterfv(texture: GLuint; pname: GLenum; const param: PGLfloat);
    procedure glTextureParameteri(texture: GLuint; pname: GLenum; param: GLint);
    procedure glTextureParameterIiv(texture: GLuint; pname: GLenum; const params: PGLint);
    procedure glTextureParameterIuiv(texture: GLuint; pname: GLenum; const params: PGLuint);
    procedure glTextureParameteriv(texture: GLuint; pname: GLenum; const param: PGLint);
    procedure glGenerateTextureMipmap(texture: GLuint);
    procedure glBindTextureUnit(aUnit: GLuint; texture: GLuint);
    procedure glGetTextureImage(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer);
    procedure glGetCompressedTextureImage(texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer);
    procedure glGetTextureLevelParameterfv(texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat);
    procedure glGetTextureLevelParameteriv(texture: GLuint; level: GLint; pname: GLenum; params: PGLint);
    procedure glGetTextureParameterfv(texture: GLuint; pname: GLenum; params: PGLfloat);
    procedure glGetTextureParameterIiv(texture: GLuint; pname: GLenum; params: PGLint);
    procedure glGetTextureParameterIuiv(texture: GLuint; pname: GLenum; params: PGLuint);
    procedure glGetTextureParameteriv(texture: GLuint; pname: GLenum; params: PGLint);
    procedure glCreateVertexArrays(n: GLsizei; arrays: PGLuint);
    procedure glDisableVertexArrayAttrib(vaobj: GLuint; index: GLuint);
    procedure glEnableVertexArrayAttrib(vaobj: GLuint; index: GLuint);
    procedure glVertexArrayElementBuffer(vaobj: GLuint; buffer: GLuint);
    procedure glVertexArrayVertexBuffer(vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei);
    procedure glVertexArrayVertexBuffers(vaobj: GLuint; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei);
    procedure glVertexArrayAttribBinding(vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint);
    procedure glVertexArrayAttribFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint);
    procedure glVertexArrayAttribIFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
    procedure glVertexArrayAttribLFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
    procedure glVertexArrayBindingDivisor(vaobj: GLuint; bindingindex: GLuint; divisor: GLuint);
    procedure glGetVertexArrayiv(vaobj: GLuint; pname: GLenum; param: PGLint);
    procedure glGetVertexArrayIndexediv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint);
    procedure glGetVertexArrayIndexed64iv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64);
    procedure glCreateSamplers(n: GLsizei; samplers: PGLuint);
    procedure glCreateProgramPipelines(n: GLsizei; pipelines: PGLuint);
    procedure glCreateQueries(target: GLenum; n: GLsizei; ids: PGLuint);
    procedure glGetQueryBufferObjecti64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
    procedure glGetQueryBufferObjectiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
    procedure glGetQueryBufferObjectui64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
    procedure glGetQueryBufferObjectuiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
    procedure glMemoryBarrierByRegion(barriers: GLbitfield);
    procedure glGetTextureSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer);
    procedure glGetCompressedTextureSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; bufSize: GLsizei; pixels: Pointer);
    function glGetGraphicsResetStatus(): GLenum;
    procedure glGetnCompressedTexImage(target: GLenum; lod: GLint; bufSize: GLsizei; pixels: Pointer);
    procedure glGetnTexImage(target: GLenum; level: GLint; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer);
    procedure glGetnUniformdv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble);
    procedure glGetnUniformfv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat);
    procedure glGetnUniformiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLint);
    procedure glGetnUniformuiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint);
    procedure glReadnPixels(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; bufSize: GLsizei; Data: Pointer);
    procedure glGetnMapdv(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLdouble);
    procedure glGetnMapfv(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLfloat);
    procedure glGetnMapiv(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLint);
    procedure glGetnPixelMapfv(map: GLenum; bufSize: GLsizei; values: PGLfloat);
    procedure glGetnPixelMapuiv(map: GLenum; bufSize: GLsizei; values: PGLuint);
    procedure glGetnPixelMapusv(map: GLenum; bufSize: GLsizei; values: PGLushort);
    procedure glGetnPolygonStipple(bufSize: GLsizei; pattern: PGLubyte);
    procedure glGetnColorTable(target: GLenum; format: GLenum; aType: GLenum; bufSize: GLsizei; table: Pointer);
    procedure glGetnConvolutionFilter(target: GLenum; format: GLenum; aType: GLenum; bufSize: GLsizei; image: Pointer);
    procedure glGetnSeparableFilter(target: GLenum; format: GLenum; aType: GLenum; rowBufSize: GLsizei; row: Pointer; columnBufSize: GLsizei; column: Pointer; span: Pointer);
    procedure glGetnHistogram(target: GLenum; reset: GLboolean; format: GLenum; aType: GLenum; bufSize: GLsizei; values: Pointer);
    procedure glGetnMinmax(target: GLenum; reset: GLboolean; format: GLenum; aType: GLenum; bufSize: GLsizei; values: Pointer);
    procedure glTextureBarrier();
  end;

  TGL_VERSION_4_6 = class(TGL_VERSION_4_5, IGL_VERSION_4_6)
  protected
    FglSpecializeShader: procedure(shader: GLuint; const pEntryPoint: PGLchar; numSpecializationConstants: GLuint; const pConstantIndex: PGLuint; const pConstantValue: PGLuint); cdecl;
    FglMultiDrawArraysIndirectCount: procedure(mode: GLenum; const indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); cdecl;
    FglMultiDrawElementsIndirectCount: procedure(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); cdecl;
    FglPolygonOffsetClamp: procedure(factor: GLfloat; units: GLfloat; clamp: GLfloat); cdecl;
  protected
    procedure bindEntry; override;
  public
    procedure glSpecializeShader(shader: GLuint; const pEntryPoint: PGLchar; numSpecializationConstants: GLuint; const pConstantIndex: PGLuint; const pConstantValue: PGLuint);
    procedure glMultiDrawArraysIndirectCount(mode: GLenum; const indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei);
    procedure glMultiDrawElementsIndirectCount(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei);
    procedure glPolygonOffsetClamp(factor: GLfloat; units: GLfloat; clamp: GLfloat);
  end;



procedure TGL_VERSION_1_0.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglCullFace), 'glCullFace');
  Bind(Pointer(FglFrontFace), 'glFrontFace');
  Bind(Pointer(FglHint), 'glHint');
  Bind(Pointer(FglLineWidth), 'glLineWidth');
  Bind(Pointer(FglPointSize), 'glPointSize');
  Bind(Pointer(FglPolygonMode), 'glPolygonMode');
  Bind(Pointer(FglScissor), 'glScissor');
  Bind(Pointer(FglTexParameterf), 'glTexParameterf');
  Bind(Pointer(FglTexParameterfv), 'glTexParameterfv');
  Bind(Pointer(FglTexParameteri), 'glTexParameteri');
  Bind(Pointer(FglTexParameteriv), 'glTexParameteriv');
  Bind(Pointer(FglTexImage1D), 'glTexImage1D');
  Bind(Pointer(FglTexImage2D), 'glTexImage2D');
  Bind(Pointer(FglDrawBuffer), 'glDrawBuffer');
  Bind(Pointer(FglClear), 'glClear');
  Bind(Pointer(FglClearColor), 'glClearColor');
  Bind(Pointer(FglClearStencil), 'glClearStencil');
  Bind(Pointer(FglClearDepth), 'glClearDepth');
  Bind(Pointer(FglStencilMask), 'glStencilMask');
  Bind(Pointer(FglColorMask), 'glColorMask');
  Bind(Pointer(FglDepthMask), 'glDepthMask');
  Bind(Pointer(FglDisable), 'glDisable');
  Bind(Pointer(FglEnable), 'glEnable');
  Bind(Pointer(FglFinish), 'glFinish');
  Bind(Pointer(FglFlush), 'glFlush');
  Bind(Pointer(FglBlendFunc), 'glBlendFunc');
  Bind(Pointer(FglLogicOp), 'glLogicOp');
  Bind(Pointer(FglStencilFunc), 'glStencilFunc');
  Bind(Pointer(FglStencilOp), 'glStencilOp');
  Bind(Pointer(FglDepthFunc), 'glDepthFunc');
  Bind(Pointer(FglPixelStoref), 'glPixelStoref');
  Bind(Pointer(FglPixelStorei), 'glPixelStorei');
  Bind(Pointer(FglReadBuffer), 'glReadBuffer');
  Bind(Pointer(FglReadPixels), 'glReadPixels');
  Bind(Pointer(FglGetBooleanv), 'glGetBooleanv');
  Bind(Pointer(FglGetDoublev), 'glGetDoublev');
  Bind(Pointer(FglGetError), 'glGetError');
  Bind(Pointer(FglGetFloatv), 'glGetFloatv');
  Bind(Pointer(FglGetIntegerv), 'glGetIntegerv');
  Bind(Pointer(FglGetString), 'glGetString');
  Bind(Pointer(FglGetTexImage), 'glGetTexImage');
  Bind(Pointer(FglGetTexParameterfv), 'glGetTexParameterfv');
  Bind(Pointer(FglGetTexParameteriv), 'glGetTexParameteriv');
  Bind(Pointer(FglGetTexLevelParameterfv), 'glGetTexLevelParameterfv');
  Bind(Pointer(FglGetTexLevelParameteriv), 'glGetTexLevelParameteriv');
  Bind(Pointer(FglIsEnabled), 'glIsEnabled');
  Bind(Pointer(FglDepthRange), 'glDepthRange');
  Bind(Pointer(FglViewport), 'glViewport');
  Bind(Pointer(FglNewList), 'glNewList');
  Bind(Pointer(FglEndList), 'glEndList');
  Bind(Pointer(FglCallList), 'glCallList');
  Bind(Pointer(FglCallLists), 'glCallLists');
  Bind(Pointer(FglDeleteLists), 'glDeleteLists');
  Bind(Pointer(FglGenLists), 'glGenLists');
  Bind(Pointer(FglListBase), 'glListBase');
  Bind(Pointer(FglBegin), 'glBegin');
  Bind(Pointer(FglBitmap), 'glBitmap');
  Bind(Pointer(FglColor3b), 'glColor3b');
  Bind(Pointer(FglColor3bv), 'glColor3bv');
  Bind(Pointer(FglColor3d), 'glColor3d');
  Bind(Pointer(FglColor3dv), 'glColor3dv');
  Bind(Pointer(FglColor3f), 'glColor3f');
  Bind(Pointer(FglColor3fv), 'glColor3fv');
  Bind(Pointer(FglColor3i), 'glColor3i');
  Bind(Pointer(FglColor3iv), 'glColor3iv');
  Bind(Pointer(FglColor3s), 'glColor3s');
  Bind(Pointer(FglColor3sv), 'glColor3sv');
  Bind(Pointer(FglColor3ub), 'glColor3ub');
  Bind(Pointer(FglColor3ubv), 'glColor3ubv');
  Bind(Pointer(FglColor3ui), 'glColor3ui');
  Bind(Pointer(FglColor3uiv), 'glColor3uiv');
  Bind(Pointer(FglColor3us), 'glColor3us');
  Bind(Pointer(FglColor3usv), 'glColor3usv');
  Bind(Pointer(FglColor4b), 'glColor4b');
  Bind(Pointer(FglColor4bv), 'glColor4bv');
  Bind(Pointer(FglColor4d), 'glColor4d');
  Bind(Pointer(FglColor4dv), 'glColor4dv');
  Bind(Pointer(FglColor4f), 'glColor4f');
  Bind(Pointer(FglColor4fv), 'glColor4fv');
  Bind(Pointer(FglColor4i), 'glColor4i');
  Bind(Pointer(FglColor4iv), 'glColor4iv');
  Bind(Pointer(FglColor4s), 'glColor4s');
  Bind(Pointer(FglColor4sv), 'glColor4sv');
  Bind(Pointer(FglColor4ub), 'glColor4ub');
  Bind(Pointer(FglColor4ubv), 'glColor4ubv');
  Bind(Pointer(FglColor4ui), 'glColor4ui');
  Bind(Pointer(FglColor4uiv), 'glColor4uiv');
  Bind(Pointer(FglColor4us), 'glColor4us');
  Bind(Pointer(FglColor4usv), 'glColor4usv');
  Bind(Pointer(FglEdgeFlag), 'glEdgeFlag');
  Bind(Pointer(FglEdgeFlagv), 'glEdgeFlagv');
  Bind(Pointer(FglEnd), 'glEnd');
  Bind(Pointer(FglIndexd), 'glIndexd');
  Bind(Pointer(FglIndexdv), 'glIndexdv');
  Bind(Pointer(FglIndexf), 'glIndexf');
  Bind(Pointer(FglIndexfv), 'glIndexfv');
  Bind(Pointer(FglIndexi), 'glIndexi');
  Bind(Pointer(FglIndexiv), 'glIndexiv');
  Bind(Pointer(FglIndexs), 'glIndexs');
  Bind(Pointer(FglIndexsv), 'glIndexsv');
  Bind(Pointer(FglNormal3b), 'glNormal3b');
  Bind(Pointer(FglNormal3bv), 'glNormal3bv');
  Bind(Pointer(FglNormal3d), 'glNormal3d');
  Bind(Pointer(FglNormal3dv), 'glNormal3dv');
  Bind(Pointer(FglNormal3f), 'glNormal3f');
  Bind(Pointer(FglNormal3fv), 'glNormal3fv');
  Bind(Pointer(FglNormal3i), 'glNormal3i');
  Bind(Pointer(FglNormal3iv), 'glNormal3iv');
  Bind(Pointer(FglNormal3s), 'glNormal3s');
  Bind(Pointer(FglNormal3sv), 'glNormal3sv');
  Bind(Pointer(FglRasterPos2d), 'glRasterPos2d');
  Bind(Pointer(FglRasterPos2dv), 'glRasterPos2dv');
  Bind(Pointer(FglRasterPos2f), 'glRasterPos2f');
  Bind(Pointer(FglRasterPos2fv), 'glRasterPos2fv');
  Bind(Pointer(FglRasterPos2i), 'glRasterPos2i');
  Bind(Pointer(FglRasterPos2iv), 'glRasterPos2iv');
  Bind(Pointer(FglRasterPos2s), 'glRasterPos2s');
  Bind(Pointer(FglRasterPos2sv), 'glRasterPos2sv');
  Bind(Pointer(FglRasterPos3d), 'glRasterPos3d');
  Bind(Pointer(FglRasterPos3dv), 'glRasterPos3dv');
  Bind(Pointer(FglRasterPos3f), 'glRasterPos3f');
  Bind(Pointer(FglRasterPos3fv), 'glRasterPos3fv');
  Bind(Pointer(FglRasterPos3i), 'glRasterPos3i');
  Bind(Pointer(FglRasterPos3iv), 'glRasterPos3iv');
  Bind(Pointer(FglRasterPos3s), 'glRasterPos3s');
  Bind(Pointer(FglRasterPos3sv), 'glRasterPos3sv');
  Bind(Pointer(FglRasterPos4d), 'glRasterPos4d');
  Bind(Pointer(FglRasterPos4dv), 'glRasterPos4dv');
  Bind(Pointer(FglRasterPos4f), 'glRasterPos4f');
  Bind(Pointer(FglRasterPos4fv), 'glRasterPos4fv');
  Bind(Pointer(FglRasterPos4i), 'glRasterPos4i');
  Bind(Pointer(FglRasterPos4iv), 'glRasterPos4iv');
  Bind(Pointer(FglRasterPos4s), 'glRasterPos4s');
  Bind(Pointer(FglRasterPos4sv), 'glRasterPos4sv');
  Bind(Pointer(FglRectd), 'glRectd');
  Bind(Pointer(FglRectdv), 'glRectdv');
  Bind(Pointer(FglRectf), 'glRectf');
  Bind(Pointer(FglRectfv), 'glRectfv');
  Bind(Pointer(FglRecti), 'glRecti');
  Bind(Pointer(FglRectiv), 'glRectiv');
  Bind(Pointer(FglRects), 'glRects');
  Bind(Pointer(FglRectsv), 'glRectsv');
  Bind(Pointer(FglTexCoord1d), 'glTexCoord1d');
  Bind(Pointer(FglTexCoord1dv), 'glTexCoord1dv');
  Bind(Pointer(FglTexCoord1f), 'glTexCoord1f');
  Bind(Pointer(FglTexCoord1fv), 'glTexCoord1fv');
  Bind(Pointer(FglTexCoord1i), 'glTexCoord1i');
  Bind(Pointer(FglTexCoord1iv), 'glTexCoord1iv');
  Bind(Pointer(FglTexCoord1s), 'glTexCoord1s');
  Bind(Pointer(FglTexCoord1sv), 'glTexCoord1sv');
  Bind(Pointer(FglTexCoord2d), 'glTexCoord2d');
  Bind(Pointer(FglTexCoord2dv), 'glTexCoord2dv');
  Bind(Pointer(FglTexCoord2f), 'glTexCoord2f');
  Bind(Pointer(FglTexCoord2fv), 'glTexCoord2fv');
  Bind(Pointer(FglTexCoord2i), 'glTexCoord2i');
  Bind(Pointer(FglTexCoord2iv), 'glTexCoord2iv');
  Bind(Pointer(FglTexCoord2s), 'glTexCoord2s');
  Bind(Pointer(FglTexCoord2sv), 'glTexCoord2sv');
  Bind(Pointer(FglTexCoord3d), 'glTexCoord3d');
  Bind(Pointer(FglTexCoord3dv), 'glTexCoord3dv');
  Bind(Pointer(FglTexCoord3f), 'glTexCoord3f');
  Bind(Pointer(FglTexCoord3fv), 'glTexCoord3fv');
  Bind(Pointer(FglTexCoord3i), 'glTexCoord3i');
  Bind(Pointer(FglTexCoord3iv), 'glTexCoord3iv');
  Bind(Pointer(FglTexCoord3s), 'glTexCoord3s');
  Bind(Pointer(FglTexCoord3sv), 'glTexCoord3sv');
  Bind(Pointer(FglTexCoord4d), 'glTexCoord4d');
  Bind(Pointer(FglTexCoord4dv), 'glTexCoord4dv');
  Bind(Pointer(FglTexCoord4f), 'glTexCoord4f');
  Bind(Pointer(FglTexCoord4fv), 'glTexCoord4fv');
  Bind(Pointer(FglTexCoord4i), 'glTexCoord4i');
  Bind(Pointer(FglTexCoord4iv), 'glTexCoord4iv');
  Bind(Pointer(FglTexCoord4s), 'glTexCoord4s');
  Bind(Pointer(FglTexCoord4sv), 'glTexCoord4sv');
  Bind(Pointer(FglVertex2d), 'glVertex2d');
  Bind(Pointer(FglVertex2dv), 'glVertex2dv');
  Bind(Pointer(FglVertex2f), 'glVertex2f');
  Bind(Pointer(FglVertex2fv), 'glVertex2fv');
  Bind(Pointer(FglVertex2i), 'glVertex2i');
  Bind(Pointer(FglVertex2iv), 'glVertex2iv');
  Bind(Pointer(FglVertex2s), 'glVertex2s');
  Bind(Pointer(FglVertex2sv), 'glVertex2sv');
  Bind(Pointer(FglVertex3d), 'glVertex3d');
  Bind(Pointer(FglVertex3dv), 'glVertex3dv');
  Bind(Pointer(FglVertex3f), 'glVertex3f');
  Bind(Pointer(FglVertex3fv), 'glVertex3fv');
  Bind(Pointer(FglVertex3i), 'glVertex3i');
  Bind(Pointer(FglVertex3iv), 'glVertex3iv');
  Bind(Pointer(FglVertex3s), 'glVertex3s');
  Bind(Pointer(FglVertex3sv), 'glVertex3sv');
  Bind(Pointer(FglVertex4d), 'glVertex4d');
  Bind(Pointer(FglVertex4dv), 'glVertex4dv');
  Bind(Pointer(FglVertex4f), 'glVertex4f');
  Bind(Pointer(FglVertex4fv), 'glVertex4fv');
  Bind(Pointer(FglVertex4i), 'glVertex4i');
  Bind(Pointer(FglVertex4iv), 'glVertex4iv');
  Bind(Pointer(FglVertex4s), 'glVertex4s');
  Bind(Pointer(FglVertex4sv), 'glVertex4sv');
  Bind(Pointer(FglClipPlane), 'glClipPlane');
  Bind(Pointer(FglColorMaterial), 'glColorMaterial');
  Bind(Pointer(FglFogf), 'glFogf');
  Bind(Pointer(FglFogfv), 'glFogfv');
  Bind(Pointer(FglFogi), 'glFogi');
  Bind(Pointer(FglFogiv), 'glFogiv');
  Bind(Pointer(FglLightf), 'glLightf');
  Bind(Pointer(FglLightfv), 'glLightfv');
  Bind(Pointer(FglLighti), 'glLighti');
  Bind(Pointer(FglLightiv), 'glLightiv');
  Bind(Pointer(FglLightModelf), 'glLightModelf');
  Bind(Pointer(FglLightModelfv), 'glLightModelfv');
  Bind(Pointer(FglLightModeli), 'glLightModeli');
  Bind(Pointer(FglLightModeliv), 'glLightModeliv');
  Bind(Pointer(FglLineStipple), 'glLineStipple');
  Bind(Pointer(FglMaterialf), 'glMaterialf');
  Bind(Pointer(FglMaterialfv), 'glMaterialfv');
  Bind(Pointer(FglMateriali), 'glMateriali');
  Bind(Pointer(FglMaterialiv), 'glMaterialiv');
  Bind(Pointer(FglPolygonStipple), 'glPolygonStipple');
  Bind(Pointer(FglShadeModel), 'glShadeModel');
  Bind(Pointer(FglTexEnvf), 'glTexEnvf');
  Bind(Pointer(FglTexEnvfv), 'glTexEnvfv');
  Bind(Pointer(FglTexEnvi), 'glTexEnvi');
  Bind(Pointer(FglTexEnviv), 'glTexEnviv');
  Bind(Pointer(FglTexGend), 'glTexGend');
  Bind(Pointer(FglTexGendv), 'glTexGendv');
  Bind(Pointer(FglTexGenf), 'glTexGenf');
  Bind(Pointer(FglTexGenfv), 'glTexGenfv');
  Bind(Pointer(FglTexGeni), 'glTexGeni');
  Bind(Pointer(FglTexGeniv), 'glTexGeniv');
  Bind(Pointer(FglFeedbackBuffer), 'glFeedbackBuffer');
  Bind(Pointer(FglSelectBuffer), 'glSelectBuffer');
  Bind(Pointer(FglRenderMode), 'glRenderMode');
  Bind(Pointer(FglInitNames), 'glInitNames');
  Bind(Pointer(FglLoadName), 'glLoadName');
  Bind(Pointer(FglPassThrough), 'glPassThrough');
  Bind(Pointer(FglPopName), 'glPopName');
  Bind(Pointer(FglPushName), 'glPushName');
  Bind(Pointer(FglClearAccum), 'glClearAccum');
  Bind(Pointer(FglClearIndex), 'glClearIndex');
  Bind(Pointer(FglIndexMask), 'glIndexMask');
  Bind(Pointer(FglAccum), 'glAccum');
  Bind(Pointer(FglPopAttrib), 'glPopAttrib');
  Bind(Pointer(FglPushAttrib), 'glPushAttrib');
  Bind(Pointer(FglMap1d), 'glMap1d');
  Bind(Pointer(FglMap1f), 'glMap1f');
  Bind(Pointer(FglMap2d), 'glMap2d');
  Bind(Pointer(FglMap2f), 'glMap2f');
  Bind(Pointer(FglMapGrid1d), 'glMapGrid1d');
  Bind(Pointer(FglMapGrid1f), 'glMapGrid1f');
  Bind(Pointer(FglMapGrid2d), 'glMapGrid2d');
  Bind(Pointer(FglMapGrid2f), 'glMapGrid2f');
  Bind(Pointer(FglEvalCoord1d), 'glEvalCoord1d');
  Bind(Pointer(FglEvalCoord1dv), 'glEvalCoord1dv');
  Bind(Pointer(FglEvalCoord1f), 'glEvalCoord1f');
  Bind(Pointer(FglEvalCoord1fv), 'glEvalCoord1fv');
  Bind(Pointer(FglEvalCoord2d), 'glEvalCoord2d');
  Bind(Pointer(FglEvalCoord2dv), 'glEvalCoord2dv');
  Bind(Pointer(FglEvalCoord2f), 'glEvalCoord2f');
  Bind(Pointer(FglEvalCoord2fv), 'glEvalCoord2fv');
  Bind(Pointer(FglEvalMesh1), 'glEvalMesh1');
  Bind(Pointer(FglEvalPoint1), 'glEvalPoint1');
  Bind(Pointer(FglEvalMesh2), 'glEvalMesh2');
  Bind(Pointer(FglEvalPoint2), 'glEvalPoint2');
  Bind(Pointer(FglAlphaFunc), 'glAlphaFunc');
  Bind(Pointer(FglPixelZoom), 'glPixelZoom');
  Bind(Pointer(FglPixelTransferf), 'glPixelTransferf');
  Bind(Pointer(FglPixelTransferi), 'glPixelTransferi');
  Bind(Pointer(FglPixelMapfv), 'glPixelMapfv');
  Bind(Pointer(FglPixelMapuiv), 'glPixelMapuiv');
  Bind(Pointer(FglPixelMapusv), 'glPixelMapusv');
  Bind(Pointer(FglCopyPixels), 'glCopyPixels');
  Bind(Pointer(FglDrawPixels), 'glDrawPixels');
  Bind(Pointer(FglGetClipPlane), 'glGetClipPlane');
  Bind(Pointer(FglGetLightfv), 'glGetLightfv');
  Bind(Pointer(FglGetLightiv), 'glGetLightiv');
  Bind(Pointer(FglGetMapdv), 'glGetMapdv');
  Bind(Pointer(FglGetMapfv), 'glGetMapfv');
  Bind(Pointer(FglGetMapiv), 'glGetMapiv');
  Bind(Pointer(FglGetMaterialfv), 'glGetMaterialfv');
  Bind(Pointer(FglGetMaterialiv), 'glGetMaterialiv');
  Bind(Pointer(FglGetPixelMapfv), 'glGetPixelMapfv');
  Bind(Pointer(FglGetPixelMapuiv), 'glGetPixelMapuiv');
  Bind(Pointer(FglGetPixelMapusv), 'glGetPixelMapusv');
  Bind(Pointer(FglGetPolygonStipple), 'glGetPolygonStipple');
  Bind(Pointer(FglGetTexEnvfv), 'glGetTexEnvfv');
  Bind(Pointer(FglGetTexEnviv), 'glGetTexEnviv');
  Bind(Pointer(FglGetTexGendv), 'glGetTexGendv');
  Bind(Pointer(FglGetTexGenfv), 'glGetTexGenfv');
  Bind(Pointer(FglGetTexGeniv), 'glGetTexGeniv');
  Bind(Pointer(FglIsList), 'glIsList');
  Bind(Pointer(FglFrustum), 'glFrustum');
  Bind(Pointer(FglLoadIdentity), 'glLoadIdentity');
  Bind(Pointer(FglLoadMatrixf), 'glLoadMatrixf');
  Bind(Pointer(FglLoadMatrixd), 'glLoadMatrixd');
  Bind(Pointer(FglMatrixMode), 'glMatrixMode');
  Bind(Pointer(FglMultMatrixf), 'glMultMatrixf');
  Bind(Pointer(FglMultMatrixd), 'glMultMatrixd');
  Bind(Pointer(FglOrtho), 'glOrtho');
  Bind(Pointer(FglPopMatrix), 'glPopMatrix');
  Bind(Pointer(FglPushMatrix), 'glPushMatrix');
  Bind(Pointer(FglRotated), 'glRotated');
  Bind(Pointer(FglRotatef), 'glRotatef');
  Bind(Pointer(FglScaled), 'glScaled');
  Bind(Pointer(FglScalef), 'glScalef');
  Bind(Pointer(FglTranslated), 'glTranslated');
  Bind(Pointer(FglTranslatef), 'glTranslatef');
end;

procedure TGL_VERSION_1_0.glCullFace(mode: GLenum);
begin
  if Assigned(FglCullFace) then
  begin
    FglCullFace(mode);
  end
  else
  begin
    raise Exception.Create('glCullFace not bound');
  end;
end;

procedure TGL_VERSION_1_0.glFrontFace(mode: GLenum);
begin
  if Assigned(FglFrontFace) then
  begin
    FglFrontFace(mode);
  end
  else
  begin
    raise Exception.Create('glFrontFace not bound');
  end;
end;

procedure TGL_VERSION_1_0.glHint(target: GLenum; mode: GLenum);
begin
  if Assigned(FglHint) then
  begin
    FglHint(target, mode);
  end
  else
  begin
    raise Exception.Create('glHint not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLineWidth(Width: GLfloat);
begin
  if Assigned(FglLineWidth) then
  begin
    FglLineWidth(Width);
  end
  else
  begin
    raise Exception.Create('glLineWidth not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPointSize(size: GLfloat);
begin
  if Assigned(FglPointSize) then
  begin
    FglPointSize(size);
  end
  else
  begin
    raise Exception.Create('glPointSize not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPolygonMode(face: GLenum; mode: GLenum);
begin
  if Assigned(FglPolygonMode) then
  begin
    FglPolygonMode(face, mode);
  end
  else
  begin
    raise Exception.Create('glPolygonMode not bound');
  end;
end;

procedure TGL_VERSION_1_0.glScissor(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglScissor) then
  begin
    FglScissor(x, y, Width, Height);
  end
  else
  begin
    raise Exception.Create('glScissor not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexParameterf(target: GLenum; pname: GLenum; param: GLfloat);
begin
  if Assigned(FglTexParameterf) then
  begin
    FglTexParameterf(target, pname, param);
  end
  else
  begin
    raise Exception.Create('glTexParameterf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexParameterfv(target: GLenum; pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglTexParameterfv) then
  begin
    FglTexParameterfv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glTexParameterfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexParameteri(target: GLenum; pname: GLenum; param: GLint);
begin
  if Assigned(FglTexParameteri) then
  begin
    FglTexParameteri(target, pname, param);
  end
  else
  begin
    raise Exception.Create('glTexParameteri not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexParameteriv(target: GLenum; pname: GLenum; const params: PGLint);
begin
  if Assigned(FglTexParameteriv) then
  begin
    FglTexParameteriv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glTexParameteriv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexImage1D(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglTexImage1D) then
  begin
    FglTexImage1D(target, level, internalformat, Width, border, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glTexImage1D not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexImage2D(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglTexImage2D) then
  begin
    FglTexImage2D(target, level, internalformat, Width, Height, border, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glTexImage2D not bound');
  end;
end;

procedure TGL_VERSION_1_0.glDrawBuffer(buf: GLenum);
begin
  if Assigned(FglDrawBuffer) then
  begin
    FglDrawBuffer(buf);
  end
  else
  begin
    raise Exception.Create('glDrawBuffer not bound');
  end;
end;

procedure TGL_VERSION_1_0.glClear(mask: GLbitfield);
begin
  if Assigned(FglClear) then
  begin
    FglClear(mask);
  end
  else
  begin
    raise Exception.Create('glClear not bound');
  end;
end;

procedure TGL_VERSION_1_0.glClearColor(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat);
begin
  if Assigned(FglClearColor) then
  begin
    FglClearColor(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glClearColor not bound');
  end;
end;

procedure TGL_VERSION_1_0.glClearStencil(s: GLint);
begin
  if Assigned(FglClearStencil) then
  begin
    FglClearStencil(s);
  end
  else
  begin
    raise Exception.Create('glClearStencil not bound');
  end;
end;

procedure TGL_VERSION_1_0.glClearDepth(depth: GLdouble);
begin
  if Assigned(FglClearDepth) then
  begin
    FglClearDepth(depth);
  end
  else
  begin
    raise Exception.Create('glClearDepth not bound');
  end;
end;

procedure TGL_VERSION_1_0.glStencilMask(mask: GLuint);
begin
  if Assigned(FglStencilMask) then
  begin
    FglStencilMask(mask);
  end
  else
  begin
    raise Exception.Create('glStencilMask not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColorMask(red: GLboolean; green: GLboolean; blue: GLboolean; alpha: GLboolean);
begin
  if Assigned(FglColorMask) then
  begin
    FglColorMask(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glColorMask not bound');
  end;
end;

procedure TGL_VERSION_1_0.glDepthMask(flag: GLboolean);
begin
  if Assigned(FglDepthMask) then
  begin
    FglDepthMask(flag);
  end
  else
  begin
    raise Exception.Create('glDepthMask not bound');
  end;
end;

procedure TGL_VERSION_1_0.glDisable(cap: GLenum);
begin
  if Assigned(FglDisable) then
  begin
    FglDisable(cap);
  end
  else
  begin
    raise Exception.Create('glDisable not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEnable(cap: GLenum);
begin
  if Assigned(FglEnable) then
  begin
    FglEnable(cap);
  end
  else
  begin
    raise Exception.Create('glEnable not bound');
  end;
end;

procedure TGL_VERSION_1_0.glFinish();
begin
  if Assigned(FglFinish) then
  begin
    FglFinish();
  end
  else
  begin
    raise Exception.Create('glFinish not bound');
  end;
end;

procedure TGL_VERSION_1_0.glFlush();
begin
  if Assigned(FglFlush) then
  begin
    FglFlush();
  end
  else
  begin
    raise Exception.Create('glFlush not bound');
  end;
end;

procedure TGL_VERSION_1_0.glBlendFunc(sfactor: GLenum; dfactor: GLenum);
begin
  if Assigned(FglBlendFunc) then
  begin
    FglBlendFunc(sfactor, dfactor);
  end
  else
  begin
    raise Exception.Create('glBlendFunc not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLogicOp(opcode: GLenum);
begin
  if Assigned(FglLogicOp) then
  begin
    FglLogicOp(opcode);
  end
  else
  begin
    raise Exception.Create('glLogicOp not bound');
  end;
end;

procedure TGL_VERSION_1_0.glStencilFunc(func: GLenum; ref: GLint; mask: GLuint);
begin
  if Assigned(FglStencilFunc) then
  begin
    FglStencilFunc(func, ref, mask);
  end
  else
  begin
    raise Exception.Create('glStencilFunc not bound');
  end;
end;

procedure TGL_VERSION_1_0.glStencilOp(fail: GLenum; zfail: GLenum; zpass: GLenum);
begin
  if Assigned(FglStencilOp) then
  begin
    FglStencilOp(fail, zfail, zpass);
  end
  else
  begin
    raise Exception.Create('glStencilOp not bound');
  end;
end;

procedure TGL_VERSION_1_0.glDepthFunc(func: GLenum);
begin
  if Assigned(FglDepthFunc) then
  begin
    FglDepthFunc(func);
  end
  else
  begin
    raise Exception.Create('glDepthFunc not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPixelStoref(pname: GLenum; param: GLfloat);
begin
  if Assigned(FglPixelStoref) then
  begin
    FglPixelStoref(pname, param);
  end
  else
  begin
    raise Exception.Create('glPixelStoref not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPixelStorei(pname: GLenum; param: GLint);
begin
  if Assigned(FglPixelStorei) then
  begin
    FglPixelStorei(pname, param);
  end
  else
  begin
    raise Exception.Create('glPixelStorei not bound');
  end;
end;

procedure TGL_VERSION_1_0.glReadBuffer(src: GLenum);
begin
  if Assigned(FglReadBuffer) then
  begin
    FglReadBuffer(src);
  end
  else
  begin
    raise Exception.Create('glReadBuffer not bound');
  end;
end;

procedure TGL_VERSION_1_0.glReadPixels(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; pixels: Pointer);
begin
  if Assigned(FglReadPixels) then
  begin
    FglReadPixels(x, y, Width, Height, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glReadPixels not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetBooleanv(pname: GLenum; Data: PGLboolean);
begin
  if Assigned(FglGetBooleanv) then
  begin
    FglGetBooleanv(pname, Data);
  end
  else
  begin
    raise Exception.Create('glGetBooleanv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetDoublev(pname: GLenum; Data: PGLdouble);
begin
  if Assigned(FglGetDoublev) then
  begin
    FglGetDoublev(pname, Data);
  end
  else
  begin
    raise Exception.Create('glGetDoublev not bound');
  end;
end;

function TGL_VERSION_1_0.glGetError(): GLenum;
begin
  if Assigned(FglGetError) then
  begin
    Result := FglGetError();
  end
  else
  begin
    raise Exception.Create('glGetError not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetFloatv(pname: GLenum; Data: PGLfloat);
begin
  if Assigned(FglGetFloatv) then
  begin
    FglGetFloatv(pname, Data);
  end
  else
  begin
    raise Exception.Create('glGetFloatv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetIntegerv(pname: GLenum; Data: PGLint);
begin
  if Assigned(FglGetIntegerv) then
  begin
    FglGetIntegerv(pname, Data);
  end
  else
  begin
    raise Exception.Create('glGetIntegerv not bound');
  end;
end;

function TGL_VERSION_1_0.glGetString(Name: GLenum): PGLubyte;
begin
  if Assigned(FglGetString) then
  begin
    Result := FglGetString(Name);
  end
  else
  begin
    raise Exception.Create('glGetString not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexImage(target: GLenum; level: GLint; format: GLenum; aType: GLenum; pixels: Pointer);
begin
  if Assigned(FglGetTexImage) then
  begin
    FglGetTexImage(target, level, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glGetTexImage not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexParameterfv(target: GLenum; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetTexParameterfv) then
  begin
    FglGetTexParameterfv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexParameterfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexParameteriv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetTexParameteriv) then
  begin
    FglGetTexParameteriv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexParameteriv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexLevelParameterfv(target: GLenum; level: GLint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetTexLevelParameterfv) then
  begin
    FglGetTexLevelParameterfv(target, level, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexLevelParameterfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexLevelParameteriv(target: GLenum; level: GLint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetTexLevelParameteriv) then
  begin
    FglGetTexLevelParameteriv(target, level, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexLevelParameteriv not bound');
  end;
end;

function TGL_VERSION_1_0.glIsEnabled(cap: GLenum): GLboolean;
begin
  if Assigned(FglIsEnabled) then
  begin
    Result := FglIsEnabled(cap);
  end
  else
  begin
    raise Exception.Create('glIsEnabled not bound');
  end;
end;

procedure TGL_VERSION_1_0.glDepthRange(n: GLdouble; f: GLdouble);
begin
  if Assigned(FglDepthRange) then
  begin
    FglDepthRange(n, f);
  end
  else
  begin
    raise Exception.Create('glDepthRange not bound');
  end;
end;

procedure TGL_VERSION_1_0.glViewport(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglViewport) then
  begin
    FglViewport(x, y, Width, Height);
  end
  else
  begin
    raise Exception.Create('glViewport not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNewList(list: GLuint; mode: GLenum);
begin
  if Assigned(FglNewList) then
  begin
    FglNewList(list, mode);
  end
  else
  begin
    raise Exception.Create('glNewList not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEndList();
begin
  if Assigned(FglEndList) then
  begin
    FglEndList();
  end
  else
  begin
    raise Exception.Create('glEndList not bound');
  end;
end;

procedure TGL_VERSION_1_0.glCallList(list: GLuint);
begin
  if Assigned(FglCallList) then
  begin
    FglCallList(list);
  end
  else
  begin
    raise Exception.Create('glCallList not bound');
  end;
end;

procedure TGL_VERSION_1_0.glCallLists(n: GLsizei; aType: GLenum; const lists: Pointer);
begin
  if Assigned(FglCallLists) then
  begin
    FglCallLists(n, aType, lists);
  end
  else
  begin
    raise Exception.Create('glCallLists not bound');
  end;
end;

procedure TGL_VERSION_1_0.glDeleteLists(list: GLuint; range: GLsizei);
begin
  if Assigned(FglDeleteLists) then
  begin
    FglDeleteLists(list, range);
  end
  else
  begin
    raise Exception.Create('glDeleteLists not bound');
  end;
end;

function TGL_VERSION_1_0.glGenLists(range: GLsizei): GLuint;
begin
  if Assigned(FglGenLists) then
  begin
    Result := FglGenLists(range);
  end
  else
  begin
    raise Exception.Create('glGenLists not bound');
  end;
end;

procedure TGL_VERSION_1_0.glListBase(base: GLuint);
begin
  if Assigned(FglListBase) then
  begin
    FglListBase(base);
  end
  else
  begin
    raise Exception.Create('glListBase not bound');
  end;
end;

procedure TGL_VERSION_1_0.glBegin(mode: GLenum);
begin
  if Assigned(FglBegin) then
  begin
    FglBegin(mode);
  end
  else
  begin
    raise Exception.Create('glBegin not bound');
  end;
end;

procedure TGL_VERSION_1_0.glBitmap(Width: GLsizei; Height: GLsizei; xorig: GLfloat; yorig: GLfloat; xmove: GLfloat; ymove: GLfloat; const bitmap: PGLubyte);
begin
  if Assigned(FglBitmap) then
  begin
    FglBitmap(Width, Height, xorig, yorig, xmove, ymove, bitmap);
  end
  else
  begin
    raise Exception.Create('glBitmap not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3b(red: GLbyte; green: GLbyte; blue: GLbyte);
begin
  if Assigned(FglColor3b) then
  begin
    FglColor3b(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glColor3b not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3bv(const v: PGLbyte);
begin
  if Assigned(FglColor3bv) then
  begin
    FglColor3bv(v);
  end
  else
  begin
    raise Exception.Create('glColor3bv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3d(red: GLdouble; green: GLdouble; blue: GLdouble);
begin
  if Assigned(FglColor3d) then
  begin
    FglColor3d(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glColor3d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3dv(const v: PGLdouble);
begin
  if Assigned(FglColor3dv) then
  begin
    FglColor3dv(v);
  end
  else
  begin
    raise Exception.Create('glColor3dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3f(red: GLfloat; green: GLfloat; blue: GLfloat);
begin
  if Assigned(FglColor3f) then
  begin
    FglColor3f(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glColor3f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3fv(const v: PGLfloat);
begin
  if Assigned(FglColor3fv) then
  begin
    FglColor3fv(v);
  end
  else
  begin
    raise Exception.Create('glColor3fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3i(red: GLint; green: GLint; blue: GLint);
begin
  if Assigned(FglColor3i) then
  begin
    FglColor3i(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glColor3i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3iv(const v: PGLint);
begin
  if Assigned(FglColor3iv) then
  begin
    FglColor3iv(v);
  end
  else
  begin
    raise Exception.Create('glColor3iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3s(red: GLshort; green: GLshort; blue: GLshort);
begin
  if Assigned(FglColor3s) then
  begin
    FglColor3s(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glColor3s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3sv(const v: PGLshort);
begin
  if Assigned(FglColor3sv) then
  begin
    FglColor3sv(v);
  end
  else
  begin
    raise Exception.Create('glColor3sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3ub(red: GLubyte; green: GLubyte; blue: GLubyte);
begin
  if Assigned(FglColor3ub) then
  begin
    FglColor3ub(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glColor3ub not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3ubv(const v: PGLubyte);
begin
  if Assigned(FglColor3ubv) then
  begin
    FglColor3ubv(v);
  end
  else
  begin
    raise Exception.Create('glColor3ubv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3ui(red: GLuint; green: GLuint; blue: GLuint);
begin
  if Assigned(FglColor3ui) then
  begin
    FglColor3ui(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glColor3ui not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3uiv(const v: PGLuint);
begin
  if Assigned(FglColor3uiv) then
  begin
    FglColor3uiv(v);
  end
  else
  begin
    raise Exception.Create('glColor3uiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3us(red: GLushort; green: GLushort; blue: GLushort);
begin
  if Assigned(FglColor3us) then
  begin
    FglColor3us(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glColor3us not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor3usv(const v: PGLushort);
begin
  if Assigned(FglColor3usv) then
  begin
    FglColor3usv(v);
  end
  else
  begin
    raise Exception.Create('glColor3usv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4b(red: GLbyte; green: GLbyte; blue: GLbyte; alpha: GLbyte);
begin
  if Assigned(FglColor4b) then
  begin
    FglColor4b(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glColor4b not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4bv(const v: PGLbyte);
begin
  if Assigned(FglColor4bv) then
  begin
    FglColor4bv(v);
  end
  else
  begin
    raise Exception.Create('glColor4bv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4d(red: GLdouble; green: GLdouble; blue: GLdouble; alpha: GLdouble);
begin
  if Assigned(FglColor4d) then
  begin
    FglColor4d(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glColor4d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4dv(const v: PGLdouble);
begin
  if Assigned(FglColor4dv) then
  begin
    FglColor4dv(v);
  end
  else
  begin
    raise Exception.Create('glColor4dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4f(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat);
begin
  if Assigned(FglColor4f) then
  begin
    FglColor4f(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glColor4f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4fv(const v: PGLfloat);
begin
  if Assigned(FglColor4fv) then
  begin
    FglColor4fv(v);
  end
  else
  begin
    raise Exception.Create('glColor4fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4i(red: GLint; green: GLint; blue: GLint; alpha: GLint);
begin
  if Assigned(FglColor4i) then
  begin
    FglColor4i(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glColor4i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4iv(const v: PGLint);
begin
  if Assigned(FglColor4iv) then
  begin
    FglColor4iv(v);
  end
  else
  begin
    raise Exception.Create('glColor4iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4s(red: GLshort; green: GLshort; blue: GLshort; alpha: GLshort);
begin
  if Assigned(FglColor4s) then
  begin
    FglColor4s(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glColor4s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4sv(const v: PGLshort);
begin
  if Assigned(FglColor4sv) then
  begin
    FglColor4sv(v);
  end
  else
  begin
    raise Exception.Create('glColor4sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4ub(red: GLubyte; green: GLubyte; blue: GLubyte; alpha: GLubyte);
begin
  if Assigned(FglColor4ub) then
  begin
    FglColor4ub(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glColor4ub not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4ubv(const v: PGLubyte);
begin
  if Assigned(FglColor4ubv) then
  begin
    FglColor4ubv(v);
  end
  else
  begin
    raise Exception.Create('glColor4ubv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4ui(red: GLuint; green: GLuint; blue: GLuint; alpha: GLuint);
begin
  if Assigned(FglColor4ui) then
  begin
    FglColor4ui(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glColor4ui not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4uiv(const v: PGLuint);
begin
  if Assigned(FglColor4uiv) then
  begin
    FglColor4uiv(v);
  end
  else
  begin
    raise Exception.Create('glColor4uiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4us(red: GLushort; green: GLushort; blue: GLushort; alpha: GLushort);
begin
  if Assigned(FglColor4us) then
  begin
    FglColor4us(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glColor4us not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColor4usv(const v: PGLushort);
begin
  if Assigned(FglColor4usv) then
  begin
    FglColor4usv(v);
  end
  else
  begin
    raise Exception.Create('glColor4usv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEdgeFlag(flag: GLboolean);
begin
  if Assigned(FglEdgeFlag) then
  begin
    FglEdgeFlag(flag);
  end
  else
  begin
    raise Exception.Create('glEdgeFlag not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEdgeFlagv(const flag: PGLboolean);
begin
  if Assigned(FglEdgeFlagv) then
  begin
    FglEdgeFlagv(flag);
  end
  else
  begin
    raise Exception.Create('glEdgeFlagv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEnd();
begin
  if Assigned(FglEnd) then
  begin
    FglEnd();
  end
  else
  begin
    raise Exception.Create('glEnd not bound');
  end;
end;

procedure TGL_VERSION_1_0.glIndexd(c: GLdouble);
begin
  if Assigned(FglIndexd) then
  begin
    FglIndexd(c);
  end
  else
  begin
    raise Exception.Create('glIndexd not bound');
  end;
end;

procedure TGL_VERSION_1_0.glIndexdv(const c: PGLdouble);
begin
  if Assigned(FglIndexdv) then
  begin
    FglIndexdv(c);
  end
  else
  begin
    raise Exception.Create('glIndexdv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glIndexf(c: GLfloat);
begin
  if Assigned(FglIndexf) then
  begin
    FglIndexf(c);
  end
  else
  begin
    raise Exception.Create('glIndexf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glIndexfv(const c: PGLfloat);
begin
  if Assigned(FglIndexfv) then
  begin
    FglIndexfv(c);
  end
  else
  begin
    raise Exception.Create('glIndexfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glIndexi(c: GLint);
begin
  if Assigned(FglIndexi) then
  begin
    FglIndexi(c);
  end
  else
  begin
    raise Exception.Create('glIndexi not bound');
  end;
end;

procedure TGL_VERSION_1_0.glIndexiv(const c: PGLint);
begin
  if Assigned(FglIndexiv) then
  begin
    FglIndexiv(c);
  end
  else
  begin
    raise Exception.Create('glIndexiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glIndexs(c: GLshort);
begin
  if Assigned(FglIndexs) then
  begin
    FglIndexs(c);
  end
  else
  begin
    raise Exception.Create('glIndexs not bound');
  end;
end;

procedure TGL_VERSION_1_0.glIndexsv(const c: PGLshort);
begin
  if Assigned(FglIndexsv) then
  begin
    FglIndexsv(c);
  end
  else
  begin
    raise Exception.Create('glIndexsv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3b(nx: GLbyte; ny: GLbyte; nz: GLbyte);
begin
  if Assigned(FglNormal3b) then
  begin
    FglNormal3b(nx, ny, nz);
  end
  else
  begin
    raise Exception.Create('glNormal3b not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3bv(const v: PGLbyte);
begin
  if Assigned(FglNormal3bv) then
  begin
    FglNormal3bv(v);
  end
  else
  begin
    raise Exception.Create('glNormal3bv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3d(nx: GLdouble; ny: GLdouble; nz: GLdouble);
begin
  if Assigned(FglNormal3d) then
  begin
    FglNormal3d(nx, ny, nz);
  end
  else
  begin
    raise Exception.Create('glNormal3d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3dv(const v: PGLdouble);
begin
  if Assigned(FglNormal3dv) then
  begin
    FglNormal3dv(v);
  end
  else
  begin
    raise Exception.Create('glNormal3dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3f(nx: GLfloat; ny: GLfloat; nz: GLfloat);
begin
  if Assigned(FglNormal3f) then
  begin
    FglNormal3f(nx, ny, nz);
  end
  else
  begin
    raise Exception.Create('glNormal3f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3fv(const v: PGLfloat);
begin
  if Assigned(FglNormal3fv) then
  begin
    FglNormal3fv(v);
  end
  else
  begin
    raise Exception.Create('glNormal3fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3i(nx: GLint; ny: GLint; nz: GLint);
begin
  if Assigned(FglNormal3i) then
  begin
    FglNormal3i(nx, ny, nz);
  end
  else
  begin
    raise Exception.Create('glNormal3i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3iv(const v: PGLint);
begin
  if Assigned(FglNormal3iv) then
  begin
    FglNormal3iv(v);
  end
  else
  begin
    raise Exception.Create('glNormal3iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3s(nx: GLshort; ny: GLshort; nz: GLshort);
begin
  if Assigned(FglNormal3s) then
  begin
    FglNormal3s(nx, ny, nz);
  end
  else
  begin
    raise Exception.Create('glNormal3s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glNormal3sv(const v: PGLshort);
begin
  if Assigned(FglNormal3sv) then
  begin
    FglNormal3sv(v);
  end
  else
  begin
    raise Exception.Create('glNormal3sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos2d(x: GLdouble; y: GLdouble);
begin
  if Assigned(FglRasterPos2d) then
  begin
    FglRasterPos2d(x, y);
  end
  else
  begin
    raise Exception.Create('glRasterPos2d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos2dv(const v: PGLdouble);
begin
  if Assigned(FglRasterPos2dv) then
  begin
    FglRasterPos2dv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos2dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos2f(x: GLfloat; y: GLfloat);
begin
  if Assigned(FglRasterPos2f) then
  begin
    FglRasterPos2f(x, y);
  end
  else
  begin
    raise Exception.Create('glRasterPos2f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos2fv(const v: PGLfloat);
begin
  if Assigned(FglRasterPos2fv) then
  begin
    FglRasterPos2fv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos2fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos2i(x: GLint; y: GLint);
begin
  if Assigned(FglRasterPos2i) then
  begin
    FglRasterPos2i(x, y);
  end
  else
  begin
    raise Exception.Create('glRasterPos2i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos2iv(const v: PGLint);
begin
  if Assigned(FglRasterPos2iv) then
  begin
    FglRasterPos2iv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos2iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos2s(x: GLshort; y: GLshort);
begin
  if Assigned(FglRasterPos2s) then
  begin
    FglRasterPos2s(x, y);
  end
  else
  begin
    raise Exception.Create('glRasterPos2s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos2sv(const v: PGLshort);
begin
  if Assigned(FglRasterPos2sv) then
  begin
    FglRasterPos2sv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos2sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos3d(x: GLdouble; y: GLdouble; z: GLdouble);
begin
  if Assigned(FglRasterPos3d) then
  begin
    FglRasterPos3d(x, y, z);
  end
  else
  begin
    raise Exception.Create('glRasterPos3d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos3dv(const v: PGLdouble);
begin
  if Assigned(FglRasterPos3dv) then
  begin
    FglRasterPos3dv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos3dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos3f(x: GLfloat; y: GLfloat; z: GLfloat);
begin
  if Assigned(FglRasterPos3f) then
  begin
    FglRasterPos3f(x, y, z);
  end
  else
  begin
    raise Exception.Create('glRasterPos3f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos3fv(const v: PGLfloat);
begin
  if Assigned(FglRasterPos3fv) then
  begin
    FglRasterPos3fv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos3fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos3i(x: GLint; y: GLint; z: GLint);
begin
  if Assigned(FglRasterPos3i) then
  begin
    FglRasterPos3i(x, y, z);
  end
  else
  begin
    raise Exception.Create('glRasterPos3i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos3iv(const v: PGLint);
begin
  if Assigned(FglRasterPos3iv) then
  begin
    FglRasterPos3iv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos3iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos3s(x: GLshort; y: GLshort; z: GLshort);
begin
  if Assigned(FglRasterPos3s) then
  begin
    FglRasterPos3s(x, y, z);
  end
  else
  begin
    raise Exception.Create('glRasterPos3s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos3sv(const v: PGLshort);
begin
  if Assigned(FglRasterPos3sv) then
  begin
    FglRasterPos3sv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos3sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos4d(x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
begin
  if Assigned(FglRasterPos4d) then
  begin
    FglRasterPos4d(x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glRasterPos4d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos4dv(const v: PGLdouble);
begin
  if Assigned(FglRasterPos4dv) then
  begin
    FglRasterPos4dv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos4dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos4f(x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat);
begin
  if Assigned(FglRasterPos4f) then
  begin
    FglRasterPos4f(x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glRasterPos4f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos4fv(const v: PGLfloat);
begin
  if Assigned(FglRasterPos4fv) then
  begin
    FglRasterPos4fv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos4fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos4i(x: GLint; y: GLint; z: GLint; w: GLint);
begin
  if Assigned(FglRasterPos4i) then
  begin
    FglRasterPos4i(x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glRasterPos4i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos4iv(const v: PGLint);
begin
  if Assigned(FglRasterPos4iv) then
  begin
    FglRasterPos4iv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos4iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos4s(x: GLshort; y: GLshort; z: GLshort; w: GLshort);
begin
  if Assigned(FglRasterPos4s) then
  begin
    FglRasterPos4s(x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glRasterPos4s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRasterPos4sv(const v: PGLshort);
begin
  if Assigned(FglRasterPos4sv) then
  begin
    FglRasterPos4sv(v);
  end
  else
  begin
    raise Exception.Create('glRasterPos4sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRectd(x1: GLdouble; y1: GLdouble; x2: GLdouble; y2: GLdouble);
begin
  if Assigned(FglRectd) then
  begin
    FglRectd(x1, y1, x2, y2);
  end
  else
  begin
    raise Exception.Create('glRectd not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRectdv(const v1: PGLdouble; const v2: PGLdouble);
begin
  if Assigned(FglRectdv) then
  begin
    FglRectdv(v1, v2);
  end
  else
  begin
    raise Exception.Create('glRectdv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRectf(x1: GLfloat; y1: GLfloat; x2: GLfloat; y2: GLfloat);
begin
  if Assigned(FglRectf) then
  begin
    FglRectf(x1, y1, x2, y2);
  end
  else
  begin
    raise Exception.Create('glRectf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRectfv(const v1: PGLfloat; const v2: PGLfloat);
begin
  if Assigned(FglRectfv) then
  begin
    FglRectfv(v1, v2);
  end
  else
  begin
    raise Exception.Create('glRectfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRecti(x1: GLint; y1: GLint; x2: GLint; y2: GLint);
begin
  if Assigned(FglRecti) then
  begin
    FglRecti(x1, y1, x2, y2);
  end
  else
  begin
    raise Exception.Create('glRecti not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRectiv(const v1: PGLint; const v2: PGLint);
begin
  if Assigned(FglRectiv) then
  begin
    FglRectiv(v1, v2);
  end
  else
  begin
    raise Exception.Create('glRectiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRects(x1: GLshort; y1: GLshort; x2: GLshort; y2: GLshort);
begin
  if Assigned(FglRects) then
  begin
    FglRects(x1, y1, x2, y2);
  end
  else
  begin
    raise Exception.Create('glRects not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRectsv(const v1: PGLshort; const v2: PGLshort);
begin
  if Assigned(FglRectsv) then
  begin
    FglRectsv(v1, v2);
  end
  else
  begin
    raise Exception.Create('glRectsv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord1d(s: GLdouble);
begin
  if Assigned(FglTexCoord1d) then
  begin
    FglTexCoord1d(s);
  end
  else
  begin
    raise Exception.Create('glTexCoord1d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord1dv(const v: PGLdouble);
begin
  if Assigned(FglTexCoord1dv) then
  begin
    FglTexCoord1dv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord1dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord1f(s: GLfloat);
begin
  if Assigned(FglTexCoord1f) then
  begin
    FglTexCoord1f(s);
  end
  else
  begin
    raise Exception.Create('glTexCoord1f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord1fv(const v: PGLfloat);
begin
  if Assigned(FglTexCoord1fv) then
  begin
    FglTexCoord1fv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord1fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord1i(s: GLint);
begin
  if Assigned(FglTexCoord1i) then
  begin
    FglTexCoord1i(s);
  end
  else
  begin
    raise Exception.Create('glTexCoord1i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord1iv(const v: PGLint);
begin
  if Assigned(FglTexCoord1iv) then
  begin
    FglTexCoord1iv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord1iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord1s(s: GLshort);
begin
  if Assigned(FglTexCoord1s) then
  begin
    FglTexCoord1s(s);
  end
  else
  begin
    raise Exception.Create('glTexCoord1s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord1sv(const v: PGLshort);
begin
  if Assigned(FglTexCoord1sv) then
  begin
    FglTexCoord1sv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord1sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord2d(s: GLdouble; t: GLdouble);
begin
  if Assigned(FglTexCoord2d) then
  begin
    FglTexCoord2d(s, t);
  end
  else
  begin
    raise Exception.Create('glTexCoord2d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord2dv(const v: PGLdouble);
begin
  if Assigned(FglTexCoord2dv) then
  begin
    FglTexCoord2dv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord2dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord2f(s: GLfloat; t: GLfloat);
begin
  if Assigned(FglTexCoord2f) then
  begin
    FglTexCoord2f(s, t);
  end
  else
  begin
    raise Exception.Create('glTexCoord2f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord2fv(const v: PGLfloat);
begin
  if Assigned(FglTexCoord2fv) then
  begin
    FglTexCoord2fv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord2fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord2i(s: GLint; t: GLint);
begin
  if Assigned(FglTexCoord2i) then
  begin
    FglTexCoord2i(s, t);
  end
  else
  begin
    raise Exception.Create('glTexCoord2i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord2iv(const v: PGLint);
begin
  if Assigned(FglTexCoord2iv) then
  begin
    FglTexCoord2iv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord2iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord2s(s: GLshort; t: GLshort);
begin
  if Assigned(FglTexCoord2s) then
  begin
    FglTexCoord2s(s, t);
  end
  else
  begin
    raise Exception.Create('glTexCoord2s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord2sv(const v: PGLshort);
begin
  if Assigned(FglTexCoord2sv) then
  begin
    FglTexCoord2sv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord2sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord3d(s: GLdouble; t: GLdouble; r: GLdouble);
begin
  if Assigned(FglTexCoord3d) then
  begin
    FglTexCoord3d(s, t, r);
  end
  else
  begin
    raise Exception.Create('glTexCoord3d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord3dv(const v: PGLdouble);
begin
  if Assigned(FglTexCoord3dv) then
  begin
    FglTexCoord3dv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord3dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord3f(s: GLfloat; t: GLfloat; r: GLfloat);
begin
  if Assigned(FglTexCoord3f) then
  begin
    FglTexCoord3f(s, t, r);
  end
  else
  begin
    raise Exception.Create('glTexCoord3f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord3fv(const v: PGLfloat);
begin
  if Assigned(FglTexCoord3fv) then
  begin
    FglTexCoord3fv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord3fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord3i(s: GLint; t: GLint; r: GLint);
begin
  if Assigned(FglTexCoord3i) then
  begin
    FglTexCoord3i(s, t, r);
  end
  else
  begin
    raise Exception.Create('glTexCoord3i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord3iv(const v: PGLint);
begin
  if Assigned(FglTexCoord3iv) then
  begin
    FglTexCoord3iv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord3iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord3s(s: GLshort; t: GLshort; r: GLshort);
begin
  if Assigned(FglTexCoord3s) then
  begin
    FglTexCoord3s(s, t, r);
  end
  else
  begin
    raise Exception.Create('glTexCoord3s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord3sv(const v: PGLshort);
begin
  if Assigned(FglTexCoord3sv) then
  begin
    FglTexCoord3sv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord3sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord4d(s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble);
begin
  if Assigned(FglTexCoord4d) then
  begin
    FglTexCoord4d(s, t, r, q);
  end
  else
  begin
    raise Exception.Create('glTexCoord4d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord4dv(const v: PGLdouble);
begin
  if Assigned(FglTexCoord4dv) then
  begin
    FglTexCoord4dv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord4dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord4f(s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat);
begin
  if Assigned(FglTexCoord4f) then
  begin
    FglTexCoord4f(s, t, r, q);
  end
  else
  begin
    raise Exception.Create('glTexCoord4f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord4fv(const v: PGLfloat);
begin
  if Assigned(FglTexCoord4fv) then
  begin
    FglTexCoord4fv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord4fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord4i(s: GLint; t: GLint; r: GLint; q: GLint);
begin
  if Assigned(FglTexCoord4i) then
  begin
    FglTexCoord4i(s, t, r, q);
  end
  else
  begin
    raise Exception.Create('glTexCoord4i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord4iv(const v: PGLint);
begin
  if Assigned(FglTexCoord4iv) then
  begin
    FglTexCoord4iv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord4iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord4s(s: GLshort; t: GLshort; r: GLshort; q: GLshort);
begin
  if Assigned(FglTexCoord4s) then
  begin
    FglTexCoord4s(s, t, r, q);
  end
  else
  begin
    raise Exception.Create('glTexCoord4s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexCoord4sv(const v: PGLshort);
begin
  if Assigned(FglTexCoord4sv) then
  begin
    FglTexCoord4sv(v);
  end
  else
  begin
    raise Exception.Create('glTexCoord4sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex2d(x: GLdouble; y: GLdouble);
begin
  if Assigned(FglVertex2d) then
  begin
    FglVertex2d(x, y);
  end
  else
  begin
    raise Exception.Create('glVertex2d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex2dv(const v: PGLdouble);
begin
  if Assigned(FglVertex2dv) then
  begin
    FglVertex2dv(v);
  end
  else
  begin
    raise Exception.Create('glVertex2dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex2f(x: GLfloat; y: GLfloat);
begin
  if Assigned(FglVertex2f) then
  begin
    FglVertex2f(x, y);
  end
  else
  begin
    raise Exception.Create('glVertex2f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex2fv(const v: PGLfloat);
begin
  if Assigned(FglVertex2fv) then
  begin
    FglVertex2fv(v);
  end
  else
  begin
    raise Exception.Create('glVertex2fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex2i(x: GLint; y: GLint);
begin
  if Assigned(FglVertex2i) then
  begin
    FglVertex2i(x, y);
  end
  else
  begin
    raise Exception.Create('glVertex2i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex2iv(const v: PGLint);
begin
  if Assigned(FglVertex2iv) then
  begin
    FglVertex2iv(v);
  end
  else
  begin
    raise Exception.Create('glVertex2iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex2s(x: GLshort; y: GLshort);
begin
  if Assigned(FglVertex2s) then
  begin
    FglVertex2s(x, y);
  end
  else
  begin
    raise Exception.Create('glVertex2s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex2sv(const v: PGLshort);
begin
  if Assigned(FglVertex2sv) then
  begin
    FglVertex2sv(v);
  end
  else
  begin
    raise Exception.Create('glVertex2sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex3d(x: GLdouble; y: GLdouble; z: GLdouble);
begin
  if Assigned(FglVertex3d) then
  begin
    FglVertex3d(x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertex3d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex3dv(const v: PGLdouble);
begin
  if Assigned(FglVertex3dv) then
  begin
    FglVertex3dv(v);
  end
  else
  begin
    raise Exception.Create('glVertex3dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex3f(x: GLfloat; y: GLfloat; z: GLfloat);
begin
  if Assigned(FglVertex3f) then
  begin
    FglVertex3f(x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertex3f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex3fv(const v: PGLfloat);
begin
  if Assigned(FglVertex3fv) then
  begin
    FglVertex3fv(v);
  end
  else
  begin
    raise Exception.Create('glVertex3fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex3i(x: GLint; y: GLint; z: GLint);
begin
  if Assigned(FglVertex3i) then
  begin
    FglVertex3i(x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertex3i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex3iv(const v: PGLint);
begin
  if Assigned(FglVertex3iv) then
  begin
    FglVertex3iv(v);
  end
  else
  begin
    raise Exception.Create('glVertex3iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex3s(x: GLshort; y: GLshort; z: GLshort);
begin
  if Assigned(FglVertex3s) then
  begin
    FglVertex3s(x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertex3s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex3sv(const v: PGLshort);
begin
  if Assigned(FglVertex3sv) then
  begin
    FglVertex3sv(v);
  end
  else
  begin
    raise Exception.Create('glVertex3sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex4d(x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
begin
  if Assigned(FglVertex4d) then
  begin
    FglVertex4d(x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertex4d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex4dv(const v: PGLdouble);
begin
  if Assigned(FglVertex4dv) then
  begin
    FglVertex4dv(v);
  end
  else
  begin
    raise Exception.Create('glVertex4dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex4f(x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat);
begin
  if Assigned(FglVertex4f) then
  begin
    FglVertex4f(x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertex4f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex4fv(const v: PGLfloat);
begin
  if Assigned(FglVertex4fv) then
  begin
    FglVertex4fv(v);
  end
  else
  begin
    raise Exception.Create('glVertex4fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex4i(x: GLint; y: GLint; z: GLint; w: GLint);
begin
  if Assigned(FglVertex4i) then
  begin
    FglVertex4i(x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertex4i not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex4iv(const v: PGLint);
begin
  if Assigned(FglVertex4iv) then
  begin
    FglVertex4iv(v);
  end
  else
  begin
    raise Exception.Create('glVertex4iv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex4s(x: GLshort; y: GLshort; z: GLshort; w: GLshort);
begin
  if Assigned(FglVertex4s) then
  begin
    FglVertex4s(x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertex4s not bound');
  end;
end;

procedure TGL_VERSION_1_0.glVertex4sv(const v: PGLshort);
begin
  if Assigned(FglVertex4sv) then
  begin
    FglVertex4sv(v);
  end
  else
  begin
    raise Exception.Create('glVertex4sv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glClipPlane(plane: GLenum; const equation: PGLdouble);
begin
  if Assigned(FglClipPlane) then
  begin
    FglClipPlane(plane, equation);
  end
  else
  begin
    raise Exception.Create('glClipPlane not bound');
  end;
end;

procedure TGL_VERSION_1_0.glColorMaterial(face: GLenum; mode: GLenum);
begin
  if Assigned(FglColorMaterial) then
  begin
    FglColorMaterial(face, mode);
  end
  else
  begin
    raise Exception.Create('glColorMaterial not bound');
  end;
end;

procedure TGL_VERSION_1_0.glFogf(pname: GLenum; param: GLfloat);
begin
  if Assigned(FglFogf) then
  begin
    FglFogf(pname, param);
  end
  else
  begin
    raise Exception.Create('glFogf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glFogfv(pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglFogfv) then
  begin
    FglFogfv(pname, params);
  end
  else
  begin
    raise Exception.Create('glFogfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glFogi(pname: GLenum; param: GLint);
begin
  if Assigned(FglFogi) then
  begin
    FglFogi(pname, param);
  end
  else
  begin
    raise Exception.Create('glFogi not bound');
  end;
end;

procedure TGL_VERSION_1_0.glFogiv(pname: GLenum; const params: PGLint);
begin
  if Assigned(FglFogiv) then
  begin
    FglFogiv(pname, params);
  end
  else
  begin
    raise Exception.Create('glFogiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLightf(light: GLenum; pname: GLenum; param: GLfloat);
begin
  if Assigned(FglLightf) then
  begin
    FglLightf(light, pname, param);
  end
  else
  begin
    raise Exception.Create('glLightf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLightfv(light: GLenum; pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglLightfv) then
  begin
    FglLightfv(light, pname, params);
  end
  else
  begin
    raise Exception.Create('glLightfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLighti(light: GLenum; pname: GLenum; param: GLint);
begin
  if Assigned(FglLighti) then
  begin
    FglLighti(light, pname, param);
  end
  else
  begin
    raise Exception.Create('glLighti not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLightiv(light: GLenum; pname: GLenum; const params: PGLint);
begin
  if Assigned(FglLightiv) then
  begin
    FglLightiv(light, pname, params);
  end
  else
  begin
    raise Exception.Create('glLightiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLightModelf(pname: GLenum; param: GLfloat);
begin
  if Assigned(FglLightModelf) then
  begin
    FglLightModelf(pname, param);
  end
  else
  begin
    raise Exception.Create('glLightModelf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLightModelfv(pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglLightModelfv) then
  begin
    FglLightModelfv(pname, params);
  end
  else
  begin
    raise Exception.Create('glLightModelfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLightModeli(pname: GLenum; param: GLint);
begin
  if Assigned(FglLightModeli) then
  begin
    FglLightModeli(pname, param);
  end
  else
  begin
    raise Exception.Create('glLightModeli not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLightModeliv(pname: GLenum; const params: PGLint);
begin
  if Assigned(FglLightModeliv) then
  begin
    FglLightModeliv(pname, params);
  end
  else
  begin
    raise Exception.Create('glLightModeliv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLineStipple(factor: GLint; pattern: GLushort);
begin
  if Assigned(FglLineStipple) then
  begin
    FglLineStipple(factor, pattern);
  end
  else
  begin
    raise Exception.Create('glLineStipple not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMaterialf(face: GLenum; pname: GLenum; param: GLfloat);
begin
  if Assigned(FglMaterialf) then
  begin
    FglMaterialf(face, pname, param);
  end
  else
  begin
    raise Exception.Create('glMaterialf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMaterialfv(face: GLenum; pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglMaterialfv) then
  begin
    FglMaterialfv(face, pname, params);
  end
  else
  begin
    raise Exception.Create('glMaterialfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMateriali(face: GLenum; pname: GLenum; param: GLint);
begin
  if Assigned(FglMateriali) then
  begin
    FglMateriali(face, pname, param);
  end
  else
  begin
    raise Exception.Create('glMateriali not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMaterialiv(face: GLenum; pname: GLenum; const params: PGLint);
begin
  if Assigned(FglMaterialiv) then
  begin
    FglMaterialiv(face, pname, params);
  end
  else
  begin
    raise Exception.Create('glMaterialiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPolygonStipple(const mask: PGLubyte);
begin
  if Assigned(FglPolygonStipple) then
  begin
    FglPolygonStipple(mask);
  end
  else
  begin
    raise Exception.Create('glPolygonStipple not bound');
  end;
end;

procedure TGL_VERSION_1_0.glShadeModel(mode: GLenum);
begin
  if Assigned(FglShadeModel) then
  begin
    FglShadeModel(mode);
  end
  else
  begin
    raise Exception.Create('glShadeModel not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexEnvf(target: GLenum; pname: GLenum; param: GLfloat);
begin
  if Assigned(FglTexEnvf) then
  begin
    FglTexEnvf(target, pname, param);
  end
  else
  begin
    raise Exception.Create('glTexEnvf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexEnvfv(target: GLenum; pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglTexEnvfv) then
  begin
    FglTexEnvfv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glTexEnvfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexEnvi(target: GLenum; pname: GLenum; param: GLint);
begin
  if Assigned(FglTexEnvi) then
  begin
    FglTexEnvi(target, pname, param);
  end
  else
  begin
    raise Exception.Create('glTexEnvi not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexEnviv(target: GLenum; pname: GLenum; const params: PGLint);
begin
  if Assigned(FglTexEnviv) then
  begin
    FglTexEnviv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glTexEnviv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexGend(coord: GLenum; pname: GLenum; param: GLdouble);
begin
  if Assigned(FglTexGend) then
  begin
    FglTexGend(coord, pname, param);
  end
  else
  begin
    raise Exception.Create('glTexGend not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexGendv(coord: GLenum; pname: GLenum; const params: PGLdouble);
begin
  if Assigned(FglTexGendv) then
  begin
    FglTexGendv(coord, pname, params);
  end
  else
  begin
    raise Exception.Create('glTexGendv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexGenf(coord: GLenum; pname: GLenum; param: GLfloat);
begin
  if Assigned(FglTexGenf) then
  begin
    FglTexGenf(coord, pname, param);
  end
  else
  begin
    raise Exception.Create('glTexGenf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexGenfv(coord: GLenum; pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglTexGenfv) then
  begin
    FglTexGenfv(coord, pname, params);
  end
  else
  begin
    raise Exception.Create('glTexGenfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexGeni(coord: GLenum; pname: GLenum; param: GLint);
begin
  if Assigned(FglTexGeni) then
  begin
    FglTexGeni(coord, pname, param);
  end
  else
  begin
    raise Exception.Create('glTexGeni not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTexGeniv(coord: GLenum; pname: GLenum; const params: PGLint);
begin
  if Assigned(FglTexGeniv) then
  begin
    FglTexGeniv(coord, pname, params);
  end
  else
  begin
    raise Exception.Create('glTexGeniv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glFeedbackBuffer(size: GLsizei; aType: GLenum; buffer: PGLfloat);
begin
  if Assigned(FglFeedbackBuffer) then
  begin
    FglFeedbackBuffer(size, aType, buffer);
  end
  else
  begin
    raise Exception.Create('glFeedbackBuffer not bound');
  end;
end;

procedure TGL_VERSION_1_0.glSelectBuffer(size: GLsizei; buffer: PGLuint);
begin
  if Assigned(FglSelectBuffer) then
  begin
    FglSelectBuffer(size, buffer);
  end
  else
  begin
    raise Exception.Create('glSelectBuffer not bound');
  end;
end;

function TGL_VERSION_1_0.glRenderMode(mode: GLenum): GLint;
begin
  if Assigned(FglRenderMode) then
  begin
    Result := FglRenderMode(mode);
  end
  else
  begin
    raise Exception.Create('glRenderMode not bound');
  end;
end;

procedure TGL_VERSION_1_0.glInitNames();
begin
  if Assigned(FglInitNames) then
  begin
    FglInitNames();
  end
  else
  begin
    raise Exception.Create('glInitNames not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLoadName(Name: GLuint);
begin
  if Assigned(FglLoadName) then
  begin
    FglLoadName(Name);
  end
  else
  begin
    raise Exception.Create('glLoadName not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPassThrough(token: GLfloat);
begin
  if Assigned(FglPassThrough) then
  begin
    FglPassThrough(token);
  end
  else
  begin
    raise Exception.Create('glPassThrough not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPopName();
begin
  if Assigned(FglPopName) then
  begin
    FglPopName();
  end
  else
  begin
    raise Exception.Create('glPopName not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPushName(Name: GLuint);
begin
  if Assigned(FglPushName) then
  begin
    FglPushName(Name);
  end
  else
  begin
    raise Exception.Create('glPushName not bound');
  end;
end;

procedure TGL_VERSION_1_0.glClearAccum(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat);
begin
  if Assigned(FglClearAccum) then
  begin
    FglClearAccum(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glClearAccum not bound');
  end;
end;

procedure TGL_VERSION_1_0.glClearIndex(c: GLfloat);
begin
  if Assigned(FglClearIndex) then
  begin
    FglClearIndex(c);
  end
  else
  begin
    raise Exception.Create('glClearIndex not bound');
  end;
end;

procedure TGL_VERSION_1_0.glIndexMask(mask: GLuint);
begin
  if Assigned(FglIndexMask) then
  begin
    FglIndexMask(mask);
  end
  else
  begin
    raise Exception.Create('glIndexMask not bound');
  end;
end;

procedure TGL_VERSION_1_0.glAccum(op: GLenum; Value: GLfloat);
begin
  if Assigned(FglAccum) then
  begin
    FglAccum(op, Value);
  end
  else
  begin
    raise Exception.Create('glAccum not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPopAttrib();
begin
  if Assigned(FglPopAttrib) then
  begin
    FglPopAttrib();
  end
  else
  begin
    raise Exception.Create('glPopAttrib not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPushAttrib(mask: GLbitfield);
begin
  if Assigned(FglPushAttrib) then
  begin
    FglPushAttrib(mask);
  end
  else
  begin
    raise Exception.Create('glPushAttrib not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMap1d(target: GLenum; u1: GLdouble; u2: GLdouble; stride: GLint; order: GLint; const points: PGLdouble);
begin
  if Assigned(FglMap1d) then
  begin
    FglMap1d(target, u1, u2, stride, order, points);
  end
  else
  begin
    raise Exception.Create('glMap1d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMap1f(target: GLenum; u1: GLfloat; u2: GLfloat; stride: GLint; order: GLint; const points: PGLfloat);
begin
  if Assigned(FglMap1f) then
  begin
    FglMap1f(target, u1, u2, stride, order, points);
  end
  else
  begin
    raise Exception.Create('glMap1f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMap2d(target: GLenum; u1: GLdouble; u2: GLdouble; ustride: GLint; uorder: GLint; v1: GLdouble; v2: GLdouble; vstride: GLint; vorder: GLint; const points: PGLdouble);
begin
  if Assigned(FglMap2d) then
  begin
    FglMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
  end
  else
  begin
    raise Exception.Create('glMap2d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMap2f(target: GLenum; u1: GLfloat; u2: GLfloat; ustride: GLint; uorder: GLint; v1: GLfloat; v2: GLfloat; vstride: GLint; vorder: GLint; const points: PGLfloat);
begin
  if Assigned(FglMap2f) then
  begin
    FglMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
  end
  else
  begin
    raise Exception.Create('glMap2f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMapGrid1d(un: GLint; u1: GLdouble; u2: GLdouble);
begin
  if Assigned(FglMapGrid1d) then
  begin
    FglMapGrid1d(un, u1, u2);
  end
  else
  begin
    raise Exception.Create('glMapGrid1d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMapGrid1f(un: GLint; u1: GLfloat; u2: GLfloat);
begin
  if Assigned(FglMapGrid1f) then
  begin
    FglMapGrid1f(un, u1, u2);
  end
  else
  begin
    raise Exception.Create('glMapGrid1f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMapGrid2d(un: GLint; u1: GLdouble; u2: GLdouble; vn: GLint; v1: GLdouble; v2: GLdouble);
begin
  if Assigned(FglMapGrid2d) then
  begin
    FglMapGrid2d(un, u1, u2, vn, v1, v2);
  end
  else
  begin
    raise Exception.Create('glMapGrid2d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMapGrid2f(un: GLint; u1: GLfloat; u2: GLfloat; vn: GLint; v1: GLfloat; v2: GLfloat);
begin
  if Assigned(FglMapGrid2f) then
  begin
    FglMapGrid2f(un, u1, u2, vn, v1, v2);
  end
  else
  begin
    raise Exception.Create('glMapGrid2f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalCoord1d(u: GLdouble);
begin
  if Assigned(FglEvalCoord1d) then
  begin
    FglEvalCoord1d(u);
  end
  else
  begin
    raise Exception.Create('glEvalCoord1d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalCoord1dv(const u: PGLdouble);
begin
  if Assigned(FglEvalCoord1dv) then
  begin
    FglEvalCoord1dv(u);
  end
  else
  begin
    raise Exception.Create('glEvalCoord1dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalCoord1f(u: GLfloat);
begin
  if Assigned(FglEvalCoord1f) then
  begin
    FglEvalCoord1f(u);
  end
  else
  begin
    raise Exception.Create('glEvalCoord1f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalCoord1fv(const u: PGLfloat);
begin
  if Assigned(FglEvalCoord1fv) then
  begin
    FglEvalCoord1fv(u);
  end
  else
  begin
    raise Exception.Create('glEvalCoord1fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalCoord2d(u: GLdouble; v: GLdouble);
begin
  if Assigned(FglEvalCoord2d) then
  begin
    FglEvalCoord2d(u, v);
  end
  else
  begin
    raise Exception.Create('glEvalCoord2d not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalCoord2dv(const u: PGLdouble);
begin
  if Assigned(FglEvalCoord2dv) then
  begin
    FglEvalCoord2dv(u);
  end
  else
  begin
    raise Exception.Create('glEvalCoord2dv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalCoord2f(u: GLfloat; v: GLfloat);
begin
  if Assigned(FglEvalCoord2f) then
  begin
    FglEvalCoord2f(u, v);
  end
  else
  begin
    raise Exception.Create('glEvalCoord2f not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalCoord2fv(const u: PGLfloat);
begin
  if Assigned(FglEvalCoord2fv) then
  begin
    FglEvalCoord2fv(u);
  end
  else
  begin
    raise Exception.Create('glEvalCoord2fv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalMesh1(mode: GLenum; i1: GLint; i2: GLint);
begin
  if Assigned(FglEvalMesh1) then
  begin
    FglEvalMesh1(mode, i1, i2);
  end
  else
  begin
    raise Exception.Create('glEvalMesh1 not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalPoint1(i: GLint);
begin
  if Assigned(FglEvalPoint1) then
  begin
    FglEvalPoint1(i);
  end
  else
  begin
    raise Exception.Create('glEvalPoint1 not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalMesh2(mode: GLenum; i1: GLint; i2: GLint; j1: GLint; j2: GLint);
begin
  if Assigned(FglEvalMesh2) then
  begin
    FglEvalMesh2(mode, i1, i2, j1, j2);
  end
  else
  begin
    raise Exception.Create('glEvalMesh2 not bound');
  end;
end;

procedure TGL_VERSION_1_0.glEvalPoint2(i: GLint; j: GLint);
begin
  if Assigned(FglEvalPoint2) then
  begin
    FglEvalPoint2(i, j);
  end
  else
  begin
    raise Exception.Create('glEvalPoint2 not bound');
  end;
end;

procedure TGL_VERSION_1_0.glAlphaFunc(func: GLenum; ref: GLfloat);
begin
  if Assigned(FglAlphaFunc) then
  begin
    FglAlphaFunc(func, ref);
  end
  else
  begin
    raise Exception.Create('glAlphaFunc not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPixelZoom(xfactor: GLfloat; yfactor: GLfloat);
begin
  if Assigned(FglPixelZoom) then
  begin
    FglPixelZoom(xfactor, yfactor);
  end
  else
  begin
    raise Exception.Create('glPixelZoom not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPixelTransferf(pname: GLenum; param: GLfloat);
begin
  if Assigned(FglPixelTransferf) then
  begin
    FglPixelTransferf(pname, param);
  end
  else
  begin
    raise Exception.Create('glPixelTransferf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPixelTransferi(pname: GLenum; param: GLint);
begin
  if Assigned(FglPixelTransferi) then
  begin
    FglPixelTransferi(pname, param);
  end
  else
  begin
    raise Exception.Create('glPixelTransferi not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPixelMapfv(map: GLenum; mapsize: GLsizei; const values: PGLfloat);
begin
  if Assigned(FglPixelMapfv) then
  begin
    FglPixelMapfv(map, mapsize, values);
  end
  else
  begin
    raise Exception.Create('glPixelMapfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPixelMapuiv(map: GLenum; mapsize: GLsizei; const values: PGLuint);
begin
  if Assigned(FglPixelMapuiv) then
  begin
    FglPixelMapuiv(map, mapsize, values);
  end
  else
  begin
    raise Exception.Create('glPixelMapuiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPixelMapusv(map: GLenum; mapsize: GLsizei; const values: PGLushort);
begin
  if Assigned(FglPixelMapusv) then
  begin
    FglPixelMapusv(map, mapsize, values);
  end
  else
  begin
    raise Exception.Create('glPixelMapusv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glCopyPixels(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; aType: GLenum);
begin
  if Assigned(FglCopyPixels) then
  begin
    FglCopyPixels(x, y, Width, Height, aType);
  end
  else
  begin
    raise Exception.Create('glCopyPixels not bound');
  end;
end;

procedure TGL_VERSION_1_0.glDrawPixels(Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglDrawPixels) then
  begin
    FglDrawPixels(Width, Height, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glDrawPixels not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetClipPlane(plane: GLenum; equation: PGLdouble);
begin
  if Assigned(FglGetClipPlane) then
  begin
    FglGetClipPlane(plane, equation);
  end
  else
  begin
    raise Exception.Create('glGetClipPlane not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetLightfv(light: GLenum; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetLightfv) then
  begin
    FglGetLightfv(light, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetLightfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetLightiv(light: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetLightiv) then
  begin
    FglGetLightiv(light, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetLightiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetMapdv(target: GLenum; query: GLenum; v: PGLdouble);
begin
  if Assigned(FglGetMapdv) then
  begin
    FglGetMapdv(target, query, v);
  end
  else
  begin
    raise Exception.Create('glGetMapdv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetMapfv(target: GLenum; query: GLenum; v: PGLfloat);
begin
  if Assigned(FglGetMapfv) then
  begin
    FglGetMapfv(target, query, v);
  end
  else
  begin
    raise Exception.Create('glGetMapfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetMapiv(target: GLenum; query: GLenum; v: PGLint);
begin
  if Assigned(FglGetMapiv) then
  begin
    FglGetMapiv(target, query, v);
  end
  else
  begin
    raise Exception.Create('glGetMapiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetMaterialfv(face: GLenum; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetMaterialfv) then
  begin
    FglGetMaterialfv(face, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetMaterialfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetMaterialiv(face: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetMaterialiv) then
  begin
    FglGetMaterialiv(face, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetMaterialiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetPixelMapfv(map: GLenum; values: PGLfloat);
begin
  if Assigned(FglGetPixelMapfv) then
  begin
    FglGetPixelMapfv(map, values);
  end
  else
  begin
    raise Exception.Create('glGetPixelMapfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetPixelMapuiv(map: GLenum; values: PGLuint);
begin
  if Assigned(FglGetPixelMapuiv) then
  begin
    FglGetPixelMapuiv(map, values);
  end
  else
  begin
    raise Exception.Create('glGetPixelMapuiv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetPixelMapusv(map: GLenum; values: PGLushort);
begin
  if Assigned(FglGetPixelMapusv) then
  begin
    FglGetPixelMapusv(map, values);
  end
  else
  begin
    raise Exception.Create('glGetPixelMapusv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetPolygonStipple(mask: PGLubyte);
begin
  if Assigned(FglGetPolygonStipple) then
  begin
    FglGetPolygonStipple(mask);
  end
  else
  begin
    raise Exception.Create('glGetPolygonStipple not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexEnvfv(target: GLenum; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetTexEnvfv) then
  begin
    FglGetTexEnvfv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexEnvfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexEnviv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetTexEnviv) then
  begin
    FglGetTexEnviv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexEnviv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexGendv(coord: GLenum; pname: GLenum; params: PGLdouble);
begin
  if Assigned(FglGetTexGendv) then
  begin
    FglGetTexGendv(coord, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexGendv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexGenfv(coord: GLenum; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetTexGenfv) then
  begin
    FglGetTexGenfv(coord, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexGenfv not bound');
  end;
end;

procedure TGL_VERSION_1_0.glGetTexGeniv(coord: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetTexGeniv) then
  begin
    FglGetTexGeniv(coord, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexGeniv not bound');
  end;
end;

function TGL_VERSION_1_0.glIsList(list: GLuint): GLboolean;
begin
  if Assigned(FglIsList) then
  begin
    Result := FglIsList(list);
  end
  else
  begin
    raise Exception.Create('glIsList not bound');
  end;
end;

procedure TGL_VERSION_1_0.glFrustum(left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble);
begin
  if Assigned(FglFrustum) then
  begin
    FglFrustum(left, right, bottom, top, zNear, zFar);
  end
  else
  begin
    raise Exception.Create('glFrustum not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLoadIdentity();
begin
  if Assigned(FglLoadIdentity) then
  begin
    FglLoadIdentity();
  end
  else
  begin
    raise Exception.Create('glLoadIdentity not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLoadMatrixf(const m: PGLfloat);
begin
  if Assigned(FglLoadMatrixf) then
  begin
    FglLoadMatrixf(m);
  end
  else
  begin
    raise Exception.Create('glLoadMatrixf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glLoadMatrixd(const m: PGLdouble);
begin
  if Assigned(FglLoadMatrixd) then
  begin
    FglLoadMatrixd(m);
  end
  else
  begin
    raise Exception.Create('glLoadMatrixd not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMatrixMode(mode: GLenum);
begin
  if Assigned(FglMatrixMode) then
  begin
    FglMatrixMode(mode);
  end
  else
  begin
    raise Exception.Create('glMatrixMode not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMultMatrixf(const m: PGLfloat);
begin
  if Assigned(FglMultMatrixf) then
  begin
    FglMultMatrixf(m);
  end
  else
  begin
    raise Exception.Create('glMultMatrixf not bound');
  end;
end;

procedure TGL_VERSION_1_0.glMultMatrixd(const m: PGLdouble);
begin
  if Assigned(FglMultMatrixd) then
  begin
    FglMultMatrixd(m);
  end
  else
  begin
    raise Exception.Create('glMultMatrixd not bound');
  end;
end;

procedure TGL_VERSION_1_0.glOrtho(left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble);
begin
  if Assigned(FglOrtho) then
  begin
    FglOrtho(left, right, bottom, top, zNear, zFar);
  end
  else
  begin
    raise Exception.Create('glOrtho not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPopMatrix();
begin
  if Assigned(FglPopMatrix) then
  begin
    FglPopMatrix();
  end
  else
  begin
    raise Exception.Create('glPopMatrix not bound');
  end;
end;

procedure TGL_VERSION_1_0.glPushMatrix();
begin
  if Assigned(FglPushMatrix) then
  begin
    FglPushMatrix();
  end
  else
  begin
    raise Exception.Create('glPushMatrix not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRotated(angle: GLdouble; x: GLdouble; y: GLdouble; z: GLdouble);
begin
  if Assigned(FglRotated) then
  begin
    FglRotated(angle, x, y, z);
  end
  else
  begin
    raise Exception.Create('glRotated not bound');
  end;
end;

procedure TGL_VERSION_1_0.glRotatef(angle: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat);
begin
  if Assigned(FglRotatef) then
  begin
    FglRotatef(angle, x, y, z);
  end
  else
  begin
    raise Exception.Create('glRotatef not bound');
  end;
end;

procedure TGL_VERSION_1_0.glScaled(x: GLdouble; y: GLdouble; z: GLdouble);
begin
  if Assigned(FglScaled) then
  begin
    FglScaled(x, y, z);
  end
  else
  begin
    raise Exception.Create('glScaled not bound');
  end;
end;

procedure TGL_VERSION_1_0.glScalef(x: GLfloat; y: GLfloat; z: GLfloat);
begin
  if Assigned(FglScalef) then
  begin
    FglScalef(x, y, z);
  end
  else
  begin
    raise Exception.Create('glScalef not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTranslated(x: GLdouble; y: GLdouble; z: GLdouble);
begin
  if Assigned(FglTranslated) then
  begin
    FglTranslated(x, y, z);
  end
  else
  begin
    raise Exception.Create('glTranslated not bound');
  end;
end;

procedure TGL_VERSION_1_0.glTranslatef(x: GLfloat; y: GLfloat; z: GLfloat);
begin
  if Assigned(FglTranslatef) then
  begin
    FglTranslatef(x, y, z);
  end
  else
  begin
    raise Exception.Create('glTranslatef not bound');
  end;
end;

procedure TGL_VERSION_1_1.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglDrawArrays), 'glDrawArrays');
  Bind(Pointer(FglDrawElements), 'glDrawElements');
  Bind(Pointer(FglGetPointerv), 'glGetPointerv');
  Bind(Pointer(FglPolygonOffset), 'glPolygonOffset');
  Bind(Pointer(FglCopyTexImage1D), 'glCopyTexImage1D');
  Bind(Pointer(FglCopyTexImage2D), 'glCopyTexImage2D');
  Bind(Pointer(FglCopyTexSubImage1D), 'glCopyTexSubImage1D');
  Bind(Pointer(FglCopyTexSubImage2D), 'glCopyTexSubImage2D');
  Bind(Pointer(FglTexSubImage1D), 'glTexSubImage1D');
  Bind(Pointer(FglTexSubImage2D), 'glTexSubImage2D');
  Bind(Pointer(FglBindTexture), 'glBindTexture');
  Bind(Pointer(FglDeleteTextures), 'glDeleteTextures');
  Bind(Pointer(FglGenTextures), 'glGenTextures');
  Bind(Pointer(FglIsTexture), 'glIsTexture');
  Bind(Pointer(FglArrayElement), 'glArrayElement');
  Bind(Pointer(FglColorPointer), 'glColorPointer');
  Bind(Pointer(FglDisableClientState), 'glDisableClientState');
  Bind(Pointer(FglEdgeFlagPointer), 'glEdgeFlagPointer');
  Bind(Pointer(FglEnableClientState), 'glEnableClientState');
  Bind(Pointer(FglIndexPointer), 'glIndexPointer');
  Bind(Pointer(FglInterleavedArrays), 'glInterleavedArrays');
  Bind(Pointer(FglNormalPointer), 'glNormalPointer');
  Bind(Pointer(FglTexCoordPointer), 'glTexCoordPointer');
  Bind(Pointer(FglVertexPointer), 'glVertexPointer');
  Bind(Pointer(FglAreTexturesResident), 'glAreTexturesResident');
  Bind(Pointer(FglPrioritizeTextures), 'glPrioritizeTextures');
  Bind(Pointer(FglIndexub), 'glIndexub');
  Bind(Pointer(FglIndexubv), 'glIndexubv');
  Bind(Pointer(FglPopClientAttrib), 'glPopClientAttrib');
  Bind(Pointer(FglPushClientAttrib), 'glPushClientAttrib');
end;

procedure TGL_VERSION_1_1.glDrawArrays(mode: GLenum; First: GLint; Count: GLsizei);
begin
  if Assigned(FglDrawArrays) then
  begin
    FglDrawArrays(mode, First, Count);
  end
  else
  begin
    raise Exception.Create('glDrawArrays not bound');
  end;
end;

procedure TGL_VERSION_1_1.glDrawElements(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer);
begin
  if Assigned(FglDrawElements) then
  begin
    FglDrawElements(mode, Count, aType, indices);
  end
  else
  begin
    raise Exception.Create('glDrawElements not bound');
  end;
end;

procedure TGL_VERSION_1_1.glGetPointerv(pname: GLenum; params: Pointer);
begin
  if Assigned(FglGetPointerv) then
  begin
    FglGetPointerv(pname, params);
  end
  else
  begin
    raise Exception.Create('glGetPointerv not bound');
  end;
end;

procedure TGL_VERSION_1_1.glPolygonOffset(factor: GLfloat; units: GLfloat);
begin
  if Assigned(FglPolygonOffset) then
  begin
    FglPolygonOffset(factor, units);
  end
  else
  begin
    raise Exception.Create('glPolygonOffset not bound');
  end;
end;

procedure TGL_VERSION_1_1.glCopyTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; border: GLint);
begin
  if Assigned(FglCopyTexImage1D) then
  begin
    FglCopyTexImage1D(target, level, internalformat, x, y, Width, border);
  end
  else
  begin
    raise Exception.Create('glCopyTexImage1D not bound');
  end;
end;

procedure TGL_VERSION_1_1.glCopyTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; border: GLint);
begin
  if Assigned(FglCopyTexImage2D) then
  begin
    FglCopyTexImage2D(target, level, internalformat, x, y, Width, Height, border);
  end
  else
  begin
    raise Exception.Create('glCopyTexImage2D not bound');
  end;
end;

procedure TGL_VERSION_1_1.glCopyTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei);
begin
  if Assigned(FglCopyTexSubImage1D) then
  begin
    FglCopyTexSubImage1D(target, level, xoffset, x, y, Width);
  end
  else
  begin
    raise Exception.Create('glCopyTexSubImage1D not bound');
  end;
end;

procedure TGL_VERSION_1_1.glCopyTexSubImage2D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglCopyTexSubImage2D) then
  begin
    FglCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, Width, Height);
  end
  else
  begin
    raise Exception.Create('glCopyTexSubImage2D not bound');
  end;
end;

procedure TGL_VERSION_1_1.glTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglTexSubImage1D) then
  begin
    FglTexSubImage1D(target, level, xoffset, Width, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glTexSubImage1D not bound');
  end;
end;

procedure TGL_VERSION_1_1.glTexSubImage2D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglTexSubImage2D) then
  begin
    FglTexSubImage2D(target, level, xoffset, yoffset, Width, Height, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glTexSubImage2D not bound');
  end;
end;

procedure TGL_VERSION_1_1.glBindTexture(target: GLenum; texture: GLuint);
begin
  if Assigned(FglBindTexture) then
  begin
    FglBindTexture(target, texture);
  end
  else
  begin
    raise Exception.Create('glBindTexture not bound');
  end;
end;

procedure TGL_VERSION_1_1.glDeleteTextures(n: GLsizei; const textures: PGLuint);
begin
  if Assigned(FglDeleteTextures) then
  begin
    FglDeleteTextures(n, textures);
  end
  else
  begin
    raise Exception.Create('glDeleteTextures not bound');
  end;
end;

procedure TGL_VERSION_1_1.glGenTextures(n: GLsizei; textures: PGLuint);
begin
  if Assigned(FglGenTextures) then
  begin
    FglGenTextures(n, textures);
  end
  else
  begin
    raise Exception.Create('glGenTextures not bound');
  end;
end;

function TGL_VERSION_1_1.glIsTexture(texture: GLuint): GLboolean;
begin
  if Assigned(FglIsTexture) then
  begin
    Result := FglIsTexture(texture);
  end
  else
  begin
    raise Exception.Create('glIsTexture not bound');
  end;
end;

procedure TGL_VERSION_1_1.glArrayElement(i: GLint);
begin
  if Assigned(FglArrayElement) then
  begin
    FglArrayElement(i);
  end
  else
  begin
    raise Exception.Create('glArrayElement not bound');
  end;
end;

procedure TGL_VERSION_1_1.glColorPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglColorPointer) then
  begin
    FglColorPointer(size, aType, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glColorPointer not bound');
  end;
end;

procedure TGL_VERSION_1_1.glDisableClientState(aArray: GLenum);
begin
  if Assigned(FglDisableClientState) then
  begin
    FglDisableClientState(aArray);
  end
  else
  begin
    raise Exception.Create('glDisableClientState not bound');
  end;
end;

procedure TGL_VERSION_1_1.glEdgeFlagPointer(stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglEdgeFlagPointer) then
  begin
    FglEdgeFlagPointer(stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glEdgeFlagPointer not bound');
  end;
end;

procedure TGL_VERSION_1_1.glEnableClientState(aArray: GLenum);
begin
  if Assigned(FglEnableClientState) then
  begin
    FglEnableClientState(aArray);
  end
  else
  begin
    raise Exception.Create('glEnableClientState not bound');
  end;
end;

procedure TGL_VERSION_1_1.glIndexPointer(aType: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglIndexPointer) then
  begin
    FglIndexPointer(aType, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glIndexPointer not bound');
  end;
end;

procedure TGL_VERSION_1_1.glInterleavedArrays(format: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglInterleavedArrays) then
  begin
    FglInterleavedArrays(format, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glInterleavedArrays not bound');
  end;
end;

procedure TGL_VERSION_1_1.glNormalPointer(aType: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglNormalPointer) then
  begin
    FglNormalPointer(aType, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glNormalPointer not bound');
  end;
end;

procedure TGL_VERSION_1_1.glTexCoordPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglTexCoordPointer) then
  begin
    FglTexCoordPointer(size, aType, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glTexCoordPointer not bound');
  end;
end;

procedure TGL_VERSION_1_1.glVertexPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglVertexPointer) then
  begin
    FglVertexPointer(size, aType, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glVertexPointer not bound');
  end;
end;

function TGL_VERSION_1_1.glAreTexturesResident(n: GLsizei; const textures: PGLuint; residences: PGLboolean): GLboolean;
begin
  if Assigned(FglAreTexturesResident) then
  begin
    Result := FglAreTexturesResident(n, textures, residences);
  end
  else
  begin
    raise Exception.Create('glAreTexturesResident not bound');
  end;
end;

procedure TGL_VERSION_1_1.glPrioritizeTextures(n: GLsizei; const textures: PGLuint; const priorities: PGLfloat);
begin
  if Assigned(FglPrioritizeTextures) then
  begin
    FglPrioritizeTextures(n, textures, priorities);
  end
  else
  begin
    raise Exception.Create('glPrioritizeTextures not bound');
  end;
end;

procedure TGL_VERSION_1_1.glIndexub(c: GLubyte);
begin
  if Assigned(FglIndexub) then
  begin
    FglIndexub(c);
  end
  else
  begin
    raise Exception.Create('glIndexub not bound');
  end;
end;

procedure TGL_VERSION_1_1.glIndexubv(const c: PGLubyte);
begin
  if Assigned(FglIndexubv) then
  begin
    FglIndexubv(c);
  end
  else
  begin
    raise Exception.Create('glIndexubv not bound');
  end;
end;

procedure TGL_VERSION_1_1.glPopClientAttrib();
begin
  if Assigned(FglPopClientAttrib) then
  begin
    FglPopClientAttrib();
  end
  else
  begin
    raise Exception.Create('glPopClientAttrib not bound');
  end;
end;

procedure TGL_VERSION_1_1.glPushClientAttrib(mask: GLbitfield);
begin
  if Assigned(FglPushClientAttrib) then
  begin
    FglPushClientAttrib(mask);
  end
  else
  begin
    raise Exception.Create('glPushClientAttrib not bound');
  end;
end;

procedure TGL_VERSION_1_2.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglDrawRangeElements), 'glDrawRangeElements');
  Bind(Pointer(FglTexImage3D), 'glTexImage3D');
  Bind(Pointer(FglTexSubImage3D), 'glTexSubImage3D');
  Bind(Pointer(FglCopyTexSubImage3D), 'glCopyTexSubImage3D');
end;

procedure TGL_VERSION_1_2.glDrawRangeElements(mode: GLenum; start: GLuint; aEnd: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer);
begin
  if Assigned(FglDrawRangeElements) then
  begin
    FglDrawRangeElements(mode, start, aEnd, Count, aType, indices);
  end
  else
  begin
    raise Exception.Create('glDrawRangeElements not bound');
  end;
end;

procedure TGL_VERSION_1_2.glTexImage3D(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglTexImage3D) then
  begin
    FglTexImage3D(target, level, internalformat, Width, Height, depth, border, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glTexImage3D not bound');
  end;
end;

procedure TGL_VERSION_1_2.glTexSubImage3D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglTexSubImage3D) then
  begin
    FglTexSubImage3D(target, level, xoffset, yoffset, zoffset, Width, Height, depth, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glTexSubImage3D not bound');
  end;
end;

procedure TGL_VERSION_1_2.glCopyTexSubImage3D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglCopyTexSubImage3D) then
  begin
    FglCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, Width, Height);
  end
  else
  begin
    raise Exception.Create('glCopyTexSubImage3D not bound');
  end;
end;

procedure TGL_VERSION_1_3.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglActiveTexture), 'glActiveTexture');
  Bind(Pointer(FglSampleCoverage), 'glSampleCoverage');
  Bind(Pointer(FglCompressedTexImage3D), 'glCompressedTexImage3D');
  Bind(Pointer(FglCompressedTexImage2D), 'glCompressedTexImage2D');
  Bind(Pointer(FglCompressedTexImage1D), 'glCompressedTexImage1D');
  Bind(Pointer(FglCompressedTexSubImage3D), 'glCompressedTexSubImage3D');
  Bind(Pointer(FglCompressedTexSubImage2D), 'glCompressedTexSubImage2D');
  Bind(Pointer(FglCompressedTexSubImage1D), 'glCompressedTexSubImage1D');
  Bind(Pointer(FglGetCompressedTexImage), 'glGetCompressedTexImage');
  Bind(Pointer(FglClientActiveTexture), 'glClientActiveTexture');
  Bind(Pointer(FglMultiTexCoord1d), 'glMultiTexCoord1d');
  Bind(Pointer(FglMultiTexCoord1dv), 'glMultiTexCoord1dv');
  Bind(Pointer(FglMultiTexCoord1f), 'glMultiTexCoord1f');
  Bind(Pointer(FglMultiTexCoord1fv), 'glMultiTexCoord1fv');
  Bind(Pointer(FglMultiTexCoord1i), 'glMultiTexCoord1i');
  Bind(Pointer(FglMultiTexCoord1iv), 'glMultiTexCoord1iv');
  Bind(Pointer(FglMultiTexCoord1s), 'glMultiTexCoord1s');
  Bind(Pointer(FglMultiTexCoord1sv), 'glMultiTexCoord1sv');
  Bind(Pointer(FglMultiTexCoord2d), 'glMultiTexCoord2d');
  Bind(Pointer(FglMultiTexCoord2dv), 'glMultiTexCoord2dv');
  Bind(Pointer(FglMultiTexCoord2f), 'glMultiTexCoord2f');
  Bind(Pointer(FglMultiTexCoord2fv), 'glMultiTexCoord2fv');
  Bind(Pointer(FglMultiTexCoord2i), 'glMultiTexCoord2i');
  Bind(Pointer(FglMultiTexCoord2iv), 'glMultiTexCoord2iv');
  Bind(Pointer(FglMultiTexCoord2s), 'glMultiTexCoord2s');
  Bind(Pointer(FglMultiTexCoord2sv), 'glMultiTexCoord2sv');
  Bind(Pointer(FglMultiTexCoord3d), 'glMultiTexCoord3d');
  Bind(Pointer(FglMultiTexCoord3dv), 'glMultiTexCoord3dv');
  Bind(Pointer(FglMultiTexCoord3f), 'glMultiTexCoord3f');
  Bind(Pointer(FglMultiTexCoord3fv), 'glMultiTexCoord3fv');
  Bind(Pointer(FglMultiTexCoord3i), 'glMultiTexCoord3i');
  Bind(Pointer(FglMultiTexCoord3iv), 'glMultiTexCoord3iv');
  Bind(Pointer(FglMultiTexCoord3s), 'glMultiTexCoord3s');
  Bind(Pointer(FglMultiTexCoord3sv), 'glMultiTexCoord3sv');
  Bind(Pointer(FglMultiTexCoord4d), 'glMultiTexCoord4d');
  Bind(Pointer(FglMultiTexCoord4dv), 'glMultiTexCoord4dv');
  Bind(Pointer(FglMultiTexCoord4f), 'glMultiTexCoord4f');
  Bind(Pointer(FglMultiTexCoord4fv), 'glMultiTexCoord4fv');
  Bind(Pointer(FglMultiTexCoord4i), 'glMultiTexCoord4i');
  Bind(Pointer(FglMultiTexCoord4iv), 'glMultiTexCoord4iv');
  Bind(Pointer(FglMultiTexCoord4s), 'glMultiTexCoord4s');
  Bind(Pointer(FglMultiTexCoord4sv), 'glMultiTexCoord4sv');
  Bind(Pointer(FglLoadTransposeMatrixf), 'glLoadTransposeMatrixf');
  Bind(Pointer(FglLoadTransposeMatrixd), 'glLoadTransposeMatrixd');
  Bind(Pointer(FglMultTransposeMatrixf), 'glMultTransposeMatrixf');
  Bind(Pointer(FglMultTransposeMatrixd), 'glMultTransposeMatrixd');
end;

procedure TGL_VERSION_1_3.glActiveTexture(texture: GLenum);
begin
  if Assigned(FglActiveTexture) then
  begin
    FglActiveTexture(texture);
  end
  else
  begin
    raise Exception.Create('glActiveTexture not bound');
  end;
end;

procedure TGL_VERSION_1_3.glSampleCoverage(Value: GLfloat; invert: GLboolean);
begin
  if Assigned(FglSampleCoverage) then
  begin
    FglSampleCoverage(Value, invert);
  end
  else
  begin
    raise Exception.Create('glSampleCoverage not bound');
  end;
end;

procedure TGL_VERSION_1_3.glCompressedTexImage3D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FglCompressedTexImage3D) then
  begin
    FglCompressedTexImage3D(target, level, internalformat, Width, Height, depth, border, imageSize, Data);
  end
  else
  begin
    raise Exception.Create('glCompressedTexImage3D not bound');
  end;
end;

procedure TGL_VERSION_1_3.glCompressedTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FglCompressedTexImage2D) then
  begin
    FglCompressedTexImage2D(target, level, internalformat, Width, Height, border, imageSize, Data);
  end
  else
  begin
    raise Exception.Create('glCompressedTexImage2D not bound');
  end;
end;

procedure TGL_VERSION_1_3.glCompressedTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FglCompressedTexImage1D) then
  begin
    FglCompressedTexImage1D(target, level, internalformat, Width, border, imageSize, Data);
  end
  else
  begin
    raise Exception.Create('glCompressedTexImage1D not bound');
  end;
end;

procedure TGL_VERSION_1_3.glCompressedTexSubImage3D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FglCompressedTexSubImage3D) then
  begin
    FglCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, Width, Height, depth, format, imageSize, Data);
  end
  else
  begin
    raise Exception.Create('glCompressedTexSubImage3D not bound');
  end;
end;

procedure TGL_VERSION_1_3.glCompressedTexSubImage2D(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FglCompressedTexSubImage2D) then
  begin
    FglCompressedTexSubImage2D(target, level, xoffset, yoffset, Width, Height, format, imageSize, Data);
  end
  else
  begin
    raise Exception.Create('glCompressedTexSubImage2D not bound');
  end;
end;

procedure TGL_VERSION_1_3.glCompressedTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FglCompressedTexSubImage1D) then
  begin
    FglCompressedTexSubImage1D(target, level, xoffset, Width, format, imageSize, Data);
  end
  else
  begin
    raise Exception.Create('glCompressedTexSubImage1D not bound');
  end;
end;

procedure TGL_VERSION_1_3.glGetCompressedTexImage(target: GLenum; level: GLint; img: Pointer);
begin
  if Assigned(FglGetCompressedTexImage) then
  begin
    FglGetCompressedTexImage(target, level, img);
  end
  else
  begin
    raise Exception.Create('glGetCompressedTexImage not bound');
  end;
end;

procedure TGL_VERSION_1_3.glClientActiveTexture(texture: GLenum);
begin
  if Assigned(FglClientActiveTexture) then
  begin
    FglClientActiveTexture(texture);
  end
  else
  begin
    raise Exception.Create('glClientActiveTexture not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord1d(target: GLenum; s: GLdouble);
begin
  if Assigned(FglMultiTexCoord1d) then
  begin
    FglMultiTexCoord1d(target, s);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord1d not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord1dv(target: GLenum; const v: PGLdouble);
begin
  if Assigned(FglMultiTexCoord1dv) then
  begin
    FglMultiTexCoord1dv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord1dv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord1f(target: GLenum; s: GLfloat);
begin
  if Assigned(FglMultiTexCoord1f) then
  begin
    FglMultiTexCoord1f(target, s);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord1f not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord1fv(target: GLenum; const v: PGLfloat);
begin
  if Assigned(FglMultiTexCoord1fv) then
  begin
    FglMultiTexCoord1fv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord1fv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord1i(target: GLenum; s: GLint);
begin
  if Assigned(FglMultiTexCoord1i) then
  begin
    FglMultiTexCoord1i(target, s);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord1i not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord1iv(target: GLenum; const v: PGLint);
begin
  if Assigned(FglMultiTexCoord1iv) then
  begin
    FglMultiTexCoord1iv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord1iv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord1s(target: GLenum; s: GLshort);
begin
  if Assigned(FglMultiTexCoord1s) then
  begin
    FglMultiTexCoord1s(target, s);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord1s not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord1sv(target: GLenum; const v: PGLshort);
begin
  if Assigned(FglMultiTexCoord1sv) then
  begin
    FglMultiTexCoord1sv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord1sv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord2d(target: GLenum; s: GLdouble; t: GLdouble);
begin
  if Assigned(FglMultiTexCoord2d) then
  begin
    FglMultiTexCoord2d(target, s, t);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord2d not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord2dv(target: GLenum; const v: PGLdouble);
begin
  if Assigned(FglMultiTexCoord2dv) then
  begin
    FglMultiTexCoord2dv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord2dv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord2f(target: GLenum; s: GLfloat; t: GLfloat);
begin
  if Assigned(FglMultiTexCoord2f) then
  begin
    FglMultiTexCoord2f(target, s, t);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord2f not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord2fv(target: GLenum; const v: PGLfloat);
begin
  if Assigned(FglMultiTexCoord2fv) then
  begin
    FglMultiTexCoord2fv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord2fv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord2i(target: GLenum; s: GLint; t: GLint);
begin
  if Assigned(FglMultiTexCoord2i) then
  begin
    FglMultiTexCoord2i(target, s, t);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord2i not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord2iv(target: GLenum; const v: PGLint);
begin
  if Assigned(FglMultiTexCoord2iv) then
  begin
    FglMultiTexCoord2iv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord2iv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord2s(target: GLenum; s: GLshort; t: GLshort);
begin
  if Assigned(FglMultiTexCoord2s) then
  begin
    FglMultiTexCoord2s(target, s, t);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord2s not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord2sv(target: GLenum; const v: PGLshort);
begin
  if Assigned(FglMultiTexCoord2sv) then
  begin
    FglMultiTexCoord2sv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord2sv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord3d(target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble);
begin
  if Assigned(FglMultiTexCoord3d) then
  begin
    FglMultiTexCoord3d(target, s, t, r);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord3d not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord3dv(target: GLenum; const v: PGLdouble);
begin
  if Assigned(FglMultiTexCoord3dv) then
  begin
    FglMultiTexCoord3dv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord3dv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord3f(target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat);
begin
  if Assigned(FglMultiTexCoord3f) then
  begin
    FglMultiTexCoord3f(target, s, t, r);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord3f not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord3fv(target: GLenum; const v: PGLfloat);
begin
  if Assigned(FglMultiTexCoord3fv) then
  begin
    FglMultiTexCoord3fv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord3fv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord3i(target: GLenum; s: GLint; t: GLint; r: GLint);
begin
  if Assigned(FglMultiTexCoord3i) then
  begin
    FglMultiTexCoord3i(target, s, t, r);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord3i not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord3iv(target: GLenum; const v: PGLint);
begin
  if Assigned(FglMultiTexCoord3iv) then
  begin
    FglMultiTexCoord3iv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord3iv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord3s(target: GLenum; s: GLshort; t: GLshort; r: GLshort);
begin
  if Assigned(FglMultiTexCoord3s) then
  begin
    FglMultiTexCoord3s(target, s, t, r);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord3s not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord3sv(target: GLenum; const v: PGLshort);
begin
  if Assigned(FglMultiTexCoord3sv) then
  begin
    FglMultiTexCoord3sv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord3sv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord4d(target: GLenum; s: GLdouble; t: GLdouble; r: GLdouble; q: GLdouble);
begin
  if Assigned(FglMultiTexCoord4d) then
  begin
    FglMultiTexCoord4d(target, s, t, r, q);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord4d not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord4dv(target: GLenum; const v: PGLdouble);
begin
  if Assigned(FglMultiTexCoord4dv) then
  begin
    FglMultiTexCoord4dv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord4dv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord4f(target: GLenum; s: GLfloat; t: GLfloat; r: GLfloat; q: GLfloat);
begin
  if Assigned(FglMultiTexCoord4f) then
  begin
    FglMultiTexCoord4f(target, s, t, r, q);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord4f not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord4fv(target: GLenum; const v: PGLfloat);
begin
  if Assigned(FglMultiTexCoord4fv) then
  begin
    FglMultiTexCoord4fv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord4fv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord4i(target: GLenum; s: GLint; t: GLint; r: GLint; q: GLint);
begin
  if Assigned(FglMultiTexCoord4i) then
  begin
    FglMultiTexCoord4i(target, s, t, r, q);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord4i not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord4iv(target: GLenum; const v: PGLint);
begin
  if Assigned(FglMultiTexCoord4iv) then
  begin
    FglMultiTexCoord4iv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord4iv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord4s(target: GLenum; s: GLshort; t: GLshort; r: GLshort; q: GLshort);
begin
  if Assigned(FglMultiTexCoord4s) then
  begin
    FglMultiTexCoord4s(target, s, t, r, q);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord4s not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultiTexCoord4sv(target: GLenum; const v: PGLshort);
begin
  if Assigned(FglMultiTexCoord4sv) then
  begin
    FglMultiTexCoord4sv(target, v);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoord4sv not bound');
  end;
end;

procedure TGL_VERSION_1_3.glLoadTransposeMatrixf(const m: PGLfloat);
begin
  if Assigned(FglLoadTransposeMatrixf) then
  begin
    FglLoadTransposeMatrixf(m);
  end
  else
  begin
    raise Exception.Create('glLoadTransposeMatrixf not bound');
  end;
end;

procedure TGL_VERSION_1_3.glLoadTransposeMatrixd(const m: PGLdouble);
begin
  if Assigned(FglLoadTransposeMatrixd) then
  begin
    FglLoadTransposeMatrixd(m);
  end
  else
  begin
    raise Exception.Create('glLoadTransposeMatrixd not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultTransposeMatrixf(const m: PGLfloat);
begin
  if Assigned(FglMultTransposeMatrixf) then
  begin
    FglMultTransposeMatrixf(m);
  end
  else
  begin
    raise Exception.Create('glMultTransposeMatrixf not bound');
  end;
end;

procedure TGL_VERSION_1_3.glMultTransposeMatrixd(const m: PGLdouble);
begin
  if Assigned(FglMultTransposeMatrixd) then
  begin
    FglMultTransposeMatrixd(m);
  end
  else
  begin
    raise Exception.Create('glMultTransposeMatrixd not bound');
  end;
end;

procedure TGL_VERSION_1_4.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglBlendFuncSeparate), 'glBlendFuncSeparate');
  Bind(Pointer(FglMultiDrawArrays), 'glMultiDrawArrays');
  Bind(Pointer(FglMultiDrawElements), 'glMultiDrawElements');
  Bind(Pointer(FglPointParameterf), 'glPointParameterf');
  Bind(Pointer(FglPointParameterfv), 'glPointParameterfv');
  Bind(Pointer(FglPointParameteri), 'glPointParameteri');
  Bind(Pointer(FglPointParameteriv), 'glPointParameteriv');
  Bind(Pointer(FglFogCoordf), 'glFogCoordf');
  Bind(Pointer(FglFogCoordfv), 'glFogCoordfv');
  Bind(Pointer(FglFogCoordd), 'glFogCoordd');
  Bind(Pointer(FglFogCoorddv), 'glFogCoorddv');
  Bind(Pointer(FglFogCoordPointer), 'glFogCoordPointer');
  Bind(Pointer(FglSecondaryColor3b), 'glSecondaryColor3b');
  Bind(Pointer(FglSecondaryColor3bv), 'glSecondaryColor3bv');
  Bind(Pointer(FglSecondaryColor3d), 'glSecondaryColor3d');
  Bind(Pointer(FglSecondaryColor3dv), 'glSecondaryColor3dv');
  Bind(Pointer(FglSecondaryColor3f), 'glSecondaryColor3f');
  Bind(Pointer(FglSecondaryColor3fv), 'glSecondaryColor3fv');
  Bind(Pointer(FglSecondaryColor3i), 'glSecondaryColor3i');
  Bind(Pointer(FglSecondaryColor3iv), 'glSecondaryColor3iv');
  Bind(Pointer(FglSecondaryColor3s), 'glSecondaryColor3s');
  Bind(Pointer(FglSecondaryColor3sv), 'glSecondaryColor3sv');
  Bind(Pointer(FglSecondaryColor3ub), 'glSecondaryColor3ub');
  Bind(Pointer(FglSecondaryColor3ubv), 'glSecondaryColor3ubv');
  Bind(Pointer(FglSecondaryColor3ui), 'glSecondaryColor3ui');
  Bind(Pointer(FglSecondaryColor3uiv), 'glSecondaryColor3uiv');
  Bind(Pointer(FglSecondaryColor3us), 'glSecondaryColor3us');
  Bind(Pointer(FglSecondaryColor3usv), 'glSecondaryColor3usv');
  Bind(Pointer(FglSecondaryColorPointer), 'glSecondaryColorPointer');
  Bind(Pointer(FglWindowPos2d), 'glWindowPos2d');
  Bind(Pointer(FglWindowPos2dv), 'glWindowPos2dv');
  Bind(Pointer(FglWindowPos2f), 'glWindowPos2f');
  Bind(Pointer(FglWindowPos2fv), 'glWindowPos2fv');
  Bind(Pointer(FglWindowPos2i), 'glWindowPos2i');
  Bind(Pointer(FglWindowPos2iv), 'glWindowPos2iv');
  Bind(Pointer(FglWindowPos2s), 'glWindowPos2s');
  Bind(Pointer(FglWindowPos2sv), 'glWindowPos2sv');
  Bind(Pointer(FglWindowPos3d), 'glWindowPos3d');
  Bind(Pointer(FglWindowPos3dv), 'glWindowPos3dv');
  Bind(Pointer(FglWindowPos3f), 'glWindowPos3f');
  Bind(Pointer(FglWindowPos3fv), 'glWindowPos3fv');
  Bind(Pointer(FglWindowPos3i), 'glWindowPos3i');
  Bind(Pointer(FglWindowPos3iv), 'glWindowPos3iv');
  Bind(Pointer(FglWindowPos3s), 'glWindowPos3s');
  Bind(Pointer(FglWindowPos3sv), 'glWindowPos3sv');
  Bind(Pointer(FglBlendColor), 'glBlendColor');
  Bind(Pointer(FglBlendEquation), 'glBlendEquation');
end;

procedure TGL_VERSION_1_4.glBlendFuncSeparate(sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum);
begin
  if Assigned(FglBlendFuncSeparate) then
  begin
    FglBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  end
  else
  begin
    raise Exception.Create('glBlendFuncSeparate not bound');
  end;
end;

procedure TGL_VERSION_1_4.glMultiDrawArrays(mode: GLenum; const First: PGLint; const Count: PGLsizei; drawcount: GLsizei);
begin
  if Assigned(FglMultiDrawArrays) then
  begin
    FglMultiDrawArrays(mode, First, Count, drawcount);
  end
  else
  begin
    raise Exception.Create('glMultiDrawArrays not bound');
  end;
end;

procedure TGL_VERSION_1_4.glMultiDrawElements(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: Pointer; drawcount: GLsizei);
begin
  if Assigned(FglMultiDrawElements) then
  begin
    FglMultiDrawElements(mode, Count, aType, indices, drawcount);
  end
  else
  begin
    raise Exception.Create('glMultiDrawElements not bound');
  end;
end;

procedure TGL_VERSION_1_4.glPointParameterf(pname: GLenum; param: GLfloat);
begin
  if Assigned(FglPointParameterf) then
  begin
    FglPointParameterf(pname, param);
  end
  else
  begin
    raise Exception.Create('glPointParameterf not bound');
  end;
end;

procedure TGL_VERSION_1_4.glPointParameterfv(pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglPointParameterfv) then
  begin
    FglPointParameterfv(pname, params);
  end
  else
  begin
    raise Exception.Create('glPointParameterfv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glPointParameteri(pname: GLenum; param: GLint);
begin
  if Assigned(FglPointParameteri) then
  begin
    FglPointParameteri(pname, param);
  end
  else
  begin
    raise Exception.Create('glPointParameteri not bound');
  end;
end;

procedure TGL_VERSION_1_4.glPointParameteriv(pname: GLenum; const params: PGLint);
begin
  if Assigned(FglPointParameteriv) then
  begin
    FglPointParameteriv(pname, params);
  end
  else
  begin
    raise Exception.Create('glPointParameteriv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glFogCoordf(coord: GLfloat);
begin
  if Assigned(FglFogCoordf) then
  begin
    FglFogCoordf(coord);
  end
  else
  begin
    raise Exception.Create('glFogCoordf not bound');
  end;
end;

procedure TGL_VERSION_1_4.glFogCoordfv(const coord: PGLfloat);
begin
  if Assigned(FglFogCoordfv) then
  begin
    FglFogCoordfv(coord);
  end
  else
  begin
    raise Exception.Create('glFogCoordfv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glFogCoordd(coord: GLdouble);
begin
  if Assigned(FglFogCoordd) then
  begin
    FglFogCoordd(coord);
  end
  else
  begin
    raise Exception.Create('glFogCoordd not bound');
  end;
end;

procedure TGL_VERSION_1_4.glFogCoorddv(const coord: PGLdouble);
begin
  if Assigned(FglFogCoorddv) then
  begin
    FglFogCoorddv(coord);
  end
  else
  begin
    raise Exception.Create('glFogCoorddv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glFogCoordPointer(aType: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglFogCoordPointer) then
  begin
    FglFogCoordPointer(aType, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glFogCoordPointer not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3b(red: GLbyte; green: GLbyte; blue: GLbyte);
begin
  if Assigned(FglSecondaryColor3b) then
  begin
    FglSecondaryColor3b(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3b not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3bv(const v: PGLbyte);
begin
  if Assigned(FglSecondaryColor3bv) then
  begin
    FglSecondaryColor3bv(v);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3bv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3d(red: GLdouble; green: GLdouble; blue: GLdouble);
begin
  if Assigned(FglSecondaryColor3d) then
  begin
    FglSecondaryColor3d(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3d not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3dv(const v: PGLdouble);
begin
  if Assigned(FglSecondaryColor3dv) then
  begin
    FglSecondaryColor3dv(v);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3dv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3f(red: GLfloat; green: GLfloat; blue: GLfloat);
begin
  if Assigned(FglSecondaryColor3f) then
  begin
    FglSecondaryColor3f(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3f not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3fv(const v: PGLfloat);
begin
  if Assigned(FglSecondaryColor3fv) then
  begin
    FglSecondaryColor3fv(v);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3fv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3i(red: GLint; green: GLint; blue: GLint);
begin
  if Assigned(FglSecondaryColor3i) then
  begin
    FglSecondaryColor3i(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3i not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3iv(const v: PGLint);
begin
  if Assigned(FglSecondaryColor3iv) then
  begin
    FglSecondaryColor3iv(v);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3iv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3s(red: GLshort; green: GLshort; blue: GLshort);
begin
  if Assigned(FglSecondaryColor3s) then
  begin
    FglSecondaryColor3s(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3s not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3sv(const v: PGLshort);
begin
  if Assigned(FglSecondaryColor3sv) then
  begin
    FglSecondaryColor3sv(v);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3sv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3ub(red: GLubyte; green: GLubyte; blue: GLubyte);
begin
  if Assigned(FglSecondaryColor3ub) then
  begin
    FglSecondaryColor3ub(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3ub not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3ubv(const v: PGLubyte);
begin
  if Assigned(FglSecondaryColor3ubv) then
  begin
    FglSecondaryColor3ubv(v);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3ubv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3ui(red: GLuint; green: GLuint; blue: GLuint);
begin
  if Assigned(FglSecondaryColor3ui) then
  begin
    FglSecondaryColor3ui(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3ui not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3uiv(const v: PGLuint);
begin
  if Assigned(FglSecondaryColor3uiv) then
  begin
    FglSecondaryColor3uiv(v);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3uiv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3us(red: GLushort; green: GLushort; blue: GLushort);
begin
  if Assigned(FglSecondaryColor3us) then
  begin
    FglSecondaryColor3us(red, green, blue);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3us not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColor3usv(const v: PGLushort);
begin
  if Assigned(FglSecondaryColor3usv) then
  begin
    FglSecondaryColor3usv(v);
  end
  else
  begin
    raise Exception.Create('glSecondaryColor3usv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glSecondaryColorPointer(size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglSecondaryColorPointer) then
  begin
    FglSecondaryColorPointer(size, aType, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glSecondaryColorPointer not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos2d(x: GLdouble; y: GLdouble);
begin
  if Assigned(FglWindowPos2d) then
  begin
    FglWindowPos2d(x, y);
  end
  else
  begin
    raise Exception.Create('glWindowPos2d not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos2dv(const v: PGLdouble);
begin
  if Assigned(FglWindowPos2dv) then
  begin
    FglWindowPos2dv(v);
  end
  else
  begin
    raise Exception.Create('glWindowPos2dv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos2f(x: GLfloat; y: GLfloat);
begin
  if Assigned(FglWindowPos2f) then
  begin
    FglWindowPos2f(x, y);
  end
  else
  begin
    raise Exception.Create('glWindowPos2f not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos2fv(const v: PGLfloat);
begin
  if Assigned(FglWindowPos2fv) then
  begin
    FglWindowPos2fv(v);
  end
  else
  begin
    raise Exception.Create('glWindowPos2fv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos2i(x: GLint; y: GLint);
begin
  if Assigned(FglWindowPos2i) then
  begin
    FglWindowPos2i(x, y);
  end
  else
  begin
    raise Exception.Create('glWindowPos2i not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos2iv(const v: PGLint);
begin
  if Assigned(FglWindowPos2iv) then
  begin
    FglWindowPos2iv(v);
  end
  else
  begin
    raise Exception.Create('glWindowPos2iv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos2s(x: GLshort; y: GLshort);
begin
  if Assigned(FglWindowPos2s) then
  begin
    FglWindowPos2s(x, y);
  end
  else
  begin
    raise Exception.Create('glWindowPos2s not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos2sv(const v: PGLshort);
begin
  if Assigned(FglWindowPos2sv) then
  begin
    FglWindowPos2sv(v);
  end
  else
  begin
    raise Exception.Create('glWindowPos2sv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos3d(x: GLdouble; y: GLdouble; z: GLdouble);
begin
  if Assigned(FglWindowPos3d) then
  begin
    FglWindowPos3d(x, y, z);
  end
  else
  begin
    raise Exception.Create('glWindowPos3d not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos3dv(const v: PGLdouble);
begin
  if Assigned(FglWindowPos3dv) then
  begin
    FglWindowPos3dv(v);
  end
  else
  begin
    raise Exception.Create('glWindowPos3dv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos3f(x: GLfloat; y: GLfloat; z: GLfloat);
begin
  if Assigned(FglWindowPos3f) then
  begin
    FglWindowPos3f(x, y, z);
  end
  else
  begin
    raise Exception.Create('glWindowPos3f not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos3fv(const v: PGLfloat);
begin
  if Assigned(FglWindowPos3fv) then
  begin
    FglWindowPos3fv(v);
  end
  else
  begin
    raise Exception.Create('glWindowPos3fv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos3i(x: GLint; y: GLint; z: GLint);
begin
  if Assigned(FglWindowPos3i) then
  begin
    FglWindowPos3i(x, y, z);
  end
  else
  begin
    raise Exception.Create('glWindowPos3i not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos3iv(const v: PGLint);
begin
  if Assigned(FglWindowPos3iv) then
  begin
    FglWindowPos3iv(v);
  end
  else
  begin
    raise Exception.Create('glWindowPos3iv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos3s(x: GLshort; y: GLshort; z: GLshort);
begin
  if Assigned(FglWindowPos3s) then
  begin
    FglWindowPos3s(x, y, z);
  end
  else
  begin
    raise Exception.Create('glWindowPos3s not bound');
  end;
end;

procedure TGL_VERSION_1_4.glWindowPos3sv(const v: PGLshort);
begin
  if Assigned(FglWindowPos3sv) then
  begin
    FglWindowPos3sv(v);
  end
  else
  begin
    raise Exception.Create('glWindowPos3sv not bound');
  end;
end;

procedure TGL_VERSION_1_4.glBlendColor(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat);
begin
  if Assigned(FglBlendColor) then
  begin
    FglBlendColor(red, green, blue, alpha);
  end
  else
  begin
    raise Exception.Create('glBlendColor not bound');
  end;
end;

procedure TGL_VERSION_1_4.glBlendEquation(mode: GLenum);
begin
  if Assigned(FglBlendEquation) then
  begin
    FglBlendEquation(mode);
  end
  else
  begin
    raise Exception.Create('glBlendEquation not bound');
  end;
end;

procedure TGL_VERSION_1_5.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglGenQueries), 'glGenQueries');
  Bind(Pointer(FglDeleteQueries), 'glDeleteQueries');
  Bind(Pointer(FglIsQuery), 'glIsQuery');
  Bind(Pointer(FglBeginQuery), 'glBeginQuery');
  Bind(Pointer(FglEndQuery), 'glEndQuery');
  Bind(Pointer(FglGetQueryiv), 'glGetQueryiv');
  Bind(Pointer(FglGetQueryObjectiv), 'glGetQueryObjectiv');
  Bind(Pointer(FglGetQueryObjectuiv), 'glGetQueryObjectuiv');
  Bind(Pointer(FglBindBuffer), 'glBindBuffer');
  Bind(Pointer(FglDeleteBuffers), 'glDeleteBuffers');
  Bind(Pointer(FglGenBuffers), 'glGenBuffers');
  Bind(Pointer(FglIsBuffer), 'glIsBuffer');
  Bind(Pointer(FglBufferData), 'glBufferData');
  Bind(Pointer(FglBufferSubData), 'glBufferSubData');
  Bind(Pointer(FglGetBufferSubData), 'glGetBufferSubData');
  Bind(Pointer(FglMapBuffer), 'glMapBuffer');
  Bind(Pointer(FglUnmapBuffer), 'glUnmapBuffer');
  Bind(Pointer(FglGetBufferParameteriv), 'glGetBufferParameteriv');
  Bind(Pointer(FglGetBufferPointerv), 'glGetBufferPointerv');
end;

procedure TGL_VERSION_1_5.glGenQueries(n: GLsizei; ids: PGLuint);
begin
  if Assigned(FglGenQueries) then
  begin
    FglGenQueries(n, ids);
  end
  else
  begin
    raise Exception.Create('glGenQueries not bound');
  end;
end;

procedure TGL_VERSION_1_5.glDeleteQueries(n: GLsizei; const ids: PGLuint);
begin
  if Assigned(FglDeleteQueries) then
  begin
    FglDeleteQueries(n, ids);
  end
  else
  begin
    raise Exception.Create('glDeleteQueries not bound');
  end;
end;

function TGL_VERSION_1_5.glIsQuery(id: GLuint): GLboolean;
begin
  if Assigned(FglIsQuery) then
  begin
    Result := FglIsQuery(id);
  end
  else
  begin
    raise Exception.Create('glIsQuery not bound');
  end;
end;

procedure TGL_VERSION_1_5.glBeginQuery(target: GLenum; id: GLuint);
begin
  if Assigned(FglBeginQuery) then
  begin
    FglBeginQuery(target, id);
  end
  else
  begin
    raise Exception.Create('glBeginQuery not bound');
  end;
end;

procedure TGL_VERSION_1_5.glEndQuery(target: GLenum);
begin
  if Assigned(FglEndQuery) then
  begin
    FglEndQuery(target);
  end
  else
  begin
    raise Exception.Create('glEndQuery not bound');
  end;
end;

procedure TGL_VERSION_1_5.glGetQueryiv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetQueryiv) then
  begin
    FglGetQueryiv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetQueryiv not bound');
  end;
end;

procedure TGL_VERSION_1_5.glGetQueryObjectiv(id: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetQueryObjectiv) then
  begin
    FglGetQueryObjectiv(id, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetQueryObjectiv not bound');
  end;
end;

procedure TGL_VERSION_1_5.glGetQueryObjectuiv(id: GLuint; pname: GLenum; params: PGLuint);
begin
  if Assigned(FglGetQueryObjectuiv) then
  begin
    FglGetQueryObjectuiv(id, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetQueryObjectuiv not bound');
  end;
end;

procedure TGL_VERSION_1_5.glBindBuffer(target: GLenum; buffer: GLuint);
begin
  if Assigned(FglBindBuffer) then
  begin
    FglBindBuffer(target, buffer);
  end
  else
  begin
    raise Exception.Create('glBindBuffer not bound');
  end;
end;

procedure TGL_VERSION_1_5.glDeleteBuffers(n: GLsizei; const buffers: PGLuint);
begin
  if Assigned(FglDeleteBuffers) then
  begin
    FglDeleteBuffers(n, buffers);
  end
  else
  begin
    raise Exception.Create('glDeleteBuffers not bound');
  end;
end;

procedure TGL_VERSION_1_5.glGenBuffers(n: GLsizei; buffers: PGLuint);
begin
  if Assigned(FglGenBuffers) then
  begin
    FglGenBuffers(n, buffers);
  end
  else
  begin
    raise Exception.Create('glGenBuffers not bound');
  end;
end;

function TGL_VERSION_1_5.glIsBuffer(buffer: GLuint): GLboolean;
begin
  if Assigned(FglIsBuffer) then
  begin
    Result := FglIsBuffer(buffer);
  end
  else
  begin
    raise Exception.Create('glIsBuffer not bound');
  end;
end;

procedure TGL_VERSION_1_5.glBufferData(target: GLenum; size: GLsizeiptr; const Data: Pointer; usage: GLenum);
begin
  if Assigned(FglBufferData) then
  begin
    FglBufferData(target, size, Data, usage);
  end
  else
  begin
    raise Exception.Create('glBufferData not bound');
  end;
end;

procedure TGL_VERSION_1_5.glBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; const Data: Pointer);
begin
  if Assigned(FglBufferSubData) then
  begin
    FglBufferSubData(target, offset, size, Data);
  end
  else
  begin
    raise Exception.Create('glBufferSubData not bound');
  end;
end;

procedure TGL_VERSION_1_5.glGetBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: Pointer);
begin
  if Assigned(FglGetBufferSubData) then
  begin
    FglGetBufferSubData(target, offset, size, Data);
  end
  else
  begin
    raise Exception.Create('glGetBufferSubData not bound');
  end;
end;

function TGL_VERSION_1_5.glMapBuffer(target: GLenum; access: GLenum): pointer;
begin
  if Assigned(FglMapBuffer) then
  begin
    Result := FglMapBuffer(target, access);
  end
  else
  begin
    raise Exception.Create('glMapBuffer not bound');
  end;
end;

function TGL_VERSION_1_5.glUnmapBuffer(target: GLenum): GLboolean;
begin
  if Assigned(FglUnmapBuffer) then
  begin
    Result := FglUnmapBuffer(target);
  end
  else
  begin
    raise Exception.Create('glUnmapBuffer not bound');
  end;
end;

procedure TGL_VERSION_1_5.glGetBufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetBufferParameteriv) then
  begin
    FglGetBufferParameteriv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetBufferParameteriv not bound');
  end;
end;

procedure TGL_VERSION_1_5.glGetBufferPointerv(target: GLenum; pname: GLenum; params: Pointer);
begin
  if Assigned(FglGetBufferPointerv) then
  begin
    FglGetBufferPointerv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetBufferPointerv not bound');
  end;
end;

procedure TGL_VERSION_2_0.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglBlendEquationSeparate), 'glBlendEquationSeparate');
  Bind(Pointer(FglDrawBuffers), 'glDrawBuffers');
  Bind(Pointer(FglStencilOpSeparate), 'glStencilOpSeparate');
  Bind(Pointer(FglStencilFuncSeparate), 'glStencilFuncSeparate');
  Bind(Pointer(FglStencilMaskSeparate), 'glStencilMaskSeparate');
  Bind(Pointer(FglAttachShader), 'glAttachShader');
  Bind(Pointer(FglBindAttribLocation), 'glBindAttribLocation');
  Bind(Pointer(FglCompileShader), 'glCompileShader');
  Bind(Pointer(FglCreateProgram), 'glCreateProgram');
  Bind(Pointer(FglCreateShader), 'glCreateShader');
  Bind(Pointer(FglDeleteProgram), 'glDeleteProgram');
  Bind(Pointer(FglDeleteShader), 'glDeleteShader');
  Bind(Pointer(FglDetachShader), 'glDetachShader');
  Bind(Pointer(FglDisableVertexAttribArray), 'glDisableVertexAttribArray');
  Bind(Pointer(FglEnableVertexAttribArray), 'glEnableVertexAttribArray');
  Bind(Pointer(FglGetActiveAttrib), 'glGetActiveAttrib');
  Bind(Pointer(FglGetActiveUniform), 'glGetActiveUniform');
  Bind(Pointer(FglGetAttachedShaders), 'glGetAttachedShaders');
  Bind(Pointer(FglGetAttribLocation), 'glGetAttribLocation');
  Bind(Pointer(FglGetProgramiv), 'glGetProgramiv');
  Bind(Pointer(FglGetProgramInfoLog), 'glGetProgramInfoLog');
  Bind(Pointer(FglGetShaderiv), 'glGetShaderiv');
  Bind(Pointer(FglGetShaderInfoLog), 'glGetShaderInfoLog');
  Bind(Pointer(FglGetShaderSource), 'glGetShaderSource');
  Bind(Pointer(FglGetUniformLocation), 'glGetUniformLocation');
  Bind(Pointer(FglGetUniformfv), 'glGetUniformfv');
  Bind(Pointer(FglGetUniformiv), 'glGetUniformiv');
  Bind(Pointer(FglGetVertexAttribdv), 'glGetVertexAttribdv');
  Bind(Pointer(FglGetVertexAttribfv), 'glGetVertexAttribfv');
  Bind(Pointer(FglGetVertexAttribiv), 'glGetVertexAttribiv');
  Bind(Pointer(FglGetVertexAttribPointerv), 'glGetVertexAttribPointerv');
  Bind(Pointer(FglIsProgram), 'glIsProgram');
  Bind(Pointer(FglIsShader), 'glIsShader');
  Bind(Pointer(FglLinkProgram), 'glLinkProgram');
  Bind(Pointer(FglShaderSource), 'glShaderSource');
  Bind(Pointer(FglUseProgram), 'glUseProgram');
  Bind(Pointer(FglUniform1f), 'glUniform1f');
  Bind(Pointer(FglUniform2f), 'glUniform2f');
  Bind(Pointer(FglUniform3f), 'glUniform3f');
  Bind(Pointer(FglUniform4f), 'glUniform4f');
  Bind(Pointer(FglUniform1i), 'glUniform1i');
  Bind(Pointer(FglUniform2i), 'glUniform2i');
  Bind(Pointer(FglUniform3i), 'glUniform3i');
  Bind(Pointer(FglUniform4i), 'glUniform4i');
  Bind(Pointer(FglUniform1fv), 'glUniform1fv');
  Bind(Pointer(FglUniform2fv), 'glUniform2fv');
  Bind(Pointer(FglUniform3fv), 'glUniform3fv');
  Bind(Pointer(FglUniform4fv), 'glUniform4fv');
  Bind(Pointer(FglUniform1iv), 'glUniform1iv');
  Bind(Pointer(FglUniform2iv), 'glUniform2iv');
  Bind(Pointer(FglUniform3iv), 'glUniform3iv');
  Bind(Pointer(FglUniform4iv), 'glUniform4iv');
  Bind(Pointer(FglUniformMatrix2fv), 'glUniformMatrix2fv');
  Bind(Pointer(FglUniformMatrix3fv), 'glUniformMatrix3fv');
  Bind(Pointer(FglUniformMatrix4fv), 'glUniformMatrix4fv');
  Bind(Pointer(FglValidateProgram), 'glValidateProgram');
  Bind(Pointer(FglVertexAttrib1d), 'glVertexAttrib1d');
  Bind(Pointer(FglVertexAttrib1dv), 'glVertexAttrib1dv');
  Bind(Pointer(FglVertexAttrib1f), 'glVertexAttrib1f');
  Bind(Pointer(FglVertexAttrib1fv), 'glVertexAttrib1fv');
  Bind(Pointer(FglVertexAttrib1s), 'glVertexAttrib1s');
  Bind(Pointer(FglVertexAttrib1sv), 'glVertexAttrib1sv');
  Bind(Pointer(FglVertexAttrib2d), 'glVertexAttrib2d');
  Bind(Pointer(FglVertexAttrib2dv), 'glVertexAttrib2dv');
  Bind(Pointer(FglVertexAttrib2f), 'glVertexAttrib2f');
  Bind(Pointer(FglVertexAttrib2fv), 'glVertexAttrib2fv');
  Bind(Pointer(FglVertexAttrib2s), 'glVertexAttrib2s');
  Bind(Pointer(FglVertexAttrib2sv), 'glVertexAttrib2sv');
  Bind(Pointer(FglVertexAttrib3d), 'glVertexAttrib3d');
  Bind(Pointer(FglVertexAttrib3dv), 'glVertexAttrib3dv');
  Bind(Pointer(FglVertexAttrib3f), 'glVertexAttrib3f');
  Bind(Pointer(FglVertexAttrib3fv), 'glVertexAttrib3fv');
  Bind(Pointer(FglVertexAttrib3s), 'glVertexAttrib3s');
  Bind(Pointer(FglVertexAttrib3sv), 'glVertexAttrib3sv');
  Bind(Pointer(FglVertexAttrib4Nbv), 'glVertexAttrib4Nbv');
  Bind(Pointer(FglVertexAttrib4Niv), 'glVertexAttrib4Niv');
  Bind(Pointer(FglVertexAttrib4Nsv), 'glVertexAttrib4Nsv');
  Bind(Pointer(FglVertexAttrib4Nub), 'glVertexAttrib4Nub');
  Bind(Pointer(FglVertexAttrib4Nubv), 'glVertexAttrib4Nubv');
  Bind(Pointer(FglVertexAttrib4Nuiv), 'glVertexAttrib4Nuiv');
  Bind(Pointer(FglVertexAttrib4Nusv), 'glVertexAttrib4Nusv');
  Bind(Pointer(FglVertexAttrib4bv), 'glVertexAttrib4bv');
  Bind(Pointer(FglVertexAttrib4d), 'glVertexAttrib4d');
  Bind(Pointer(FglVertexAttrib4dv), 'glVertexAttrib4dv');
  Bind(Pointer(FglVertexAttrib4f), 'glVertexAttrib4f');
  Bind(Pointer(FglVertexAttrib4fv), 'glVertexAttrib4fv');
  Bind(Pointer(FglVertexAttrib4iv), 'glVertexAttrib4iv');
  Bind(Pointer(FglVertexAttrib4s), 'glVertexAttrib4s');
  Bind(Pointer(FglVertexAttrib4sv), 'glVertexAttrib4sv');
  Bind(Pointer(FglVertexAttrib4ubv), 'glVertexAttrib4ubv');
  Bind(Pointer(FglVertexAttrib4uiv), 'glVertexAttrib4uiv');
  Bind(Pointer(FglVertexAttrib4usv), 'glVertexAttrib4usv');
  Bind(Pointer(FglVertexAttribPointer), 'glVertexAttribPointer');
end;

procedure TGL_VERSION_2_0.glBlendEquationSeparate(modeRGB: GLenum; modeAlpha: GLenum);
begin
  if Assigned(FglBlendEquationSeparate) then
  begin
    FglBlendEquationSeparate(modeRGB, modeAlpha);
  end
  else
  begin
    raise Exception.Create('glBlendEquationSeparate not bound');
  end;
end;

procedure TGL_VERSION_2_0.glDrawBuffers(n: GLsizei; const bufs: PGLenum);
begin
  if Assigned(FglDrawBuffers) then
  begin
    FglDrawBuffers(n, bufs);
  end
  else
  begin
    raise Exception.Create('glDrawBuffers not bound');
  end;
end;

procedure TGL_VERSION_2_0.glStencilOpSeparate(face: GLenum; sfail: GLenum; dpfail: GLenum; dppass: GLenum);
begin
  if Assigned(FglStencilOpSeparate) then
  begin
    FglStencilOpSeparate(face, sfail, dpfail, dppass);
  end
  else
  begin
    raise Exception.Create('glStencilOpSeparate not bound');
  end;
end;

procedure TGL_VERSION_2_0.glStencilFuncSeparate(face: GLenum; func: GLenum; ref: GLint; mask: GLuint);
begin
  if Assigned(FglStencilFuncSeparate) then
  begin
    FglStencilFuncSeparate(face, func, ref, mask);
  end
  else
  begin
    raise Exception.Create('glStencilFuncSeparate not bound');
  end;
end;

procedure TGL_VERSION_2_0.glStencilMaskSeparate(face: GLenum; mask: GLuint);
begin
  if Assigned(FglStencilMaskSeparate) then
  begin
    FglStencilMaskSeparate(face, mask);
  end
  else
  begin
    raise Exception.Create('glStencilMaskSeparate not bound');
  end;
end;

procedure TGL_VERSION_2_0.glAttachShader(aProgram: GLuint; shader: GLuint);
begin
  if Assigned(FglAttachShader) then
  begin
    FglAttachShader(aProgram, shader);
  end
  else
  begin
    raise Exception.Create('glAttachShader not bound');
  end;
end;

procedure TGL_VERSION_2_0.glBindAttribLocation(aProgram: GLuint; index: GLuint; const Name: PGLchar);
begin
  if Assigned(FglBindAttribLocation) then
  begin
    FglBindAttribLocation(aProgram, index, Name);
  end
  else
  begin
    raise Exception.Create('glBindAttribLocation not bound');
  end;
end;

procedure TGL_VERSION_2_0.glCompileShader(shader: GLuint);
begin
  if Assigned(FglCompileShader) then
  begin
    FglCompileShader(shader);
  end
  else
  begin
    raise Exception.Create('glCompileShader not bound');
  end;
end;

function TGL_VERSION_2_0.glCreateProgram(): GLuint;
begin
  if Assigned(FglCreateProgram) then
  begin
    Result := FglCreateProgram();
  end
  else
  begin
    raise Exception.Create('glCreateProgram not bound');
  end;
end;

function TGL_VERSION_2_0.glCreateShader(aType: GLenum): GLuint;
begin
  if Assigned(FglCreateShader) then
  begin
    Result := FglCreateShader(aType);
  end
  else
  begin
    raise Exception.Create('glCreateShader not bound');
  end;
end;

procedure TGL_VERSION_2_0.glDeleteProgram(aProgram: GLuint);
begin
  if Assigned(FglDeleteProgram) then
  begin
    FglDeleteProgram(aProgram);
  end
  else
  begin
    raise Exception.Create('glDeleteProgram not bound');
  end;
end;

procedure TGL_VERSION_2_0.glDeleteShader(shader: GLuint);
begin
  if Assigned(FglDeleteShader) then
  begin
    FglDeleteShader(shader);
  end
  else
  begin
    raise Exception.Create('glDeleteShader not bound');
  end;
end;

procedure TGL_VERSION_2_0.glDetachShader(aProgram: GLuint; shader: GLuint);
begin
  if Assigned(FglDetachShader) then
  begin
    FglDetachShader(aProgram, shader);
  end
  else
  begin
    raise Exception.Create('glDetachShader not bound');
  end;
end;

procedure TGL_VERSION_2_0.glDisableVertexAttribArray(index: GLuint);
begin
  if Assigned(FglDisableVertexAttribArray) then
  begin
    FglDisableVertexAttribArray(index);
  end
  else
  begin
    raise Exception.Create('glDisableVertexAttribArray not bound');
  end;
end;

procedure TGL_VERSION_2_0.glEnableVertexAttribArray(index: GLuint);
begin
  if Assigned(FglEnableVertexAttribArray) then
  begin
    FglEnableVertexAttribArray(index);
  end
  else
  begin
    raise Exception.Create('glEnableVertexAttribArray not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetActiveAttrib(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; aType: PGLenum; Name: PGLchar);
begin
  if Assigned(FglGetActiveAttrib) then
  begin
    FglGetActiveAttrib(aProgram, index, bufSize, length, size, aType, Name);
  end
  else
  begin
    raise Exception.Create('glGetActiveAttrib not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetActiveUniform(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; aType: PGLenum; Name: PGLchar);
begin
  if Assigned(FglGetActiveUniform) then
  begin
    FglGetActiveUniform(aProgram, index, bufSize, length, size, aType, Name);
  end
  else
  begin
    raise Exception.Create('glGetActiveUniform not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetAttachedShaders(aProgram: GLuint; maxCount: GLsizei; Count: PGLsizei; shaders: PGLuint);
begin
  if Assigned(FglGetAttachedShaders) then
  begin
    FglGetAttachedShaders(aProgram, maxCount, Count, shaders);
  end
  else
  begin
    raise Exception.Create('glGetAttachedShaders not bound');
  end;
end;

function TGL_VERSION_2_0.glGetAttribLocation(aProgram: GLuint; const Name: PGLchar): GLint;
begin
  if Assigned(FglGetAttribLocation) then
  begin
    Result := FglGetAttribLocation(aProgram, Name);
  end
  else
  begin
    raise Exception.Create('glGetAttribLocation not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetProgramiv(aProgram: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetProgramiv) then
  begin
    FglGetProgramiv(aProgram, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetProgramiv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetProgramInfoLog(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar);
begin
  if Assigned(FglGetProgramInfoLog) then
  begin
    FglGetProgramInfoLog(aProgram, bufSize, length, infoLog);
  end
  else
  begin
    raise Exception.Create('glGetProgramInfoLog not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetShaderiv(shader: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetShaderiv) then
  begin
    FglGetShaderiv(shader, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetShaderiv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetShaderInfoLog(shader: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar);
begin
  if Assigned(FglGetShaderInfoLog) then
  begin
    FglGetShaderInfoLog(shader, bufSize, length, infoLog);
  end
  else
  begin
    raise Exception.Create('glGetShaderInfoLog not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetShaderSource(shader: GLuint; bufSize: GLsizei; length: PGLsizei; Source: PGLchar);
begin
  if Assigned(FglGetShaderSource) then
  begin
    FglGetShaderSource(shader, bufSize, length, Source);
  end
  else
  begin
    raise Exception.Create('glGetShaderSource not bound');
  end;
end;

function TGL_VERSION_2_0.glGetUniformLocation(aProgram: GLuint; const Name: PGLchar): GLint;
begin
  if Assigned(FglGetUniformLocation) then
  begin
    Result := FglGetUniformLocation(aProgram, Name);
  end
  else
  begin
    raise Exception.Create('glGetUniformLocation not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetUniformfv(aProgram: GLuint; location: GLint; params: PGLfloat);
begin
  if Assigned(FglGetUniformfv) then
  begin
    FglGetUniformfv(aProgram, location, params);
  end
  else
  begin
    raise Exception.Create('glGetUniformfv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetUniformiv(aProgram: GLuint; location: GLint; params: PGLint);
begin
  if Assigned(FglGetUniformiv) then
  begin
    FglGetUniformiv(aProgram, location, params);
  end
  else
  begin
    raise Exception.Create('glGetUniformiv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetVertexAttribdv(index: GLuint; pname: GLenum; params: PGLdouble);
begin
  if Assigned(FglGetVertexAttribdv) then
  begin
    FglGetVertexAttribdv(index, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetVertexAttribdv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetVertexAttribfv(index: GLuint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetVertexAttribfv) then
  begin
    FglGetVertexAttribfv(index, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetVertexAttribfv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetVertexAttribiv(index: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetVertexAttribiv) then
  begin
    FglGetVertexAttribiv(index, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetVertexAttribiv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glGetVertexAttribPointerv(index: GLuint; pname: GLenum; aPointer: Pointer);
begin
  if Assigned(FglGetVertexAttribPointerv) then
  begin
    FglGetVertexAttribPointerv(index, pname, aPointer);
  end
  else
  begin
    raise Exception.Create('glGetVertexAttribPointerv not bound');
  end;
end;

function TGL_VERSION_2_0.glIsProgram(aProgram: GLuint): GLboolean;
begin
  if Assigned(FglIsProgram) then
  begin
    Result := FglIsProgram(aProgram);
  end
  else
  begin
    raise Exception.Create('glIsProgram not bound');
  end;
end;

function TGL_VERSION_2_0.glIsShader(shader: GLuint): GLboolean;
begin
  if Assigned(FglIsShader) then
  begin
    Result := FglIsShader(shader);
  end
  else
  begin
    raise Exception.Create('glIsShader not bound');
  end;
end;

procedure TGL_VERSION_2_0.glLinkProgram(aProgram: GLuint);
begin
  if Assigned(FglLinkProgram) then
  begin
    FglLinkProgram(aProgram);
  end
  else
  begin
    raise Exception.Create('glLinkProgram not bound');
  end;
end;

procedure TGL_VERSION_2_0.glShaderSource(shader: GLuint; Count: GLsizei; const aString: PGLchar; const length: PGLint);
begin
  if Assigned(FglShaderSource) then
  begin
    FglShaderSource(shader, Count, aString, length);
  end
  else
  begin
    raise Exception.Create('glShaderSource not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUseProgram(aProgram: GLuint);
begin
  if Assigned(FglUseProgram) then
  begin
    FglUseProgram(aProgram);
  end
  else
  begin
    raise Exception.Create('glUseProgram not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform1f(location: GLint; v0: GLfloat);
begin
  if Assigned(FglUniform1f) then
  begin
    FglUniform1f(location, v0);
  end
  else
  begin
    raise Exception.Create('glUniform1f not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform2f(location: GLint; v0: GLfloat; v1: GLfloat);
begin
  if Assigned(FglUniform2f) then
  begin
    FglUniform2f(location, v0, v1);
  end
  else
  begin
    raise Exception.Create('glUniform2f not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform3f(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat);
begin
  if Assigned(FglUniform3f) then
  begin
    FglUniform3f(location, v0, v1, v2);
  end
  else
  begin
    raise Exception.Create('glUniform3f not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform4f(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat);
begin
  if Assigned(FglUniform4f) then
  begin
    FglUniform4f(location, v0, v1, v2, v3);
  end
  else
  begin
    raise Exception.Create('glUniform4f not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform1i(location: GLint; v0: GLint);
begin
  if Assigned(FglUniform1i) then
  begin
    FglUniform1i(location, v0);
  end
  else
  begin
    raise Exception.Create('glUniform1i not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform2i(location: GLint; v0: GLint; v1: GLint);
begin
  if Assigned(FglUniform2i) then
  begin
    FglUniform2i(location, v0, v1);
  end
  else
  begin
    raise Exception.Create('glUniform2i not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform3i(location: GLint; v0: GLint; v1: GLint; v2: GLint);
begin
  if Assigned(FglUniform3i) then
  begin
    FglUniform3i(location, v0, v1, v2);
  end
  else
  begin
    raise Exception.Create('glUniform3i not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform4i(location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint);
begin
  if Assigned(FglUniform4i) then
  begin
    FglUniform4i(location, v0, v1, v2, v3);
  end
  else
  begin
    raise Exception.Create('glUniform4i not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform1fv(location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FglUniform1fv) then
  begin
    FglUniform1fv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform1fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform2fv(location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FglUniform2fv) then
  begin
    FglUniform2fv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform2fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform3fv(location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FglUniform3fv) then
  begin
    FglUniform3fv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform3fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform4fv(location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FglUniform4fv) then
  begin
    FglUniform4fv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform4fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform1iv(location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FglUniform1iv) then
  begin
    FglUniform1iv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform1iv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform2iv(location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FglUniform2iv) then
  begin
    FglUniform2iv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform2iv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform3iv(location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FglUniform3iv) then
  begin
    FglUniform3iv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform3iv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniform4iv(location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FglUniform4iv) then
  begin
    FglUniform4iv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform4iv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniformMatrix2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglUniformMatrix2fv) then
  begin
    FglUniformMatrix2fv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix2fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniformMatrix3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglUniformMatrix3fv) then
  begin
    FglUniformMatrix3fv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix3fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glUniformMatrix4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglUniformMatrix4fv) then
  begin
    FglUniformMatrix4fv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix4fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glValidateProgram(aProgram: GLuint);
begin
  if Assigned(FglValidateProgram) then
  begin
    FglValidateProgram(aProgram);
  end
  else
  begin
    raise Exception.Create('glValidateProgram not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib1d(index: GLuint; x: GLdouble);
begin
  if Assigned(FglVertexAttrib1d) then
  begin
    FglVertexAttrib1d(index, x);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib1d not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib1dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FglVertexAttrib1dv) then
  begin
    FglVertexAttrib1dv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib1dv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib1f(index: GLuint; x: GLfloat);
begin
  if Assigned(FglVertexAttrib1f) then
  begin
    FglVertexAttrib1f(index, x);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib1f not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib1fv(index: GLuint; const v: PGLfloat);
begin
  if Assigned(FglVertexAttrib1fv) then
  begin
    FglVertexAttrib1fv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib1fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib1s(index: GLuint; x: GLshort);
begin
  if Assigned(FglVertexAttrib1s) then
  begin
    FglVertexAttrib1s(index, x);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib1s not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib1sv(index: GLuint; const v: PGLshort);
begin
  if Assigned(FglVertexAttrib1sv) then
  begin
    FglVertexAttrib1sv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib1sv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib2d(index: GLuint; x: GLdouble; y: GLdouble);
begin
  if Assigned(FglVertexAttrib2d) then
  begin
    FglVertexAttrib2d(index, x, y);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib2d not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib2dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FglVertexAttrib2dv) then
  begin
    FglVertexAttrib2dv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib2dv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib2f(index: GLuint; x: GLfloat; y: GLfloat);
begin
  if Assigned(FglVertexAttrib2f) then
  begin
    FglVertexAttrib2f(index, x, y);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib2f not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib2fv(index: GLuint; const v: PGLfloat);
begin
  if Assigned(FglVertexAttrib2fv) then
  begin
    FglVertexAttrib2fv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib2fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib2s(index: GLuint; x: GLshort; y: GLshort);
begin
  if Assigned(FglVertexAttrib2s) then
  begin
    FglVertexAttrib2s(index, x, y);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib2s not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib2sv(index: GLuint; const v: PGLshort);
begin
  if Assigned(FglVertexAttrib2sv) then
  begin
    FglVertexAttrib2sv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib2sv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib3d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble);
begin
  if Assigned(FglVertexAttrib3d) then
  begin
    FglVertexAttrib3d(index, x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib3d not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib3dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FglVertexAttrib3dv) then
  begin
    FglVertexAttrib3dv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib3dv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib3f(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat);
begin
  if Assigned(FglVertexAttrib3f) then
  begin
    FglVertexAttrib3f(index, x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib3f not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib3fv(index: GLuint; const v: PGLfloat);
begin
  if Assigned(FglVertexAttrib3fv) then
  begin
    FglVertexAttrib3fv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib3fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib3s(index: GLuint; x: GLshort; y: GLshort; z: GLshort);
begin
  if Assigned(FglVertexAttrib3s) then
  begin
    FglVertexAttrib3s(index, x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib3s not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib3sv(index: GLuint; const v: PGLshort);
begin
  if Assigned(FglVertexAttrib3sv) then
  begin
    FglVertexAttrib3sv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib3sv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4Nbv(index: GLuint; const v: PGLbyte);
begin
  if Assigned(FglVertexAttrib4Nbv) then
  begin
    FglVertexAttrib4Nbv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4Nbv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4Niv(index: GLuint; const v: PGLint);
begin
  if Assigned(FglVertexAttrib4Niv) then
  begin
    FglVertexAttrib4Niv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4Niv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4Nsv(index: GLuint; const v: PGLshort);
begin
  if Assigned(FglVertexAttrib4Nsv) then
  begin
    FglVertexAttrib4Nsv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4Nsv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4Nub(index: GLuint; x: GLubyte; y: GLubyte; z: GLubyte; w: GLubyte);
begin
  if Assigned(FglVertexAttrib4Nub) then
  begin
    FglVertexAttrib4Nub(index, x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4Nub not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4Nubv(index: GLuint; const v: PGLubyte);
begin
  if Assigned(FglVertexAttrib4Nubv) then
  begin
    FglVertexAttrib4Nubv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4Nubv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4Nuiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FglVertexAttrib4Nuiv) then
  begin
    FglVertexAttrib4Nuiv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4Nuiv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4Nusv(index: GLuint; const v: PGLushort);
begin
  if Assigned(FglVertexAttrib4Nusv) then
  begin
    FglVertexAttrib4Nusv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4Nusv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4bv(index: GLuint; const v: PGLbyte);
begin
  if Assigned(FglVertexAttrib4bv) then
  begin
    FglVertexAttrib4bv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4bv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
begin
  if Assigned(FglVertexAttrib4d) then
  begin
    FglVertexAttrib4d(index, x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4d not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FglVertexAttrib4dv) then
  begin
    FglVertexAttrib4dv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4dv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4f(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat);
begin
  if Assigned(FglVertexAttrib4f) then
  begin
    FglVertexAttrib4f(index, x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4f not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4fv(index: GLuint; const v: PGLfloat);
begin
  if Assigned(FglVertexAttrib4fv) then
  begin
    FglVertexAttrib4fv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4fv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4iv(index: GLuint; const v: PGLint);
begin
  if Assigned(FglVertexAttrib4iv) then
  begin
    FglVertexAttrib4iv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4iv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4s(index: GLuint; x: GLshort; y: GLshort; z: GLshort; w: GLshort);
begin
  if Assigned(FglVertexAttrib4s) then
  begin
    FglVertexAttrib4s(index, x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4s not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4sv(index: GLuint; const v: PGLshort);
begin
  if Assigned(FglVertexAttrib4sv) then
  begin
    FglVertexAttrib4sv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4sv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4ubv(index: GLuint; const v: PGLubyte);
begin
  if Assigned(FglVertexAttrib4ubv) then
  begin
    FglVertexAttrib4ubv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4ubv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4uiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FglVertexAttrib4uiv) then
  begin
    FglVertexAttrib4uiv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4uiv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttrib4usv(index: GLuint; const v: PGLushort);
begin
  if Assigned(FglVertexAttrib4usv) then
  begin
    FglVertexAttrib4usv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttrib4usv not bound');
  end;
end;

procedure TGL_VERSION_2_0.glVertexAttribPointer(index: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglVertexAttribPointer) then
  begin
    FglVertexAttribPointer(index, size, aType, normalized, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glVertexAttribPointer not bound');
  end;
end;

procedure TGL_VERSION_2_1.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglUniformMatrix2x3fv), 'glUniformMatrix2x3fv');
  Bind(Pointer(FglUniformMatrix3x2fv), 'glUniformMatrix3x2fv');
  Bind(Pointer(FglUniformMatrix2x4fv), 'glUniformMatrix2x4fv');
  Bind(Pointer(FglUniformMatrix4x2fv), 'glUniformMatrix4x2fv');
  Bind(Pointer(FglUniformMatrix3x4fv), 'glUniformMatrix3x4fv');
  Bind(Pointer(FglUniformMatrix4x3fv), 'glUniformMatrix4x3fv');
end;

procedure TGL_VERSION_2_1.glUniformMatrix2x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglUniformMatrix2x3fv) then
  begin
    FglUniformMatrix2x3fv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix2x3fv not bound');
  end;
end;

procedure TGL_VERSION_2_1.glUniformMatrix3x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglUniformMatrix3x2fv) then
  begin
    FglUniformMatrix3x2fv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix3x2fv not bound');
  end;
end;

procedure TGL_VERSION_2_1.glUniformMatrix2x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglUniformMatrix2x4fv) then
  begin
    FglUniformMatrix2x4fv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix2x4fv not bound');
  end;
end;

procedure TGL_VERSION_2_1.glUniformMatrix4x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglUniformMatrix4x2fv) then
  begin
    FglUniformMatrix4x2fv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix4x2fv not bound');
  end;
end;

procedure TGL_VERSION_2_1.glUniformMatrix3x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglUniformMatrix3x4fv) then
  begin
    FglUniformMatrix3x4fv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix3x4fv not bound');
  end;
end;

procedure TGL_VERSION_2_1.glUniformMatrix4x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglUniformMatrix4x3fv) then
  begin
    FglUniformMatrix4x3fv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix4x3fv not bound');
  end;
end;

procedure TGL_VERSION_3_0.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglColorMaski), 'glColorMaski');
  Bind(Pointer(FglGetBooleani_v), 'glGetBooleani_v');
  Bind(Pointer(FglGetIntegeri_v), 'glGetIntegeri_v');
  Bind(Pointer(FglEnablei), 'glEnablei');
  Bind(Pointer(FglDisablei), 'glDisablei');
  Bind(Pointer(FglIsEnabledi), 'glIsEnabledi');
  Bind(Pointer(FglBeginTransformFeedback), 'glBeginTransformFeedback');
  Bind(Pointer(FglEndTransformFeedback), 'glEndTransformFeedback');
  Bind(Pointer(FglBindBufferRange), 'glBindBufferRange');
  Bind(Pointer(FglBindBufferBase), 'glBindBufferBase');
  Bind(Pointer(FglTransformFeedbackVaryings), 'glTransformFeedbackVaryings');
  Bind(Pointer(FglGetTransformFeedbackVarying), 'glGetTransformFeedbackVarying');
  Bind(Pointer(FglClampColor), 'glClampColor');
  Bind(Pointer(FglBeginConditionalRender), 'glBeginConditionalRender');
  Bind(Pointer(FglEndConditionalRender), 'glEndConditionalRender');
  Bind(Pointer(FglVertexAttribIPointer), 'glVertexAttribIPointer');
  Bind(Pointer(FglGetVertexAttribIiv), 'glGetVertexAttribIiv');
  Bind(Pointer(FglGetVertexAttribIuiv), 'glGetVertexAttribIuiv');
  Bind(Pointer(FglVertexAttribI1i), 'glVertexAttribI1i');
  Bind(Pointer(FglVertexAttribI2i), 'glVertexAttribI2i');
  Bind(Pointer(FglVertexAttribI3i), 'glVertexAttribI3i');
  Bind(Pointer(FglVertexAttribI4i), 'glVertexAttribI4i');
  Bind(Pointer(FglVertexAttribI1ui), 'glVertexAttribI1ui');
  Bind(Pointer(FglVertexAttribI2ui), 'glVertexAttribI2ui');
  Bind(Pointer(FglVertexAttribI3ui), 'glVertexAttribI3ui');
  Bind(Pointer(FglVertexAttribI4ui), 'glVertexAttribI4ui');
  Bind(Pointer(FglVertexAttribI1iv), 'glVertexAttribI1iv');
  Bind(Pointer(FglVertexAttribI2iv), 'glVertexAttribI2iv');
  Bind(Pointer(FglVertexAttribI3iv), 'glVertexAttribI3iv');
  Bind(Pointer(FglVertexAttribI4iv), 'glVertexAttribI4iv');
  Bind(Pointer(FglVertexAttribI1uiv), 'glVertexAttribI1uiv');
  Bind(Pointer(FglVertexAttribI2uiv), 'glVertexAttribI2uiv');
  Bind(Pointer(FglVertexAttribI3uiv), 'glVertexAttribI3uiv');
  Bind(Pointer(FglVertexAttribI4uiv), 'glVertexAttribI4uiv');
  Bind(Pointer(FglVertexAttribI4bv), 'glVertexAttribI4bv');
  Bind(Pointer(FglVertexAttribI4sv), 'glVertexAttribI4sv');
  Bind(Pointer(FglVertexAttribI4ubv), 'glVertexAttribI4ubv');
  Bind(Pointer(FglVertexAttribI4usv), 'glVertexAttribI4usv');
  Bind(Pointer(FglGetUniformuiv), 'glGetUniformuiv');
  Bind(Pointer(FglBindFragDataLocation), 'glBindFragDataLocation');
  Bind(Pointer(FglGetFragDataLocation), 'glGetFragDataLocation');
  Bind(Pointer(FglUniform1ui), 'glUniform1ui');
  Bind(Pointer(FglUniform2ui), 'glUniform2ui');
  Bind(Pointer(FglUniform3ui), 'glUniform3ui');
  Bind(Pointer(FglUniform4ui), 'glUniform4ui');
  Bind(Pointer(FglUniform1uiv), 'glUniform1uiv');
  Bind(Pointer(FglUniform2uiv), 'glUniform2uiv');
  Bind(Pointer(FglUniform3uiv), 'glUniform3uiv');
  Bind(Pointer(FglUniform4uiv), 'glUniform4uiv');
  Bind(Pointer(FglTexParameterIiv), 'glTexParameterIiv');
  Bind(Pointer(FglTexParameterIuiv), 'glTexParameterIuiv');
  Bind(Pointer(FglGetTexParameterIiv), 'glGetTexParameterIiv');
  Bind(Pointer(FglGetTexParameterIuiv), 'glGetTexParameterIuiv');
  Bind(Pointer(FglClearBufferiv), 'glClearBufferiv');
  Bind(Pointer(FglClearBufferuiv), 'glClearBufferuiv');
  Bind(Pointer(FglClearBufferfv), 'glClearBufferfv');
  Bind(Pointer(FglClearBufferfi), 'glClearBufferfi');
  Bind(Pointer(FglGetStringi), 'glGetStringi');
  Bind(Pointer(FglIsRenderbuffer), 'glIsRenderbuffer');
  Bind(Pointer(FglBindRenderbuffer), 'glBindRenderbuffer');
  Bind(Pointer(FglDeleteRenderbuffers), 'glDeleteRenderbuffers');
  Bind(Pointer(FglGenRenderbuffers), 'glGenRenderbuffers');
  Bind(Pointer(FglRenderbufferStorage), 'glRenderbufferStorage');
  Bind(Pointer(FglGetRenderbufferParameteriv), 'glGetRenderbufferParameteriv');
  Bind(Pointer(FglIsFramebuffer), 'glIsFramebuffer');
  Bind(Pointer(FglBindFramebuffer), 'glBindFramebuffer');
  Bind(Pointer(FglDeleteFramebuffers), 'glDeleteFramebuffers');
  Bind(Pointer(FglGenFramebuffers), 'glGenFramebuffers');
  Bind(Pointer(FglCheckFramebufferStatus), 'glCheckFramebufferStatus');
  Bind(Pointer(FglFramebufferTexture1D), 'glFramebufferTexture1D');
  Bind(Pointer(FglFramebufferTexture2D), 'glFramebufferTexture2D');
  Bind(Pointer(FglFramebufferTexture3D), 'glFramebufferTexture3D');
  Bind(Pointer(FglFramebufferRenderbuffer), 'glFramebufferRenderbuffer');
  Bind(Pointer(FglGetFramebufferAttachmentParameteriv), 'glGetFramebufferAttachmentParameteriv');
  Bind(Pointer(FglGenerateMipmap), 'glGenerateMipmap');
  Bind(Pointer(FglBlitFramebuffer), 'glBlitFramebuffer');
  Bind(Pointer(FglRenderbufferStorageMultisample), 'glRenderbufferStorageMultisample');
  Bind(Pointer(FglFramebufferTextureLayer), 'glFramebufferTextureLayer');
  Bind(Pointer(FglMapBufferRange), 'glMapBufferRange');
  Bind(Pointer(FglFlushMappedBufferRange), 'glFlushMappedBufferRange');
  Bind(Pointer(FglBindVertexArray), 'glBindVertexArray');
  Bind(Pointer(FglDeleteVertexArrays), 'glDeleteVertexArrays');
  Bind(Pointer(FglGenVertexArrays), 'glGenVertexArrays');
  Bind(Pointer(FglIsVertexArray), 'glIsVertexArray');
end;

procedure TGL_VERSION_3_0.glColorMaski(index: GLuint; r: GLboolean; g: GLboolean; b: GLboolean; a: GLboolean);
begin
  if Assigned(FglColorMaski) then
  begin
    FglColorMaski(index, r, g, b, a);
  end
  else
  begin
    raise Exception.Create('glColorMaski not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetBooleani_v(target: GLenum; index: GLuint; Data: PGLboolean);
begin
  if Assigned(FglGetBooleani_v) then
  begin
    FglGetBooleani_v(target, index, Data);
  end
  else
  begin
    raise Exception.Create('glGetBooleani_v not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetIntegeri_v(target: GLenum; index: GLuint; Data: PGLint);
begin
  if Assigned(FglGetIntegeri_v) then
  begin
    FglGetIntegeri_v(target, index, Data);
  end
  else
  begin
    raise Exception.Create('glGetIntegeri_v not bound');
  end;
end;

procedure TGL_VERSION_3_0.glEnablei(target: GLenum; index: GLuint);
begin
  if Assigned(FglEnablei) then
  begin
    FglEnablei(target, index);
  end
  else
  begin
    raise Exception.Create('glEnablei not bound');
  end;
end;

procedure TGL_VERSION_3_0.glDisablei(target: GLenum; index: GLuint);
begin
  if Assigned(FglDisablei) then
  begin
    FglDisablei(target, index);
  end
  else
  begin
    raise Exception.Create('glDisablei not bound');
  end;
end;

function TGL_VERSION_3_0.glIsEnabledi(target: GLenum; index: GLuint): GLboolean;
begin
  if Assigned(FglIsEnabledi) then
  begin
    Result := FglIsEnabledi(target, index);
  end
  else
  begin
    raise Exception.Create('glIsEnabledi not bound');
  end;
end;

procedure TGL_VERSION_3_0.glBeginTransformFeedback(primitiveMode: GLenum);
begin
  if Assigned(FglBeginTransformFeedback) then
  begin
    FglBeginTransformFeedback(primitiveMode);
  end
  else
  begin
    raise Exception.Create('glBeginTransformFeedback not bound');
  end;
end;

procedure TGL_VERSION_3_0.glEndTransformFeedback();
begin
  if Assigned(FglEndTransformFeedback) then
  begin
    FglEndTransformFeedback();
  end
  else
  begin
    raise Exception.Create('glEndTransformFeedback not bound');
  end;
end;

procedure TGL_VERSION_3_0.glBindBufferRange(target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FglBindBufferRange) then
  begin
    FglBindBufferRange(target, index, buffer, offset, size);
  end
  else
  begin
    raise Exception.Create('glBindBufferRange not bound');
  end;
end;

procedure TGL_VERSION_3_0.glBindBufferBase(target: GLenum; index: GLuint; buffer: GLuint);
begin
  if Assigned(FglBindBufferBase) then
  begin
    FglBindBufferBase(target, index, buffer);
  end
  else
  begin
    raise Exception.Create('glBindBufferBase not bound');
  end;
end;

procedure TGL_VERSION_3_0.glTransformFeedbackVaryings(aProgram: GLuint; Count: GLsizei; const varyings: PGLchar; bufferMode: GLenum);
begin
  if Assigned(FglTransformFeedbackVaryings) then
  begin
    FglTransformFeedbackVaryings(aProgram, Count, varyings, bufferMode);
  end
  else
  begin
    raise Exception.Create('glTransformFeedbackVaryings not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetTransformFeedbackVarying(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; aType: PGLenum; Name: PGLchar);
begin
  if Assigned(FglGetTransformFeedbackVarying) then
  begin
    FglGetTransformFeedbackVarying(aProgram, index, bufSize, length, size, aType, Name);
  end
  else
  begin
    raise Exception.Create('glGetTransformFeedbackVarying not bound');
  end;
end;

procedure TGL_VERSION_3_0.glClampColor(target: GLenum; clamp: GLenum);
begin
  if Assigned(FglClampColor) then
  begin
    FglClampColor(target, clamp);
  end
  else
  begin
    raise Exception.Create('glClampColor not bound');
  end;
end;

procedure TGL_VERSION_3_0.glBeginConditionalRender(id: GLuint; mode: GLenum);
begin
  if Assigned(FglBeginConditionalRender) then
  begin
    FglBeginConditionalRender(id, mode);
  end
  else
  begin
    raise Exception.Create('glBeginConditionalRender not bound');
  end;
end;

procedure TGL_VERSION_3_0.glEndConditionalRender();
begin
  if Assigned(FglEndConditionalRender) then
  begin
    FglEndConditionalRender();
  end
  else
  begin
    raise Exception.Create('glEndConditionalRender not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribIPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglVertexAttribIPointer) then
  begin
    FglVertexAttribIPointer(index, size, aType, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glVertexAttribIPointer not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetVertexAttribIiv(index: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetVertexAttribIiv) then
  begin
    FglGetVertexAttribIiv(index, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetVertexAttribIiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetVertexAttribIuiv(index: GLuint; pname: GLenum; params: PGLuint);
begin
  if Assigned(FglGetVertexAttribIuiv) then
  begin
    FglGetVertexAttribIuiv(index, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetVertexAttribIuiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI1i(index: GLuint; x: GLint);
begin
  if Assigned(FglVertexAttribI1i) then
  begin
    FglVertexAttribI1i(index, x);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI1i not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI2i(index: GLuint; x: GLint; y: GLint);
begin
  if Assigned(FglVertexAttribI2i) then
  begin
    FglVertexAttribI2i(index, x, y);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI2i not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI3i(index: GLuint; x: GLint; y: GLint; z: GLint);
begin
  if Assigned(FglVertexAttribI3i) then
  begin
    FglVertexAttribI3i(index, x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI3i not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI4i(index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint);
begin
  if Assigned(FglVertexAttribI4i) then
  begin
    FglVertexAttribI4i(index, x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI4i not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI1ui(index: GLuint; x: GLuint);
begin
  if Assigned(FglVertexAttribI1ui) then
  begin
    FglVertexAttribI1ui(index, x);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI1ui not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI2ui(index: GLuint; x: GLuint; y: GLuint);
begin
  if Assigned(FglVertexAttribI2ui) then
  begin
    FglVertexAttribI2ui(index, x, y);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI2ui not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI3ui(index: GLuint; x: GLuint; y: GLuint; z: GLuint);
begin
  if Assigned(FglVertexAttribI3ui) then
  begin
    FglVertexAttribI3ui(index, x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI3ui not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI4ui(index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint);
begin
  if Assigned(FglVertexAttribI4ui) then
  begin
    FglVertexAttribI4ui(index, x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI4ui not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI1iv(index: GLuint; const v: PGLint);
begin
  if Assigned(FglVertexAttribI1iv) then
  begin
    FglVertexAttribI1iv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI1iv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI2iv(index: GLuint; const v: PGLint);
begin
  if Assigned(FglVertexAttribI2iv) then
  begin
    FglVertexAttribI2iv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI2iv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI3iv(index: GLuint; const v: PGLint);
begin
  if Assigned(FglVertexAttribI3iv) then
  begin
    FglVertexAttribI3iv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI3iv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI4iv(index: GLuint; const v: PGLint);
begin
  if Assigned(FglVertexAttribI4iv) then
  begin
    FglVertexAttribI4iv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI4iv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI1uiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FglVertexAttribI1uiv) then
  begin
    FglVertexAttribI1uiv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI1uiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI2uiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FglVertexAttribI2uiv) then
  begin
    FglVertexAttribI2uiv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI2uiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI3uiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FglVertexAttribI3uiv) then
  begin
    FglVertexAttribI3uiv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI3uiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI4uiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FglVertexAttribI4uiv) then
  begin
    FglVertexAttribI4uiv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI4uiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI4bv(index: GLuint; const v: PGLbyte);
begin
  if Assigned(FglVertexAttribI4bv) then
  begin
    FglVertexAttribI4bv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI4bv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI4sv(index: GLuint; const v: PGLshort);
begin
  if Assigned(FglVertexAttribI4sv) then
  begin
    FglVertexAttribI4sv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI4sv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI4ubv(index: GLuint; const v: PGLubyte);
begin
  if Assigned(FglVertexAttribI4ubv) then
  begin
    FglVertexAttribI4ubv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI4ubv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glVertexAttribI4usv(index: GLuint; const v: PGLushort);
begin
  if Assigned(FglVertexAttribI4usv) then
  begin
    FglVertexAttribI4usv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribI4usv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetUniformuiv(aProgram: GLuint; location: GLint; params: PGLuint);
begin
  if Assigned(FglGetUniformuiv) then
  begin
    FglGetUniformuiv(aProgram, location, params);
  end
  else
  begin
    raise Exception.Create('glGetUniformuiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glBindFragDataLocation(aProgram: GLuint; color: GLuint; const Name: PGLchar);
begin
  if Assigned(FglBindFragDataLocation) then
  begin
    FglBindFragDataLocation(aProgram, color, Name);
  end
  else
  begin
    raise Exception.Create('glBindFragDataLocation not bound');
  end;
end;

function TGL_VERSION_3_0.glGetFragDataLocation(aProgram: GLuint; const Name: PGLchar): GLint;
begin
  if Assigned(FglGetFragDataLocation) then
  begin
    Result := FglGetFragDataLocation(aProgram, Name);
  end
  else
  begin
    raise Exception.Create('glGetFragDataLocation not bound');
  end;
end;

procedure TGL_VERSION_3_0.glUniform1ui(location: GLint; v0: GLuint);
begin
  if Assigned(FglUniform1ui) then
  begin
    FglUniform1ui(location, v0);
  end
  else
  begin
    raise Exception.Create('glUniform1ui not bound');
  end;
end;

procedure TGL_VERSION_3_0.glUniform2ui(location: GLint; v0: GLuint; v1: GLuint);
begin
  if Assigned(FglUniform2ui) then
  begin
    FglUniform2ui(location, v0, v1);
  end
  else
  begin
    raise Exception.Create('glUniform2ui not bound');
  end;
end;

procedure TGL_VERSION_3_0.glUniform3ui(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint);
begin
  if Assigned(FglUniform3ui) then
  begin
    FglUniform3ui(location, v0, v1, v2);
  end
  else
  begin
    raise Exception.Create('glUniform3ui not bound');
  end;
end;

procedure TGL_VERSION_3_0.glUniform4ui(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint);
begin
  if Assigned(FglUniform4ui) then
  begin
    FglUniform4ui(location, v0, v1, v2, v3);
  end
  else
  begin
    raise Exception.Create('glUniform4ui not bound');
  end;
end;

procedure TGL_VERSION_3_0.glUniform1uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FglUniform1uiv) then
  begin
    FglUniform1uiv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform1uiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glUniform2uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FglUniform2uiv) then
  begin
    FglUniform2uiv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform2uiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glUniform3uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FglUniform3uiv) then
  begin
    FglUniform3uiv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform3uiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glUniform4uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FglUniform4uiv) then
  begin
    FglUniform4uiv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform4uiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glTexParameterIiv(target: GLenum; pname: GLenum; const params: PGLint);
begin
  if Assigned(FglTexParameterIiv) then
  begin
    FglTexParameterIiv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glTexParameterIiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glTexParameterIuiv(target: GLenum; pname: GLenum; const params: PGLuint);
begin
  if Assigned(FglTexParameterIuiv) then
  begin
    FglTexParameterIuiv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glTexParameterIuiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetTexParameterIiv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetTexParameterIiv) then
  begin
    FglGetTexParameterIiv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexParameterIiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetTexParameterIuiv(target: GLenum; pname: GLenum; params: PGLuint);
begin
  if Assigned(FglGetTexParameterIuiv) then
  begin
    FglGetTexParameterIuiv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTexParameterIuiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glClearBufferiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLint);
begin
  if Assigned(FglClearBufferiv) then
  begin
    FglClearBufferiv(buffer, drawbuffer, Value);
  end
  else
  begin
    raise Exception.Create('glClearBufferiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glClearBufferuiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLuint);
begin
  if Assigned(FglClearBufferuiv) then
  begin
    FglClearBufferuiv(buffer, drawbuffer, Value);
  end
  else
  begin
    raise Exception.Create('glClearBufferuiv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glClearBufferfv(buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat);
begin
  if Assigned(FglClearBufferfv) then
  begin
    FglClearBufferfv(buffer, drawbuffer, Value);
  end
  else
  begin
    raise Exception.Create('glClearBufferfv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glClearBufferfi(buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint);
begin
  if Assigned(FglClearBufferfi) then
  begin
    FglClearBufferfi(buffer, drawbuffer, depth, stencil);
  end
  else
  begin
    raise Exception.Create('glClearBufferfi not bound');
  end;
end;

function TGL_VERSION_3_0.glGetStringi(Name: GLenum; index: GLuint): PGLubyte;
begin
  if Assigned(FglGetStringi) then
  begin
    Result := FglGetStringi(Name, index);
  end
  else
  begin
    raise Exception.Create('glGetStringi not bound');
  end;
end;

function TGL_VERSION_3_0.glIsRenderbuffer(renderbuffer: GLuint): GLboolean;
begin
  if Assigned(FglIsRenderbuffer) then
  begin
    Result := FglIsRenderbuffer(renderbuffer);
  end
  else
  begin
    raise Exception.Create('glIsRenderbuffer not bound');
  end;
end;

procedure TGL_VERSION_3_0.glBindRenderbuffer(target: GLenum; renderbuffer: GLuint);
begin
  if Assigned(FglBindRenderbuffer) then
  begin
    FglBindRenderbuffer(target, renderbuffer);
  end
  else
  begin
    raise Exception.Create('glBindRenderbuffer not bound');
  end;
end;

procedure TGL_VERSION_3_0.glDeleteRenderbuffers(n: GLsizei; const renderbuffers: PGLuint);
begin
  if Assigned(FglDeleteRenderbuffers) then
  begin
    FglDeleteRenderbuffers(n, renderbuffers);
  end
  else
  begin
    raise Exception.Create('glDeleteRenderbuffers not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGenRenderbuffers(n: GLsizei; renderbuffers: PGLuint);
begin
  if Assigned(FglGenRenderbuffers) then
  begin
    FglGenRenderbuffers(n, renderbuffers);
  end
  else
  begin
    raise Exception.Create('glGenRenderbuffers not bound');
  end;
end;

procedure TGL_VERSION_3_0.glRenderbufferStorage(target: GLenum; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglRenderbufferStorage) then
  begin
    FglRenderbufferStorage(target, internalformat, Width, Height);
  end
  else
  begin
    raise Exception.Create('glRenderbufferStorage not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetRenderbufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetRenderbufferParameteriv) then
  begin
    FglGetRenderbufferParameteriv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetRenderbufferParameteriv not bound');
  end;
end;

function TGL_VERSION_3_0.glIsFramebuffer(framebuffer: GLuint): GLboolean;
begin
  if Assigned(FglIsFramebuffer) then
  begin
    Result := FglIsFramebuffer(framebuffer);
  end
  else
  begin
    raise Exception.Create('glIsFramebuffer not bound');
  end;
end;

procedure TGL_VERSION_3_0.glBindFramebuffer(target: GLenum; framebuffer: GLuint);
begin
  if Assigned(FglBindFramebuffer) then
  begin
    FglBindFramebuffer(target, framebuffer);
  end
  else
  begin
    raise Exception.Create('glBindFramebuffer not bound');
  end;
end;

procedure TGL_VERSION_3_0.glDeleteFramebuffers(n: GLsizei; const framebuffers: PGLuint);
begin
  if Assigned(FglDeleteFramebuffers) then
  begin
    FglDeleteFramebuffers(n, framebuffers);
  end
  else
  begin
    raise Exception.Create('glDeleteFramebuffers not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGenFramebuffers(n: GLsizei; framebuffers: PGLuint);
begin
  if Assigned(FglGenFramebuffers) then
  begin
    FglGenFramebuffers(n, framebuffers);
  end
  else
  begin
    raise Exception.Create('glGenFramebuffers not bound');
  end;
end;

function TGL_VERSION_3_0.glCheckFramebufferStatus(target: GLenum): GLenum;
begin
  if Assigned(FglCheckFramebufferStatus) then
  begin
    Result := FglCheckFramebufferStatus(target);
  end
  else
  begin
    raise Exception.Create('glCheckFramebufferStatus not bound');
  end;
end;

procedure TGL_VERSION_3_0.glFramebufferTexture1D(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint);
begin
  if Assigned(FglFramebufferTexture1D) then
  begin
    FglFramebufferTexture1D(target, attachment, textarget, texture, level);
  end
  else
  begin
    raise Exception.Create('glFramebufferTexture1D not bound');
  end;
end;

procedure TGL_VERSION_3_0.glFramebufferTexture2D(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint);
begin
  if Assigned(FglFramebufferTexture2D) then
  begin
    FglFramebufferTexture2D(target, attachment, textarget, texture, level);
  end
  else
  begin
    raise Exception.Create('glFramebufferTexture2D not bound');
  end;
end;

procedure TGL_VERSION_3_0.glFramebufferTexture3D(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; zoffset: GLint);
begin
  if Assigned(FglFramebufferTexture3D) then
  begin
    FglFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
  end
  else
  begin
    raise Exception.Create('glFramebufferTexture3D not bound');
  end;
end;

procedure TGL_VERSION_3_0.glFramebufferRenderbuffer(target: GLenum; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint);
begin
  if Assigned(FglFramebufferRenderbuffer) then
  begin
    FglFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
  end
  else
  begin
    raise Exception.Create('glFramebufferRenderbuffer not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGetFramebufferAttachmentParameteriv(target: GLenum; attachment: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetFramebufferAttachmentParameteriv) then
  begin
    FglGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetFramebufferAttachmentParameteriv not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGenerateMipmap(target: GLenum);
begin
  if Assigned(FglGenerateMipmap) then
  begin
    FglGenerateMipmap(target);
  end
  else
  begin
    raise Exception.Create('glGenerateMipmap not bound');
  end;
end;

procedure TGL_VERSION_3_0.glBlitFramebuffer(srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum);
begin
  if Assigned(FglBlitFramebuffer) then
  begin
    FglBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  end
  else
  begin
    raise Exception.Create('glBlitFramebuffer not bound');
  end;
end;

procedure TGL_VERSION_3_0.glRenderbufferStorageMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglRenderbufferStorageMultisample) then
  begin
    FglRenderbufferStorageMultisample(target, samples, internalformat, Width, Height);
  end
  else
  begin
    raise Exception.Create('glRenderbufferStorageMultisample not bound');
  end;
end;

procedure TGL_VERSION_3_0.glFramebufferTextureLayer(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint);
begin
  if Assigned(FglFramebufferTextureLayer) then
  begin
    FglFramebufferTextureLayer(target, attachment, texture, level, layer);
  end
  else
  begin
    raise Exception.Create('glFramebufferTextureLayer not bound');
  end;
end;

function TGL_VERSION_3_0.glMapBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): pointer;
begin
  if Assigned(FglMapBufferRange) then
  begin
    Result := FglMapBufferRange(target, offset, length, access);
  end
  else
  begin
    raise Exception.Create('glMapBufferRange not bound');
  end;
end;

procedure TGL_VERSION_3_0.glFlushMappedBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr);
begin
  if Assigned(FglFlushMappedBufferRange) then
  begin
    FglFlushMappedBufferRange(target, offset, length);
  end
  else
  begin
    raise Exception.Create('glFlushMappedBufferRange not bound');
  end;
end;

procedure TGL_VERSION_3_0.glBindVertexArray(aArray: GLuint);
begin
  if Assigned(FglBindVertexArray) then
  begin
    FglBindVertexArray(aArray);
  end
  else
  begin
    raise Exception.Create('glBindVertexArray not bound');
  end;
end;

procedure TGL_VERSION_3_0.glDeleteVertexArrays(n: GLsizei; const arrays: PGLuint);
begin
  if Assigned(FglDeleteVertexArrays) then
  begin
    FglDeleteVertexArrays(n, arrays);
  end
  else
  begin
    raise Exception.Create('glDeleteVertexArrays not bound');
  end;
end;

procedure TGL_VERSION_3_0.glGenVertexArrays(n: GLsizei; arrays: PGLuint);
begin
  if Assigned(FglGenVertexArrays) then
  begin
    FglGenVertexArrays(n, arrays);
  end
  else
  begin
    raise Exception.Create('glGenVertexArrays not bound');
  end;
end;

function TGL_VERSION_3_0.glIsVertexArray(aArray: GLuint): GLboolean;
begin
  if Assigned(FglIsVertexArray) then
  begin
    Result := FglIsVertexArray(aArray);
  end
  else
  begin
    raise Exception.Create('glIsVertexArray not bound');
  end;
end;

procedure TGL_VERSION_3_1.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglDrawArraysInstanced), 'glDrawArraysInstanced');
  Bind(Pointer(FglDrawElementsInstanced), 'glDrawElementsInstanced');
  Bind(Pointer(FglTexBuffer), 'glTexBuffer');
  Bind(Pointer(FglPrimitiveRestartIndex), 'glPrimitiveRestartIndex');
  Bind(Pointer(FglCopyBufferSubData), 'glCopyBufferSubData');
  Bind(Pointer(FglGetUniformIndices), 'glGetUniformIndices');
  Bind(Pointer(FglGetActiveUniformsiv), 'glGetActiveUniformsiv');
  Bind(Pointer(FglGetActiveUniformName), 'glGetActiveUniformName');
  Bind(Pointer(FglGetUniformBlockIndex), 'glGetUniformBlockIndex');
  Bind(Pointer(FglGetActiveUniformBlockiv), 'glGetActiveUniformBlockiv');
  Bind(Pointer(FglGetActiveUniformBlockName), 'glGetActiveUniformBlockName');
  Bind(Pointer(FglUniformBlockBinding), 'glUniformBlockBinding');
end;

procedure TGL_VERSION_3_1.glDrawArraysInstanced(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei);
begin
  if Assigned(FglDrawArraysInstanced) then
  begin
    FglDrawArraysInstanced(mode, First, Count, instancecount);
  end
  else
  begin
    raise Exception.Create('glDrawArraysInstanced not bound');
  end;
end;

procedure TGL_VERSION_3_1.glDrawElementsInstanced(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei);
begin
  if Assigned(FglDrawElementsInstanced) then
  begin
    FglDrawElementsInstanced(mode, Count, aType, indices, instancecount);
  end
  else
  begin
    raise Exception.Create('glDrawElementsInstanced not bound');
  end;
end;

procedure TGL_VERSION_3_1.glTexBuffer(target: GLenum; internalformat: GLenum; buffer: GLuint);
begin
  if Assigned(FglTexBuffer) then
  begin
    FglTexBuffer(target, internalformat, buffer);
  end
  else
  begin
    raise Exception.Create('glTexBuffer not bound');
  end;
end;

procedure TGL_VERSION_3_1.glPrimitiveRestartIndex(index: GLuint);
begin
  if Assigned(FglPrimitiveRestartIndex) then
  begin
    FglPrimitiveRestartIndex(index);
  end
  else
  begin
    raise Exception.Create('glPrimitiveRestartIndex not bound');
  end;
end;

procedure TGL_VERSION_3_1.glCopyBufferSubData(readTarget: GLenum; writeTarget: GLenum; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FglCopyBufferSubData) then
  begin
    FglCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
  end
  else
  begin
    raise Exception.Create('glCopyBufferSubData not bound');
  end;
end;

procedure TGL_VERSION_3_1.glGetUniformIndices(aProgram: GLuint; uniformCount: GLsizei; const uniformNames: PGLchar; uniformIndices: PGLuint);
begin
  if Assigned(FglGetUniformIndices) then
  begin
    FglGetUniformIndices(aProgram, uniformCount, uniformNames, uniformIndices);
  end
  else
  begin
    raise Exception.Create('glGetUniformIndices not bound');
  end;
end;

procedure TGL_VERSION_3_1.glGetActiveUniformsiv(aProgram: GLuint; uniformCount: GLsizei; const uniformIndices: PGLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetActiveUniformsiv) then
  begin
    FglGetActiveUniformsiv(aProgram, uniformCount, uniformIndices, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetActiveUniformsiv not bound');
  end;
end;

procedure TGL_VERSION_3_1.glGetActiveUniformName(aProgram: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar);
begin
  if Assigned(FglGetActiveUniformName) then
  begin
    FglGetActiveUniformName(aProgram, uniformIndex, bufSize, length, uniformName);
  end
  else
  begin
    raise Exception.Create('glGetActiveUniformName not bound');
  end;
end;

function TGL_VERSION_3_1.glGetUniformBlockIndex(aProgram: GLuint; const uniformBlockName: PGLchar): GLuint;
begin
  if Assigned(FglGetUniformBlockIndex) then
  begin
    Result := FglGetUniformBlockIndex(aProgram, uniformBlockName);
  end
  else
  begin
    raise Exception.Create('glGetUniformBlockIndex not bound');
  end;
end;

procedure TGL_VERSION_3_1.glGetActiveUniformBlockiv(aProgram: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetActiveUniformBlockiv) then
  begin
    FglGetActiveUniformBlockiv(aProgram, uniformBlockIndex, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetActiveUniformBlockiv not bound');
  end;
end;

procedure TGL_VERSION_3_1.glGetActiveUniformBlockName(aProgram: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar);
begin
  if Assigned(FglGetActiveUniformBlockName) then
  begin
    FglGetActiveUniformBlockName(aProgram, uniformBlockIndex, bufSize, length, uniformBlockName);
  end
  else
  begin
    raise Exception.Create('glGetActiveUniformBlockName not bound');
  end;
end;

procedure TGL_VERSION_3_1.glUniformBlockBinding(aProgram: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint);
begin
  if Assigned(FglUniformBlockBinding) then
  begin
    FglUniformBlockBinding(aProgram, uniformBlockIndex, uniformBlockBinding);
  end
  else
  begin
    raise Exception.Create('glUniformBlockBinding not bound');
  end;
end;

procedure TGL_VERSION_3_2.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglDrawElementsBaseVertex), 'glDrawElementsBaseVertex');
  Bind(Pointer(FglDrawRangeElementsBaseVertex), 'glDrawRangeElementsBaseVertex');
  Bind(Pointer(FglDrawElementsInstancedBaseVertex), 'glDrawElementsInstancedBaseVertex');
  Bind(Pointer(FglMultiDrawElementsBaseVertex), 'glMultiDrawElementsBaseVertex');
  Bind(Pointer(FglProvokingVertex), 'glProvokingVertex');
  Bind(Pointer(FglFenceSync), 'glFenceSync');
  Bind(Pointer(FglIsSync), 'glIsSync');
  Bind(Pointer(FglDeleteSync), 'glDeleteSync');
  Bind(Pointer(FglClientWaitSync), 'glClientWaitSync');
  Bind(Pointer(FglWaitSync), 'glWaitSync');
  Bind(Pointer(FglGetInteger64v), 'glGetInteger64v');
  Bind(Pointer(FglGetSynciv), 'glGetSynciv');
  Bind(Pointer(FglGetInteger64i_v), 'glGetInteger64i_v');
  Bind(Pointer(FglGetBufferParameteri64v), 'glGetBufferParameteri64v');
  Bind(Pointer(FglFramebufferTexture), 'glFramebufferTexture');
  Bind(Pointer(FglTexImage2DMultisample), 'glTexImage2DMultisample');
  Bind(Pointer(FglTexImage3DMultisample), 'glTexImage3DMultisample');
  Bind(Pointer(FglGetMultisamplefv), 'glGetMultisamplefv');
  Bind(Pointer(FglSampleMaski), 'glSampleMaski');
end;

procedure TGL_VERSION_3_2.glDrawElementsBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint);
begin
  if Assigned(FglDrawElementsBaseVertex) then
  begin
    FglDrawElementsBaseVertex(mode, Count, aType, indices, basevertex);
  end
  else
  begin
    raise Exception.Create('glDrawElementsBaseVertex not bound');
  end;
end;

procedure TGL_VERSION_3_2.glDrawRangeElementsBaseVertex(mode: GLenum; start: GLuint; aEnd: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint);
begin
  if Assigned(FglDrawRangeElementsBaseVertex) then
  begin
    FglDrawRangeElementsBaseVertex(mode, start, aEnd, Count, aType, indices, basevertex);
  end
  else
  begin
    raise Exception.Create('glDrawRangeElementsBaseVertex not bound');
  end;
end;

procedure TGL_VERSION_3_2.glDrawElementsInstancedBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint);
begin
  if Assigned(FglDrawElementsInstancedBaseVertex) then
  begin
    FglDrawElementsInstancedBaseVertex(mode, Count, aType, indices, instancecount, basevertex);
  end
  else
  begin
    raise Exception.Create('glDrawElementsInstancedBaseVertex not bound');
  end;
end;

procedure TGL_VERSION_3_2.glMultiDrawElementsBaseVertex(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: Pointer; drawcount: GLsizei; const basevertex: PGLint);
begin
  if Assigned(FglMultiDrawElementsBaseVertex) then
  begin
    FglMultiDrawElementsBaseVertex(mode, Count, aType, indices, drawcount, basevertex);
  end
  else
  begin
    raise Exception.Create('glMultiDrawElementsBaseVertex not bound');
  end;
end;

procedure TGL_VERSION_3_2.glProvokingVertex(mode: GLenum);
begin
  if Assigned(FglProvokingVertex) then
  begin
    FglProvokingVertex(mode);
  end
  else
  begin
    raise Exception.Create('glProvokingVertex not bound');
  end;
end;

function TGL_VERSION_3_2.glFenceSync(condition: GLenum; flags: GLbitfield): GLsync;
begin
  if Assigned(FglFenceSync) then
  begin
    Result := FglFenceSync(condition, flags);
  end
  else
  begin
    raise Exception.Create('glFenceSync not bound');
  end;
end;

function TGL_VERSION_3_2.glIsSync(sync: GLsync): GLboolean;
begin
  if Assigned(FglIsSync) then
  begin
    Result := FglIsSync(sync);
  end
  else
  begin
    raise Exception.Create('glIsSync not bound');
  end;
end;

procedure TGL_VERSION_3_2.glDeleteSync(sync: GLsync);
begin
  if Assigned(FglDeleteSync) then
  begin
    FglDeleteSync(sync);
  end
  else
  begin
    raise Exception.Create('glDeleteSync not bound');
  end;
end;

function TGL_VERSION_3_2.glClientWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum;
begin
  if Assigned(FglClientWaitSync) then
  begin
    Result := FglClientWaitSync(sync, flags, timeout);
  end
  else
  begin
    raise Exception.Create('glClientWaitSync not bound');
  end;
end;

procedure TGL_VERSION_3_2.glWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64);
begin
  if Assigned(FglWaitSync) then
  begin
    FglWaitSync(sync, flags, timeout);
  end
  else
  begin
    raise Exception.Create('glWaitSync not bound');
  end;
end;

procedure TGL_VERSION_3_2.glGetInteger64v(pname: GLenum; Data: PGLint64);
begin
  if Assigned(FglGetInteger64v) then
  begin
    FglGetInteger64v(pname, Data);
  end
  else
  begin
    raise Exception.Create('glGetInteger64v not bound');
  end;
end;

procedure TGL_VERSION_3_2.glGetSynciv(sync: GLsync; pname: GLenum; Count: GLsizei; length: PGLsizei; values: PGLint);
begin
  if Assigned(FglGetSynciv) then
  begin
    FglGetSynciv(sync, pname, Count, length, values);
  end
  else
  begin
    raise Exception.Create('glGetSynciv not bound');
  end;
end;

procedure TGL_VERSION_3_2.glGetInteger64i_v(target: GLenum; index: GLuint; Data: PGLint64);
begin
  if Assigned(FglGetInteger64i_v) then
  begin
    FglGetInteger64i_v(target, index, Data);
  end
  else
  begin
    raise Exception.Create('glGetInteger64i_v not bound');
  end;
end;

procedure TGL_VERSION_3_2.glGetBufferParameteri64v(target: GLenum; pname: GLenum; params: PGLint64);
begin
  if Assigned(FglGetBufferParameteri64v) then
  begin
    FglGetBufferParameteri64v(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetBufferParameteri64v not bound');
  end;
end;

procedure TGL_VERSION_3_2.glFramebufferTexture(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint);
begin
  if Assigned(FglFramebufferTexture) then
  begin
    FglFramebufferTexture(target, attachment, texture, level);
  end
  else
  begin
    raise Exception.Create('glFramebufferTexture not bound');
  end;
end;

procedure TGL_VERSION_3_2.glTexImage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FglTexImage2DMultisample) then
  begin
    FglTexImage2DMultisample(target, samples, internalformat, Width, Height, fixedsamplelocations);
  end
  else
  begin
    raise Exception.Create('glTexImage2DMultisample not bound');
  end;
end;

procedure TGL_VERSION_3_2.glTexImage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FglTexImage3DMultisample) then
  begin
    FglTexImage3DMultisample(target, samples, internalformat, Width, Height, depth, fixedsamplelocations);
  end
  else
  begin
    raise Exception.Create('glTexImage3DMultisample not bound');
  end;
end;

procedure TGL_VERSION_3_2.glGetMultisamplefv(pname: GLenum; index: GLuint; val: PGLfloat);
begin
  if Assigned(FglGetMultisamplefv) then
  begin
    FglGetMultisamplefv(pname, index, val);
  end
  else
  begin
    raise Exception.Create('glGetMultisamplefv not bound');
  end;
end;

procedure TGL_VERSION_3_2.glSampleMaski(maskNumber: GLuint; mask: GLbitfield);
begin
  if Assigned(FglSampleMaski) then
  begin
    FglSampleMaski(maskNumber, mask);
  end
  else
  begin
    raise Exception.Create('glSampleMaski not bound');
  end;
end;

procedure TGL_VERSION_3_3.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglBindFragDataLocationIndexed), 'glBindFragDataLocationIndexed');
  Bind(Pointer(FglGetFragDataIndex), 'glGetFragDataIndex');
  Bind(Pointer(FglGenSamplers), 'glGenSamplers');
  Bind(Pointer(FglDeleteSamplers), 'glDeleteSamplers');
  Bind(Pointer(FglIsSampler), 'glIsSampler');
  Bind(Pointer(FglBindSampler), 'glBindSampler');
  Bind(Pointer(FglSamplerParameteri), 'glSamplerParameteri');
  Bind(Pointer(FglSamplerParameteriv), 'glSamplerParameteriv');
  Bind(Pointer(FglSamplerParameterf), 'glSamplerParameterf');
  Bind(Pointer(FglSamplerParameterfv), 'glSamplerParameterfv');
  Bind(Pointer(FglSamplerParameterIiv), 'glSamplerParameterIiv');
  Bind(Pointer(FglSamplerParameterIuiv), 'glSamplerParameterIuiv');
  Bind(Pointer(FglGetSamplerParameteriv), 'glGetSamplerParameteriv');
  Bind(Pointer(FglGetSamplerParameterIiv), 'glGetSamplerParameterIiv');
  Bind(Pointer(FglGetSamplerParameterfv), 'glGetSamplerParameterfv');
  Bind(Pointer(FglGetSamplerParameterIuiv), 'glGetSamplerParameterIuiv');
  Bind(Pointer(FglQueryCounter), 'glQueryCounter');
  Bind(Pointer(FglGetQueryObjecti64v), 'glGetQueryObjecti64v');
  Bind(Pointer(FglGetQueryObjectui64v), 'glGetQueryObjectui64v');
  Bind(Pointer(FglVertexAttribDivisor), 'glVertexAttribDivisor');
  Bind(Pointer(FglVertexAttribP1ui), 'glVertexAttribP1ui');
  Bind(Pointer(FglVertexAttribP1uiv), 'glVertexAttribP1uiv');
  Bind(Pointer(FglVertexAttribP2ui), 'glVertexAttribP2ui');
  Bind(Pointer(FglVertexAttribP2uiv), 'glVertexAttribP2uiv');
  Bind(Pointer(FglVertexAttribP3ui), 'glVertexAttribP3ui');
  Bind(Pointer(FglVertexAttribP3uiv), 'glVertexAttribP3uiv');
  Bind(Pointer(FglVertexAttribP4ui), 'glVertexAttribP4ui');
  Bind(Pointer(FglVertexAttribP4uiv), 'glVertexAttribP4uiv');
  Bind(Pointer(FglVertexP2ui), 'glVertexP2ui');
  Bind(Pointer(FglVertexP2uiv), 'glVertexP2uiv');
  Bind(Pointer(FglVertexP3ui), 'glVertexP3ui');
  Bind(Pointer(FglVertexP3uiv), 'glVertexP3uiv');
  Bind(Pointer(FglVertexP4ui), 'glVertexP4ui');
  Bind(Pointer(FglVertexP4uiv), 'glVertexP4uiv');
  Bind(Pointer(FglTexCoordP1ui), 'glTexCoordP1ui');
  Bind(Pointer(FglTexCoordP1uiv), 'glTexCoordP1uiv');
  Bind(Pointer(FglTexCoordP2ui), 'glTexCoordP2ui');
  Bind(Pointer(FglTexCoordP2uiv), 'glTexCoordP2uiv');
  Bind(Pointer(FglTexCoordP3ui), 'glTexCoordP3ui');
  Bind(Pointer(FglTexCoordP3uiv), 'glTexCoordP3uiv');
  Bind(Pointer(FglTexCoordP4ui), 'glTexCoordP4ui');
  Bind(Pointer(FglTexCoordP4uiv), 'glTexCoordP4uiv');
  Bind(Pointer(FglMultiTexCoordP1ui), 'glMultiTexCoordP1ui');
  Bind(Pointer(FglMultiTexCoordP1uiv), 'glMultiTexCoordP1uiv');
  Bind(Pointer(FglMultiTexCoordP2ui), 'glMultiTexCoordP2ui');
  Bind(Pointer(FglMultiTexCoordP2uiv), 'glMultiTexCoordP2uiv');
  Bind(Pointer(FglMultiTexCoordP3ui), 'glMultiTexCoordP3ui');
  Bind(Pointer(FglMultiTexCoordP3uiv), 'glMultiTexCoordP3uiv');
  Bind(Pointer(FglMultiTexCoordP4ui), 'glMultiTexCoordP4ui');
  Bind(Pointer(FglMultiTexCoordP4uiv), 'glMultiTexCoordP4uiv');
  Bind(Pointer(FglNormalP3ui), 'glNormalP3ui');
  Bind(Pointer(FglNormalP3uiv), 'glNormalP3uiv');
  Bind(Pointer(FglColorP3ui), 'glColorP3ui');
  Bind(Pointer(FglColorP3uiv), 'glColorP3uiv');
  Bind(Pointer(FglColorP4ui), 'glColorP4ui');
  Bind(Pointer(FglColorP4uiv), 'glColorP4uiv');
  Bind(Pointer(FglSecondaryColorP3ui), 'glSecondaryColorP3ui');
  Bind(Pointer(FglSecondaryColorP3uiv), 'glSecondaryColorP3uiv');
end;

procedure TGL_VERSION_3_3.glBindFragDataLocationIndexed(aProgram: GLuint; colorNumber: GLuint; index: GLuint; const Name: PGLchar);
begin
  if Assigned(FglBindFragDataLocationIndexed) then
  begin
    FglBindFragDataLocationIndexed(aProgram, colorNumber, index, Name);
  end
  else
  begin
    raise Exception.Create('glBindFragDataLocationIndexed not bound');
  end;
end;

function TGL_VERSION_3_3.glGetFragDataIndex(aProgram: GLuint; const Name: PGLchar): GLint;
begin
  if Assigned(FglGetFragDataIndex) then
  begin
    Result := FglGetFragDataIndex(aProgram, Name);
  end
  else
  begin
    raise Exception.Create('glGetFragDataIndex not bound');
  end;
end;

procedure TGL_VERSION_3_3.glGenSamplers(Count: GLsizei; samplers: PGLuint);
begin
  if Assigned(FglGenSamplers) then
  begin
    FglGenSamplers(Count, samplers);
  end
  else
  begin
    raise Exception.Create('glGenSamplers not bound');
  end;
end;

procedure TGL_VERSION_3_3.glDeleteSamplers(Count: GLsizei; const samplers: PGLuint);
begin
  if Assigned(FglDeleteSamplers) then
  begin
    FglDeleteSamplers(Count, samplers);
  end
  else
  begin
    raise Exception.Create('glDeleteSamplers not bound');
  end;
end;

function TGL_VERSION_3_3.glIsSampler(sampler: GLuint): GLboolean;
begin
  if Assigned(FglIsSampler) then
  begin
    Result := FglIsSampler(sampler);
  end
  else
  begin
    raise Exception.Create('glIsSampler not bound');
  end;
end;

procedure TGL_VERSION_3_3.glBindSampler(aUnit: GLuint; sampler: GLuint);
begin
  if Assigned(FglBindSampler) then
  begin
    FglBindSampler(aUnit, sampler);
  end
  else
  begin
    raise Exception.Create('glBindSampler not bound');
  end;
end;

procedure TGL_VERSION_3_3.glSamplerParameteri(sampler: GLuint; pname: GLenum; param: GLint);
begin
  if Assigned(FglSamplerParameteri) then
  begin
    FglSamplerParameteri(sampler, pname, param);
  end
  else
  begin
    raise Exception.Create('glSamplerParameteri not bound');
  end;
end;

procedure TGL_VERSION_3_3.glSamplerParameteriv(sampler: GLuint; pname: GLenum; const param: PGLint);
begin
  if Assigned(FglSamplerParameteriv) then
  begin
    FglSamplerParameteriv(sampler, pname, param);
  end
  else
  begin
    raise Exception.Create('glSamplerParameteriv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glSamplerParameterf(sampler: GLuint; pname: GLenum; param: GLfloat);
begin
  if Assigned(FglSamplerParameterf) then
  begin
    FglSamplerParameterf(sampler, pname, param);
  end
  else
  begin
    raise Exception.Create('glSamplerParameterf not bound');
  end;
end;

procedure TGL_VERSION_3_3.glSamplerParameterfv(sampler: GLuint; pname: GLenum; const param: PGLfloat);
begin
  if Assigned(FglSamplerParameterfv) then
  begin
    FglSamplerParameterfv(sampler, pname, param);
  end
  else
  begin
    raise Exception.Create('glSamplerParameterfv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glSamplerParameterIiv(sampler: GLuint; pname: GLenum; const param: PGLint);
begin
  if Assigned(FglSamplerParameterIiv) then
  begin
    FglSamplerParameterIiv(sampler, pname, param);
  end
  else
  begin
    raise Exception.Create('glSamplerParameterIiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glSamplerParameterIuiv(sampler: GLuint; pname: GLenum; const param: PGLuint);
begin
  if Assigned(FglSamplerParameterIuiv) then
  begin
    FglSamplerParameterIuiv(sampler, pname, param);
  end
  else
  begin
    raise Exception.Create('glSamplerParameterIuiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glGetSamplerParameteriv(sampler: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetSamplerParameteriv) then
  begin
    FglGetSamplerParameteriv(sampler, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetSamplerParameteriv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glGetSamplerParameterIiv(sampler: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetSamplerParameterIiv) then
  begin
    FglGetSamplerParameterIiv(sampler, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetSamplerParameterIiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glGetSamplerParameterfv(sampler: GLuint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetSamplerParameterfv) then
  begin
    FglGetSamplerParameterfv(sampler, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetSamplerParameterfv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glGetSamplerParameterIuiv(sampler: GLuint; pname: GLenum; params: PGLuint);
begin
  if Assigned(FglGetSamplerParameterIuiv) then
  begin
    FglGetSamplerParameterIuiv(sampler, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetSamplerParameterIuiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glQueryCounter(id: GLuint; target: GLenum);
begin
  if Assigned(FglQueryCounter) then
  begin
    FglQueryCounter(id, target);
  end
  else
  begin
    raise Exception.Create('glQueryCounter not bound');
  end;
end;

procedure TGL_VERSION_3_3.glGetQueryObjecti64v(id: GLuint; pname: GLenum; params: PGLint64);
begin
  if Assigned(FglGetQueryObjecti64v) then
  begin
    FglGetQueryObjecti64v(id, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetQueryObjecti64v not bound');
  end;
end;

procedure TGL_VERSION_3_3.glGetQueryObjectui64v(id: GLuint; pname: GLenum; params: PGLuint64);
begin
  if Assigned(FglGetQueryObjectui64v) then
  begin
    FglGetQueryObjectui64v(id, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetQueryObjectui64v not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexAttribDivisor(index: GLuint; divisor: GLuint);
begin
  if Assigned(FglVertexAttribDivisor) then
  begin
    FglVertexAttribDivisor(index, divisor);
  end
  else
  begin
    raise Exception.Create('glVertexAttribDivisor not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexAttribP1ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
begin
  if Assigned(FglVertexAttribP1ui) then
  begin
    FglVertexAttribP1ui(index, aType, normalized, Value);
  end
  else
  begin
    raise Exception.Create('glVertexAttribP1ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexAttribP1uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
begin
  if Assigned(FglVertexAttribP1uiv) then
  begin
    FglVertexAttribP1uiv(index, aType, normalized, Value);
  end
  else
  begin
    raise Exception.Create('glVertexAttribP1uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexAttribP2ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
begin
  if Assigned(FglVertexAttribP2ui) then
  begin
    FglVertexAttribP2ui(index, aType, normalized, Value);
  end
  else
  begin
    raise Exception.Create('glVertexAttribP2ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexAttribP2uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
begin
  if Assigned(FglVertexAttribP2uiv) then
  begin
    FglVertexAttribP2uiv(index, aType, normalized, Value);
  end
  else
  begin
    raise Exception.Create('glVertexAttribP2uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexAttribP3ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
begin
  if Assigned(FglVertexAttribP3ui) then
  begin
    FglVertexAttribP3ui(index, aType, normalized, Value);
  end
  else
  begin
    raise Exception.Create('glVertexAttribP3ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexAttribP3uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
begin
  if Assigned(FglVertexAttribP3uiv) then
  begin
    FglVertexAttribP3uiv(index, aType, normalized, Value);
  end
  else
  begin
    raise Exception.Create('glVertexAttribP3uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexAttribP4ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
begin
  if Assigned(FglVertexAttribP4ui) then
  begin
    FglVertexAttribP4ui(index, aType, normalized, Value);
  end
  else
  begin
    raise Exception.Create('glVertexAttribP4ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexAttribP4uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
begin
  if Assigned(FglVertexAttribP4uiv) then
  begin
    FglVertexAttribP4uiv(index, aType, normalized, Value);
  end
  else
  begin
    raise Exception.Create('glVertexAttribP4uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexP2ui(aType: GLenum; Value: GLuint);
begin
  if Assigned(FglVertexP2ui) then
  begin
    FglVertexP2ui(aType, Value);
  end
  else
  begin
    raise Exception.Create('glVertexP2ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexP2uiv(aType: GLenum; const Value: PGLuint);
begin
  if Assigned(FglVertexP2uiv) then
  begin
    FglVertexP2uiv(aType, Value);
  end
  else
  begin
    raise Exception.Create('glVertexP2uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexP3ui(aType: GLenum; Value: GLuint);
begin
  if Assigned(FglVertexP3ui) then
  begin
    FglVertexP3ui(aType, Value);
  end
  else
  begin
    raise Exception.Create('glVertexP3ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexP3uiv(aType: GLenum; const Value: PGLuint);
begin
  if Assigned(FglVertexP3uiv) then
  begin
    FglVertexP3uiv(aType, Value);
  end
  else
  begin
    raise Exception.Create('glVertexP3uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexP4ui(aType: GLenum; Value: GLuint);
begin
  if Assigned(FglVertexP4ui) then
  begin
    FglVertexP4ui(aType, Value);
  end
  else
  begin
    raise Exception.Create('glVertexP4ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glVertexP4uiv(aType: GLenum; const Value: PGLuint);
begin
  if Assigned(FglVertexP4uiv) then
  begin
    FglVertexP4uiv(aType, Value);
  end
  else
  begin
    raise Exception.Create('glVertexP4uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glTexCoordP1ui(aType: GLenum; coords: GLuint);
begin
  if Assigned(FglTexCoordP1ui) then
  begin
    FglTexCoordP1ui(aType, coords);
  end
  else
  begin
    raise Exception.Create('glTexCoordP1ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glTexCoordP1uiv(aType: GLenum; const coords: PGLuint);
begin
  if Assigned(FglTexCoordP1uiv) then
  begin
    FglTexCoordP1uiv(aType, coords);
  end
  else
  begin
    raise Exception.Create('glTexCoordP1uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glTexCoordP2ui(aType: GLenum; coords: GLuint);
begin
  if Assigned(FglTexCoordP2ui) then
  begin
    FglTexCoordP2ui(aType, coords);
  end
  else
  begin
    raise Exception.Create('glTexCoordP2ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glTexCoordP2uiv(aType: GLenum; const coords: PGLuint);
begin
  if Assigned(FglTexCoordP2uiv) then
  begin
    FglTexCoordP2uiv(aType, coords);
  end
  else
  begin
    raise Exception.Create('glTexCoordP2uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glTexCoordP3ui(aType: GLenum; coords: GLuint);
begin
  if Assigned(FglTexCoordP3ui) then
  begin
    FglTexCoordP3ui(aType, coords);
  end
  else
  begin
    raise Exception.Create('glTexCoordP3ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glTexCoordP3uiv(aType: GLenum; const coords: PGLuint);
begin
  if Assigned(FglTexCoordP3uiv) then
  begin
    FglTexCoordP3uiv(aType, coords);
  end
  else
  begin
    raise Exception.Create('glTexCoordP3uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glTexCoordP4ui(aType: GLenum; coords: GLuint);
begin
  if Assigned(FglTexCoordP4ui) then
  begin
    FglTexCoordP4ui(aType, coords);
  end
  else
  begin
    raise Exception.Create('glTexCoordP4ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glTexCoordP4uiv(aType: GLenum; const coords: PGLuint);
begin
  if Assigned(FglTexCoordP4uiv) then
  begin
    FglTexCoordP4uiv(aType, coords);
  end
  else
  begin
    raise Exception.Create('glTexCoordP4uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glMultiTexCoordP1ui(texture: GLenum; aType: GLenum; coords: GLuint);
begin
  if Assigned(FglMultiTexCoordP1ui) then
  begin
    FglMultiTexCoordP1ui(texture, aType, coords);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoordP1ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glMultiTexCoordP1uiv(texture: GLenum; aType: GLenum; const coords: PGLuint);
begin
  if Assigned(FglMultiTexCoordP1uiv) then
  begin
    FglMultiTexCoordP1uiv(texture, aType, coords);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoordP1uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glMultiTexCoordP2ui(texture: GLenum; aType: GLenum; coords: GLuint);
begin
  if Assigned(FglMultiTexCoordP2ui) then
  begin
    FglMultiTexCoordP2ui(texture, aType, coords);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoordP2ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glMultiTexCoordP2uiv(texture: GLenum; aType: GLenum; const coords: PGLuint);
begin
  if Assigned(FglMultiTexCoordP2uiv) then
  begin
    FglMultiTexCoordP2uiv(texture, aType, coords);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoordP2uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glMultiTexCoordP3ui(texture: GLenum; aType: GLenum; coords: GLuint);
begin
  if Assigned(FglMultiTexCoordP3ui) then
  begin
    FglMultiTexCoordP3ui(texture, aType, coords);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoordP3ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glMultiTexCoordP3uiv(texture: GLenum; aType: GLenum; const coords: PGLuint);
begin
  if Assigned(FglMultiTexCoordP3uiv) then
  begin
    FglMultiTexCoordP3uiv(texture, aType, coords);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoordP3uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glMultiTexCoordP4ui(texture: GLenum; aType: GLenum; coords: GLuint);
begin
  if Assigned(FglMultiTexCoordP4ui) then
  begin
    FglMultiTexCoordP4ui(texture, aType, coords);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoordP4ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glMultiTexCoordP4uiv(texture: GLenum; aType: GLenum; const coords: PGLuint);
begin
  if Assigned(FglMultiTexCoordP4uiv) then
  begin
    FglMultiTexCoordP4uiv(texture, aType, coords);
  end
  else
  begin
    raise Exception.Create('glMultiTexCoordP4uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glNormalP3ui(aType: GLenum; coords: GLuint);
begin
  if Assigned(FglNormalP3ui) then
  begin
    FglNormalP3ui(aType, coords);
  end
  else
  begin
    raise Exception.Create('glNormalP3ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glNormalP3uiv(aType: GLenum; const coords: PGLuint);
begin
  if Assigned(FglNormalP3uiv) then
  begin
    FglNormalP3uiv(aType, coords);
  end
  else
  begin
    raise Exception.Create('glNormalP3uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glColorP3ui(aType: GLenum; color: GLuint);
begin
  if Assigned(FglColorP3ui) then
  begin
    FglColorP3ui(aType, color);
  end
  else
  begin
    raise Exception.Create('glColorP3ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glColorP3uiv(aType: GLenum; const color: PGLuint);
begin
  if Assigned(FglColorP3uiv) then
  begin
    FglColorP3uiv(aType, color);
  end
  else
  begin
    raise Exception.Create('glColorP3uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glColorP4ui(aType: GLenum; color: GLuint);
begin
  if Assigned(FglColorP4ui) then
  begin
    FglColorP4ui(aType, color);
  end
  else
  begin
    raise Exception.Create('glColorP4ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glColorP4uiv(aType: GLenum; const color: PGLuint);
begin
  if Assigned(FglColorP4uiv) then
  begin
    FglColorP4uiv(aType, color);
  end
  else
  begin
    raise Exception.Create('glColorP4uiv not bound');
  end;
end;

procedure TGL_VERSION_3_3.glSecondaryColorP3ui(aType: GLenum; color: GLuint);
begin
  if Assigned(FglSecondaryColorP3ui) then
  begin
    FglSecondaryColorP3ui(aType, color);
  end
  else
  begin
    raise Exception.Create('glSecondaryColorP3ui not bound');
  end;
end;

procedure TGL_VERSION_3_3.glSecondaryColorP3uiv(aType: GLenum; const color: PGLuint);
begin
  if Assigned(FglSecondaryColorP3uiv) then
  begin
    FglSecondaryColorP3uiv(aType, color);
  end
  else
  begin
    raise Exception.Create('glSecondaryColorP3uiv not bound');
  end;
end;

procedure TGL_VERSION_4_0.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglMinSampleShading), 'glMinSampleShading');
  Bind(Pointer(FglBlendEquationi), 'glBlendEquationi');
  Bind(Pointer(FglBlendEquationSeparatei), 'glBlendEquationSeparatei');
  Bind(Pointer(FglBlendFunci), 'glBlendFunci');
  Bind(Pointer(FglBlendFuncSeparatei), 'glBlendFuncSeparatei');
  Bind(Pointer(FglDrawArraysIndirect), 'glDrawArraysIndirect');
  Bind(Pointer(FglDrawElementsIndirect), 'glDrawElementsIndirect');
  Bind(Pointer(FglUniform1d), 'glUniform1d');
  Bind(Pointer(FglUniform2d), 'glUniform2d');
  Bind(Pointer(FglUniform3d), 'glUniform3d');
  Bind(Pointer(FglUniform4d), 'glUniform4d');
  Bind(Pointer(FglUniform1dv), 'glUniform1dv');
  Bind(Pointer(FglUniform2dv), 'glUniform2dv');
  Bind(Pointer(FglUniform3dv), 'glUniform3dv');
  Bind(Pointer(FglUniform4dv), 'glUniform4dv');
  Bind(Pointer(FglUniformMatrix2dv), 'glUniformMatrix2dv');
  Bind(Pointer(FglUniformMatrix3dv), 'glUniformMatrix3dv');
  Bind(Pointer(FglUniformMatrix4dv), 'glUniformMatrix4dv');
  Bind(Pointer(FglUniformMatrix2x3dv), 'glUniformMatrix2x3dv');
  Bind(Pointer(FglUniformMatrix2x4dv), 'glUniformMatrix2x4dv');
  Bind(Pointer(FglUniformMatrix3x2dv), 'glUniformMatrix3x2dv');
  Bind(Pointer(FglUniformMatrix3x4dv), 'glUniformMatrix3x4dv');
  Bind(Pointer(FglUniformMatrix4x2dv), 'glUniformMatrix4x2dv');
  Bind(Pointer(FglUniformMatrix4x3dv), 'glUniformMatrix4x3dv');
  Bind(Pointer(FglGetUniformdv), 'glGetUniformdv');
  Bind(Pointer(FglGetSubroutineUniformLocation), 'glGetSubroutineUniformLocation');
  Bind(Pointer(FglGetSubroutineIndex), 'glGetSubroutineIndex');
  Bind(Pointer(FglGetActiveSubroutineUniformiv), 'glGetActiveSubroutineUniformiv');
  Bind(Pointer(FglGetActiveSubroutineUniformName), 'glGetActiveSubroutineUniformName');
  Bind(Pointer(FglGetActiveSubroutineName), 'glGetActiveSubroutineName');
  Bind(Pointer(FglUniformSubroutinesuiv), 'glUniformSubroutinesuiv');
  Bind(Pointer(FglGetUniformSubroutineuiv), 'glGetUniformSubroutineuiv');
  Bind(Pointer(FglGetProgramStageiv), 'glGetProgramStageiv');
  Bind(Pointer(FglPatchParameteri), 'glPatchParameteri');
  Bind(Pointer(FglPatchParameterfv), 'glPatchParameterfv');
  Bind(Pointer(FglBindTransformFeedback), 'glBindTransformFeedback');
  Bind(Pointer(FglDeleteTransformFeedbacks), 'glDeleteTransformFeedbacks');
  Bind(Pointer(FglGenTransformFeedbacks), 'glGenTransformFeedbacks');
  Bind(Pointer(FglIsTransformFeedback), 'glIsTransformFeedback');
  Bind(Pointer(FglPauseTransformFeedback), 'glPauseTransformFeedback');
  Bind(Pointer(FglResumeTransformFeedback), 'glResumeTransformFeedback');
  Bind(Pointer(FglDrawTransformFeedback), 'glDrawTransformFeedback');
  Bind(Pointer(FglDrawTransformFeedbackStream), 'glDrawTransformFeedbackStream');
  Bind(Pointer(FglBeginQueryIndexed), 'glBeginQueryIndexed');
  Bind(Pointer(FglEndQueryIndexed), 'glEndQueryIndexed');
  Bind(Pointer(FglGetQueryIndexediv), 'glGetQueryIndexediv');
end;

procedure TGL_VERSION_4_0.glMinSampleShading(Value: GLfloat);
begin
  if Assigned(FglMinSampleShading) then
  begin
    FglMinSampleShading(Value);
  end
  else
  begin
    raise Exception.Create('glMinSampleShading not bound');
  end;
end;

procedure TGL_VERSION_4_0.glBlendEquationi(buf: GLuint; mode: GLenum);
begin
  if Assigned(FglBlendEquationi) then
  begin
    FglBlendEquationi(buf, mode);
  end
  else
  begin
    raise Exception.Create('glBlendEquationi not bound');
  end;
end;

procedure TGL_VERSION_4_0.glBlendEquationSeparatei(buf: GLuint; modeRGB: GLenum; modeAlpha: GLenum);
begin
  if Assigned(FglBlendEquationSeparatei) then
  begin
    FglBlendEquationSeparatei(buf, modeRGB, modeAlpha);
  end
  else
  begin
    raise Exception.Create('glBlendEquationSeparatei not bound');
  end;
end;

procedure TGL_VERSION_4_0.glBlendFunci(buf: GLuint; src: GLenum; dst: GLenum);
begin
  if Assigned(FglBlendFunci) then
  begin
    FglBlendFunci(buf, src, dst);
  end
  else
  begin
    raise Exception.Create('glBlendFunci not bound');
  end;
end;

procedure TGL_VERSION_4_0.glBlendFuncSeparatei(buf: GLuint; srcRGB: GLenum; dstRGB: GLenum; srcAlpha: GLenum; dstAlpha: GLenum);
begin
  if Assigned(FglBlendFuncSeparatei) then
  begin
    FglBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  end
  else
  begin
    raise Exception.Create('glBlendFuncSeparatei not bound');
  end;
end;

procedure TGL_VERSION_4_0.glDrawArraysIndirect(mode: GLenum; const indirect: Pointer);
begin
  if Assigned(FglDrawArraysIndirect) then
  begin
    FglDrawArraysIndirect(mode, indirect);
  end
  else
  begin
    raise Exception.Create('glDrawArraysIndirect not bound');
  end;
end;

procedure TGL_VERSION_4_0.glDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer);
begin
  if Assigned(FglDrawElementsIndirect) then
  begin
    FglDrawElementsIndirect(mode, aType, indirect);
  end
  else
  begin
    raise Exception.Create('glDrawElementsIndirect not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniform1d(location: GLint; x: GLdouble);
begin
  if Assigned(FglUniform1d) then
  begin
    FglUniform1d(location, x);
  end
  else
  begin
    raise Exception.Create('glUniform1d not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniform2d(location: GLint; x: GLdouble; y: GLdouble);
begin
  if Assigned(FglUniform2d) then
  begin
    FglUniform2d(location, x, y);
  end
  else
  begin
    raise Exception.Create('glUniform2d not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniform3d(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble);
begin
  if Assigned(FglUniform3d) then
  begin
    FglUniform3d(location, x, y, z);
  end
  else
  begin
    raise Exception.Create('glUniform3d not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniform4d(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
begin
  if Assigned(FglUniform4d) then
  begin
    FglUniform4d(location, x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glUniform4d not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniform1dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FglUniform1dv) then
  begin
    FglUniform1dv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform1dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniform2dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FglUniform2dv) then
  begin
    FglUniform2dv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform2dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniform3dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FglUniform3dv) then
  begin
    FglUniform3dv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform3dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniform4dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FglUniform4dv) then
  begin
    FglUniform4dv(location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glUniform4dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformMatrix2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglUniformMatrix2dv) then
  begin
    FglUniformMatrix2dv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix2dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformMatrix3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglUniformMatrix3dv) then
  begin
    FglUniformMatrix3dv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix3dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformMatrix4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglUniformMatrix4dv) then
  begin
    FglUniformMatrix4dv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix4dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformMatrix2x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglUniformMatrix2x3dv) then
  begin
    FglUniformMatrix2x3dv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix2x3dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformMatrix2x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglUniformMatrix2x4dv) then
  begin
    FglUniformMatrix2x4dv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix2x4dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformMatrix3x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglUniformMatrix3x2dv) then
  begin
    FglUniformMatrix3x2dv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix3x2dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformMatrix3x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglUniformMatrix3x4dv) then
  begin
    FglUniformMatrix3x4dv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix3x4dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformMatrix4x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglUniformMatrix4x2dv) then
  begin
    FglUniformMatrix4x2dv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix4x2dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformMatrix4x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglUniformMatrix4x3dv) then
  begin
    FglUniformMatrix4x3dv(location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glUniformMatrix4x3dv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glGetUniformdv(aProgram: GLuint; location: GLint; params: PGLdouble);
begin
  if Assigned(FglGetUniformdv) then
  begin
    FglGetUniformdv(aProgram, location, params);
  end
  else
  begin
    raise Exception.Create('glGetUniformdv not bound');
  end;
end;

function TGL_VERSION_4_0.glGetSubroutineUniformLocation(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLint;
begin
  if Assigned(FglGetSubroutineUniformLocation) then
  begin
    Result := FglGetSubroutineUniformLocation(aProgram, shadertype, Name);
  end
  else
  begin
    raise Exception.Create('glGetSubroutineUniformLocation not bound');
  end;
end;

function TGL_VERSION_4_0.glGetSubroutineIndex(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLuint;
begin
  if Assigned(FglGetSubroutineIndex) then
  begin
    Result := FglGetSubroutineIndex(aProgram, shadertype, Name);
  end
  else
  begin
    raise Exception.Create('glGetSubroutineIndex not bound');
  end;
end;

procedure TGL_VERSION_4_0.glGetActiveSubroutineUniformiv(aProgram: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint);
begin
  if Assigned(FglGetActiveSubroutineUniformiv) then
  begin
    FglGetActiveSubroutineUniformiv(aProgram, shadertype, index, pname, values);
  end
  else
  begin
    raise Exception.Create('glGetActiveSubroutineUniformiv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glGetActiveSubroutineUniformName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar);
begin
  if Assigned(FglGetActiveSubroutineUniformName) then
  begin
    FglGetActiveSubroutineUniformName(aProgram, shadertype, index, bufSize, length, Name);
  end
  else
  begin
    raise Exception.Create('glGetActiveSubroutineUniformName not bound');
  end;
end;

procedure TGL_VERSION_4_0.glGetActiveSubroutineName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar);
begin
  if Assigned(FglGetActiveSubroutineName) then
  begin
    FglGetActiveSubroutineName(aProgram, shadertype, index, bufSize, length, Name);
  end
  else
  begin
    raise Exception.Create('glGetActiveSubroutineName not bound');
  end;
end;

procedure TGL_VERSION_4_0.glUniformSubroutinesuiv(shadertype: GLenum; Count: GLsizei; const indices: PGLuint);
begin
  if Assigned(FglUniformSubroutinesuiv) then
  begin
    FglUniformSubroutinesuiv(shadertype, Count, indices);
  end
  else
  begin
    raise Exception.Create('glUniformSubroutinesuiv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glGetUniformSubroutineuiv(shadertype: GLenum; location: GLint; params: PGLuint);
begin
  if Assigned(FglGetUniformSubroutineuiv) then
  begin
    FglGetUniformSubroutineuiv(shadertype, location, params);
  end
  else
  begin
    raise Exception.Create('glGetUniformSubroutineuiv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glGetProgramStageiv(aProgram: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint);
begin
  if Assigned(FglGetProgramStageiv) then
  begin
    FglGetProgramStageiv(aProgram, shadertype, pname, values);
  end
  else
  begin
    raise Exception.Create('glGetProgramStageiv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glPatchParameteri(pname: GLenum; Value: GLint);
begin
  if Assigned(FglPatchParameteri) then
  begin
    FglPatchParameteri(pname, Value);
  end
  else
  begin
    raise Exception.Create('glPatchParameteri not bound');
  end;
end;

procedure TGL_VERSION_4_0.glPatchParameterfv(pname: GLenum; const values: PGLfloat);
begin
  if Assigned(FglPatchParameterfv) then
  begin
    FglPatchParameterfv(pname, values);
  end
  else
  begin
    raise Exception.Create('glPatchParameterfv not bound');
  end;
end;

procedure TGL_VERSION_4_0.glBindTransformFeedback(target: GLenum; id: GLuint);
begin
  if Assigned(FglBindTransformFeedback) then
  begin
    FglBindTransformFeedback(target, id);
  end
  else
  begin
    raise Exception.Create('glBindTransformFeedback not bound');
  end;
end;

procedure TGL_VERSION_4_0.glDeleteTransformFeedbacks(n: GLsizei; const ids: PGLuint);
begin
  if Assigned(FglDeleteTransformFeedbacks) then
  begin
    FglDeleteTransformFeedbacks(n, ids);
  end
  else
  begin
    raise Exception.Create('glDeleteTransformFeedbacks not bound');
  end;
end;

procedure TGL_VERSION_4_0.glGenTransformFeedbacks(n: GLsizei; ids: PGLuint);
begin
  if Assigned(FglGenTransformFeedbacks) then
  begin
    FglGenTransformFeedbacks(n, ids);
  end
  else
  begin
    raise Exception.Create('glGenTransformFeedbacks not bound');
  end;
end;

function TGL_VERSION_4_0.glIsTransformFeedback(id: GLuint): GLboolean;
begin
  if Assigned(FglIsTransformFeedback) then
  begin
    Result := FglIsTransformFeedback(id);
  end
  else
  begin
    raise Exception.Create('glIsTransformFeedback not bound');
  end;
end;

procedure TGL_VERSION_4_0.glPauseTransformFeedback();
begin
  if Assigned(FglPauseTransformFeedback) then
  begin
    FglPauseTransformFeedback();
  end
  else
  begin
    raise Exception.Create('glPauseTransformFeedback not bound');
  end;
end;

procedure TGL_VERSION_4_0.glResumeTransformFeedback();
begin
  if Assigned(FglResumeTransformFeedback) then
  begin
    FglResumeTransformFeedback();
  end
  else
  begin
    raise Exception.Create('glResumeTransformFeedback not bound');
  end;
end;

procedure TGL_VERSION_4_0.glDrawTransformFeedback(mode: GLenum; id: GLuint);
begin
  if Assigned(FglDrawTransformFeedback) then
  begin
    FglDrawTransformFeedback(mode, id);
  end
  else
  begin
    raise Exception.Create('glDrawTransformFeedback not bound');
  end;
end;

procedure TGL_VERSION_4_0.glDrawTransformFeedbackStream(mode: GLenum; id: GLuint; stream: GLuint);
begin
  if Assigned(FglDrawTransformFeedbackStream) then
  begin
    FglDrawTransformFeedbackStream(mode, id, stream);
  end
  else
  begin
    raise Exception.Create('glDrawTransformFeedbackStream not bound');
  end;
end;

procedure TGL_VERSION_4_0.glBeginQueryIndexed(target: GLenum; index: GLuint; id: GLuint);
begin
  if Assigned(FglBeginQueryIndexed) then
  begin
    FglBeginQueryIndexed(target, index, id);
  end
  else
  begin
    raise Exception.Create('glBeginQueryIndexed not bound');
  end;
end;

procedure TGL_VERSION_4_0.glEndQueryIndexed(target: GLenum; index: GLuint);
begin
  if Assigned(FglEndQueryIndexed) then
  begin
    FglEndQueryIndexed(target, index);
  end
  else
  begin
    raise Exception.Create('glEndQueryIndexed not bound');
  end;
end;

procedure TGL_VERSION_4_0.glGetQueryIndexediv(target: GLenum; index: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetQueryIndexediv) then
  begin
    FglGetQueryIndexediv(target, index, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetQueryIndexediv not bound');
  end;
end;

procedure TGL_VERSION_4_1.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglReleaseShaderCompiler), 'glReleaseShaderCompiler');
  Bind(Pointer(FglShaderBinary), 'glShaderBinary');
  Bind(Pointer(FglGetShaderPrecisionFormat), 'glGetShaderPrecisionFormat');
  Bind(Pointer(FglDepthRangef), 'glDepthRangef');
  Bind(Pointer(FglClearDepthf), 'glClearDepthf');
  Bind(Pointer(FglGetProgramBinary), 'glGetProgramBinary');
  Bind(Pointer(FglProgramBinary), 'glProgramBinary');
  Bind(Pointer(FglProgramParameteri), 'glProgramParameteri');
  Bind(Pointer(FglUseProgramStages), 'glUseProgramStages');
  Bind(Pointer(FglActiveShaderProgram), 'glActiveShaderProgram');
  Bind(Pointer(FglCreateShaderProgramv), 'glCreateShaderProgramv');
  Bind(Pointer(FglBindProgramPipeline), 'glBindProgramPipeline');
  Bind(Pointer(FglDeleteProgramPipelines), 'glDeleteProgramPipelines');
  Bind(Pointer(FglGenProgramPipelines), 'glGenProgramPipelines');
  Bind(Pointer(FglIsProgramPipeline), 'glIsProgramPipeline');
  Bind(Pointer(FglGetProgramPipelineiv), 'glGetProgramPipelineiv');
  Bind(Pointer(FglProgramUniform1i), 'glProgramUniform1i');
  Bind(Pointer(FglProgramUniform1iv), 'glProgramUniform1iv');
  Bind(Pointer(FglProgramUniform1f), 'glProgramUniform1f');
  Bind(Pointer(FglProgramUniform1fv), 'glProgramUniform1fv');
  Bind(Pointer(FglProgramUniform1d), 'glProgramUniform1d');
  Bind(Pointer(FglProgramUniform1dv), 'glProgramUniform1dv');
  Bind(Pointer(FglProgramUniform1ui), 'glProgramUniform1ui');
  Bind(Pointer(FglProgramUniform1uiv), 'glProgramUniform1uiv');
  Bind(Pointer(FglProgramUniform2i), 'glProgramUniform2i');
  Bind(Pointer(FglProgramUniform2iv), 'glProgramUniform2iv');
  Bind(Pointer(FglProgramUniform2f), 'glProgramUniform2f');
  Bind(Pointer(FglProgramUniform2fv), 'glProgramUniform2fv');
  Bind(Pointer(FglProgramUniform2d), 'glProgramUniform2d');
  Bind(Pointer(FglProgramUniform2dv), 'glProgramUniform2dv');
  Bind(Pointer(FglProgramUniform2ui), 'glProgramUniform2ui');
  Bind(Pointer(FglProgramUniform2uiv), 'glProgramUniform2uiv');
  Bind(Pointer(FglProgramUniform3i), 'glProgramUniform3i');
  Bind(Pointer(FglProgramUniform3iv), 'glProgramUniform3iv');
  Bind(Pointer(FglProgramUniform3f), 'glProgramUniform3f');
  Bind(Pointer(FglProgramUniform3fv), 'glProgramUniform3fv');
  Bind(Pointer(FglProgramUniform3d), 'glProgramUniform3d');
  Bind(Pointer(FglProgramUniform3dv), 'glProgramUniform3dv');
  Bind(Pointer(FglProgramUniform3ui), 'glProgramUniform3ui');
  Bind(Pointer(FglProgramUniform3uiv), 'glProgramUniform3uiv');
  Bind(Pointer(FglProgramUniform4i), 'glProgramUniform4i');
  Bind(Pointer(FglProgramUniform4iv), 'glProgramUniform4iv');
  Bind(Pointer(FglProgramUniform4f), 'glProgramUniform4f');
  Bind(Pointer(FglProgramUniform4fv), 'glProgramUniform4fv');
  Bind(Pointer(FglProgramUniform4d), 'glProgramUniform4d');
  Bind(Pointer(FglProgramUniform4dv), 'glProgramUniform4dv');
  Bind(Pointer(FglProgramUniform4ui), 'glProgramUniform4ui');
  Bind(Pointer(FglProgramUniform4uiv), 'glProgramUniform4uiv');
  Bind(Pointer(FglProgramUniformMatrix2fv), 'glProgramUniformMatrix2fv');
  Bind(Pointer(FglProgramUniformMatrix3fv), 'glProgramUniformMatrix3fv');
  Bind(Pointer(FglProgramUniformMatrix4fv), 'glProgramUniformMatrix4fv');
  Bind(Pointer(FglProgramUniformMatrix2dv), 'glProgramUniformMatrix2dv');
  Bind(Pointer(FglProgramUniformMatrix3dv), 'glProgramUniformMatrix3dv');
  Bind(Pointer(FglProgramUniformMatrix4dv), 'glProgramUniformMatrix4dv');
  Bind(Pointer(FglProgramUniformMatrix2x3fv), 'glProgramUniformMatrix2x3fv');
  Bind(Pointer(FglProgramUniformMatrix3x2fv), 'glProgramUniformMatrix3x2fv');
  Bind(Pointer(FglProgramUniformMatrix2x4fv), 'glProgramUniformMatrix2x4fv');
  Bind(Pointer(FglProgramUniformMatrix4x2fv), 'glProgramUniformMatrix4x2fv');
  Bind(Pointer(FglProgramUniformMatrix3x4fv), 'glProgramUniformMatrix3x4fv');
  Bind(Pointer(FglProgramUniformMatrix4x3fv), 'glProgramUniformMatrix4x3fv');
  Bind(Pointer(FglProgramUniformMatrix2x3dv), 'glProgramUniformMatrix2x3dv');
  Bind(Pointer(FglProgramUniformMatrix3x2dv), 'glProgramUniformMatrix3x2dv');
  Bind(Pointer(FglProgramUniformMatrix2x4dv), 'glProgramUniformMatrix2x4dv');
  Bind(Pointer(FglProgramUniformMatrix4x2dv), 'glProgramUniformMatrix4x2dv');
  Bind(Pointer(FglProgramUniformMatrix3x4dv), 'glProgramUniformMatrix3x4dv');
  Bind(Pointer(FglProgramUniformMatrix4x3dv), 'glProgramUniformMatrix4x3dv');
  Bind(Pointer(FglValidateProgramPipeline), 'glValidateProgramPipeline');
  Bind(Pointer(FglGetProgramPipelineInfoLog), 'glGetProgramPipelineInfoLog');
  Bind(Pointer(FglVertexAttribL1d), 'glVertexAttribL1d');
  Bind(Pointer(FglVertexAttribL2d), 'glVertexAttribL2d');
  Bind(Pointer(FglVertexAttribL3d), 'glVertexAttribL3d');
  Bind(Pointer(FglVertexAttribL4d), 'glVertexAttribL4d');
  Bind(Pointer(FglVertexAttribL1dv), 'glVertexAttribL1dv');
  Bind(Pointer(FglVertexAttribL2dv), 'glVertexAttribL2dv');
  Bind(Pointer(FglVertexAttribL3dv), 'glVertexAttribL3dv');
  Bind(Pointer(FglVertexAttribL4dv), 'glVertexAttribL4dv');
  Bind(Pointer(FglVertexAttribLPointer), 'glVertexAttribLPointer');
  Bind(Pointer(FglGetVertexAttribLdv), 'glGetVertexAttribLdv');
  Bind(Pointer(FglViewportArrayv), 'glViewportArrayv');
  Bind(Pointer(FglViewportIndexedf), 'glViewportIndexedf');
  Bind(Pointer(FglViewportIndexedfv), 'glViewportIndexedfv');
  Bind(Pointer(FglScissorArrayv), 'glScissorArrayv');
  Bind(Pointer(FglScissorIndexed), 'glScissorIndexed');
  Bind(Pointer(FglScissorIndexedv), 'glScissorIndexedv');
  Bind(Pointer(FglDepthRangeArrayv), 'glDepthRangeArrayv');
  Bind(Pointer(FglDepthRangeIndexed), 'glDepthRangeIndexed');
  Bind(Pointer(FglGetFloati_v), 'glGetFloati_v');
  Bind(Pointer(FglGetDoublei_v), 'glGetDoublei_v');
end;

procedure TGL_VERSION_4_1.glReleaseShaderCompiler();
begin
  if Assigned(FglReleaseShaderCompiler) then
  begin
    FglReleaseShaderCompiler();
  end
  else
  begin
    raise Exception.Create('glReleaseShaderCompiler not bound');
  end;
end;

procedure TGL_VERSION_4_1.glShaderBinary(Count: GLsizei; const shaders: PGLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei);
begin
  if Assigned(FglShaderBinary) then
  begin
    FglShaderBinary(Count, shaders, binaryFormat, binary, length);
  end
  else
  begin
    raise Exception.Create('glShaderBinary not bound');
  end;
end;

procedure TGL_VERSION_4_1.glGetShaderPrecisionFormat(shadertype: GLenum; precisiontype: GLenum; range: PGLint; precision: PGLint);
begin
  if Assigned(FglGetShaderPrecisionFormat) then
  begin
    FglGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
  end
  else
  begin
    raise Exception.Create('glGetShaderPrecisionFormat not bound');
  end;
end;

procedure TGL_VERSION_4_1.glDepthRangef(n: GLfloat; f: GLfloat);
begin
  if Assigned(FglDepthRangef) then
  begin
    FglDepthRangef(n, f);
  end
  else
  begin
    raise Exception.Create('glDepthRangef not bound');
  end;
end;

procedure TGL_VERSION_4_1.glClearDepthf(d: GLfloat);
begin
  if Assigned(FglClearDepthf) then
  begin
    FglClearDepthf(d);
  end
  else
  begin
    raise Exception.Create('glClearDepthf not bound');
  end;
end;

procedure TGL_VERSION_4_1.glGetProgramBinary(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer);
begin
  if Assigned(FglGetProgramBinary) then
  begin
    FglGetProgramBinary(aProgram, bufSize, length, binaryFormat, binary);
  end
  else
  begin
    raise Exception.Create('glGetProgramBinary not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramBinary(aProgram: GLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei);
begin
  if Assigned(FglProgramBinary) then
  begin
    FglProgramBinary(aProgram, binaryFormat, binary, length);
  end
  else
  begin
    raise Exception.Create('glProgramBinary not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramParameteri(aProgram: GLuint; pname: GLenum; Value: GLint);
begin
  if Assigned(FglProgramParameteri) then
  begin
    FglProgramParameteri(aProgram, pname, Value);
  end
  else
  begin
    raise Exception.Create('glProgramParameteri not bound');
  end;
end;

procedure TGL_VERSION_4_1.glUseProgramStages(pipeline: GLuint; stages: GLbitfield; aProgram: GLuint);
begin
  if Assigned(FglUseProgramStages) then
  begin
    FglUseProgramStages(pipeline, stages, aProgram);
  end
  else
  begin
    raise Exception.Create('glUseProgramStages not bound');
  end;
end;

procedure TGL_VERSION_4_1.glActiveShaderProgram(pipeline: GLuint; aProgram: GLuint);
begin
  if Assigned(FglActiveShaderProgram) then
  begin
    FglActiveShaderProgram(pipeline, aProgram);
  end
  else
  begin
    raise Exception.Create('glActiveShaderProgram not bound');
  end;
end;

function TGL_VERSION_4_1.glCreateShaderProgramv(aType: GLenum; Count: GLsizei; const strings: PGLchar): GLuint;
begin
  if Assigned(FglCreateShaderProgramv) then
  begin
    Result := FglCreateShaderProgramv(aType, Count, strings);
  end
  else
  begin
    raise Exception.Create('glCreateShaderProgramv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glBindProgramPipeline(pipeline: GLuint);
begin
  if Assigned(FglBindProgramPipeline) then
  begin
    FglBindProgramPipeline(pipeline);
  end
  else
  begin
    raise Exception.Create('glBindProgramPipeline not bound');
  end;
end;

procedure TGL_VERSION_4_1.glDeleteProgramPipelines(n: GLsizei; const pipelines: PGLuint);
begin
  if Assigned(FglDeleteProgramPipelines) then
  begin
    FglDeleteProgramPipelines(n, pipelines);
  end
  else
  begin
    raise Exception.Create('glDeleteProgramPipelines not bound');
  end;
end;

procedure TGL_VERSION_4_1.glGenProgramPipelines(n: GLsizei; pipelines: PGLuint);
begin
  if Assigned(FglGenProgramPipelines) then
  begin
    FglGenProgramPipelines(n, pipelines);
  end
  else
  begin
    raise Exception.Create('glGenProgramPipelines not bound');
  end;
end;

function TGL_VERSION_4_1.glIsProgramPipeline(pipeline: GLuint): GLboolean;
begin
  if Assigned(FglIsProgramPipeline) then
  begin
    Result := FglIsProgramPipeline(pipeline);
  end
  else
  begin
    raise Exception.Create('glIsProgramPipeline not bound');
  end;
end;

procedure TGL_VERSION_4_1.glGetProgramPipelineiv(pipeline: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetProgramPipelineiv) then
  begin
    FglGetProgramPipelineiv(pipeline, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetProgramPipelineiv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform1i(aProgram: GLuint; location: GLint; v0: GLint);
begin
  if Assigned(FglProgramUniform1i) then
  begin
    FglProgramUniform1i(aProgram, location, v0);
  end
  else
  begin
    raise Exception.Create('glProgramUniform1i not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform1iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FglProgramUniform1iv) then
  begin
    FglProgramUniform1iv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform1iv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform1f(aProgram: GLuint; location: GLint; v0: GLfloat);
begin
  if Assigned(FglProgramUniform1f) then
  begin
    FglProgramUniform1f(aProgram, location, v0);
  end
  else
  begin
    raise Exception.Create('glProgramUniform1f not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform1fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniform1fv) then
  begin
    FglProgramUniform1fv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform1fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform1d(aProgram: GLuint; location: GLint; v0: GLdouble);
begin
  if Assigned(FglProgramUniform1d) then
  begin
    FglProgramUniform1d(aProgram, location, v0);
  end
  else
  begin
    raise Exception.Create('glProgramUniform1d not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform1dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniform1dv) then
  begin
    FglProgramUniform1dv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform1dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform1ui(aProgram: GLuint; location: GLint; v0: GLuint);
begin
  if Assigned(FglProgramUniform1ui) then
  begin
    FglProgramUniform1ui(aProgram, location, v0);
  end
  else
  begin
    raise Exception.Create('glProgramUniform1ui not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform1uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FglProgramUniform1uiv) then
  begin
    FglProgramUniform1uiv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform1uiv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform2i(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint);
begin
  if Assigned(FglProgramUniform2i) then
  begin
    FglProgramUniform2i(aProgram, location, v0, v1);
  end
  else
  begin
    raise Exception.Create('glProgramUniform2i not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform2iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FglProgramUniform2iv) then
  begin
    FglProgramUniform2iv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform2iv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform2f(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat);
begin
  if Assigned(FglProgramUniform2f) then
  begin
    FglProgramUniform2f(aProgram, location, v0, v1);
  end
  else
  begin
    raise Exception.Create('glProgramUniform2f not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform2fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniform2fv) then
  begin
    FglProgramUniform2fv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform2fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform2d(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble);
begin
  if Assigned(FglProgramUniform2d) then
  begin
    FglProgramUniform2d(aProgram, location, v0, v1);
  end
  else
  begin
    raise Exception.Create('glProgramUniform2d not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform2dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniform2dv) then
  begin
    FglProgramUniform2dv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform2dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform2ui(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint);
begin
  if Assigned(FglProgramUniform2ui) then
  begin
    FglProgramUniform2ui(aProgram, location, v0, v1);
  end
  else
  begin
    raise Exception.Create('glProgramUniform2ui not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform2uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FglProgramUniform2uiv) then
  begin
    FglProgramUniform2uiv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform2uiv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform3i(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint);
begin
  if Assigned(FglProgramUniform3i) then
  begin
    FglProgramUniform3i(aProgram, location, v0, v1, v2);
  end
  else
  begin
    raise Exception.Create('glProgramUniform3i not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform3iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FglProgramUniform3iv) then
  begin
    FglProgramUniform3iv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform3iv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform3f(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat);
begin
  if Assigned(FglProgramUniform3f) then
  begin
    FglProgramUniform3f(aProgram, location, v0, v1, v2);
  end
  else
  begin
    raise Exception.Create('glProgramUniform3f not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform3fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniform3fv) then
  begin
    FglProgramUniform3fv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform3fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform3d(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble);
begin
  if Assigned(FglProgramUniform3d) then
  begin
    FglProgramUniform3d(aProgram, location, v0, v1, v2);
  end
  else
  begin
    raise Exception.Create('glProgramUniform3d not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform3dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniform3dv) then
  begin
    FglProgramUniform3dv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform3dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform3ui(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint);
begin
  if Assigned(FglProgramUniform3ui) then
  begin
    FglProgramUniform3ui(aProgram, location, v0, v1, v2);
  end
  else
  begin
    raise Exception.Create('glProgramUniform3ui not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform3uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FglProgramUniform3uiv) then
  begin
    FglProgramUniform3uiv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform3uiv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform4i(aProgram: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint);
begin
  if Assigned(FglProgramUniform4i) then
  begin
    FglProgramUniform4i(aProgram, location, v0, v1, v2, v3);
  end
  else
  begin
    raise Exception.Create('glProgramUniform4i not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform4iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FglProgramUniform4iv) then
  begin
    FglProgramUniform4iv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform4iv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform4f(aProgram: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat);
begin
  if Assigned(FglProgramUniform4f) then
  begin
    FglProgramUniform4f(aProgram, location, v0, v1, v2, v3);
  end
  else
  begin
    raise Exception.Create('glProgramUniform4f not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform4fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniform4fv) then
  begin
    FglProgramUniform4fv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform4fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform4d(aProgram: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble; v3: GLdouble);
begin
  if Assigned(FglProgramUniform4d) then
  begin
    FglProgramUniform4d(aProgram, location, v0, v1, v2, v3);
  end
  else
  begin
    raise Exception.Create('glProgramUniform4d not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform4dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniform4dv) then
  begin
    FglProgramUniform4dv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform4dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform4ui(aProgram: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint);
begin
  if Assigned(FglProgramUniform4ui) then
  begin
    FglProgramUniform4ui(aProgram, location, v0, v1, v2, v3);
  end
  else
  begin
    raise Exception.Create('glProgramUniform4ui not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniform4uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FglProgramUniform4uiv) then
  begin
    FglProgramUniform4uiv(aProgram, location, Count, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniform4uiv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniformMatrix2fv) then
  begin
    FglProgramUniformMatrix2fv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix2fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniformMatrix3fv) then
  begin
    FglProgramUniformMatrix3fv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix3fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniformMatrix4fv) then
  begin
    FglProgramUniformMatrix4fv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix4fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniformMatrix2dv) then
  begin
    FglProgramUniformMatrix2dv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix2dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniformMatrix3dv) then
  begin
    FglProgramUniformMatrix3dv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix3dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniformMatrix4dv) then
  begin
    FglProgramUniformMatrix4dv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix4dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix2x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniformMatrix2x3fv) then
  begin
    FglProgramUniformMatrix2x3fv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix2x3fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix3x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniformMatrix3x2fv) then
  begin
    FglProgramUniformMatrix3x2fv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix3x2fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix2x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniformMatrix2x4fv) then
  begin
    FglProgramUniformMatrix2x4fv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix2x4fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix4x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniformMatrix4x2fv) then
  begin
    FglProgramUniformMatrix4x2fv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix4x2fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix3x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniformMatrix3x4fv) then
  begin
    FglProgramUniformMatrix3x4fv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix3x4fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix4x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FglProgramUniformMatrix4x3fv) then
  begin
    FglProgramUniformMatrix4x3fv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix4x3fv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix2x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniformMatrix2x3dv) then
  begin
    FglProgramUniformMatrix2x3dv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix2x3dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix3x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniformMatrix3x2dv) then
  begin
    FglProgramUniformMatrix3x2dv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix3x2dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix2x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniformMatrix2x4dv) then
  begin
    FglProgramUniformMatrix2x4dv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix2x4dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix4x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniformMatrix4x2dv) then
  begin
    FglProgramUniformMatrix4x2dv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix4x2dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix3x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniformMatrix3x4dv) then
  begin
    FglProgramUniformMatrix3x4dv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix3x4dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glProgramUniformMatrix4x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FglProgramUniformMatrix4x3dv) then
  begin
    FglProgramUniformMatrix4x3dv(aProgram, location, Count, transpose, Value);
  end
  else
  begin
    raise Exception.Create('glProgramUniformMatrix4x3dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glValidateProgramPipeline(pipeline: GLuint);
begin
  if Assigned(FglValidateProgramPipeline) then
  begin
    FglValidateProgramPipeline(pipeline);
  end
  else
  begin
    raise Exception.Create('glValidateProgramPipeline not bound');
  end;
end;

procedure TGL_VERSION_4_1.glGetProgramPipelineInfoLog(pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar);
begin
  if Assigned(FglGetProgramPipelineInfoLog) then
  begin
    FglGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
  end
  else
  begin
    raise Exception.Create('glGetProgramPipelineInfoLog not bound');
  end;
end;

procedure TGL_VERSION_4_1.glVertexAttribL1d(index: GLuint; x: GLdouble);
begin
  if Assigned(FglVertexAttribL1d) then
  begin
    FglVertexAttribL1d(index, x);
  end
  else
  begin
    raise Exception.Create('glVertexAttribL1d not bound');
  end;
end;

procedure TGL_VERSION_4_1.glVertexAttribL2d(index: GLuint; x: GLdouble; y: GLdouble);
begin
  if Assigned(FglVertexAttribL2d) then
  begin
    FglVertexAttribL2d(index, x, y);
  end
  else
  begin
    raise Exception.Create('glVertexAttribL2d not bound');
  end;
end;

procedure TGL_VERSION_4_1.glVertexAttribL3d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble);
begin
  if Assigned(FglVertexAttribL3d) then
  begin
    FglVertexAttribL3d(index, x, y, z);
  end
  else
  begin
    raise Exception.Create('glVertexAttribL3d not bound');
  end;
end;

procedure TGL_VERSION_4_1.glVertexAttribL4d(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble);
begin
  if Assigned(FglVertexAttribL4d) then
  begin
    FglVertexAttribL4d(index, x, y, z, w);
  end
  else
  begin
    raise Exception.Create('glVertexAttribL4d not bound');
  end;
end;

procedure TGL_VERSION_4_1.glVertexAttribL1dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FglVertexAttribL1dv) then
  begin
    FglVertexAttribL1dv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribL1dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glVertexAttribL2dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FglVertexAttribL2dv) then
  begin
    FglVertexAttribL2dv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribL2dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glVertexAttribL3dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FglVertexAttribL3dv) then
  begin
    FglVertexAttribL3dv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribL3dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glVertexAttribL4dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FglVertexAttribL4dv) then
  begin
    FglVertexAttribL4dv(index, v);
  end
  else
  begin
    raise Exception.Create('glVertexAttribL4dv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glVertexAttribLPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const aPointer: Pointer);
begin
  if Assigned(FglVertexAttribLPointer) then
  begin
    FglVertexAttribLPointer(index, size, aType, stride, aPointer);
  end
  else
  begin
    raise Exception.Create('glVertexAttribLPointer not bound');
  end;
end;

procedure TGL_VERSION_4_1.glGetVertexAttribLdv(index: GLuint; pname: GLenum; params: PGLdouble);
begin
  if Assigned(FglGetVertexAttribLdv) then
  begin
    FglGetVertexAttribLdv(index, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetVertexAttribLdv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glViewportArrayv(First: GLuint; Count: GLsizei; const v: PGLfloat);
begin
  if Assigned(FglViewportArrayv) then
  begin
    FglViewportArrayv(First, Count, v);
  end
  else
  begin
    raise Exception.Create('glViewportArrayv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glViewportIndexedf(index: GLuint; x: GLfloat; y: GLfloat; w: GLfloat; h: GLfloat);
begin
  if Assigned(FglViewportIndexedf) then
  begin
    FglViewportIndexedf(index, x, y, w, h);
  end
  else
  begin
    raise Exception.Create('glViewportIndexedf not bound');
  end;
end;

procedure TGL_VERSION_4_1.glViewportIndexedfv(index: GLuint; const v: PGLfloat);
begin
  if Assigned(FglViewportIndexedfv) then
  begin
    FglViewportIndexedfv(index, v);
  end
  else
  begin
    raise Exception.Create('glViewportIndexedfv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glScissorArrayv(First: GLuint; Count: GLsizei; const v: PGLint);
begin
  if Assigned(FglScissorArrayv) then
  begin
    FglScissorArrayv(First, Count, v);
  end
  else
  begin
    raise Exception.Create('glScissorArrayv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glScissorIndexed(index: GLuint; left: GLint; bottom: GLint; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglScissorIndexed) then
  begin
    FglScissorIndexed(index, left, bottom, Width, Height);
  end
  else
  begin
    raise Exception.Create('glScissorIndexed not bound');
  end;
end;

procedure TGL_VERSION_4_1.glScissorIndexedv(index: GLuint; const v: PGLint);
begin
  if Assigned(FglScissorIndexedv) then
  begin
    FglScissorIndexedv(index, v);
  end
  else
  begin
    raise Exception.Create('glScissorIndexedv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glDepthRangeArrayv(First: GLuint; Count: GLsizei; const v: PGLdouble);
begin
  if Assigned(FglDepthRangeArrayv) then
  begin
    FglDepthRangeArrayv(First, Count, v);
  end
  else
  begin
    raise Exception.Create('glDepthRangeArrayv not bound');
  end;
end;

procedure TGL_VERSION_4_1.glDepthRangeIndexed(index: GLuint; n: GLdouble; f: GLdouble);
begin
  if Assigned(FglDepthRangeIndexed) then
  begin
    FglDepthRangeIndexed(index, n, f);
  end
  else
  begin
    raise Exception.Create('glDepthRangeIndexed not bound');
  end;
end;

procedure TGL_VERSION_4_1.glGetFloati_v(target: GLenum; index: GLuint; Data: PGLfloat);
begin
  if Assigned(FglGetFloati_v) then
  begin
    FglGetFloati_v(target, index, Data);
  end
  else
  begin
    raise Exception.Create('glGetFloati_v not bound');
  end;
end;

procedure TGL_VERSION_4_1.glGetDoublei_v(target: GLenum; index: GLuint; Data: PGLdouble);
begin
  if Assigned(FglGetDoublei_v) then
  begin
    FglGetDoublei_v(target, index, Data);
  end
  else
  begin
    raise Exception.Create('glGetDoublei_v not bound');
  end;
end;

procedure TGL_VERSION_4_2.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglDrawArraysInstancedBaseInstance), 'glDrawArraysInstancedBaseInstance');
  Bind(Pointer(FglDrawElementsInstancedBaseInstance), 'glDrawElementsInstancedBaseInstance');
  Bind(Pointer(FglDrawElementsInstancedBaseVertexBaseInstance), 'glDrawElementsInstancedBaseVertexBaseInstance');
  Bind(Pointer(FglGetInternalformativ), 'glGetInternalformativ');
  Bind(Pointer(FglGetActiveAtomicCounterBufferiv), 'glGetActiveAtomicCounterBufferiv');
  Bind(Pointer(FglBindImageTexture), 'glBindImageTexture');
  Bind(Pointer(FglMemoryBarrier), 'glMemoryBarrier');
  Bind(Pointer(FglTexStorage1D), 'glTexStorage1D');
  Bind(Pointer(FglTexStorage2D), 'glTexStorage2D');
  Bind(Pointer(FglTexStorage3D), 'glTexStorage3D');
  Bind(Pointer(FglDrawTransformFeedbackInstanced), 'glDrawTransformFeedbackInstanced');
  Bind(Pointer(FglDrawTransformFeedbackStreamInstanced), 'glDrawTransformFeedbackStreamInstanced');
end;

procedure TGL_VERSION_4_2.glDrawArraysInstancedBaseInstance(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei; baseinstance: GLuint);
begin
  if Assigned(FglDrawArraysInstancedBaseInstance) then
  begin
    FglDrawArraysInstancedBaseInstance(mode, First, Count, instancecount, baseinstance);
  end
  else
  begin
    raise Exception.Create('glDrawArraysInstancedBaseInstance not bound');
  end;
end;

procedure TGL_VERSION_4_2.glDrawElementsInstancedBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; baseinstance: GLuint);
begin
  if Assigned(FglDrawElementsInstancedBaseInstance) then
  begin
    FglDrawElementsInstancedBaseInstance(mode, Count, aType, indices, instancecount, baseinstance);
  end
  else
  begin
    raise Exception.Create('glDrawElementsInstancedBaseInstance not bound');
  end;
end;

procedure TGL_VERSION_4_2.glDrawElementsInstancedBaseVertexBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint);
begin
  if Assigned(FglDrawElementsInstancedBaseVertexBaseInstance) then
  begin
    FglDrawElementsInstancedBaseVertexBaseInstance(mode, Count, aType, indices, instancecount, basevertex, baseinstance);
  end
  else
  begin
    raise Exception.Create('glDrawElementsInstancedBaseVertexBaseInstance not bound');
  end;
end;

procedure TGL_VERSION_4_2.glGetInternalformativ(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint);
begin
  if Assigned(FglGetInternalformativ) then
  begin
    FglGetInternalformativ(target, internalformat, pname, Count, params);
  end
  else
  begin
    raise Exception.Create('glGetInternalformativ not bound');
  end;
end;

procedure TGL_VERSION_4_2.glGetActiveAtomicCounterBufferiv(aProgram: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetActiveAtomicCounterBufferiv) then
  begin
    FglGetActiveAtomicCounterBufferiv(aProgram, bufferIndex, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetActiveAtomicCounterBufferiv not bound');
  end;
end;

procedure TGL_VERSION_4_2.glBindImageTexture(aUnit: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum);
begin
  if Assigned(FglBindImageTexture) then
  begin
    FglBindImageTexture(aUnit, texture, level, layered, layer, access, format);
  end
  else
  begin
    raise Exception.Create('glBindImageTexture not bound');
  end;
end;

procedure TGL_VERSION_4_2.glMemoryBarrier(barriers: GLbitfield);
begin
  if Assigned(FglMemoryBarrier) then
  begin
    FglMemoryBarrier(barriers);
  end
  else
  begin
    raise Exception.Create('glMemoryBarrier not bound');
  end;
end;

procedure TGL_VERSION_4_2.glTexStorage1D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei);
begin
  if Assigned(FglTexStorage1D) then
  begin
    FglTexStorage1D(target, levels, internalformat, Width);
  end
  else
  begin
    raise Exception.Create('glTexStorage1D not bound');
  end;
end;

procedure TGL_VERSION_4_2.glTexStorage2D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglTexStorage2D) then
  begin
    FglTexStorage2D(target, levels, internalformat, Width, Height);
  end
  else
  begin
    raise Exception.Create('glTexStorage2D not bound');
  end;
end;

procedure TGL_VERSION_4_2.glTexStorage3D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei);
begin
  if Assigned(FglTexStorage3D) then
  begin
    FglTexStorage3D(target, levels, internalformat, Width, Height, depth);
  end
  else
  begin
    raise Exception.Create('glTexStorage3D not bound');
  end;
end;

procedure TGL_VERSION_4_2.glDrawTransformFeedbackInstanced(mode: GLenum; id: GLuint; instancecount: GLsizei);
begin
  if Assigned(FglDrawTransformFeedbackInstanced) then
  begin
    FglDrawTransformFeedbackInstanced(mode, id, instancecount);
  end
  else
  begin
    raise Exception.Create('glDrawTransformFeedbackInstanced not bound');
  end;
end;

procedure TGL_VERSION_4_2.glDrawTransformFeedbackStreamInstanced(mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei);
begin
  if Assigned(FglDrawTransformFeedbackStreamInstanced) then
  begin
    FglDrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount);
  end
  else
  begin
    raise Exception.Create('glDrawTransformFeedbackStreamInstanced not bound');
  end;
end;

procedure TGL_VERSION_4_3.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglClearBufferData), 'glClearBufferData');
  Bind(Pointer(FglClearBufferSubData), 'glClearBufferSubData');
  Bind(Pointer(FglDispatchCompute), 'glDispatchCompute');
  Bind(Pointer(FglDispatchComputeIndirect), 'glDispatchComputeIndirect');
  Bind(Pointer(FglCopyImageSubData), 'glCopyImageSubData');
  Bind(Pointer(FglFramebufferParameteri), 'glFramebufferParameteri');
  Bind(Pointer(FglGetFramebufferParameteriv), 'glGetFramebufferParameteriv');
  Bind(Pointer(FglGetInternalformati64v), 'glGetInternalformati64v');
  Bind(Pointer(FglInvalidateTexSubImage), 'glInvalidateTexSubImage');
  Bind(Pointer(FglInvalidateTexImage), 'glInvalidateTexImage');
  Bind(Pointer(FglInvalidateBufferSubData), 'glInvalidateBufferSubData');
  Bind(Pointer(FglInvalidateBufferData), 'glInvalidateBufferData');
  Bind(Pointer(FglInvalidateFramebuffer), 'glInvalidateFramebuffer');
  Bind(Pointer(FglInvalidateSubFramebuffer), 'glInvalidateSubFramebuffer');
  Bind(Pointer(FglMultiDrawArraysIndirect), 'glMultiDrawArraysIndirect');
  Bind(Pointer(FglMultiDrawElementsIndirect), 'glMultiDrawElementsIndirect');
  Bind(Pointer(FglGetProgramInterfaceiv), 'glGetProgramInterfaceiv');
  Bind(Pointer(FglGetProgramResourceIndex), 'glGetProgramResourceIndex');
  Bind(Pointer(FglGetProgramResourceName), 'glGetProgramResourceName');
  Bind(Pointer(FglGetProgramResourceiv), 'glGetProgramResourceiv');
  Bind(Pointer(FglGetProgramResourceLocation), 'glGetProgramResourceLocation');
  Bind(Pointer(FglGetProgramResourceLocationIndex), 'glGetProgramResourceLocationIndex');
  Bind(Pointer(FglShaderStorageBlockBinding), 'glShaderStorageBlockBinding');
  Bind(Pointer(FglTexBufferRange), 'glTexBufferRange');
  Bind(Pointer(FglTexStorage2DMultisample), 'glTexStorage2DMultisample');
  Bind(Pointer(FglTexStorage3DMultisample), 'glTexStorage3DMultisample');
  Bind(Pointer(FglTextureView), 'glTextureView');
  Bind(Pointer(FglBindVertexBuffer), 'glBindVertexBuffer');
  Bind(Pointer(FglVertexAttribFormat), 'glVertexAttribFormat');
  Bind(Pointer(FglVertexAttribIFormat), 'glVertexAttribIFormat');
  Bind(Pointer(FglVertexAttribLFormat), 'glVertexAttribLFormat');
  Bind(Pointer(FglVertexAttribBinding), 'glVertexAttribBinding');
  Bind(Pointer(FglVertexBindingDivisor), 'glVertexBindingDivisor');
  Bind(Pointer(FglDebugMessageControl), 'glDebugMessageControl');
  Bind(Pointer(FglDebugMessageInsert), 'glDebugMessageInsert');
  Bind(Pointer(FglDebugMessageCallback), 'glDebugMessageCallback');
  Bind(Pointer(FglGetDebugMessageLog), 'glGetDebugMessageLog');
  Bind(Pointer(FglPushDebugGroup), 'glPushDebugGroup');
  Bind(Pointer(FglPopDebugGroup), 'glPopDebugGroup');
  Bind(Pointer(FglObjectLabel), 'glObjectLabel');
  Bind(Pointer(FglGetObjectLabel), 'glGetObjectLabel');
  Bind(Pointer(FglObjectPtrLabel), 'glObjectPtrLabel');
  Bind(Pointer(FglGetObjectPtrLabel), 'glGetObjectPtrLabel');
end;

procedure TGL_VERSION_4_3.glClearBufferData(target: GLenum; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FglClearBufferData) then
  begin
    FglClearBufferData(target, internalformat, format, aType, Data);
  end
  else
  begin
    raise Exception.Create('glClearBufferData not bound');
  end;
end;

procedure TGL_VERSION_4_3.glClearBufferSubData(target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FglClearBufferSubData) then
  begin
    FglClearBufferSubData(target, internalformat, offset, size, format, aType, Data);
  end
  else
  begin
    raise Exception.Create('glClearBufferSubData not bound');
  end;
end;

procedure TGL_VERSION_4_3.glDispatchCompute(num_groups_x: GLuint; num_groups_y: GLuint; num_groups_z: GLuint);
begin
  if Assigned(FglDispatchCompute) then
  begin
    FglDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
  end
  else
  begin
    raise Exception.Create('glDispatchCompute not bound');
  end;
end;

procedure TGL_VERSION_4_3.glDispatchComputeIndirect(indirect: GLintptr);
begin
  if Assigned(FglDispatchComputeIndirect) then
  begin
    FglDispatchComputeIndirect(indirect);
  end
  else
  begin
    raise Exception.Create('glDispatchComputeIndirect not bound');
  end;
end;

procedure TGL_VERSION_4_3.glCopyImageSubData(srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei; srcHeight: GLsizei; srcDepth: GLsizei);
begin
  if Assigned(FglCopyImageSubData) then
  begin
    FglCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
  end
  else
  begin
    raise Exception.Create('glCopyImageSubData not bound');
  end;
end;

procedure TGL_VERSION_4_3.glFramebufferParameteri(target: GLenum; pname: GLenum; param: GLint);
begin
  if Assigned(FglFramebufferParameteri) then
  begin
    FglFramebufferParameteri(target, pname, param);
  end
  else
  begin
    raise Exception.Create('glFramebufferParameteri not bound');
  end;
end;

procedure TGL_VERSION_4_3.glGetFramebufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetFramebufferParameteriv) then
  begin
    FglGetFramebufferParameteriv(target, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetFramebufferParameteriv not bound');
  end;
end;

procedure TGL_VERSION_4_3.glGetInternalformati64v(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint64);
begin
  if Assigned(FglGetInternalformati64v) then
  begin
    FglGetInternalformati64v(target, internalformat, pname, Count, params);
  end
  else
  begin
    raise Exception.Create('glGetInternalformati64v not bound');
  end;
end;

procedure TGL_VERSION_4_3.glInvalidateTexSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei);
begin
  if Assigned(FglInvalidateTexSubImage) then
  begin
    FglInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, Width, Height, depth);
  end
  else
  begin
    raise Exception.Create('glInvalidateTexSubImage not bound');
  end;
end;

procedure TGL_VERSION_4_3.glInvalidateTexImage(texture: GLuint; level: GLint);
begin
  if Assigned(FglInvalidateTexImage) then
  begin
    FglInvalidateTexImage(texture, level);
  end
  else
  begin
    raise Exception.Create('glInvalidateTexImage not bound');
  end;
end;

procedure TGL_VERSION_4_3.glInvalidateBufferSubData(buffer: GLuint; offset: GLintptr; length: GLsizeiptr);
begin
  if Assigned(FglInvalidateBufferSubData) then
  begin
    FglInvalidateBufferSubData(buffer, offset, length);
  end
  else
  begin
    raise Exception.Create('glInvalidateBufferSubData not bound');
  end;
end;

procedure TGL_VERSION_4_3.glInvalidateBufferData(buffer: GLuint);
begin
  if Assigned(FglInvalidateBufferData) then
  begin
    FglInvalidateBufferData(buffer);
  end
  else
  begin
    raise Exception.Create('glInvalidateBufferData not bound');
  end;
end;

procedure TGL_VERSION_4_3.glInvalidateFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum);
begin
  if Assigned(FglInvalidateFramebuffer) then
  begin
    FglInvalidateFramebuffer(target, numAttachments, attachments);
  end
  else
  begin
    raise Exception.Create('glInvalidateFramebuffer not bound');
  end;
end;

procedure TGL_VERSION_4_3.glInvalidateSubFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglInvalidateSubFramebuffer) then
  begin
    FglInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, Width, Height);
  end
  else
  begin
    raise Exception.Create('glInvalidateSubFramebuffer not bound');
  end;
end;

procedure TGL_VERSION_4_3.glMultiDrawArraysIndirect(mode: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei);
begin
  if Assigned(FglMultiDrawArraysIndirect) then
  begin
    FglMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
  end
  else
  begin
    raise Exception.Create('glMultiDrawArraysIndirect not bound');
  end;
end;

procedure TGL_VERSION_4_3.glMultiDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei);
begin
  if Assigned(FglMultiDrawElementsIndirect) then
  begin
    FglMultiDrawElementsIndirect(mode, aType, indirect, drawcount, stride);
  end
  else
  begin
    raise Exception.Create('glMultiDrawElementsIndirect not bound');
  end;
end;

procedure TGL_VERSION_4_3.glGetProgramInterfaceiv(aProgram: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetProgramInterfaceiv) then
  begin
    FglGetProgramInterfaceiv(aProgram, programInterface, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetProgramInterfaceiv not bound');
  end;
end;

function TGL_VERSION_4_3.glGetProgramResourceIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLuint;
begin
  if Assigned(FglGetProgramResourceIndex) then
  begin
    Result := FglGetProgramResourceIndex(aProgram, programInterface, Name);
  end
  else
  begin
    raise Exception.Create('glGetProgramResourceIndex not bound');
  end;
end;

procedure TGL_VERSION_4_3.glGetProgramResourceName(aProgram: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar);
begin
  if Assigned(FglGetProgramResourceName) then
  begin
    FglGetProgramResourceName(aProgram, programInterface, index, bufSize, length, Name);
  end
  else
  begin
    raise Exception.Create('glGetProgramResourceName not bound');
  end;
end;

procedure TGL_VERSION_4_3.glGetProgramResourceiv(aProgram: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; const props: PGLenum; Count: GLsizei; length: PGLsizei; params: PGLint);
begin
  if Assigned(FglGetProgramResourceiv) then
  begin
    FglGetProgramResourceiv(aProgram, programInterface, index, propCount, props, Count, length, params);
  end
  else
  begin
    raise Exception.Create('glGetProgramResourceiv not bound');
  end;
end;

function TGL_VERSION_4_3.glGetProgramResourceLocation(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint;
begin
  if Assigned(FglGetProgramResourceLocation) then
  begin
    Result := FglGetProgramResourceLocation(aProgram, programInterface, Name);
  end
  else
  begin
    raise Exception.Create('glGetProgramResourceLocation not bound');
  end;
end;

function TGL_VERSION_4_3.glGetProgramResourceLocationIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint;
begin
  if Assigned(FglGetProgramResourceLocationIndex) then
  begin
    Result := FglGetProgramResourceLocationIndex(aProgram, programInterface, Name);
  end
  else
  begin
    raise Exception.Create('glGetProgramResourceLocationIndex not bound');
  end;
end;

procedure TGL_VERSION_4_3.glShaderStorageBlockBinding(aProgram: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint);
begin
  if Assigned(FglShaderStorageBlockBinding) then
  begin
    FglShaderStorageBlockBinding(aProgram, storageBlockIndex, storageBlockBinding);
  end
  else
  begin
    raise Exception.Create('glShaderStorageBlockBinding not bound');
  end;
end;

procedure TGL_VERSION_4_3.glTexBufferRange(target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FglTexBufferRange) then
  begin
    FglTexBufferRange(target, internalformat, buffer, offset, size);
  end
  else
  begin
    raise Exception.Create('glTexBufferRange not bound');
  end;
end;

procedure TGL_VERSION_4_3.glTexStorage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FglTexStorage2DMultisample) then
  begin
    FglTexStorage2DMultisample(target, samples, internalformat, Width, Height, fixedsamplelocations);
  end
  else
  begin
    raise Exception.Create('glTexStorage2DMultisample not bound');
  end;
end;

procedure TGL_VERSION_4_3.glTexStorage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FglTexStorage3DMultisample) then
  begin
    FglTexStorage3DMultisample(target, samples, internalformat, Width, Height, depth, fixedsamplelocations);
  end
  else
  begin
    raise Exception.Create('glTexStorage3DMultisample not bound');
  end;
end;

procedure TGL_VERSION_4_3.glTextureView(texture: GLuint; target: GLenum; origtexture: GLuint; internalformat: GLenum; minlevel: GLuint; numlevels: GLuint; minlayer: GLuint; numlayers: GLuint);
begin
  if Assigned(FglTextureView) then
  begin
    FglTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
  end
  else
  begin
    raise Exception.Create('glTextureView not bound');
  end;
end;

procedure TGL_VERSION_4_3.glBindVertexBuffer(bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei);
begin
  if Assigned(FglBindVertexBuffer) then
  begin
    FglBindVertexBuffer(bindingindex, buffer, offset, stride);
  end
  else
  begin
    raise Exception.Create('glBindVertexBuffer not bound');
  end;
end;

procedure TGL_VERSION_4_3.glVertexAttribFormat(attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint);
begin
  if Assigned(FglVertexAttribFormat) then
  begin
    FglVertexAttribFormat(attribindex, size, aType, normalized, relativeoffset);
  end
  else
  begin
    raise Exception.Create('glVertexAttribFormat not bound');
  end;
end;

procedure TGL_VERSION_4_3.glVertexAttribIFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
begin
  if Assigned(FglVertexAttribIFormat) then
  begin
    FglVertexAttribIFormat(attribindex, size, aType, relativeoffset);
  end
  else
  begin
    raise Exception.Create('glVertexAttribIFormat not bound');
  end;
end;

procedure TGL_VERSION_4_3.glVertexAttribLFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
begin
  if Assigned(FglVertexAttribLFormat) then
  begin
    FglVertexAttribLFormat(attribindex, size, aType, relativeoffset);
  end
  else
  begin
    raise Exception.Create('glVertexAttribLFormat not bound');
  end;
end;

procedure TGL_VERSION_4_3.glVertexAttribBinding(attribindex: GLuint; bindingindex: GLuint);
begin
  if Assigned(FglVertexAttribBinding) then
  begin
    FglVertexAttribBinding(attribindex, bindingindex);
  end
  else
  begin
    raise Exception.Create('glVertexAttribBinding not bound');
  end;
end;

procedure TGL_VERSION_4_3.glVertexBindingDivisor(bindingindex: GLuint; divisor: GLuint);
begin
  if Assigned(FglVertexBindingDivisor) then
  begin
    FglVertexBindingDivisor(bindingindex, divisor);
  end
  else
  begin
    raise Exception.Create('glVertexBindingDivisor not bound');
  end;
end;

procedure TGL_VERSION_4_3.glDebugMessageControl(Source: GLenum; aType: GLenum; severity: GLenum; Count: GLsizei; const ids: PGLuint; Enabled: GLboolean);
begin
  if Assigned(FglDebugMessageControl) then
  begin
    FglDebugMessageControl(Source, aType, severity, Count, ids, Enabled);
  end
  else
  begin
    raise Exception.Create('glDebugMessageControl not bound');
  end;
end;

procedure TGL_VERSION_4_3.glDebugMessageInsert(Source: GLenum; aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const buf: PGLchar);
begin
  if Assigned(FglDebugMessageInsert) then
  begin
    FglDebugMessageInsert(Source, aType, id, severity, length, buf);
  end
  else
  begin
    raise Exception.Create('glDebugMessageInsert not bound');
  end;
end;

procedure TGL_VERSION_4_3.glDebugMessageCallback(callback: GLDEBUGPROC; const userParam: Pointer);
begin
  if Assigned(FglDebugMessageCallback) then
  begin
    FglDebugMessageCallback(callback, userParam);
  end
  else
  begin
    raise Exception.Create('glDebugMessageCallback not bound');
  end;
end;

function TGL_VERSION_4_3.glGetDebugMessageLog(Count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint;
begin
  if Assigned(FglGetDebugMessageLog) then
  begin
    Result := FglGetDebugMessageLog(Count, bufSize, sources, types, ids, severities, lengths, messageLog);
  end
  else
  begin
    raise Exception.Create('glGetDebugMessageLog not bound');
  end;
end;

procedure TGL_VERSION_4_3.glPushDebugGroup(Source: GLenum; id: GLuint; length: GLsizei; const message: PGLchar);
begin
  if Assigned(FglPushDebugGroup) then
  begin
    FglPushDebugGroup(Source, id, length, message);
  end
  else
  begin
    raise Exception.Create('glPushDebugGroup not bound');
  end;
end;

procedure TGL_VERSION_4_3.glPopDebugGroup();
begin
  if Assigned(FglPopDebugGroup) then
  begin
    FglPopDebugGroup();
  end
  else
  begin
    raise Exception.Create('glPopDebugGroup not bound');
  end;
end;

procedure TGL_VERSION_4_3.glObjectLabel(identifier: GLenum; Name: GLuint; length: GLsizei; const aLabel: PGLchar);
begin
  if Assigned(FglObjectLabel) then
  begin
    FglObjectLabel(identifier, Name, length, aLabel);
  end
  else
  begin
    raise Exception.Create('glObjectLabel not bound');
  end;
end;

procedure TGL_VERSION_4_3.glGetObjectLabel(identifier: GLenum; Name: GLuint; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar);
begin
  if Assigned(FglGetObjectLabel) then
  begin
    FglGetObjectLabel(identifier, Name, bufSize, length, aLabel);
  end
  else
  begin
    raise Exception.Create('glGetObjectLabel not bound');
  end;
end;

procedure TGL_VERSION_4_3.glObjectPtrLabel(const ptr: Pointer; length: GLsizei; const aLabel: PGLchar);
begin
  if Assigned(FglObjectPtrLabel) then
  begin
    FglObjectPtrLabel(ptr, length, aLabel);
  end
  else
  begin
    raise Exception.Create('glObjectPtrLabel not bound');
  end;
end;

procedure TGL_VERSION_4_3.glGetObjectPtrLabel(const ptr: Pointer; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar);
begin
  if Assigned(FglGetObjectPtrLabel) then
  begin
    FglGetObjectPtrLabel(ptr, bufSize, length, aLabel);
  end
  else
  begin
    raise Exception.Create('glGetObjectPtrLabel not bound');
  end;
end;

procedure TGL_VERSION_4_4.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglBufferStorage), 'glBufferStorage');
  Bind(Pointer(FglClearTexImage), 'glClearTexImage');
  Bind(Pointer(FglClearTexSubImage), 'glClearTexSubImage');
  Bind(Pointer(FglBindBuffersBase), 'glBindBuffersBase');
  Bind(Pointer(FglBindBuffersRange), 'glBindBuffersRange');
  Bind(Pointer(FglBindTextures), 'glBindTextures');
  Bind(Pointer(FglBindSamplers), 'glBindSamplers');
  Bind(Pointer(FglBindImageTextures), 'glBindImageTextures');
  Bind(Pointer(FglBindVertexBuffers), 'glBindVertexBuffers');
end;

procedure TGL_VERSION_4_4.glBufferStorage(target: GLenum; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield);
begin
  if Assigned(FglBufferStorage) then
  begin
    FglBufferStorage(target, size, Data, flags);
  end
  else
  begin
    raise Exception.Create('glBufferStorage not bound');
  end;
end;

procedure TGL_VERSION_4_4.glClearTexImage(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FglClearTexImage) then
  begin
    FglClearTexImage(texture, level, format, aType, Data);
  end
  else
  begin
    raise Exception.Create('glClearTexImage not bound');
  end;
end;

procedure TGL_VERSION_4_4.glClearTexSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FglClearTexSubImage) then
  begin
    FglClearTexSubImage(texture, level, xoffset, yoffset, zoffset, Width, Height, depth, format, aType, Data);
  end
  else
  begin
    raise Exception.Create('glClearTexSubImage not bound');
  end;
end;

procedure TGL_VERSION_4_4.glBindBuffersBase(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint);
begin
  if Assigned(FglBindBuffersBase) then
  begin
    FglBindBuffersBase(target, First, Count, buffers);
  end
  else
  begin
    raise Exception.Create('glBindBuffersBase not bound');
  end;
end;

procedure TGL_VERSION_4_4.glBindBuffersRange(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const sizes: PGLsizeiptr);
begin
  if Assigned(FglBindBuffersRange) then
  begin
    FglBindBuffersRange(target, First, Count, buffers, offsets, sizes);
  end
  else
  begin
    raise Exception.Create('glBindBuffersRange not bound');
  end;
end;

procedure TGL_VERSION_4_4.glBindTextures(First: GLuint; Count: GLsizei; const textures: PGLuint);
begin
  if Assigned(FglBindTextures) then
  begin
    FglBindTextures(First, Count, textures);
  end
  else
  begin
    raise Exception.Create('glBindTextures not bound');
  end;
end;

procedure TGL_VERSION_4_4.glBindSamplers(First: GLuint; Count: GLsizei; const samplers: PGLuint);
begin
  if Assigned(FglBindSamplers) then
  begin
    FglBindSamplers(First, Count, samplers);
  end
  else
  begin
    raise Exception.Create('glBindSamplers not bound');
  end;
end;

procedure TGL_VERSION_4_4.glBindImageTextures(First: GLuint; Count: GLsizei; const textures: PGLuint);
begin
  if Assigned(FglBindImageTextures) then
  begin
    FglBindImageTextures(First, Count, textures);
  end
  else
  begin
    raise Exception.Create('glBindImageTextures not bound');
  end;
end;

procedure TGL_VERSION_4_4.glBindVertexBuffers(First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei);
begin
  if Assigned(FglBindVertexBuffers) then
  begin
    FglBindVertexBuffers(First, Count, buffers, offsets, strides);
  end
  else
  begin
    raise Exception.Create('glBindVertexBuffers not bound');
  end;
end;

procedure TGL_VERSION_4_5.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglClipControl), 'glClipControl');
  Bind(Pointer(FglCreateTransformFeedbacks), 'glCreateTransformFeedbacks');
  Bind(Pointer(FglTransformFeedbackBufferBase), 'glTransformFeedbackBufferBase');
  Bind(Pointer(FglTransformFeedbackBufferRange), 'glTransformFeedbackBufferRange');
  Bind(Pointer(FglGetTransformFeedbackiv), 'glGetTransformFeedbackiv');
  Bind(Pointer(FglGetTransformFeedbacki_v), 'glGetTransformFeedbacki_v');
  Bind(Pointer(FglGetTransformFeedbacki64_v), 'glGetTransformFeedbacki64_v');
  Bind(Pointer(FglCreateBuffers), 'glCreateBuffers');
  Bind(Pointer(FglNamedBufferStorage), 'glNamedBufferStorage');
  Bind(Pointer(FglNamedBufferData), 'glNamedBufferData');
  Bind(Pointer(FglNamedBufferSubData), 'glNamedBufferSubData');
  Bind(Pointer(FglCopyNamedBufferSubData), 'glCopyNamedBufferSubData');
  Bind(Pointer(FglClearNamedBufferData), 'glClearNamedBufferData');
  Bind(Pointer(FglClearNamedBufferSubData), 'glClearNamedBufferSubData');
  Bind(Pointer(FglMapNamedBuffer), 'glMapNamedBuffer');
  Bind(Pointer(FglMapNamedBufferRange), 'glMapNamedBufferRange');
  Bind(Pointer(FglUnmapNamedBuffer), 'glUnmapNamedBuffer');
  Bind(Pointer(FglFlushMappedNamedBufferRange), 'glFlushMappedNamedBufferRange');
  Bind(Pointer(FglGetNamedBufferParameteriv), 'glGetNamedBufferParameteriv');
  Bind(Pointer(FglGetNamedBufferParameteri64v), 'glGetNamedBufferParameteri64v');
  Bind(Pointer(FglGetNamedBufferPointerv), 'glGetNamedBufferPointerv');
  Bind(Pointer(FglGetNamedBufferSubData), 'glGetNamedBufferSubData');
  Bind(Pointer(FglCreateFramebuffers), 'glCreateFramebuffers');
  Bind(Pointer(FglNamedFramebufferRenderbuffer), 'glNamedFramebufferRenderbuffer');
  Bind(Pointer(FglNamedFramebufferParameteri), 'glNamedFramebufferParameteri');
  Bind(Pointer(FglNamedFramebufferTexture), 'glNamedFramebufferTexture');
  Bind(Pointer(FglNamedFramebufferTextureLayer), 'glNamedFramebufferTextureLayer');
  Bind(Pointer(FglNamedFramebufferDrawBuffer), 'glNamedFramebufferDrawBuffer');
  Bind(Pointer(FglNamedFramebufferDrawBuffers), 'glNamedFramebufferDrawBuffers');
  Bind(Pointer(FglNamedFramebufferReadBuffer), 'glNamedFramebufferReadBuffer');
  Bind(Pointer(FglInvalidateNamedFramebufferData), 'glInvalidateNamedFramebufferData');
  Bind(Pointer(FglInvalidateNamedFramebufferSubData), 'glInvalidateNamedFramebufferSubData');
  Bind(Pointer(FglClearNamedFramebufferiv), 'glClearNamedFramebufferiv');
  Bind(Pointer(FglClearNamedFramebufferuiv), 'glClearNamedFramebufferuiv');
  Bind(Pointer(FglClearNamedFramebufferfv), 'glClearNamedFramebufferfv');
  Bind(Pointer(FglClearNamedFramebufferfi), 'glClearNamedFramebufferfi');
  Bind(Pointer(FglBlitNamedFramebuffer), 'glBlitNamedFramebuffer');
  Bind(Pointer(FglCheckNamedFramebufferStatus), 'glCheckNamedFramebufferStatus');
  Bind(Pointer(FglGetNamedFramebufferParameteriv), 'glGetNamedFramebufferParameteriv');
  Bind(Pointer(FglGetNamedFramebufferAttachmentParameteriv), 'glGetNamedFramebufferAttachmentParameteriv');
  Bind(Pointer(FglCreateRenderbuffers), 'glCreateRenderbuffers');
  Bind(Pointer(FglNamedRenderbufferStorage), 'glNamedRenderbufferStorage');
  Bind(Pointer(FglNamedRenderbufferStorageMultisample), 'glNamedRenderbufferStorageMultisample');
  Bind(Pointer(FglGetNamedRenderbufferParameteriv), 'glGetNamedRenderbufferParameteriv');
  Bind(Pointer(FglCreateTextures), 'glCreateTextures');
  Bind(Pointer(FglTextureBuffer), 'glTextureBuffer');
  Bind(Pointer(FglTextureBufferRange), 'glTextureBufferRange');
  Bind(Pointer(FglTextureStorage1D), 'glTextureStorage1D');
  Bind(Pointer(FglTextureStorage2D), 'glTextureStorage2D');
  Bind(Pointer(FglTextureStorage3D), 'glTextureStorage3D');
  Bind(Pointer(FglTextureStorage2DMultisample), 'glTextureStorage2DMultisample');
  Bind(Pointer(FglTextureStorage3DMultisample), 'glTextureStorage3DMultisample');
  Bind(Pointer(FglTextureSubImage1D), 'glTextureSubImage1D');
  Bind(Pointer(FglTextureSubImage2D), 'glTextureSubImage2D');
  Bind(Pointer(FglTextureSubImage3D), 'glTextureSubImage3D');
  Bind(Pointer(FglCompressedTextureSubImage1D), 'glCompressedTextureSubImage1D');
  Bind(Pointer(FglCompressedTextureSubImage2D), 'glCompressedTextureSubImage2D');
  Bind(Pointer(FglCompressedTextureSubImage3D), 'glCompressedTextureSubImage3D');
  Bind(Pointer(FglCopyTextureSubImage1D), 'glCopyTextureSubImage1D');
  Bind(Pointer(FglCopyTextureSubImage2D), 'glCopyTextureSubImage2D');
  Bind(Pointer(FglCopyTextureSubImage3D), 'glCopyTextureSubImage3D');
  Bind(Pointer(FglTextureParameterf), 'glTextureParameterf');
  Bind(Pointer(FglTextureParameterfv), 'glTextureParameterfv');
  Bind(Pointer(FglTextureParameteri), 'glTextureParameteri');
  Bind(Pointer(FglTextureParameterIiv), 'glTextureParameterIiv');
  Bind(Pointer(FglTextureParameterIuiv), 'glTextureParameterIuiv');
  Bind(Pointer(FglTextureParameteriv), 'glTextureParameteriv');
  Bind(Pointer(FglGenerateTextureMipmap), 'glGenerateTextureMipmap');
  Bind(Pointer(FglBindTextureUnit), 'glBindTextureUnit');
  Bind(Pointer(FglGetTextureImage), 'glGetTextureImage');
  Bind(Pointer(FglGetCompressedTextureImage), 'glGetCompressedTextureImage');
  Bind(Pointer(FglGetTextureLevelParameterfv), 'glGetTextureLevelParameterfv');
  Bind(Pointer(FglGetTextureLevelParameteriv), 'glGetTextureLevelParameteriv');
  Bind(Pointer(FglGetTextureParameterfv), 'glGetTextureParameterfv');
  Bind(Pointer(FglGetTextureParameterIiv), 'glGetTextureParameterIiv');
  Bind(Pointer(FglGetTextureParameterIuiv), 'glGetTextureParameterIuiv');
  Bind(Pointer(FglGetTextureParameteriv), 'glGetTextureParameteriv');
  Bind(Pointer(FglCreateVertexArrays), 'glCreateVertexArrays');
  Bind(Pointer(FglDisableVertexArrayAttrib), 'glDisableVertexArrayAttrib');
  Bind(Pointer(FglEnableVertexArrayAttrib), 'glEnableVertexArrayAttrib');
  Bind(Pointer(FglVertexArrayElementBuffer), 'glVertexArrayElementBuffer');
  Bind(Pointer(FglVertexArrayVertexBuffer), 'glVertexArrayVertexBuffer');
  Bind(Pointer(FglVertexArrayVertexBuffers), 'glVertexArrayVertexBuffers');
  Bind(Pointer(FglVertexArrayAttribBinding), 'glVertexArrayAttribBinding');
  Bind(Pointer(FglVertexArrayAttribFormat), 'glVertexArrayAttribFormat');
  Bind(Pointer(FglVertexArrayAttribIFormat), 'glVertexArrayAttribIFormat');
  Bind(Pointer(FglVertexArrayAttribLFormat), 'glVertexArrayAttribLFormat');
  Bind(Pointer(FglVertexArrayBindingDivisor), 'glVertexArrayBindingDivisor');
  Bind(Pointer(FglGetVertexArrayiv), 'glGetVertexArrayiv');
  Bind(Pointer(FglGetVertexArrayIndexediv), 'glGetVertexArrayIndexediv');
  Bind(Pointer(FglGetVertexArrayIndexed64iv), 'glGetVertexArrayIndexed64iv');
  Bind(Pointer(FglCreateSamplers), 'glCreateSamplers');
  Bind(Pointer(FglCreateProgramPipelines), 'glCreateProgramPipelines');
  Bind(Pointer(FglCreateQueries), 'glCreateQueries');
  Bind(Pointer(FglGetQueryBufferObjecti64v), 'glGetQueryBufferObjecti64v');
  Bind(Pointer(FglGetQueryBufferObjectiv), 'glGetQueryBufferObjectiv');
  Bind(Pointer(FglGetQueryBufferObjectui64v), 'glGetQueryBufferObjectui64v');
  Bind(Pointer(FglGetQueryBufferObjectuiv), 'glGetQueryBufferObjectuiv');
  Bind(Pointer(FglMemoryBarrierByRegion), 'glMemoryBarrierByRegion');
  Bind(Pointer(FglGetTextureSubImage), 'glGetTextureSubImage');
  Bind(Pointer(FglGetCompressedTextureSubImage), 'glGetCompressedTextureSubImage');
  Bind(Pointer(FglGetGraphicsResetStatus), 'glGetGraphicsResetStatus');
  Bind(Pointer(FglGetnCompressedTexImage), 'glGetnCompressedTexImage');
  Bind(Pointer(FglGetnTexImage), 'glGetnTexImage');
  Bind(Pointer(FglGetnUniformdv), 'glGetnUniformdv');
  Bind(Pointer(FglGetnUniformfv), 'glGetnUniformfv');
  Bind(Pointer(FglGetnUniformiv), 'glGetnUniformiv');
  Bind(Pointer(FglGetnUniformuiv), 'glGetnUniformuiv');
  Bind(Pointer(FglReadnPixels), 'glReadnPixels');
  Bind(Pointer(FglGetnMapdv), 'glGetnMapdv');
  Bind(Pointer(FglGetnMapfv), 'glGetnMapfv');
  Bind(Pointer(FglGetnMapiv), 'glGetnMapiv');
  Bind(Pointer(FglGetnPixelMapfv), 'glGetnPixelMapfv');
  Bind(Pointer(FglGetnPixelMapuiv), 'glGetnPixelMapuiv');
  Bind(Pointer(FglGetnPixelMapusv), 'glGetnPixelMapusv');
  Bind(Pointer(FglGetnPolygonStipple), 'glGetnPolygonStipple');
  Bind(Pointer(FglGetnColorTable), 'glGetnColorTable');
  Bind(Pointer(FglGetnConvolutionFilter), 'glGetnConvolutionFilter');
  Bind(Pointer(FglGetnSeparableFilter), 'glGetnSeparableFilter');
  Bind(Pointer(FglGetnHistogram), 'glGetnHistogram');
  Bind(Pointer(FglGetnMinmax), 'glGetnMinmax');
  Bind(Pointer(FglTextureBarrier), 'glTextureBarrier');
end;

procedure TGL_VERSION_4_5.glClipControl(origin: GLenum; depth: GLenum);
begin
  if Assigned(FglClipControl) then
  begin
    FglClipControl(origin, depth);
  end
  else
  begin
    raise Exception.Create('glClipControl not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCreateTransformFeedbacks(n: GLsizei; ids: PGLuint);
begin
  if Assigned(FglCreateTransformFeedbacks) then
  begin
    FglCreateTransformFeedbacks(n, ids);
  end
  else
  begin
    raise Exception.Create('glCreateTransformFeedbacks not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTransformFeedbackBufferBase(xfb: GLuint; index: GLuint; buffer: GLuint);
begin
  if Assigned(FglTransformFeedbackBufferBase) then
  begin
    FglTransformFeedbackBufferBase(xfb, index, buffer);
  end
  else
  begin
    raise Exception.Create('glTransformFeedbackBufferBase not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTransformFeedbackBufferRange(xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FglTransformFeedbackBufferRange) then
  begin
    FglTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
  end
  else
  begin
    raise Exception.Create('glTransformFeedbackBufferRange not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTransformFeedbackiv(xfb: GLuint; pname: GLenum; param: PGLint);
begin
  if Assigned(FglGetTransformFeedbackiv) then
  begin
    FglGetTransformFeedbackiv(xfb, pname, param);
  end
  else
  begin
    raise Exception.Create('glGetTransformFeedbackiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTransformFeedbacki_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint);
begin
  if Assigned(FglGetTransformFeedbacki_v) then
  begin
    FglGetTransformFeedbacki_v(xfb, pname, index, param);
  end
  else
  begin
    raise Exception.Create('glGetTransformFeedbacki_v not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTransformFeedbacki64_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64);
begin
  if Assigned(FglGetTransformFeedbacki64_v) then
  begin
    FglGetTransformFeedbacki64_v(xfb, pname, index, param);
  end
  else
  begin
    raise Exception.Create('glGetTransformFeedbacki64_v not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCreateBuffers(n: GLsizei; buffers: PGLuint);
begin
  if Assigned(FglCreateBuffers) then
  begin
    FglCreateBuffers(n, buffers);
  end
  else
  begin
    raise Exception.Create('glCreateBuffers not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedBufferStorage(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield);
begin
  if Assigned(FglNamedBufferStorage) then
  begin
    FglNamedBufferStorage(buffer, size, Data, flags);
  end
  else
  begin
    raise Exception.Create('glNamedBufferStorage not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedBufferData(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; usage: GLenum);
begin
  if Assigned(FglNamedBufferData) then
  begin
    FglNamedBufferData(buffer, size, Data, usage);
  end
  else
  begin
    raise Exception.Create('glNamedBufferData not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; const Data: Pointer);
begin
  if Assigned(FglNamedBufferSubData) then
  begin
    FglNamedBufferSubData(buffer, offset, size, Data);
  end
  else
  begin
    raise Exception.Create('glNamedBufferSubData not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCopyNamedBufferSubData(readBuffer: GLuint; writeBuffer: GLuint; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FglCopyNamedBufferSubData) then
  begin
    FglCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
  end
  else
  begin
    raise Exception.Create('glCopyNamedBufferSubData not bound');
  end;
end;

procedure TGL_VERSION_4_5.glClearNamedBufferData(buffer: GLuint; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FglClearNamedBufferData) then
  begin
    FglClearNamedBufferData(buffer, internalformat, format, aType, Data);
  end
  else
  begin
    raise Exception.Create('glClearNamedBufferData not bound');
  end;
end;

procedure TGL_VERSION_4_5.glClearNamedBufferSubData(buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FglClearNamedBufferSubData) then
  begin
    FglClearNamedBufferSubData(buffer, internalformat, offset, size, format, aType, Data);
  end
  else
  begin
    raise Exception.Create('glClearNamedBufferSubData not bound');
  end;
end;

function TGL_VERSION_4_5.glMapNamedBuffer(buffer: GLuint; access: GLenum): pointer;
begin
  if Assigned(FglMapNamedBuffer) then
  begin
    Result := FglMapNamedBuffer(buffer, access);
  end
  else
  begin
    raise Exception.Create('glMapNamedBuffer not bound');
  end;
end;

function TGL_VERSION_4_5.glMapNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): pointer;
begin
  if Assigned(FglMapNamedBufferRange) then
  begin
    Result := FglMapNamedBufferRange(buffer, offset, length, access);
  end
  else
  begin
    raise Exception.Create('glMapNamedBufferRange not bound');
  end;
end;

function TGL_VERSION_4_5.glUnmapNamedBuffer(buffer: GLuint): GLboolean;
begin
  if Assigned(FglUnmapNamedBuffer) then
  begin
    Result := FglUnmapNamedBuffer(buffer);
  end
  else
  begin
    raise Exception.Create('glUnmapNamedBuffer not bound');
  end;
end;

procedure TGL_VERSION_4_5.glFlushMappedNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr);
begin
  if Assigned(FglFlushMappedNamedBufferRange) then
  begin
    FglFlushMappedNamedBufferRange(buffer, offset, length);
  end
  else
  begin
    raise Exception.Create('glFlushMappedNamedBufferRange not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetNamedBufferParameteriv(buffer: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetNamedBufferParameteriv) then
  begin
    FglGetNamedBufferParameteriv(buffer, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetNamedBufferParameteriv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetNamedBufferParameteri64v(buffer: GLuint; pname: GLenum; params: PGLint64);
begin
  if Assigned(FglGetNamedBufferParameteri64v) then
  begin
    FglGetNamedBufferParameteri64v(buffer, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetNamedBufferParameteri64v not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetNamedBufferPointerv(buffer: GLuint; pname: GLenum; params: Pointer);
begin
  if Assigned(FglGetNamedBufferPointerv) then
  begin
    FglGetNamedBufferPointerv(buffer, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetNamedBufferPointerv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer);
begin
  if Assigned(FglGetNamedBufferSubData) then
  begin
    FglGetNamedBufferSubData(buffer, offset, size, Data);
  end
  else
  begin
    raise Exception.Create('glGetNamedBufferSubData not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCreateFramebuffers(n: GLsizei; framebuffers: PGLuint);
begin
  if Assigned(FglCreateFramebuffers) then
  begin
    FglCreateFramebuffers(n, framebuffers);
  end
  else
  begin
    raise Exception.Create('glCreateFramebuffers not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedFramebufferRenderbuffer(framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint);
begin
  if Assigned(FglNamedFramebufferRenderbuffer) then
  begin
    FglNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
  end
  else
  begin
    raise Exception.Create('glNamedFramebufferRenderbuffer not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedFramebufferParameteri(framebuffer: GLuint; pname: GLenum; param: GLint);
begin
  if Assigned(FglNamedFramebufferParameteri) then
  begin
    FglNamedFramebufferParameteri(framebuffer, pname, param);
  end
  else
  begin
    raise Exception.Create('glNamedFramebufferParameteri not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedFramebufferTexture(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint);
begin
  if Assigned(FglNamedFramebufferTexture) then
  begin
    FglNamedFramebufferTexture(framebuffer, attachment, texture, level);
  end
  else
  begin
    raise Exception.Create('glNamedFramebufferTexture not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedFramebufferTextureLayer(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint);
begin
  if Assigned(FglNamedFramebufferTextureLayer) then
  begin
    FglNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
  end
  else
  begin
    raise Exception.Create('glNamedFramebufferTextureLayer not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedFramebufferDrawBuffer(framebuffer: GLuint; buf: GLenum);
begin
  if Assigned(FglNamedFramebufferDrawBuffer) then
  begin
    FglNamedFramebufferDrawBuffer(framebuffer, buf);
  end
  else
  begin
    raise Exception.Create('glNamedFramebufferDrawBuffer not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedFramebufferDrawBuffers(framebuffer: GLuint; n: GLsizei; const bufs: PGLenum);
begin
  if Assigned(FglNamedFramebufferDrawBuffers) then
  begin
    FglNamedFramebufferDrawBuffers(framebuffer, n, bufs);
  end
  else
  begin
    raise Exception.Create('glNamedFramebufferDrawBuffers not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedFramebufferReadBuffer(framebuffer: GLuint; src: GLenum);
begin
  if Assigned(FglNamedFramebufferReadBuffer) then
  begin
    FglNamedFramebufferReadBuffer(framebuffer, src);
  end
  else
  begin
    raise Exception.Create('glNamedFramebufferReadBuffer not bound');
  end;
end;

procedure TGL_VERSION_4_5.glInvalidateNamedFramebufferData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum);
begin
  if Assigned(FglInvalidateNamedFramebufferData) then
  begin
    FglInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
  end
  else
  begin
    raise Exception.Create('glInvalidateNamedFramebufferData not bound');
  end;
end;

procedure TGL_VERSION_4_5.glInvalidateNamedFramebufferSubData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglInvalidateNamedFramebufferSubData) then
  begin
    FglInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, Width, Height);
  end
  else
  begin
    raise Exception.Create('glInvalidateNamedFramebufferSubData not bound');
  end;
end;

procedure TGL_VERSION_4_5.glClearNamedFramebufferiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLint);
begin
  if Assigned(FglClearNamedFramebufferiv) then
  begin
    FglClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, Value);
  end
  else
  begin
    raise Exception.Create('glClearNamedFramebufferiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glClearNamedFramebufferuiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLuint);
begin
  if Assigned(FglClearNamedFramebufferuiv) then
  begin
    FglClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, Value);
  end
  else
  begin
    raise Exception.Create('glClearNamedFramebufferuiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glClearNamedFramebufferfv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat);
begin
  if Assigned(FglClearNamedFramebufferfv) then
  begin
    FglClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, Value);
  end
  else
  begin
    raise Exception.Create('glClearNamedFramebufferfv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glClearNamedFramebufferfi(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint);
begin
  if Assigned(FglClearNamedFramebufferfi) then
  begin
    FglClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
  end
  else
  begin
    raise Exception.Create('glClearNamedFramebufferfi not bound');
  end;
end;

procedure TGL_VERSION_4_5.glBlitNamedFramebuffer(readFramebuffer: GLuint; drawFramebuffer: GLuint; srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum);
begin
  if Assigned(FglBlitNamedFramebuffer) then
  begin
    FglBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  end
  else
  begin
    raise Exception.Create('glBlitNamedFramebuffer not bound');
  end;
end;

function TGL_VERSION_4_5.glCheckNamedFramebufferStatus(framebuffer: GLuint; target: GLenum): GLenum;
begin
  if Assigned(FglCheckNamedFramebufferStatus) then
  begin
    Result := FglCheckNamedFramebufferStatus(framebuffer, target);
  end
  else
  begin
    raise Exception.Create('glCheckNamedFramebufferStatus not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetNamedFramebufferParameteriv(framebuffer: GLuint; pname: GLenum; param: PGLint);
begin
  if Assigned(FglGetNamedFramebufferParameteriv) then
  begin
    FglGetNamedFramebufferParameteriv(framebuffer, pname, param);
  end
  else
  begin
    raise Exception.Create('glGetNamedFramebufferParameteriv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetNamedFramebufferAttachmentParameteriv(framebuffer: GLuint; attachment: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetNamedFramebufferAttachmentParameteriv) then
  begin
    FglGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetNamedFramebufferAttachmentParameteriv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCreateRenderbuffers(n: GLsizei; renderbuffers: PGLuint);
begin
  if Assigned(FglCreateRenderbuffers) then
  begin
    FglCreateRenderbuffers(n, renderbuffers);
  end
  else
  begin
    raise Exception.Create('glCreateRenderbuffers not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedRenderbufferStorage(renderbuffer: GLuint; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglNamedRenderbufferStorage) then
  begin
    FglNamedRenderbufferStorage(renderbuffer, internalformat, Width, Height);
  end
  else
  begin
    raise Exception.Create('glNamedRenderbufferStorage not bound');
  end;
end;

procedure TGL_VERSION_4_5.glNamedRenderbufferStorageMultisample(renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglNamedRenderbufferStorageMultisample) then
  begin
    FglNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, Width, Height);
  end
  else
  begin
    raise Exception.Create('glNamedRenderbufferStorageMultisample not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetNamedRenderbufferParameteriv(renderbuffer: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetNamedRenderbufferParameteriv) then
  begin
    FglGetNamedRenderbufferParameteriv(renderbuffer, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetNamedRenderbufferParameteriv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCreateTextures(target: GLenum; n: GLsizei; textures: PGLuint);
begin
  if Assigned(FglCreateTextures) then
  begin
    FglCreateTextures(target, n, textures);
  end
  else
  begin
    raise Exception.Create('glCreateTextures not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureBuffer(texture: GLuint; internalformat: GLenum; buffer: GLuint);
begin
  if Assigned(FglTextureBuffer) then
  begin
    FglTextureBuffer(texture, internalformat, buffer);
  end
  else
  begin
    raise Exception.Create('glTextureBuffer not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureBufferRange(texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FglTextureBufferRange) then
  begin
    FglTextureBufferRange(texture, internalformat, buffer, offset, size);
  end
  else
  begin
    raise Exception.Create('glTextureBufferRange not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureStorage1D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei);
begin
  if Assigned(FglTextureStorage1D) then
  begin
    FglTextureStorage1D(texture, levels, internalformat, Width);
  end
  else
  begin
    raise Exception.Create('glTextureStorage1D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureStorage2D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglTextureStorage2D) then
  begin
    FglTextureStorage2D(texture, levels, internalformat, Width, Height);
  end
  else
  begin
    raise Exception.Create('glTextureStorage2D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureStorage3D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei);
begin
  if Assigned(FglTextureStorage3D) then
  begin
    FglTextureStorage3D(texture, levels, internalformat, Width, Height, depth);
  end
  else
  begin
    raise Exception.Create('glTextureStorage3D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureStorage2DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FglTextureStorage2DMultisample) then
  begin
    FglTextureStorage2DMultisample(texture, samples, internalformat, Width, Height, fixedsamplelocations);
  end
  else
  begin
    raise Exception.Create('glTextureStorage2DMultisample not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureStorage3DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FglTextureStorage3DMultisample) then
  begin
    FglTextureStorage3DMultisample(texture, samples, internalformat, Width, Height, depth, fixedsamplelocations);
  end
  else
  begin
    raise Exception.Create('glTextureStorage3DMultisample not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureSubImage1D(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglTextureSubImage1D) then
  begin
    FglTextureSubImage1D(texture, level, xoffset, Width, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glTextureSubImage1D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureSubImage2D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglTextureSubImage2D) then
  begin
    FglTextureSubImage2D(texture, level, xoffset, yoffset, Width, Height, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glTextureSubImage2D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureSubImage3D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FglTextureSubImage3D) then
  begin
    FglTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, Width, Height, depth, format, aType, pixels);
  end
  else
  begin
    raise Exception.Create('glTextureSubImage3D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCompressedTextureSubImage1D(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FglCompressedTextureSubImage1D) then
  begin
    FglCompressedTextureSubImage1D(texture, level, xoffset, Width, format, imageSize, Data);
  end
  else
  begin
    raise Exception.Create('glCompressedTextureSubImage1D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCompressedTextureSubImage2D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FglCompressedTextureSubImage2D) then
  begin
    FglCompressedTextureSubImage2D(texture, level, xoffset, yoffset, Width, Height, format, imageSize, Data);
  end
  else
  begin
    raise Exception.Create('glCompressedTextureSubImage2D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCompressedTextureSubImage3D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FglCompressedTextureSubImage3D) then
  begin
    FglCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, Width, Height, depth, format, imageSize, Data);
  end
  else
  begin
    raise Exception.Create('glCompressedTextureSubImage3D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCopyTextureSubImage1D(texture: GLuint; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei);
begin
  if Assigned(FglCopyTextureSubImage1D) then
  begin
    FglCopyTextureSubImage1D(texture, level, xoffset, x, y, Width);
  end
  else
  begin
    raise Exception.Create('glCopyTextureSubImage1D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCopyTextureSubImage2D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglCopyTextureSubImage2D) then
  begin
    FglCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, Width, Height);
  end
  else
  begin
    raise Exception.Create('glCopyTextureSubImage2D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCopyTextureSubImage3D(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei);
begin
  if Assigned(FglCopyTextureSubImage3D) then
  begin
    FglCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, Width, Height);
  end
  else
  begin
    raise Exception.Create('glCopyTextureSubImage3D not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureParameterf(texture: GLuint; pname: GLenum; param: GLfloat);
begin
  if Assigned(FglTextureParameterf) then
  begin
    FglTextureParameterf(texture, pname, param);
  end
  else
  begin
    raise Exception.Create('glTextureParameterf not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureParameterfv(texture: GLuint; pname: GLenum; const param: PGLfloat);
begin
  if Assigned(FglTextureParameterfv) then
  begin
    FglTextureParameterfv(texture, pname, param);
  end
  else
  begin
    raise Exception.Create('glTextureParameterfv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureParameteri(texture: GLuint; pname: GLenum; param: GLint);
begin
  if Assigned(FglTextureParameteri) then
  begin
    FglTextureParameteri(texture, pname, param);
  end
  else
  begin
    raise Exception.Create('glTextureParameteri not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureParameterIiv(texture: GLuint; pname: GLenum; const params: PGLint);
begin
  if Assigned(FglTextureParameterIiv) then
  begin
    FglTextureParameterIiv(texture, pname, params);
  end
  else
  begin
    raise Exception.Create('glTextureParameterIiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureParameterIuiv(texture: GLuint; pname: GLenum; const params: PGLuint);
begin
  if Assigned(FglTextureParameterIuiv) then
  begin
    FglTextureParameterIuiv(texture, pname, params);
  end
  else
  begin
    raise Exception.Create('glTextureParameterIuiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureParameteriv(texture: GLuint; pname: GLenum; const param: PGLint);
begin
  if Assigned(FglTextureParameteriv) then
  begin
    FglTextureParameteriv(texture, pname, param);
  end
  else
  begin
    raise Exception.Create('glTextureParameteriv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGenerateTextureMipmap(texture: GLuint);
begin
  if Assigned(FglGenerateTextureMipmap) then
  begin
    FglGenerateTextureMipmap(texture);
  end
  else
  begin
    raise Exception.Create('glGenerateTextureMipmap not bound');
  end;
end;

procedure TGL_VERSION_4_5.glBindTextureUnit(aUnit: GLuint; texture: GLuint);
begin
  if Assigned(FglBindTextureUnit) then
  begin
    FglBindTextureUnit(aUnit, texture);
  end
  else
  begin
    raise Exception.Create('glBindTextureUnit not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTextureImage(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FglGetTextureImage) then
  begin
    FglGetTextureImage(texture, level, format, aType, bufSize, pixels);
  end
  else
  begin
    raise Exception.Create('glGetTextureImage not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetCompressedTextureImage(texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FglGetCompressedTextureImage) then
  begin
    FglGetCompressedTextureImage(texture, level, bufSize, pixels);
  end
  else
  begin
    raise Exception.Create('glGetCompressedTextureImage not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTextureLevelParameterfv(texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetTextureLevelParameterfv) then
  begin
    FglGetTextureLevelParameterfv(texture, level, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTextureLevelParameterfv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTextureLevelParameteriv(texture: GLuint; level: GLint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetTextureLevelParameteriv) then
  begin
    FglGetTextureLevelParameteriv(texture, level, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTextureLevelParameteriv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTextureParameterfv(texture: GLuint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FglGetTextureParameterfv) then
  begin
    FglGetTextureParameterfv(texture, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTextureParameterfv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTextureParameterIiv(texture: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetTextureParameterIiv) then
  begin
    FglGetTextureParameterIiv(texture, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTextureParameterIiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTextureParameterIuiv(texture: GLuint; pname: GLenum; params: PGLuint);
begin
  if Assigned(FglGetTextureParameterIuiv) then
  begin
    FglGetTextureParameterIuiv(texture, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTextureParameterIuiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTextureParameteriv(texture: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FglGetTextureParameteriv) then
  begin
    FglGetTextureParameteriv(texture, pname, params);
  end
  else
  begin
    raise Exception.Create('glGetTextureParameteriv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCreateVertexArrays(n: GLsizei; arrays: PGLuint);
begin
  if Assigned(FglCreateVertexArrays) then
  begin
    FglCreateVertexArrays(n, arrays);
  end
  else
  begin
    raise Exception.Create('glCreateVertexArrays not bound');
  end;
end;

procedure TGL_VERSION_4_5.glDisableVertexArrayAttrib(vaobj: GLuint; index: GLuint);
begin
  if Assigned(FglDisableVertexArrayAttrib) then
  begin
    FglDisableVertexArrayAttrib(vaobj, index);
  end
  else
  begin
    raise Exception.Create('glDisableVertexArrayAttrib not bound');
  end;
end;

procedure TGL_VERSION_4_5.glEnableVertexArrayAttrib(vaobj: GLuint; index: GLuint);
begin
  if Assigned(FglEnableVertexArrayAttrib) then
  begin
    FglEnableVertexArrayAttrib(vaobj, index);
  end
  else
  begin
    raise Exception.Create('glEnableVertexArrayAttrib not bound');
  end;
end;

procedure TGL_VERSION_4_5.glVertexArrayElementBuffer(vaobj: GLuint; buffer: GLuint);
begin
  if Assigned(FglVertexArrayElementBuffer) then
  begin
    FglVertexArrayElementBuffer(vaobj, buffer);
  end
  else
  begin
    raise Exception.Create('glVertexArrayElementBuffer not bound');
  end;
end;

procedure TGL_VERSION_4_5.glVertexArrayVertexBuffer(vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei);
begin
  if Assigned(FglVertexArrayVertexBuffer) then
  begin
    FglVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
  end
  else
  begin
    raise Exception.Create('glVertexArrayVertexBuffer not bound');
  end;
end;

procedure TGL_VERSION_4_5.glVertexArrayVertexBuffers(vaobj: GLuint; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei);
begin
  if Assigned(FglVertexArrayVertexBuffers) then
  begin
    FglVertexArrayVertexBuffers(vaobj, First, Count, buffers, offsets, strides);
  end
  else
  begin
    raise Exception.Create('glVertexArrayVertexBuffers not bound');
  end;
end;

procedure TGL_VERSION_4_5.glVertexArrayAttribBinding(vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint);
begin
  if Assigned(FglVertexArrayAttribBinding) then
  begin
    FglVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
  end
  else
  begin
    raise Exception.Create('glVertexArrayAttribBinding not bound');
  end;
end;

procedure TGL_VERSION_4_5.glVertexArrayAttribFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint);
begin
  if Assigned(FglVertexArrayAttribFormat) then
  begin
    FglVertexArrayAttribFormat(vaobj, attribindex, size, aType, normalized, relativeoffset);
  end
  else
  begin
    raise Exception.Create('glVertexArrayAttribFormat not bound');
  end;
end;

procedure TGL_VERSION_4_5.glVertexArrayAttribIFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
begin
  if Assigned(FglVertexArrayAttribIFormat) then
  begin
    FglVertexArrayAttribIFormat(vaobj, attribindex, size, aType, relativeoffset);
  end
  else
  begin
    raise Exception.Create('glVertexArrayAttribIFormat not bound');
  end;
end;

procedure TGL_VERSION_4_5.glVertexArrayAttribLFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
begin
  if Assigned(FglVertexArrayAttribLFormat) then
  begin
    FglVertexArrayAttribLFormat(vaobj, attribindex, size, aType, relativeoffset);
  end
  else
  begin
    raise Exception.Create('glVertexArrayAttribLFormat not bound');
  end;
end;

procedure TGL_VERSION_4_5.glVertexArrayBindingDivisor(vaobj: GLuint; bindingindex: GLuint; divisor: GLuint);
begin
  if Assigned(FglVertexArrayBindingDivisor) then
  begin
    FglVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
  end
  else
  begin
    raise Exception.Create('glVertexArrayBindingDivisor not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetVertexArrayiv(vaobj: GLuint; pname: GLenum; param: PGLint);
begin
  if Assigned(FglGetVertexArrayiv) then
  begin
    FglGetVertexArrayiv(vaobj, pname, param);
  end
  else
  begin
    raise Exception.Create('glGetVertexArrayiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetVertexArrayIndexediv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint);
begin
  if Assigned(FglGetVertexArrayIndexediv) then
  begin
    FglGetVertexArrayIndexediv(vaobj, index, pname, param);
  end
  else
  begin
    raise Exception.Create('glGetVertexArrayIndexediv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetVertexArrayIndexed64iv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64);
begin
  if Assigned(FglGetVertexArrayIndexed64iv) then
  begin
    FglGetVertexArrayIndexed64iv(vaobj, index, pname, param);
  end
  else
  begin
    raise Exception.Create('glGetVertexArrayIndexed64iv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCreateSamplers(n: GLsizei; samplers: PGLuint);
begin
  if Assigned(FglCreateSamplers) then
  begin
    FglCreateSamplers(n, samplers);
  end
  else
  begin
    raise Exception.Create('glCreateSamplers not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCreateProgramPipelines(n: GLsizei; pipelines: PGLuint);
begin
  if Assigned(FglCreateProgramPipelines) then
  begin
    FglCreateProgramPipelines(n, pipelines);
  end
  else
  begin
    raise Exception.Create('glCreateProgramPipelines not bound');
  end;
end;

procedure TGL_VERSION_4_5.glCreateQueries(target: GLenum; n: GLsizei; ids: PGLuint);
begin
  if Assigned(FglCreateQueries) then
  begin
    FglCreateQueries(target, n, ids);
  end
  else
  begin
    raise Exception.Create('glCreateQueries not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetQueryBufferObjecti64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
begin
  if Assigned(FglGetQueryBufferObjecti64v) then
  begin
    FglGetQueryBufferObjecti64v(id, buffer, pname, offset);
  end
  else
  begin
    raise Exception.Create('glGetQueryBufferObjecti64v not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetQueryBufferObjectiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
begin
  if Assigned(FglGetQueryBufferObjectiv) then
  begin
    FglGetQueryBufferObjectiv(id, buffer, pname, offset);
  end
  else
  begin
    raise Exception.Create('glGetQueryBufferObjectiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetQueryBufferObjectui64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
begin
  if Assigned(FglGetQueryBufferObjectui64v) then
  begin
    FglGetQueryBufferObjectui64v(id, buffer, pname, offset);
  end
  else
  begin
    raise Exception.Create('glGetQueryBufferObjectui64v not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetQueryBufferObjectuiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
begin
  if Assigned(FglGetQueryBufferObjectuiv) then
  begin
    FglGetQueryBufferObjectuiv(id, buffer, pname, offset);
  end
  else
  begin
    raise Exception.Create('glGetQueryBufferObjectuiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glMemoryBarrierByRegion(barriers: GLbitfield);
begin
  if Assigned(FglMemoryBarrierByRegion) then
  begin
    FglMemoryBarrierByRegion(barriers);
  end
  else
  begin
    raise Exception.Create('glMemoryBarrierByRegion not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetTextureSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FglGetTextureSubImage) then
  begin
    FglGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, Width, Height, depth, format, aType, bufSize, pixels);
  end
  else
  begin
    raise Exception.Create('glGetTextureSubImage not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetCompressedTextureSubImage(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FglGetCompressedTextureSubImage) then
  begin
    FglGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, Width, Height, depth, bufSize, pixels);
  end
  else
  begin
    raise Exception.Create('glGetCompressedTextureSubImage not bound');
  end;
end;

function TGL_VERSION_4_5.glGetGraphicsResetStatus(): GLenum;
begin
  if Assigned(FglGetGraphicsResetStatus) then
  begin
    Result := FglGetGraphicsResetStatus();
  end
  else
  begin
    raise Exception.Create('glGetGraphicsResetStatus not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnCompressedTexImage(target: GLenum; lod: GLint; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FglGetnCompressedTexImage) then
  begin
    FglGetnCompressedTexImage(target, lod, bufSize, pixels);
  end
  else
  begin
    raise Exception.Create('glGetnCompressedTexImage not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnTexImage(target: GLenum; level: GLint; format: GLenum; aType: GLenum; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FglGetnTexImage) then
  begin
    FglGetnTexImage(target, level, format, aType, bufSize, pixels);
  end
  else
  begin
    raise Exception.Create('glGetnTexImage not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnUniformdv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble);
begin
  if Assigned(FglGetnUniformdv) then
  begin
    FglGetnUniformdv(aProgram, location, bufSize, params);
  end
  else
  begin
    raise Exception.Create('glGetnUniformdv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnUniformfv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat);
begin
  if Assigned(FglGetnUniformfv) then
  begin
    FglGetnUniformfv(aProgram, location, bufSize, params);
  end
  else
  begin
    raise Exception.Create('glGetnUniformfv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnUniformiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLint);
begin
  if Assigned(FglGetnUniformiv) then
  begin
    FglGetnUniformiv(aProgram, location, bufSize, params);
  end
  else
  begin
    raise Exception.Create('glGetnUniformiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnUniformuiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint);
begin
  if Assigned(FglGetnUniformuiv) then
  begin
    FglGetnUniformuiv(aProgram, location, bufSize, params);
  end
  else
  begin
    raise Exception.Create('glGetnUniformuiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glReadnPixels(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; aType: GLenum; bufSize: GLsizei; Data: Pointer);
begin
  if Assigned(FglReadnPixels) then
  begin
    FglReadnPixels(x, y, Width, Height, format, aType, bufSize, Data);
  end
  else
  begin
    raise Exception.Create('glReadnPixels not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnMapdv(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLdouble);
begin
  if Assigned(FglGetnMapdv) then
  begin
    FglGetnMapdv(target, query, bufSize, v);
  end
  else
  begin
    raise Exception.Create('glGetnMapdv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnMapfv(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLfloat);
begin
  if Assigned(FglGetnMapfv) then
  begin
    FglGetnMapfv(target, query, bufSize, v);
  end
  else
  begin
    raise Exception.Create('glGetnMapfv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnMapiv(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLint);
begin
  if Assigned(FglGetnMapiv) then
  begin
    FglGetnMapiv(target, query, bufSize, v);
  end
  else
  begin
    raise Exception.Create('glGetnMapiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnPixelMapfv(map: GLenum; bufSize: GLsizei; values: PGLfloat);
begin
  if Assigned(FglGetnPixelMapfv) then
  begin
    FglGetnPixelMapfv(map, bufSize, values);
  end
  else
  begin
    raise Exception.Create('glGetnPixelMapfv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnPixelMapuiv(map: GLenum; bufSize: GLsizei; values: PGLuint);
begin
  if Assigned(FglGetnPixelMapuiv) then
  begin
    FglGetnPixelMapuiv(map, bufSize, values);
  end
  else
  begin
    raise Exception.Create('glGetnPixelMapuiv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnPixelMapusv(map: GLenum; bufSize: GLsizei; values: PGLushort);
begin
  if Assigned(FglGetnPixelMapusv) then
  begin
    FglGetnPixelMapusv(map, bufSize, values);
  end
  else
  begin
    raise Exception.Create('glGetnPixelMapusv not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnPolygonStipple(bufSize: GLsizei; pattern: PGLubyte);
begin
  if Assigned(FglGetnPolygonStipple) then
  begin
    FglGetnPolygonStipple(bufSize, pattern);
  end
  else
  begin
    raise Exception.Create('glGetnPolygonStipple not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnColorTable(target: GLenum; format: GLenum; aType: GLenum; bufSize: GLsizei; table: Pointer);
begin
  if Assigned(FglGetnColorTable) then
  begin
    FglGetnColorTable(target, format, aType, bufSize, table);
  end
  else
  begin
    raise Exception.Create('glGetnColorTable not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnConvolutionFilter(target: GLenum; format: GLenum; aType: GLenum; bufSize: GLsizei; image: Pointer);
begin
  if Assigned(FglGetnConvolutionFilter) then
  begin
    FglGetnConvolutionFilter(target, format, aType, bufSize, image);
  end
  else
  begin
    raise Exception.Create('glGetnConvolutionFilter not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnSeparableFilter(target: GLenum; format: GLenum; aType: GLenum; rowBufSize: GLsizei; row: Pointer; columnBufSize: GLsizei; column: Pointer; span: Pointer);
begin
  if Assigned(FglGetnSeparableFilter) then
  begin
    FglGetnSeparableFilter(target, format, aType, rowBufSize, row, columnBufSize, column, span);
  end
  else
  begin
    raise Exception.Create('glGetnSeparableFilter not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnHistogram(target: GLenum; reset: GLboolean; format: GLenum; aType: GLenum; bufSize: GLsizei; values: Pointer);
begin
  if Assigned(FglGetnHistogram) then
  begin
    FglGetnHistogram(target, reset, format, aType, bufSize, values);
  end
  else
  begin
    raise Exception.Create('glGetnHistogram not bound');
  end;
end;

procedure TGL_VERSION_4_5.glGetnMinmax(target: GLenum; reset: GLboolean; format: GLenum; aType: GLenum; bufSize: GLsizei; values: Pointer);
begin
  if Assigned(FglGetnMinmax) then
  begin
    FglGetnMinmax(target, reset, format, aType, bufSize, values);
  end
  else
  begin
    raise Exception.Create('glGetnMinmax not bound');
  end;
end;

procedure TGL_VERSION_4_5.glTextureBarrier();
begin
  if Assigned(FglTextureBarrier) then
  begin
    FglTextureBarrier();
  end
  else
  begin
    raise Exception.Create('glTextureBarrier not bound');
  end;
end;

procedure TGL_VERSION_4_6.bindEntry;
begin
  inherited bindEntry;
  Bind(Pointer(FglSpecializeShader), 'glSpecializeShader');
  Bind(Pointer(FglMultiDrawArraysIndirectCount), 'glMultiDrawArraysIndirectCount');
  Bind(Pointer(FglMultiDrawElementsIndirectCount), 'glMultiDrawElementsIndirectCount');
  Bind(Pointer(FglPolygonOffsetClamp), 'glPolygonOffsetClamp');
end;

procedure TGL_VERSION_4_6.glSpecializeShader(shader: GLuint; const pEntryPoint: PGLchar; numSpecializationConstants: GLuint; const pConstantIndex: PGLuint; const pConstantValue: PGLuint);
begin
  if Assigned(FglSpecializeShader) then
  begin
    FglSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
  end
  else
  begin
    raise Exception.Create('glSpecializeShader not bound');
  end;
end;

procedure TGL_VERSION_4_6.glMultiDrawArraysIndirectCount(mode: GLenum; const indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei);
begin
  if Assigned(FglMultiDrawArraysIndirectCount) then
  begin
    FglMultiDrawArraysIndirectCount(mode, indirect, drawcount, maxdrawcount, stride);
  end
  else
  begin
    raise Exception.Create('glMultiDrawArraysIndirectCount not bound');
  end;
end;

procedure TGL_VERSION_4_6.glMultiDrawElementsIndirectCount(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei);
begin
  if Assigned(FglMultiDrawElementsIndirectCount) then
  begin
    FglMultiDrawElementsIndirectCount(mode, aType, indirect, drawcount, maxdrawcount, stride);
  end
  else
  begin
    raise Exception.Create('glMultiDrawElementsIndirectCount not bound');
  end;
end;

procedure TGL_VERSION_4_6.glPolygonOffsetClamp(factor: GLfloat; units: GLfloat; clamp: GLfloat);
begin
  if Assigned(FglPolygonOffsetClamp) then
  begin
    FglPolygonOffsetClamp(factor, units, clamp);
  end
  else
  begin
    raise Exception.Create('glPolygonOffsetClamp not bound');
  end;
end;


function GetOpenGL: IOpenGL;
var
  Base: TGL_VERSION_4_6;
begin
  if singleton = nil then
  begin
    base := TGL_VERSION_4_6.Create;
    base.LoadLibrary;
    Base.bindEntry;
    singleton := Base;
  end;
  Result := singleton;
end;

initialization

  singleton := nil;

finalization

  singleton := nil;

end.
