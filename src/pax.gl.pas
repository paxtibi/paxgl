unit pax.gl;

{$mode objfpc}{$H+}
{$modeswitch advancedrecords}
{$WARN 5062 off : Found abstract method: $1}
{$WARN 4046 off : Constructing a class "$1" with abstract method "$2"}
interface

uses
  Classes, SysUtils;

const
  {$IFDEF WINDOWS}
    libGL = 'opengl32.dll';
  {$ELSEIF DEFINED(LINUX)}
    libGL = 'libGL.so.1';
  {$ELSEIF DEFINED(DARWIN)}
    libGL = 'OpenGL';
  {$ELSE}
  libGL = '';
  {$ENDIF}

  {$DEFINE OPENGL_CORE_4_6}

const
  // OGL 1.0
  GL_DEPTH_BUFFER_BIT = $00000100;
  GL_STENCIL_BUFFER_BIT = $00000400;
  GL_COLOR_BUFFER_BIT = $00004000;
  GL_FALSE = 0;
  GL_TRUE = 1;

  GL_POINTS = $0000;
  GL_LINES = $0001;
  GL_LINE_LOOP = $0002;
  GL_LINE_STRIP = $0003;
  GL_TRIANGLES = $0004;
  GL_TRIANGLE_STRIP = $0005;
  GL_TRIANGLE_FAN = $0006;
  GL_QUADS = $0007;
  GL_QUAD_STRIP = $0008;
  GL_POLYGON = $0009;

  GL_FLAT = $1D00;
  GL_SMOOTH = $1D01;

  GL_MODELVIEW = $1700;
  GL_PROJECTION = $1701;
  GL_TEXTURE = $1702;

  GL_MODELVIEW_MATRIX = $0BA6;
  GL_PROJECTION_MATRIX = $0BA7;

  GL_DEPTH_TEST = $0B71;
  GL_CULL_FACE = $0B44;
  GL_LIGHTING = $0B50;
  GL_COLOR_MATERIAL = $0B57;
  GL_NORMALIZE = $0BA1;
  GL_ALPHA_TEST = $0BC0;
  GL_BLEND = $0BE2;
  GL_FOG = $0B60;

  GL_FRONT = $0404;
  GL_BACK = $0405;
  GL_FRONT_AND_BACK = $0408;

  GL_CW = $0900;
  GL_CCW = $0901;

  GL_ZERO = 0;
  GL_ONE = 1;
  GL_SRC_COLOR = $0300;
  GL_ONE_MINUS_SRC_COLOR = $0301;
  GL_DST_COLOR = $0306;
  GL_ONE_MINUS_DST_COLOR = $0307;
  GL_SRC_ALPHA = $0302;
  GL_ONE_MINUS_SRC_ALPHA = $0303;
  GL_DST_ALPHA = $0304;
  GL_ONE_MINUS_DST_ALPHA = $0305;
  GL_CONSTANT_COLOR = $8001;
  GL_ONE_MINUS_CONSTANT_COLOR = $8002;
  GL_CONSTANT_ALPHA = $8003;
  GL_ONE_MINUS_CONSTANT_ALPHA = $8004;

  GL_LIGHT0 = $4000;
  GL_AMBIENT = $1200;
  GL_DIFFUSE = $1201;
  GL_SPECULAR = $1202;
  GL_POSITION = $1203;
  GL_EMISSION = $1600;

  GL_COMPILE = $1300;
  GL_AMBIENT_AND_DIFFUSE = $1602;

  {$IFNDEF OPENGL_CORE_4_6}
  GL_QUADS = $0007;
  {$ENDIF}
  GL_NEVER = $0200;
  GL_LESS = $0201;
  GL_EQUAL = $0202;
  GL_LEQUAL = $0203;
  GL_GREATER = $0204;
  GL_NOTEQUAL = $0205;
  GL_GEQUAL = $0206;
  GL_ALWAYS = $0207;
  GL_SRC_ALPHA_SATURATE = $0308;
  GL_NONE = 0;
  GL_FRONT_LEFT = $0400;
  GL_FRONT_RIGHT = $0401;
  GL_BACK_LEFT = $0402;
  GL_BACK_RIGHT = $0403;
  GL_LEFT = $0406;
  GL_RIGHT = $0407;
  GL_NO_ERROR = 0;
  GL_INVALID_ENUM = $0500;
  GL_INVALID_VALUE = $0501;
  GL_INVALID_OPERATION = $0502;
  GL_OUT_OF_MEMORY = $0505;
  GL_POINT_SIZE = $0B11;
  GL_POINT_SIZE_RANGE = $0B12;
  GL_POINT_SIZE_GRANULARITY = $0B13;
  GL_LINE_SMOOTH = $0B20;
  GL_LINE_WIDTH = $0B21;
  GL_LINE_WIDTH_RANGE = $0B22;
  GL_LINE_WIDTH_GRANULARITY = $0B23;
  GL_POLYGON_MODE = $0B40;
  GL_POLYGON_SMOOTH = $0B41;
  GL_CULL_FACE_MODE = $0B45;
  GL_FRONT_FACE = $0B46;
  GL_DEPTH_RANGE = $0B70;
  GL_DEPTH_WRITEMASK = $0B72;
  GL_DEPTH_CLEAR_VALUE = $0B73;
  GL_DEPTH_FUNC = $0B74;
  GL_STENCIL_TEST = $0B90;
  GL_STENCIL_CLEAR_VALUE = $0B91;
  GL_STENCIL_FUNC = $0B92;
  GL_STENCIL_VALUE_MASK = $0B93;
  GL_STENCIL_FAIL = $0B94;
  GL_STENCIL_PASS_DEPTH_FAIL = $0B95;
  GL_STENCIL_PASS_DEPTH_PASS = $0B96;
  GL_STENCIL_REF = $0B97;
  GL_STENCIL_WRITEMASK = $0B98;
  GL_VIEWPORT = $0BA2;
  GL_DITHER = $0BD0;
  GL_BLEND_DST = $0BE0;
  GL_BLEND_SRC = $0BE1;
  GL_LOGIC_OP_MODE = $0BF0;
  GL_DRAW_BUFFER = $0C01;
  GL_READ_BUFFER = $0C02;
  GL_SCISSOR_BOX = $0C10;
  GL_SCISSOR_TEST = $0C11;
  GL_COLOR_CLEAR_VALUE = $0C22;
  GL_COLOR_WRITEMASK = $0C23;
  GL_DOUBLEBUFFER = $0C32;
  GL_STEREO = $0C33;
  GL_LINE_SMOOTH_HINT = $0C52;
  GL_POLYGON_SMOOTH_HINT = $0C53;
  GL_UNPACK_SWAP_BYTES = $0CF0;
  GL_UNPACK_LSB_FIRST = $0CF1;
  GL_UNPACK_ROW_LENGTH = $0CF2;
  GL_UNPACK_SKIP_ROWS = $0CF3;
  GL_UNPACK_SKIP_PIXELS = $0CF4;
  GL_UNPACK_ALIGNMENT = $0CF5;
  GL_PACK_SWAP_BYTES = $0D00;
  GL_PACK_LSB_FIRST = $0D01;
  GL_PACK_ROW_LENGTH = $0D02;
  GL_PACK_SKIP_ROWS = $0D03;
  GL_PACK_SKIP_PIXELS = $0D04;
  GL_PACK_ALIGNMENT = $0D05;
  GL_MAX_TEXTURE_SIZE = $0D33;
  GL_MAX_VIEWPORT_DIMS = $0D3A;
  GL_SUBPIXEL_BITS = $0D50;
  GL_TEXTURE_1D = $0DE0;
  GL_TEXTURE_2D = $0DE1;
  GL_TEXTURE_WIDTH = $1000;
  GL_TEXTURE_HEIGHT = $1001;
  GL_TEXTURE_BORDER_COLOR = $1004;
  GL_DONT_CARE = $1100;
  GL_FASTEST = $1101;
  GL_NICEST = $1102;
  GL_BYTE = $1400;
  GL_UNSIGNED_BYTE = $1401;
  GL_SHORT = $1402;
  GL_UNSIGNED_SHORT = $1403;
  GL_INT = $1404;
  GL_UNSIGNED_INT = $1405;
  GL_FLOAT = $1406;
  GL_STACK_OVERFLOW = $0503;
  GL_STACK_UNDERFLOW = $0504;
  GL_CLEAR = $1500;
  GL_AND = $1501;
  GL_AND_REVERSE = $1502;
  GL_COPY = $1503;
  GL_AND_INVERTED = $1504;
  GL_NOOP = $1505;
  GL_XOR = $1506;
  GL_OR = $1507;
  GL_NOR = $1508;
  GL_EQUIV = $1509;
  GL_INVERT = $150A;
  GL_OR_REVERSE = $150B;
  GL_COPY_INVERTED = $150C;
  GL_OR_INVERTED = $150D;
  GL_NAND = $150E;
  GL_SET = $150F;
  GL_COLOR = $1800;
  GL_DEPTH = $1801;
  GL_STENCIL = $1802;
  GL_STENCIL_INDEX = $1901;
  GL_DEPTH_COMPONENT = $1902;
  GL_RED = $1903;
  GL_GREEN = $1904;
  GL_BLUE = $1905;
  GL_ALPHA = $1906;
  GL_RGB = $1907;
  GL_RGBA = $1908;
  GL_LUMINANCE = $1909;
  GL_POINT = $1B00;
  GL_LINE = $1B01;
  GL_FILL = $1B02;
  GL_KEEP = $1E00;
  GL_REPLACE = $1E01;
  GL_INCR = $1E02;
  GL_DECR = $1E03;
  GL_VENDOR = $1F00;
  GL_RENDERER = $1F01;
  GL_VERSION = $1F02;
  GL_EXTENSIONS = $1F03;
  GL_NEAREST = $2600;
  GL_LINEAR = $2601;
  GL_NEAREST_MIPMAP_NEAREST = $2700;
  GL_LINEAR_MIPMAP_NEAREST = $2701;
  GL_NEAREST_MIPMAP_LINEAR = $2702;
  GL_LINEAR_MIPMAP_LINEAR = $2703;
  GL_TEXTURE_MAG_FILTER = $2800;
  GL_TEXTURE_MIN_FILTER = $2801;
  GL_TEXTURE_WRAP_S = $2802;
  GL_TEXTURE_WRAP_T = $2803;
  GL_CLAMP = $2900;
  GL_REPEAT = $2901;
  // OGL 1.1
  GL_COLOR_LOGIC_OP = $0BF2;
  GL_POLYGON_OFFSET_UNITS = $2A00;
  GL_POLYGON_OFFSET_POINT = $2A01;
  GL_POLYGON_OFFSET_LINE = $2A02;
  GL_POLYGON_OFFSET_FILL = $8037;
  GL_POLYGON_OFFSET_FACTOR = $8038;
  GL_TEXTURE_BINDING_1D = $8068;
  GL_TEXTURE_BINDING_2D = $8069;
  GL_TEXTURE_INTERNAL_FORMAT = $1003;
  GL_TEXTURE_RED_SIZE = $805C;
  GL_TEXTURE_GREEN_SIZE = $805D;
  GL_TEXTURE_BLUE_SIZE = $805E;
  GL_TEXTURE_ALPHA_SIZE = $805F;
  GL_DOUBLE = $140A;
  GL_PROXY_TEXTURE_1D = $8063;
  GL_PROXY_TEXTURE_2D = $8064;
  GL_R3_G3_B2 = $2A10;
  GL_RGB4 = $804F;
  GL_RGB5 = $8050;
  GL_RGB8 = $8051;
  GL_RGB10 = $8052;
  GL_RGB12 = $8053;
  GL_RGB16 = $8054;
  GL_RGBA2 = $8055;
  GL_RGBA4 = $8056;
  GL_RGB5_A1 = $8057;
  GL_RGBA8 = $8058;
  GL_RGB10_A2 = $8059;
  GL_RGBA12 = $805A;
  GL_RGBA16 = $805B;
  GL_VERTEX_ARRAY = $8074;
  // OGL 1.2
  GL_UNSIGNED_BYTE_3_3_2 = $8032;
  GL_UNSIGNED_SHORT_4_4_4_4 = $8033;
  GL_UNSIGNED_SHORT_5_5_5_1 = $8034;
  GL_UNSIGNED_INT_8_8_8_8 = $8035;
  GL_UNSIGNED_INT_10_10_10_2 = $8036;
  GL_TEXTURE_BINDING_3D = $806A;
  GL_PACK_SKIP_IMAGES = $806B;
  GL_PACK_IMAGE_HEIGHT = $806C;
  GL_UNPACK_SKIP_IMAGES = $806D;
  GL_UNPACK_IMAGE_HEIGHT = $806E;
  GL_TEXTURE_3D = $806F;
  GL_PROXY_TEXTURE_3D = $8070;
  GL_TEXTURE_DEPTH = $8071;
  GL_TEXTURE_WRAP_R = $8072;
  GL_MAX_3D_TEXTURE_SIZE = $8073;
  GL_UNSIGNED_BYTE_2_3_3_REV = $8362;
  GL_UNSIGNED_SHORT_5_6_5 = $8363;
  GL_UNSIGNED_SHORT_5_6_5_REV = $8364;
  GL_UNSIGNED_SHORT_4_4_4_4_REV = $8365;
  GL_UNSIGNED_SHORT_1_5_5_5_REV = $8366;
  GL_UNSIGNED_INT_8_8_8_8_REV = $8367;
  GL_UNSIGNED_INT_2_10_10_10_REV = $8368;
  GL_BGR = $80E0;
  GL_BGRA = $80E1;
  GL_MAX_ELEMENTS_VERTICES = $80E8;
  GL_MAX_ELEMENTS_INDICES = $80E9;
  GL_CLAMP_TO_EDGE = $812F;
  GL_TEXTURE_MIN_LOD = $813A;
  GL_TEXTURE_MAX_LOD = $813B;
  GL_TEXTURE_BASE_LEVEL = $813C;
  GL_TEXTURE_MAX_LEVEL = $813D;
  GL_SMOOTH_POINT_SIZE_RANGE = $0B12;
  GL_SMOOTH_POINT_SIZE_GRANULARITY = $0B13;
  GL_SMOOTH_LINE_WIDTH_RANGE = $0B22;
  GL_SMOOTH_LINE_WIDTH_GRANULARITY = $0B23;
  GL_ALIASED_LINE_WIDTH_RANGE = $846E;
  // OGL 1.3
  GL_TEXTURE0 = $84C0;
  GL_TEXTURE1 = $84C1;
  GL_TEXTURE2 = $84C2;
  GL_TEXTURE3 = $84C3;
  GL_TEXTURE4 = $84C4;
  GL_TEXTURE5 = $84C5;
  GL_TEXTURE6 = $84C6;
  GL_TEXTURE7 = $84C7;
  GL_TEXTURE8 = $84C8;
  GL_TEXTURE9 = $84C9;
  GL_TEXTURE10 = $84CA;
  GL_TEXTURE11 = $84CB;
  GL_TEXTURE12 = $84CC;
  GL_TEXTURE13 = $84CD;
  GL_TEXTURE14 = $84CE;
  GL_TEXTURE15 = $84CF;
  GL_TEXTURE16 = $84D0;
  GL_TEXTURE17 = $84D1;
  GL_TEXTURE18 = $84D2;
  GL_TEXTURE19 = $84D3;
  GL_TEXTURE20 = $84D4;
  GL_TEXTURE21 = $84D5;
  GL_TEXTURE22 = $84D6;
  GL_TEXTURE23 = $84D7;
  GL_TEXTURE24 = $84D8;
  GL_TEXTURE25 = $84D9;
  GL_TEXTURE26 = $84DA;
  GL_TEXTURE27 = $84DB;
  GL_TEXTURE28 = $84DC;
  GL_TEXTURE29 = $84DD;
  GL_TEXTURE30 = $84DE;
  GL_TEXTURE31 = $84DF;
  GL_ACTIVE_TEXTURE = $84E0;
  GL_MULTISAMPLE = $809D;
  GL_SAMPLE_ALPHA_TO_COVERAGE = $809E;
  GL_SAMPLE_ALPHA_TO_ONE = $809F;
  GL_SAMPLE_COVERAGE = $80A0;
  GL_SAMPLE_BUFFERS = $80A8;
  GL_SAMPLES = $80A9;
  GL_SAMPLE_COVERAGE_VALUE = $80AA;
  GL_SAMPLE_COVERAGE_INVERT = $80AB;
  GL_TEXTURE_CUBE_MAP = $8513;
  GL_TEXTURE_BINDING_CUBE_MAP = $8514;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X = $8515;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X = $8516;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y = $8517;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = $8518;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z = $8519;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = $851A;
  GL_PROXY_TEXTURE_CUBE_MAP = $851B;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE = $851C;
  GL_COMPRESSED_RGB = $84ED;
  GL_COMPRESSED_RGBA = $84EE;
  GL_TEXTURE_COMPRESSION_HINT = $84EF;
  GL_TEXTURE_COMPRESSED_IMAGE_SIZE = $86A0;
  GL_TEXTURE_COMPRESSED = $86A1;
  GL_NUM_COMPRESSED_TEXTURE_FORMATS = $86A2;
  GL_COMPRESSED_TEXTURE_FORMATS = $86A3;
  GL_CLAMP_TO_BORDER = $812D;
  // OGL 1.4
  GL_BLEND_DST_RGB = $80C8;
  GL_BLEND_SRC_RGB = $80C9;
  GL_BLEND_DST_ALPHA = $80CA;
  GL_BLEND_SRC_ALPHA = $80CB;
  GL_POINT_FADE_THRESHOLD_SIZE = $8128;
  GL_DEPTH_COMPONENT16 = $81A5;
  GL_DEPTH_COMPONENT24 = $81A6;
  GL_DEPTH_COMPONENT32 = $81A7;
  GL_MIRRORED_REPEAT = $8370;
  GL_MAX_TEXTURE_LOD_BIAS = $84FD;
  GL_TEXTURE_LOD_BIAS = $8501;
  GL_INCR_WRAP = $8507;
  GL_DECR_WRAP = $8508;
  GL_TEXTURE_DEPTH_SIZE = $884A;
  GL_TEXTURE_COMPARE_MODE = $884C;
  GL_TEXTURE_COMPARE_FUNC = $884D;
  GL_BLEND_COLOR = $8005;
  GL_BLEND_EQUATION = $8009;
  GL_FUNC_ADD = $8006;
  GL_FUNC_REVERSE_SUBTRACT = $800B;
  GL_FUNC_SUBTRACT = $800A;
  GL_MIN = $8007;
  GL_MAX = $8008;
  // OGL 1.5
  GL_BUFFER_SIZE = $8764;
  GL_BUFFER_USAGE = $8765;
  GL_QUERY_COUNTER_BITS = $8864;
  GL_CURRENT_QUERY = $8865;
  GL_QUERY_RESULT = $8866;
  GL_QUERY_RESULT_AVAILABLE = $8867;
  GL_ARRAY_BUFFER = $8892;
  GL_ELEMENT_ARRAY_BUFFER = $8893;
  GL_ARRAY_BUFFER_BINDING = $8894;
  GL_ELEMENT_ARRAY_BUFFER_BINDING = $8895;
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = $889F;
  GL_READ_ONLY = $88B8;
  GL_WRITE_ONLY = $88B9;
  GL_READ_WRITE = $88BA;
  GL_BUFFER_ACCESS = $88BB;
  GL_BUFFER_MAPPED = $88BC;
  GL_BUFFER_MAP_POINTER = $88BD;
  GL_STREAM_DRAW = $88E0;
  GL_STREAM_READ = $88E1;
  GL_STREAM_COPY = $88E2;
  GL_STATIC_DRAW = $88E4;
  GL_STATIC_READ = $88E5;
  GL_STATIC_COPY = $88E6;
  GL_DYNAMIC_DRAW = $88E8;
  GL_DYNAMIC_READ = $88E9;
  GL_DYNAMIC_COPY = $88EA;
  GL_SAMPLES_PASSED = $8914;
  GL_SRC1_ALPHA = $8589;
  // OGL 2.0
  GL_BLEND_EQUATION_RGB = $8009;
  GL_VERTEX_ATTRIB_ARRAY_ENABLED = $8622;
  GL_VERTEX_ATTRIB_ARRAY_SIZE = $8623;
  GL_VERTEX_ATTRIB_ARRAY_STRIDE = $8624;
  GL_VERTEX_ATTRIB_ARRAY_TYPE = $8625;
  GL_CURRENT_VERTEX_ATTRIB = $8626;
  GL_VERTEX_PROGRAM_POINT_SIZE = $8642;
  GL_VERTEX_ATTRIB_ARRAY_POINTER = $8645;
  GL_STENCIL_BACK_FUNC = $8800;
  GL_STENCIL_BACK_FAIL = $8801;
  GL_STENCIL_BACK_PASS_DEPTH_FAIL = $8802;
  GL_STENCIL_BACK_PASS_DEPTH_PASS = $8803;
  GL_MAX_DRAW_BUFFERS = $8824;
  GL_DRAW_BUFFER0 = $8825;
  GL_DRAW_BUFFER1 = $8826;
  GL_DRAW_BUFFER2 = $8827;
  GL_DRAW_BUFFER3 = $8828;
  GL_DRAW_BUFFER4 = $8829;
  GL_DRAW_BUFFER5 = $882A;
  GL_DRAW_BUFFER6 = $882B;
  GL_DRAW_BUFFER7 = $882C;
  GL_DRAW_BUFFER8 = $882D;
  GL_DRAW_BUFFER9 = $882E;
  GL_DRAW_BUFFER10 = $882F;
  GL_DRAW_BUFFER11 = $8830;
  GL_DRAW_BUFFER12 = $8831;
  GL_DRAW_BUFFER13 = $8832;
  GL_DRAW_BUFFER14 = $8833;
  GL_DRAW_BUFFER15 = $8834;
  GL_BLEND_EQUATION_ALPHA = $883D;
  GL_MAX_VERTEX_ATTRIBS = $8869;
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = $886A;
  GL_MAX_TEXTURE_IMAGE_UNITS = $8872;
  GL_FRAGMENT_SHADER = $8B30;
  GL_VERTEX_SHADER = $8B31;
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = $8B49;
  GL_MAX_VERTEX_UNIFORM_COMPONENTS = $8B4A;
  GL_MAX_VARYING_FLOATS = $8B4B;
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = $8B4C;
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = $8B4D;
  GL_SHADER_TYPE = $8B4F;
  GL_FLOAT_VEC2 = $8B50;
  GL_FLOAT_VEC3 = $8B51;
  GL_FLOAT_VEC4 = $8B52;
  GL_INT_VEC2 = $8B53;
  GL_INT_VEC3 = $8B54;
  GL_INT_VEC4 = $8B55;
  GL_BOOL = $8B56;
  GL_BOOL_VEC2 = $8B57;
  GL_BOOL_VEC3 = $8B58;
  GL_BOOL_VEC4 = $8B59;
  GL_FLOAT_MAT2 = $8B5A;
  GL_FLOAT_MAT3 = $8B5B;
  GL_FLOAT_MAT4 = $8B5C;
  GL_SAMPLER_1D = $8B5D;
  GL_SAMPLER_2D = $8B5E;
  GL_SAMPLER_3D = $8B5F;
  GL_SAMPLER_CUBE = $8B60;
  GL_SAMPLER_1D_SHADOW = $8B61;
  GL_SAMPLER_2D_SHADOW = $8B62;
  GL_DELETE_STATUS = $8B80;
  GL_COMPILE_STATUS = $8B81;
  GL_LINK_STATUS = $8B82;
  GL_VALIDATE_STATUS = $8B83;
  GL_INFO_LOG_LENGTH = $8B84;
  GL_ATTACHED_SHADERS = $8B85;
  GL_ACTIVE_UNIFORMS = $8B86;
  GL_ACTIVE_UNIFORM_MAX_LENGTH = $8B87;
  GL_SHADER_SOURCE_LENGTH = $8B88;
  GL_ACTIVE_ATTRIBUTES = $8B89;
  GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = $8B8A;
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT = $8B8B;
  GL_SHADING_LANGUAGE_VERSION = $8B8C;
  GL_CURRENT_PROGRAM = $8B8D;
  GL_POINT_SPRITE_COORD_ORIGIN = $8CA0;
  GL_LOWER_LEFT = $8CA1;
  GL_UPPER_LEFT = $8CA2;
  GL_STENCIL_BACK_REF = $8CA3;
  GL_STENCIL_BACK_VALUE_MASK = $8CA4;
  GL_STENCIL_BACK_WRITEMASK = $8CA5;
  // OGL 2.0
  GL_PIXEL_PACK_BUFFER = $88EB;
  GL_PIXEL_UNPACK_BUFFER = $88EC;
  GL_PIXEL_PACK_BUFFER_BINDING = $88ED;
  GL_PIXEL_UNPACK_BUFFER_BINDING = $88EF;
  GL_FLOAT_MAT2x3 = $8B65;
  GL_FLOAT_MAT2x4 = $8B66;
  GL_FLOAT_MAT3x2 = $8B67;
  GL_FLOAT_MAT3x4 = $8B68;
  GL_FLOAT_MAT4x2 = $8B69;
  GL_FLOAT_MAT4x3 = $8B6A;
  GL_SRGB = $8C40;
  GL_SRGB8 = $8C41;
  GL_SRGB_ALPHA = $8C42;
  GL_SRGB8_ALPHA8 = $8C43;
  GL_COMPRESSED_SRGB = $8C48;
  GL_COMPRESSED_SRGB_ALPHA = $8C49;
  // OGL 3.0
  GL_COMPARE_REF_TO_TEXTURE = $884E;
  GL_CLIP_DISTANCE0 = $3000;
  GL_CLIP_DISTANCE1 = $3001;
  GL_CLIP_DISTANCE2 = $3002;
  GL_CLIP_DISTANCE3 = $3003;
  GL_CLIP_DISTANCE4 = $3004;
  GL_CLIP_DISTANCE5 = $3005;
  GL_CLIP_DISTANCE6 = $3006;
  GL_CLIP_DISTANCE7 = $3007;
  GL_MAX_CLIP_DISTANCES = $0D32;
  GL_MAJOR_VERSION = $821B;
  GL_MINOR_VERSION = $821C;
  GL_NUM_EXTENSIONS = $821D;
  GL_CONTEXT_FLAGS = $821E;
  GL_COMPRESSED_RED = $8225;
  GL_COMPRESSED_RG = $8226;
  GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = $00000001;
  GL_RGBA32F = $8814;
  GL_RGB32F = $8815;
  GL_RGBA16F = $881A;
  GL_RGB16F = $881B;
  GL_VERTEX_ATTRIB_ARRAY_INTEGER = $88FD;
  GL_MAX_ARRAY_TEXTURE_LAYERS = $88FF;
  GL_MIN_PROGRAM_TEXEL_OFFSET = $8904;
  GL_MAX_PROGRAM_TEXEL_OFFSET = $8905;
  GL_CLAMP_READ_COLOR = $891C;
  GL_FIXED_ONLY = $891D;
  GL_MAX_VARYING_COMPONENTS = $8B4B;
  GL_TEXTURE_1D_ARRAY = $8C18;
  GL_PROXY_TEXTURE_1D_ARRAY = $8C19;
  GL_TEXTURE_2D_ARRAY = $8C1A;
  GL_PROXY_TEXTURE_2D_ARRAY = $8C1B;
  GL_TEXTURE_BINDING_1D_ARRAY = $8C1C;
  GL_TEXTURE_BINDING_2D_ARRAY = $8C1D;
  GL_R11F_G11F_B10F = $8C3A;
  GL_UNSIGNED_INT_10F_11F_11F_REV = $8C3B;
  GL_RGB9_E5 = $8C3D;
  GL_UNSIGNED_INT_5_9_9_9_REV = $8C3E;
  GL_TEXTURE_SHARED_SIZE = $8C3F;
  GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = $8C76;
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE = $8C7F;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = $8C80;
  GL_TRANSFORM_FEEDBACK_VARYINGS = $8C83;
  GL_TRANSFORM_FEEDBACK_BUFFER_START = $8C84;
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = $8C85;
  GL_PRIMITIVES_GENERATED = $8C87;
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = $8C88;
  GL_RASTERIZER_DISCARD = $8C89;
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = $8C8A;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = $8C8B;
  GL_INTERLEAVED_ATTRIBS = $8C8C;
  GL_SEPARATE_ATTRIBS = $8C8D;
  GL_TRANSFORM_FEEDBACK_BUFFER = $8C8E;
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = $8C8F;
  GL_RGBA32UI = $8D70;
  GL_RGB32UI = $8D71;
  GL_RGBA16UI = $8D76;
  GL_RGB16UI = $8D77;
  GL_RGBA8UI = $8D7C;
  GL_RGB8UI = $8D7D;
  GL_RGBA32I = $8D82;
  GL_RGB32I = $8D83;
  GL_RGBA16I = $8D88;
  GL_RGB16I = $8D89;
  GL_RGBA8I = $8D8E;
  GL_RGB8I = $8D8F;
  GL_RED_INTEGER = $8D94;
  GL_GREEN_INTEGER = $8D95;
  GL_BLUE_INTEGER = $8D96;
  GL_RGB_INTEGER = $8D98;
  GL_RGBA_INTEGER = $8D99;
  GL_BGR_INTEGER = $8D9A;
  GL_BGRA_INTEGER = $8D9B;
  GL_SAMPLER_1D_ARRAY = $8DC0;
  GL_SAMPLER_2D_ARRAY = $8DC1;
  GL_SAMPLER_1D_ARRAY_SHADOW = $8DC3;
  GL_SAMPLER_2D_ARRAY_SHADOW = $8DC4;
  GL_SAMPLER_CUBE_SHADOW = $8DC5;
  GL_UNSIGNED_INT_VEC2 = $8DC6;
  GL_UNSIGNED_INT_VEC3 = $8DC7;
  GL_UNSIGNED_INT_VEC4 = $8DC8;
  GL_INT_SAMPLER_1D = $8DC9;
  GL_INT_SAMPLER_2D = $8DCA;
  GL_INT_SAMPLER_3D = $8DCB;
  GL_INT_SAMPLER_CUBE = $8DCC;
  GL_INT_SAMPLER_1D_ARRAY = $8DCE;
  GL_INT_SAMPLER_2D_ARRAY = $8DCF;
  GL_UNSIGNED_INT_SAMPLER_1D = $8DD1;
  GL_UNSIGNED_INT_SAMPLER_2D = $8DD2;
  GL_UNSIGNED_INT_SAMPLER_3D = $8DD3;
  GL_UNSIGNED_INT_SAMPLER_CUBE = $8DD4;
  GL_UNSIGNED_INT_SAMPLER_1D_ARRAY = $8DD6;
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = $8DD7;
  GL_QUERY_WAIT = $8E13;
  GL_QUERY_NO_WAIT = $8E14;
  GL_QUERY_BY_REGION_WAIT = $8E15;
  GL_QUERY_BY_REGION_NO_WAIT = $8E16;
  GL_BUFFER_ACCESS_FLAGS = $911F;
  GL_BUFFER_MAP_LENGTH = $9120;
  GL_BUFFER_MAP_OFFSET = $9121;
  GL_DEPTH_COMPONENT32F = $8CAC;
  GL_DEPTH32F_STENCIL8 = $8CAD;
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV = $8DAD;
  GL_INVALID_FRAMEBUFFER_OPERATION = $0506;
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = $8210;
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = $8211;
  GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = $8212;
  GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = $8213;
  GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = $8214;
  GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = $8215;
  GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = $8216;
  GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = $8217;
  GL_FRAMEBUFFER_DEFAULT = $8218;
  GL_FRAMEBUFFER_UNDEFINED = $8219;
  GL_DEPTH_STENCIL_ATTACHMENT = $821A;
  GL_MAX_RENDERBUFFER_SIZE = $84E8;
  GL_DEPTH_STENCIL = $84F9;
  GL_UNSIGNED_INT_24_8 = $84FA;
  GL_DEPTH24_STENCIL8 = $88F0;
  GL_TEXTURE_STENCIL_SIZE = $88F1;
  GL_TEXTURE_RED_TYPE = $8C10;
  GL_TEXTURE_GREEN_TYPE = $8C11;
  GL_TEXTURE_BLUE_TYPE = $8C12;
  GL_TEXTURE_ALPHA_TYPE = $8C13;
  GL_TEXTURE_DEPTH_TYPE = $8C16;
  GL_UNSIGNED_NORMALIZED = $8C17;
  GL_FRAMEBUFFER_BINDING = $8CA6;
  GL_DRAW_FRAMEBUFFER_BINDING = $8CA6;
  GL_RENDERBUFFER_BINDING = $8CA7;
  GL_READ_FRAMEBUFFER = $8CA8;
  GL_DRAW_FRAMEBUFFER = $8CA9;
  GL_READ_FRAMEBUFFER_BINDING = $8CAA;
  GL_RENDERBUFFER_SAMPLES = $8CAB;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = $8CD0;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = $8CD1;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = $8CD2;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = $8CD3;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = $8CD4;
  GL_FRAMEBUFFER_COMPLETE = $8CD5;
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = $8CD6;
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = $8CD7;
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = $8CDB;
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = $8CDC;
  GL_FRAMEBUFFER_UNSUPPORTED = $8CDD;
  GL_MAX_COLOR_ATTACHMENTS = $8CDF;
  GL_COLOR_ATTACHMENT0 = $8CE0;
  GL_COLOR_ATTACHMENT1 = $8CE1;
  GL_COLOR_ATTACHMENT2 = $8CE2;
  GL_COLOR_ATTACHMENT3 = $8CE3;
  GL_COLOR_ATTACHMENT4 = $8CE4;
  GL_COLOR_ATTACHMENT5 = $8CE5;
  GL_COLOR_ATTACHMENT6 = $8CE6;
  GL_COLOR_ATTACHMENT7 = $8CE7;
  GL_COLOR_ATTACHMENT8 = $8CE8;
  GL_COLOR_ATTACHMENT9 = $8CE9;
  GL_COLOR_ATTACHMENT10 = $8CEA;
  GL_COLOR_ATTACHMENT11 = $8CEB;
  GL_COLOR_ATTACHMENT12 = $8CEC;
  GL_COLOR_ATTACHMENT13 = $8CED;
  GL_COLOR_ATTACHMENT14 = $8CEE;
  GL_COLOR_ATTACHMENT15 = $8CEF;
  GL_COLOR_ATTACHMENT16 = $8CF0;
  GL_COLOR_ATTACHMENT17 = $8CF1;
  GL_COLOR_ATTACHMENT18 = $8CF2;
  GL_COLOR_ATTACHMENT19 = $8CF3;
  GL_COLOR_ATTACHMENT20 = $8CF4;
  GL_COLOR_ATTACHMENT21 = $8CF5;
  GL_COLOR_ATTACHMENT22 = $8CF6;
  GL_COLOR_ATTACHMENT23 = $8CF7;
  GL_COLOR_ATTACHMENT24 = $8CF8;
  GL_COLOR_ATTACHMENT25 = $8CF9;
  GL_COLOR_ATTACHMENT26 = $8CFA;
  GL_COLOR_ATTACHMENT27 = $8CFB;
  GL_COLOR_ATTACHMENT28 = $8CFC;
  GL_COLOR_ATTACHMENT29 = $8CFD;
  GL_COLOR_ATTACHMENT30 = $8CFE;
  GL_COLOR_ATTACHMENT31 = $8CFF;
  GL_DEPTH_ATTACHMENT = $8D00;
  GL_STENCIL_ATTACHMENT = $8D20;
  GL_FRAMEBUFFER = $8D40;
  GL_RENDERBUFFER = $8D41;
  GL_RENDERBUFFER_WIDTH = $8D42;
  GL_RENDERBUFFER_HEIGHT = $8D43;
  GL_RENDERBUFFER_INTERNAL_FORMAT = $8D44;
  GL_STENCIL_INDEX1 = $8D46;
  GL_STENCIL_INDEX4 = $8D47;
  GL_STENCIL_INDEX8 = $8D48;
  GL_STENCIL_INDEX16 = $8D49;
  GL_RENDERBUFFER_RED_SIZE = $8D50;
  GL_RENDERBUFFER_GREEN_SIZE = $8D51;
  GL_RENDERBUFFER_BLUE_SIZE = $8D52;
  GL_RENDERBUFFER_ALPHA_SIZE = $8D53;
  GL_RENDERBUFFER_DEPTH_SIZE = $8D54;
  GL_RENDERBUFFER_STENCIL_SIZE = $8D55;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = $8D56;
  GL_MAX_SAMPLES = $8D57;
  GL_FRAMEBUFFER_SRGB = $8DB9;
  GL_HALF_FLOAT = $140B;
  GL_MAP_READ_BIT = $0001;
  GL_MAP_WRITE_BIT = $0002;
  GL_MAP_INVALIDATE_RANGE_BIT = $0004;
  GL_MAP_INVALIDATE_BUFFER_BIT = $0008;
  GL_MAP_FLUSH_EXPLICIT_BIT = $0010;
  GL_MAP_UNSYNCHRONIZED_BIT = $0020;
  GL_COMPRESSED_RED_RGTC1 = $8DBB;
  GL_COMPRESSED_SIGNED_RED_RGTC1 = $8DBC;
  GL_COMPRESSED_RG_RGTC2 = $8DBD;
  GL_COMPRESSED_SIGNED_RG_RGTC2 = $8DBE;
  GL_RG = $8227;
  GL_RG_INTEGER = $8228;
  GL_R8 = $8229;
  GL_R16 = $822A;
  GL_RG8 = $822B;
  GL_RG16 = $822C;
  GL_R16F = $822D;
  GL_R32F = $822E;
  GL_RG16F = $822F;
  GL_RG32F = $8230;
  GL_R8I = $8231;
  GL_R8UI = $8232;
  GL_R16I = $8233;
  GL_R16UI = $8234;
  GL_R32I = $8235;
  GL_R32UI = $8236;
  GL_RG8I = $8237;
  GL_RG8UI = $8238;
  GL_RG16I = $8239;
  GL_RG16UI = $823A;
  GL_RG32I = $823B;
  GL_RG32UI = $823C;
  GL_VERTEX_ARRAY_BINDING = $85B5;
  // OGL 3.1
  GL_SAMPLER_2D_RECT = $8B63;
  GL_SAMPLER_2D_RECT_SHADOW = $8B64;
  GL_SAMPLER_BUFFER = $8DC2;
  GL_INT_SAMPLER_2D_RECT = $8DCD;
  GL_INT_SAMPLER_BUFFER = $8DD0;
  GL_UNSIGNED_INT_SAMPLER_2D_RECT = $8DD5;
  GL_UNSIGNED_INT_SAMPLER_BUFFER = $8DD8;
  GL_TEXTURE_BUFFER = $8C2A;
  GL_MAX_TEXTURE_BUFFER_SIZE = $8C2B;
  GL_TEXTURE_BINDING_BUFFER = $8C2C;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING = $8C2D;
  GL_TEXTURE_RECTANGLE = $84F5;
  GL_TEXTURE_BINDING_RECTANGLE = $84F6;
  GL_PROXY_TEXTURE_RECTANGLE = $84F7;
  GL_MAX_RECTANGLE_TEXTURE_SIZE = $84F8;
  GL_R8_SNORM = $8F94;
  GL_RG8_SNORM = $8F95;
  GL_RGB8_SNORM = $8F96;
  GL_RGBA8_SNORM = $8F97;
  GL_R16_SNORM = $8F98;
  GL_RG16_SNORM = $8F99;
  GL_RGB16_SNORM = $8F9A;
  GL_RGBA16_SNORM = $8F9B;
  GL_SIGNED_NORMALIZED = $8F9C;
  GL_PRIMITIVE_RESTART = $8F9D;
  GL_PRIMITIVE_RESTART_INDEX = $8F9E;
  GL_COPY_READ_BUFFER = $8F36;
  GL_COPY_WRITE_BUFFER = $8F37;
  GL_UNIFORM_BUFFER = $8A11;
  GL_UNIFORM_BUFFER_BINDING = $8A28;
  GL_UNIFORM_BUFFER_START = $8A29;
  GL_UNIFORM_BUFFER_SIZE = $8A2A;
  GL_MAX_VERTEX_UNIFORM_BLOCKS = $8A2B;
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS = $8A2C;
  GL_MAX_FRAGMENT_UNIFORM_BLOCKS = $8A2D;
  GL_MAX_COMBINED_UNIFORM_BLOCKS = $8A2E;
  GL_MAX_UNIFORM_BUFFER_BINDINGS = $8A2F;
  GL_MAX_UNIFORM_BLOCK_SIZE = $8A30;
  GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = $8A31;
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = $8A32;
  GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = $8A33;
  GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = $8A34;
  GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = $8A35;
  GL_ACTIVE_UNIFORM_BLOCKS = $8A36;
  GL_UNIFORM_TYPE = $8A37;
  GL_UNIFORM_SIZE = $8A38;
  GL_UNIFORM_NAME_LENGTH = $8A39;
  GL_UNIFORM_BLOCK_INDEX = $8A3A;
  GL_UNIFORM_OFFSET = $8A3B;
  GL_UNIFORM_ARRAY_STRIDE = $8A3C;
  GL_UNIFORM_MATRIX_STRIDE = $8A3D;
  GL_UNIFORM_IS_ROW_MAJOR = $8A3E;
  GL_UNIFORM_BLOCK_BINDING = $8A3F;
  GL_UNIFORM_BLOCK_DATA_SIZE = $8A40;
  GL_UNIFORM_BLOCK_NAME_LENGTH = $8A41;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = $8A42;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = $8A43;
  GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = $8A44;
  GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = $8A45;
  GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = $8A46;
  GL_INVALID_INDEX = $FFFFFFFF;
  // OGL 3.2
  GL_CONTEXT_CORE_PROFILE_BIT = $00000001;
  GL_CONTEXT_COMPATIBILITY_PROFILE_BIT = $00000002;
  GL_LINES_ADJACENCY = $000A;
  GL_LINE_STRIP_ADJACENCY = $000B;
  GL_TRIANGLES_ADJACENCY = $000C;
  GL_TRIANGLE_STRIP_ADJACENCY = $000D;
  GL_PROGRAM_POINT_SIZE = $8642;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = $8C29;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED = $8DA7;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = $8DA8;
  GL_GEOMETRY_SHADER = $8DD9;
  GL_GEOMETRY_VERTICES_OUT = $8916;
  GL_GEOMETRY_INPUT_TYPE = $8917;
  GL_GEOMETRY_OUTPUT_TYPE = $8918;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS = $8DDF;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES = $8DE0;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = $8DE1;
  GL_MAX_VERTEX_OUTPUT_COMPONENTS = $9122;
  GL_MAX_GEOMETRY_INPUT_COMPONENTS = $9123;
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS = $9124;
  GL_MAX_FRAGMENT_INPUT_COMPONENTS = $9125;
  GL_CONTEXT_PROFILE_MASK = $9126;
  GL_DEPTH_CLAMP = $864F;
  GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = $8E4C;
  GL_FIRST_VERTEX_CONVENTION = $8E4D;
  GL_LAST_VERTEX_CONVENTION = $8E4E;
  GL_PROVOKING_VERTEX = $8E4F;
  GL_TEXTURE_CUBE_MAP_SEAMLESS = $884F;
  GL_MAX_SERVER_WAIT_TIMEOUT = $9111;
  GL_OBJECT_TYPE = $9112;
  GL_SYNC_CONDITION = $9113;
  GL_SYNC_STATUS = $9114;
  GL_SYNC_FLAGS = $9115;
  GL_SYNC_FENCE = $9116;
  GL_SYNC_GPU_COMMANDS_COMPLETE = $9117;
  GL_UNSIGNALED = $9118;
  GL_SIGNALED = $9119;
  GL_ALREADY_SIGNALED = $911A;
  GL_TIMEOUT_EXPIRED = $911B;
  GL_CONDITION_SATISFIED = $911C;
  GL_WAIT_FAILED = $911D;
  GL_TIMEOUT_IGNORED = $FFFFFFFFFFFFFFFF;
  GL_SYNC_FLUSH_COMMANDS_BIT = $00000001;
  GL_SAMPLE_POSITION = $8E50;
  GL_SAMPLE_MASK = $8E51;
  GL_SAMPLE_MASK_VALUE = $8E52;
  GL_MAX_SAMPLE_MASK_WORDS = $8E59;
  GL_TEXTURE_2D_MULTISAMPLE = $9100;
  GL_PROXY_TEXTURE_2D_MULTISAMPLE = $9101;
  GL_TEXTURE_2D_MULTISAMPLE_ARRAY = $9102;
  GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = $9103;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE = $9104;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = $9105;
  GL_TEXTURE_SAMPLES = $9106;
  GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = $9107;
  GL_SAMPLER_2D_MULTISAMPLE = $9108;
  GL_INT_SAMPLER_2D_MULTISAMPLE = $9109;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = $910A;
  GL_SAMPLER_2D_MULTISAMPLE_ARRAY = $910B;
  GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = $910C;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = $910D;
  GL_MAX_COLOR_TEXTURE_SAMPLES = $910E;
  GL_MAX_DEPTH_TEXTURE_SAMPLES = $910F;
  GL_MAX_INTEGER_SAMPLES = $9110;
  // OGL 3.3
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR = $88FE;
  GL_SRC1_COLOR = $88F9;
  GL_ONE_MINUS_SRC1_COLOR = $88FA;
  GL_ONE_MINUS_SRC1_ALPHA = $88FB;
  GL_MAX_DUAL_SOURCE_DRAW_BUFFERS = $88FC;
  GL_ANY_SAMPLES_PASSED = $8C2F;
  GL_SAMPLER_BINDING = $8919;
  GL_RGB10_A2UI = $906F;
  GL_TEXTURE_SWIZZLE_R = $8E42;
  GL_TEXTURE_SWIZZLE_G = $8E43;
  GL_TEXTURE_SWIZZLE_B = $8E44;
  GL_TEXTURE_SWIZZLE_A = $8E45;
  GL_TEXTURE_SWIZZLE_RGBA = $8E46;
  GL_TIME_ELAPSED = $88BF;
  GL_TIMESTAMP = $8E28;
  GL_INT_2_10_10_10_REV = $8D9F;
  // OGL 4.0
  GL_SAMPLE_SHADING = $8C36;
  GL_MIN_SAMPLE_SHADING_VALUE = $8C37;
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET = $8E5E;
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET = $8E5F;
  GL_TEXTURE_CUBE_MAP_ARRAY = $9009;
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = $900A;
  GL_PROXY_TEXTURE_CUBE_MAP_ARRAY = $900B;
  GL_SAMPLER_CUBE_MAP_ARRAY = $900C;
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW = $900D;
  GL_INT_SAMPLER_CUBE_MAP_ARRAY = $900E;
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = $900F;
  GL_DRAW_INDIRECT_BUFFER = $8F3F;
  GL_DRAW_INDIRECT_BUFFER_BINDING = $8F43;
  GL_GEOMETRY_SHADER_INVOCATIONS = $887F;
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS = $8E5A;
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = $8E5B;
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = $8E5C;
  GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = $8E5D;
  GL_MAX_VERTEX_STREAMS = $8E71;
  GL_DOUBLE_VEC2 = $8FFC;
  GL_DOUBLE_VEC3 = $8FFD;
  GL_DOUBLE_VEC4 = $8FFE;
  GL_DOUBLE_MAT2 = $8F46;
  GL_DOUBLE_MAT3 = $8F47;
  GL_DOUBLE_MAT4 = $8F48;
  GL_DOUBLE_MAT2x3 = $8F49;
  GL_DOUBLE_MAT2x4 = $8F4A;
  GL_DOUBLE_MAT3x2 = $8F4B;
  GL_DOUBLE_MAT3x4 = $8F4C;
  GL_DOUBLE_MAT4x2 = $8F4D;
  GL_DOUBLE_MAT4x3 = $8F4E;
  GL_ACTIVE_SUBROUTINES = $8DE5;
  GL_ACTIVE_SUBROUTINE_UNIFORMS = $8DE6;
  GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = $8E47;
  GL_ACTIVE_SUBROUTINE_MAX_LENGTH = $8E48;
  GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = $8E49;
  GL_MAX_SUBROUTINES = $8DE7;
  GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = $8DE8;
  GL_NUM_COMPATIBLE_SUBROUTINES = $8E4A;
  GL_COMPATIBLE_SUBROUTINES = $8E4B;
  GL_PATCHES = $000E;
  GL_PATCH_VERTICES = $8E72;
  GL_PATCH_DEFAULT_INNER_LEVEL = $8E73;
  GL_PATCH_DEFAULT_OUTER_LEVEL = $8E74;
  GL_TESS_CONTROL_OUTPUT_VERTICES = $8E75;
  GL_TESS_GEN_MODE = $8E76;
  GL_TESS_GEN_SPACING = $8E77;
  GL_TESS_GEN_VERTEX_ORDER = $8E78;
  GL_TESS_GEN_POINT_MODE = $8E79;
  GL_ISOLINES = $8E7A;
  GL_FRACTIONAL_ODD = $8E7B;
  GL_FRACTIONAL_EVEN = $8E7C;
  GL_MAX_PATCH_VERTICES = $8E7D;
  GL_MAX_TESS_GEN_LEVEL = $8E7E;
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = $8E7F;
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = $8E80;
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = $8E81;
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = $8E82;
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = $8E83;
  GL_MAX_TESS_PATCH_COMPONENTS = $8E84;
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = $8E85;
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = $8E86;
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = $8E89;
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = $8E8A;
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = $886C;
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = $886D;
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = $8E1E;
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = $8E1F;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = $84F0;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = $84F1;
  GL_TESS_EVALUATION_SHADER = $8E87;
  GL_TESS_CONTROL_SHADER = $8E88;
  GL_TRANSFORM_FEEDBACK = $8E22;
  GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = $8E23;
  GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = $8E24;
  GL_TRANSFORM_FEEDBACK_BINDING = $8E25;
  GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = $8E70;

  // OGL 4.1
  GL_FIXED = $140C;
  GL_IMPLEMENTATION_COLOR_READ_TYPE = $8B9A;
  GL_IMPLEMENTATION_COLOR_READ_FORMAT = $8B9B;
  GL_LOW_FLOAT = $8DF0;
  GL_MEDIUM_FLOAT = $8DF1;
  GL_HIGH_FLOAT = $8DF2;
  GL_LOW_INT = $8DF3;
  GL_MEDIUM_INT = $8DF4;
  GL_HIGH_INT = $8DF5;
  GL_SHADER_COMPILER = $8DFA;
  GL_SHADER_BINARY_FORMATS = $8DF8;
  GL_NUM_SHADER_BINARY_FORMATS = $8DF9;
  GL_MAX_VERTEX_UNIFORM_VECTORS = $8DFB;
  GL_MAX_VARYING_VECTORS = $8DFC;
  GL_MAX_FRAGMENT_UNIFORM_VECTORS = $8DFD;
  GL_RGB565 = $8D62;
  GL_PROGRAM_BINARY_RETRIEVABLE_HINT = $8257;
  GL_PROGRAM_BINARY_LENGTH = $8741;
  GL_NUM_PROGRAM_BINARY_FORMATS = $87FE;
  GL_PROGRAM_BINARY_FORMATS = $87FF;
  GL_VERTEX_SHADER_BIT = $00000001;
  GL_FRAGMENT_SHADER_BIT = $00000002;
  GL_GEOMETRY_SHADER_BIT = $00000004;
  GL_TESS_CONTROL_SHADER_BIT = $00000008;
  GL_TESS_EVALUATION_SHADER_BIT = $00000010;
  GL_ALL_SHADER_BITS = $FFFFFFFF;
  GL_PROGRAM_SEPARABLE = $8258;
  GL_ACTIVE_PROGRAM = $8259;
  GL_PROGRAM_PIPELINE_BINDING = $825A;
  GL_MAX_VIEWPORTS = $825B;
  GL_VIEWPORT_SUBPIXEL_BITS = $825C;
  GL_VIEWPORT_BOUNDS_RANGE = $825D;
  GL_LAYER_PROVOKING_VERTEX = $825E;
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX = $825F;
  GL_UNDEFINED_VERTEX = $8260;
  // OGL 4.2
  GL_COPY_READ_BUFFER_BINDING = $8F36;
  GL_COPY_WRITE_BUFFER_BINDING = $8F37;
  GL_TRANSFORM_FEEDBACK_ACTIVE = $8E24;
  GL_TRANSFORM_FEEDBACK_PAUSED = $8E23;
  GL_UNPACK_COMPRESSED_BLOCK_WIDTH = $9127;
  GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = $9128;
  GL_UNPACK_COMPRESSED_BLOCK_DEPTH = $9129;
  GL_UNPACK_COMPRESSED_BLOCK_SIZE = $912A;
  GL_PACK_COMPRESSED_BLOCK_WIDTH = $912B;
  GL_PACK_COMPRESSED_BLOCK_HEIGHT = $912C;
  GL_PACK_COMPRESSED_BLOCK_DEPTH = $912D;
  GL_PACK_COMPRESSED_BLOCK_SIZE = $912E;
  GL_NUM_SAMPLE_COUNTS = $9380;
  GL_MIN_MAP_BUFFER_ALIGNMENT = $90BC;
  GL_ATOMIC_COUNTER_BUFFER = $92C0;
  GL_ATOMIC_COUNTER_BUFFER_BINDING = $92C1;
  GL_ATOMIC_COUNTER_BUFFER_START = $92C2;
  GL_ATOMIC_COUNTER_BUFFER_SIZE = $92C3;
  GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = $92C4;
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = $92C5;
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = $92C6;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = $92C7;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = $92C8;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = $92C9;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = $92CA;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = $92CB;
  GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = $92CC;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = $92CD;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = $92CE;
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = $92CF;
  GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = $92D0;
  GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = $92D1;
  GL_MAX_VERTEX_ATOMIC_COUNTERS = $92D2;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = $92D3;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = $92D4;
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS = $92D5;
  GL_MAX_FRAGMENT_ATOMIC_COUNTERS = $92D6;
  GL_MAX_COMBINED_ATOMIC_COUNTERS = $92D7;
  GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = $92D8;
  GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = $92DC;
  GL_ACTIVE_ATOMIC_COUNTER_BUFFERS = $92D9;
  GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = $92DA;
  GL_UNSIGNED_INT_ATOMIC_COUNTER = $92DB;
  GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = $00000001;
  GL_ELEMENT_ARRAY_BARRIER_BIT = $00000002;
  GL_UNIFORM_BARRIER_BIT = $00000004;
  GL_TEXTURE_FETCH_BARRIER_BIT = $00000008;
  GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = $00000020;
  GL_COMMAND_BARRIER_BIT = $00000040;
  GL_PIXEL_BUFFER_BARRIER_BIT = $00000080;
  GL_TEXTURE_UPDATE_BARRIER_BIT = $00000100;
  GL_BUFFER_UPDATE_BARRIER_BIT = $00000200;
  GL_FRAMEBUFFER_BARRIER_BIT = $00000400;
  GL_TRANSFORM_FEEDBACK_BARRIER_BIT = $00000800;
  GL_ATOMIC_COUNTER_BARRIER_BIT = $00001000;
  GL_ALL_BARRIER_BITS = $FFFFFFFF;
  GL_MAX_IMAGE_UNITS = $8F38;
  GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = $8F39;
  GL_IMAGE_BINDING_NAME = $8F3A;
  GL_IMAGE_BINDING_LEVEL = $8F3B;
  GL_IMAGE_BINDING_LAYERED = $8F3C;
  GL_IMAGE_BINDING_LAYER = $8F3D;
  GL_IMAGE_BINDING_ACCESS = $8F3E;
  GL_IMAGE_1D = $904C;
  GL_IMAGE_2D = $904D;
  GL_IMAGE_3D = $904E;
  GL_IMAGE_2D_RECT = $904F;
  GL_IMAGE_CUBE = $9050;
  GL_IMAGE_BUFFER = $9051;
  GL_IMAGE_1D_ARRAY = $9052;
  GL_IMAGE_2D_ARRAY = $9053;
  GL_IMAGE_CUBE_MAP_ARRAY = $9054;
  GL_IMAGE_2D_MULTISAMPLE = $9055;
  GL_IMAGE_2D_MULTISAMPLE_ARRAY = $9056;
  GL_INT_IMAGE_1D = $9057;
  GL_INT_IMAGE_2D = $9058;
  GL_INT_IMAGE_3D = $9059;
  GL_INT_IMAGE_2D_RECT = $905A;
  GL_INT_IMAGE_CUBE = $905B;
  GL_INT_IMAGE_BUFFER = $905C;
  GL_INT_IMAGE_1D_ARRAY = $905D;
  GL_INT_IMAGE_2D_ARRAY = $905E;
  GL_INT_IMAGE_CUBE_MAP_ARRAY = $905F;
  GL_INT_IMAGE_2D_MULTISAMPLE = $9060;
  GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = $9061;
  GL_UNSIGNED_INT_IMAGE_1D = $9062;
  GL_UNSIGNED_INT_IMAGE_2D = $9063;
  GL_UNSIGNED_INT_IMAGE_3D = $9064;
  GL_UNSIGNED_INT_IMAGE_2D_RECT = $9065;
  GL_UNSIGNED_INT_IMAGE_CUBE = $9066;
  GL_UNSIGNED_INT_IMAGE_BUFFER = $9067;
  GL_UNSIGNED_INT_IMAGE_1D_ARRAY = $9068;
  GL_UNSIGNED_INT_IMAGE_2D_ARRAY = $9069;
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = $906A;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = $906B;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = $906C;
  GL_MAX_IMAGE_SAMPLES = $906D;
  GL_IMAGE_BINDING_FORMAT = $906E;
  GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = $90C7;
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = $90C8;
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = $90C9;
  GL_MAX_VERTEX_IMAGE_UNIFORMS = $90CA;
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = $90CB;
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = $90CC;
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS = $90CD;
  GL_MAX_FRAGMENT_IMAGE_UNIFORMS = $90CE;
  GL_MAX_COMBINED_IMAGE_UNIFORMS = $90CF;
  GL_COMPRESSED_RGBA_BPTC_UNORM = $8E8C;
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = $8E8D;
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = $8E8E;
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = $8E8F;
  GL_TEXTURE_IMMUTABLE_FORMAT = $912F;
  // OGL 4.3
  GL_NUM_SHADING_LANGUAGE_VERSIONS = $82E9;
  GL_VERTEX_ATTRIB_ARRAY_LONG = $874E;
  GL_COMPRESSED_RGB8_ETC2 = $9274;
  GL_COMPRESSED_SRGB8_ETC2 = $9275;
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9276;
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9277;
  GL_COMPRESSED_RGBA8_ETC2_EAC = $9278;
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = $9279;
  GL_COMPRESSED_R11_EAC = $9270;
  GL_COMPRESSED_SIGNED_R11_EAC = $9271;
  GL_COMPRESSED_RG11_EAC = $9272;
  GL_COMPRESSED_SIGNED_RG11_EAC = $9273;
  GL_PRIMITIVE_RESTART_FIXED_INDEX = $8D69;
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE = $8D6A;
  GL_MAX_ELEMENT_INDEX = $8D6B;
  GL_COMPUTE_SHADER = $91B9;
  GL_MAX_COMPUTE_UNIFORM_BLOCKS = $91BB;
  GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = $91BC;
  GL_MAX_COMPUTE_IMAGE_UNIFORMS = $91BD;
  GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = $8262;
  GL_MAX_COMPUTE_UNIFORM_COMPONENTS = $8263;
  GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = $8264;
  GL_MAX_COMPUTE_ATOMIC_COUNTERS = $8265;
  GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = $8266;
  GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS = $90EB;
  GL_MAX_COMPUTE_WORK_GROUP_COUNT = $91BE;
  GL_MAX_COMPUTE_WORK_GROUP_SIZE = $91BF;
  GL_COMPUTE_WORK_GROUP_SIZE = $8267;
  GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = $90EC;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = $90ED;
  GL_DISPATCH_INDIRECT_BUFFER = $90EE;
  GL_DISPATCH_INDIRECT_BUFFER_BINDING = $90EF;
  GL_COMPUTE_SHADER_BIT = $00000020;
  GL_DEBUG_OUTPUT_SYNCHRONOUS = $8242;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = $8243;
  GL_DEBUG_CALLBACK_FUNCTION = $8244;
  GL_DEBUG_CALLBACK_USER_PARAM = $8245;
  GL_DEBUG_SOURCE_API = $8246;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM = $8247;
  GL_DEBUG_SOURCE_SHADER_COMPILER = $8248;
  GL_DEBUG_SOURCE_THIRD_PARTY = $8249;
  GL_DEBUG_SOURCE_APPLICATION = $824A;
  GL_DEBUG_SOURCE_OTHER = $824B;
  GL_DEBUG_TYPE_ERROR = $824C;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = $824D;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR = $824E;
  GL_DEBUG_TYPE_PORTABILITY = $824F;
  GL_DEBUG_TYPE_PERFORMANCE = $8250;
  GL_DEBUG_TYPE_OTHER = $8251;
  GL_MAX_DEBUG_MESSAGE_LENGTH = $9143;
  GL_MAX_DEBUG_LOGGED_MESSAGES = $9144;
  GL_DEBUG_LOGGED_MESSAGES = $9145;
  GL_DEBUG_SEVERITY_HIGH = $9146;
  GL_DEBUG_SEVERITY_MEDIUM = $9147;
  GL_DEBUG_SEVERITY_LOW = $9148;
  GL_DEBUG_TYPE_MARKER = $8268;
  GL_DEBUG_TYPE_PUSH_GROUP = $8269;
  GL_DEBUG_TYPE_POP_GROUP = $826A;
  GL_DEBUG_SEVERITY_NOTIFICATION = $826B;
  GL_MAX_DEBUG_GROUP_STACK_DEPTH = $826C;
  GL_DEBUG_GROUP_STACK_DEPTH = $826D;
  GL_BUFFER = $82E0;
  GL_SHADER = $82E1;
  GL_PROGRAM = $82E2;
  GL_QUERY = $82E3;
  GL_PROGRAM_PIPELINE = $82E4;
  GL_SAMPLER = $82E6;
  GL_MAX_LABEL_LENGTH = $82E8;
  GL_DEBUG_OUTPUT = $92E0;
  GL_CONTEXT_FLAG_DEBUG_BIT = $00000002;
  GL_MAX_UNIFORM_LOCATIONS = $826E;
  GL_FRAMEBUFFER_DEFAULT_WIDTH = $9310;
  GL_FRAMEBUFFER_DEFAULT_HEIGHT = $9311;
  GL_FRAMEBUFFER_DEFAULT_LAYERS = $9312;
  GL_FRAMEBUFFER_DEFAULT_SAMPLES = $9313;
  GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = $9314;
  GL_MAX_FRAMEBUFFER_WIDTH = $9315;
  GL_MAX_FRAMEBUFFER_HEIGHT = $9316;
  GL_MAX_FRAMEBUFFER_LAYERS = $9317;
  GL_MAX_FRAMEBUFFER_SAMPLES = $9318;
  GL_INTERNALFORMAT_SUPPORTED = $826F;
  GL_INTERNALFORMAT_PREFERRED = $8270;
  GL_INTERNALFORMAT_RED_SIZE = $8271;
  GL_INTERNALFORMAT_GREEN_SIZE = $8272;
  GL_INTERNALFORMAT_BLUE_SIZE = $8273;
  GL_INTERNALFORMAT_ALPHA_SIZE = $8274;
  GL_INTERNALFORMAT_DEPTH_SIZE = $8275;
  GL_INTERNALFORMAT_STENCIL_SIZE = $8276;
  GL_INTERNALFORMAT_SHARED_SIZE = $8277;
  GL_INTERNALFORMAT_RED_TYPE = $8278;
  GL_INTERNALFORMAT_GREEN_TYPE = $8279;
  GL_INTERNALFORMAT_BLUE_TYPE = $827A;
  GL_INTERNALFORMAT_ALPHA_TYPE = $827B;
  GL_INTERNALFORMAT_DEPTH_TYPE = $827C;
  GL_INTERNALFORMAT_STENCIL_TYPE = $827D;
  GL_MAX_WIDTH = $827E;
  GL_MAX_HEIGHT = $827F;
  GL_MAX_DEPTH = $8280;
  GL_MAX_LAYERS = $8281;
  GL_MAX_COMBINED_DIMENSIONS = $8282;
  GL_COLOR_COMPONENTS = $8283;
  GL_DEPTH_COMPONENTS = $8284;
  GL_STENCIL_COMPONENTS = $8285;
  GL_COLOR_RENDERABLE = $8286;
  GL_DEPTH_RENDERABLE = $8287;
  GL_STENCIL_RENDERABLE = $8288;
  GL_FRAMEBUFFER_RENDERABLE = $8289;
  GL_FRAMEBUFFER_RENDERABLE_LAYERED = $828A;
  GL_FRAMEBUFFER_BLEND = $828B;
  GL_READ_PIXELS = $828C;
  GL_READ_PIXELS_FORMAT = $828D;
  GL_READ_PIXELS_TYPE = $828E;
  GL_TEXTURE_IMAGE_FORMAT = $828F;
  GL_TEXTURE_IMAGE_TYPE = $8290;
  GL_GET_TEXTURE_IMAGE_FORMAT = $8291;
  GL_GET_TEXTURE_IMAGE_TYPE = $8292;
  GL_MIPMAP = $8293;
  GL_MANUAL_GENERATE_MIPMAP = $8294;
  GL_AUTO_GENERATE_MIPMAP = $8295;
  GL_COLOR_ENCODING = $8296;
  GL_SRGB_READ = $8297;
  GL_SRGB_WRITE = $8298;
  GL_FILTER = $829A;
  GL_VERTEX_TEXTURE = $829B;
  GL_TESS_CONTROL_TEXTURE = $829C;
  GL_TESS_EVALUATION_TEXTURE = $829D;
  GL_GEOMETRY_TEXTURE = $829E;
  GL_FRAGMENT_TEXTURE = $829F;
  GL_COMPUTE_TEXTURE = $82A0;
  GL_TEXTURE_SHADOW = $82A1;
  GL_TEXTURE_GATHER = $82A2;
  GL_TEXTURE_GATHER_SHADOW = $82A3;
  GL_SHADER_IMAGE_LOAD = $82A4;
  GL_SHADER_IMAGE_STORE = $82A5;
  GL_SHADER_IMAGE_ATOMIC = $82A6;
  GL_IMAGE_TEXEL_SIZE = $82A7;
  GL_IMAGE_COMPATIBILITY_CLASS = $82A8;
  GL_IMAGE_PIXEL_FORMAT = $82A9;
  GL_IMAGE_PIXEL_TYPE = $82AA;
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = $82AC;
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = $82AD;
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = $82AE;
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = $82AF;
  GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = $82B1;
  GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = $82B2;
  GL_TEXTURE_COMPRESSED_BLOCK_SIZE = $82B3;
  GL_CLEAR_BUFFER = $82B4;
  GL_TEXTURE_VIEW = $82B5;
  GL_VIEW_COMPATIBILITY_CLASS = $82B6;
  GL_FULL_SUPPORT = $82B7;
  GL_CAVEAT_SUPPORT = $82B8;
  GL_IMAGE_CLASS_4_X_32 = $82B9;
  GL_IMAGE_CLASS_2_X_32 = $82BA;
  GL_IMAGE_CLASS_1_X_32 = $82BB;
  GL_IMAGE_CLASS_4_X_16 = $82BC;
  GL_IMAGE_CLASS_2_X_16 = $82BD;
  GL_IMAGE_CLASS_1_X_16 = $82BE;
  GL_IMAGE_CLASS_4_X_8 = $82BF;
  GL_IMAGE_CLASS_2_X_8 = $82C0;
  GL_IMAGE_CLASS_1_X_8 = $82C1;
  GL_IMAGE_CLASS_11_11_10 = $82C2;
  GL_IMAGE_CLASS_10_10_10_2 = $82C3;
  GL_VIEW_CLASS_128_BITS = $82C4;
  GL_VIEW_CLASS_96_BITS = $82C5;
  GL_VIEW_CLASS_64_BITS = $82C6;
  GL_VIEW_CLASS_48_BITS = $82C7;
  GL_VIEW_CLASS_32_BITS = $82C8;
  GL_VIEW_CLASS_24_BITS = $82C9;
  GL_VIEW_CLASS_16_BITS = $82CA;
  GL_VIEW_CLASS_8_BITS = $82CB;
  GL_VIEW_CLASS_S3TC_DXT1_RGB = $82CC;
  GL_VIEW_CLASS_S3TC_DXT1_RGBA = $82CD;
  GL_VIEW_CLASS_S3TC_DXT3_RGBA = $82CE;
  GL_VIEW_CLASS_S3TC_DXT5_RGBA = $82CF;
  GL_VIEW_CLASS_RGTC1_RED = $82D0;
  GL_VIEW_CLASS_RGTC2_RG = $82D1;
  GL_VIEW_CLASS_BPTC_UNORM = $82D2;
  GL_VIEW_CLASS_BPTC_FLOAT = $82D3;
  GL_UNIFORM = $92E1;
  GL_UNIFORM_BLOCK = $92E2;
  GL_PROGRAM_INPUT = $92E3;
  GL_PROGRAM_OUTPUT = $92E4;
  GL_BUFFER_VARIABLE = $92E5;
  GL_SHADER_STORAGE_BLOCK = $92E6;
  GL_VERTEX_SUBROUTINE = $92E8;
  GL_TESS_CONTROL_SUBROUTINE = $92E9;
  GL_TESS_EVALUATION_SUBROUTINE = $92EA;
  GL_GEOMETRY_SUBROUTINE = $92EB;
  GL_FRAGMENT_SUBROUTINE = $92EC;
  GL_COMPUTE_SUBROUTINE = $92ED;
  GL_VERTEX_SUBROUTINE_UNIFORM = $92EE;
  GL_TESS_CONTROL_SUBROUTINE_UNIFORM = $92EF;
  GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = $92F0;
  GL_GEOMETRY_SUBROUTINE_UNIFORM = $92F1;
  GL_FRAGMENT_SUBROUTINE_UNIFORM = $92F2;
  GL_COMPUTE_SUBROUTINE_UNIFORM = $92F3;
  GL_TRANSFORM_FEEDBACK_VARYING = $92F4;
  GL_ACTIVE_RESOURCES = $92F5;
  GL_MAX_NAME_LENGTH = $92F6;
  GL_MAX_NUM_ACTIVE_VARIABLES = $92F7;
  GL_MAX_NUM_COMPATIBLE_SUBROUTINES = $92F8;
  GL_NAME_LENGTH = $92F9;
  GL_TYPE = $92FA;
  GL_ARRAY_SIZE = $92FB;
  GL_OFFSET = $92FC;
  GL_BLOCK_INDEX = $92FD;
  GL_ARRAY_STRIDE = $92FE;
  GL_MATRIX_STRIDE = $92FF;
  GL_IS_ROW_MAJOR = $9300;
  GL_ATOMIC_COUNTER_BUFFER_INDEX = $9301;
  GL_BUFFER_BINDING = $9302;
  GL_BUFFER_DATA_SIZE = $9303;
  GL_NUM_ACTIVE_VARIABLES = $9304;
  GL_ACTIVE_VARIABLES = $9305;
  GL_REFERENCED_BY_VERTEX_SHADER = $9306;
  GL_REFERENCED_BY_TESS_CONTROL_SHADER = $9307;
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER = $9308;
  GL_REFERENCED_BY_GEOMETRY_SHADER = $9309;
  GL_REFERENCED_BY_FRAGMENT_SHADER = $930A;
  GL_REFERENCED_BY_COMPUTE_SHADER = $930B;
  GL_TOP_LEVEL_ARRAY_SIZE = $930C;
  GL_TOP_LEVEL_ARRAY_STRIDE = $930D;
  GL_LOCATION = $930E;
  GL_LOCATION_INDEX = $930F;
  GL_IS_PER_PATCH = $92E7;
  GL_SHADER_STORAGE_BUFFER = $90D2;
  GL_SHADER_STORAGE_BUFFER_BINDING = $90D3;
  GL_SHADER_STORAGE_BUFFER_START = $90D4;
  GL_SHADER_STORAGE_BUFFER_SIZE = $90D5;
  GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = $90D6;
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = $90D7;
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = $90D8;
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = $90D9;
  GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = $90DA;
  GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = $90DB;
  GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = $90DC;
  GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = $90DD;
  GL_MAX_SHADER_STORAGE_BLOCK_SIZE = $90DE;
  GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = $90DF;
  GL_SHADER_STORAGE_BARRIER_BIT = $00002000;
  GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = $8F39;
  GL_DEPTH_STENCIL_TEXTURE_MODE = $90EA;
  GL_TEXTURE_BUFFER_OFFSET = $919D;
  GL_TEXTURE_BUFFER_SIZE = $919E;
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = $919F;
  GL_TEXTURE_VIEW_MIN_LEVEL = $82DB;
  GL_TEXTURE_VIEW_NUM_LEVELS = $82DC;
  GL_TEXTURE_VIEW_MIN_LAYER = $82DD;
  GL_TEXTURE_VIEW_NUM_LAYERS = $82DE;
  GL_TEXTURE_IMMUTABLE_LEVELS = $82DF;
  GL_VERTEX_ATTRIB_BINDING = $82D4;
  GL_VERTEX_ATTRIB_RELATIVE_OFFSET = $82D5;
  GL_VERTEX_BINDING_DIVISOR = $82D6;
  GL_VERTEX_BINDING_OFFSET = $82D7;
  GL_VERTEX_BINDING_STRIDE = $82D8;
  GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = $82D9;
  GL_MAX_VERTEX_ATTRIB_BINDINGS = $82DA;
  GL_VERTEX_BINDING_BUFFER = $8F4F;
  // OGL 4.4
  GL_MAX_VERTEX_ATTRIB_STRIDE = $82E5;
  GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = $8221;
  GL_TEXTURE_BUFFER_BINDING = $8C2A;
  GL_MAP_PERSISTENT_BIT = $0040;
  GL_MAP_COHERENT_BIT = $0080;
  GL_DYNAMIC_STORAGE_BIT = $0100;
  GL_CLIENT_STORAGE_BIT = $0200;
  GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = $00004000;
  GL_BUFFER_IMMUTABLE_STORAGE = $821F;
  GL_BUFFER_STORAGE_FLAGS = $8220;
  GL_CLEAR_TEXTURE = $9365;
  GL_LOCATION_COMPONENT = $934A;
  GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = $934B;
  GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = $934C;
  GL_QUERY_BUFFER = $9192;
  GL_QUERY_BUFFER_BARRIER_BIT = $00008000;
  GL_QUERY_BUFFER_BINDING = $9193;
  GL_QUERY_RESULT_NO_WAIT = $9194;
  GL_MIRROR_CLAMP_TO_EDGE = $8743;
  // OGL 4.5
  GL_CONTEXT_LOST = $0507;
  GL_NEGATIVE_ONE_TO_ONE = $935E;
  GL_ZERO_TO_ONE = $935F;
  GL_CLIP_ORIGIN = $935C;
  GL_CLIP_DEPTH_MODE = $935D;
  GL_QUERY_WAIT_INVERTED = $8E17;
  GL_QUERY_NO_WAIT_INVERTED = $8E18;
  GL_QUERY_BY_REGION_WAIT_INVERTED = $8E19;
  GL_QUERY_BY_REGION_NO_WAIT_INVERTED = $8E1A;
  GL_MAX_CULL_DISTANCES = $82F9;
  GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = $82FA;
  GL_TEXTURE_TARGET = $1006;
  GL_QUERY_TARGET = $82EA;
  GL_GUILTY_CONTEXT_RESET = $8253;
  GL_INNOCENT_CONTEXT_RESET = $8254;
  GL_UNKNOWN_CONTEXT_RESET = $8255;
  GL_RESET_NOTIFICATION_STRATEGY = $8256;
  GL_LOSE_CONTEXT_ON_RESET = $8252;
  GL_NO_RESET_NOTIFICATION = $8261;
  GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT = $00000004;
  GL_CONTEXT_RELEASE_BEHAVIOR = $82FB;
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = $82FC;
  // OGL 4.6
  GL_SHADER_BINARY_FORMAT_SPIR_V = $9551;
  GL_SPIR_V_BINARY = $9552;
  GL_PARAMETER_BUFFER = $80EE;
  GL_PARAMETER_BUFFER_BINDING = $80EF;
  GL_CONTEXT_FLAG_NO_ERROR_BIT = $00000008;
  GL_VERTICES_SUBMITTED = $82EE;
  GL_PRIMITIVES_SUBMITTED = $82EF;
  GL_VERTEX_SHADER_INVOCATIONS = $82F0;
  GL_TESS_CONTROL_SHADER_PATCHES = $82F1;
  GL_TESS_EVALUATION_SHADER_INVOCATIONS = $82F2;
  GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED = $82F3;
  GL_FRAGMENT_SHADER_INVOCATIONS = $82F4;
  GL_COMPUTE_SHADER_INVOCATIONS = $82F5;
  GL_CLIPPING_INPUT_PRIMITIVES = $82F6;
  GL_CLIPPING_OUTPUT_PRIMITIVES = $82F7;
  GL_POLYGON_OFFSET_CLAMP = $8E1B;
  GL_SPIR_V_EXTENSIONS = $9553;
  GL_NUM_SPIR_V_EXTENSIONS = $9554;
  GL_TEXTURE_MAX_ANISOTROPY = $84FE;
  GL_MAX_TEXTURE_MAX_ANISOTROPY = $84FF;
  GL_TRANSFORM_FEEDBACK_OVERFLOW = $82EC;


type
  GLbitfield = uint32;
  GLboolean = uint8;
  GLbyte = int8;
  GLchar = ansichar;
  GLclampd = double;
  GLclampf = single;
  GLdouble = double;
  GLenum = uint32;
  GLfloat = single;
  GLint = int32;
  GLint64 = int64;
  GLintptr = PtrInt;
  GLshort = int16;
  GLsizei = int32;
  GLsizeiptr = PtrInt;
  GLsync = Pointer;
  GLubyte = uint8;
  GLuint = uint32;
  GLuint64 = uint64;
  GLuint64EXT = uint64;
  GLushort = uint16;
  GLvoid = Pointer;
  PGLbitfield = ^GLbitfield;
  PGLboolean = ^GLboolean;
  PGLbyte = ^GLbyte;
  PGLchar = pansichar;
  PGLclampd = ^GLclampd;
  PGLclampf = ^GLclampf;
  PGLdouble = ^GLdouble;
  PGLenum = ^GLenum;
  PGLfloat = ^GLfloat;
  PGLint = ^GLint;
  PGLint64 = ^GLint64;
  PGLuint64EXT = ^GLuint64EXT;
  PGLintptr = ^GLintptr;
  PGLshort = ^GLshort;
  PGLsizei = ^GLsizei;
  PGLsizeiptr = ^GLsizeiptr;
  PGLsync = ^GLsync;
  PGLubyte = ^GLubyte;
  PGLuint = ^GLuint;
  PGLuint64 = ^GLuint64;
  PGLushort = ^GLushort;
  PGLvoid = Pointer;
  PPGLchar = ^PGLchar;
  PPGLubyte = ^PGLubyte;
  PPGLvoid = ^PGLvoid;
  GLDEBUGPROC = procedure(Source, typ: GLenum; id: GLuint; severity: GLenum; length: GLsizei; message: PGLchar; userParam: Pointer); cdecl;

type

  { IOpenGL10 }

  IOpenGL10 = interface
    ['{A4665333-B396-4E1C-AA8E-4A434272AD62}']
    procedure glAccum(op: GLenum; Value: GLfloat);
    procedure glAlphaFunc(func: GLenum; ref: GLclampf);
    procedure glBegin(mode: GLenum);
    procedure glBitmap(Width, Height: GLsizei; xorig, yorig: GLfloat; xmove, ymove: GLfloat; bitmap: PGLubyte);
    procedure glBlendFunc(sfactor, dfactor: GLenum);
    procedure glCallList(list: GLuint);
    procedure glCallLists(n: GLsizei; atype: GLenum; lists: Pointer);
    procedure glClear(mask: GLbitfield);
    procedure glClearAccum(red, green, blue, alpha: GLfloat);
    procedure glClearColor(red, green, blue, alpha: GLclampf);
    procedure glClearDepth(depth: GLclampd);
    procedure glClearIndex(c: GLfloat);
    procedure glClearStencil(s: GLint);
    procedure glClipPlane(plane: GLenum; equation: PGLdouble);
    procedure glColor3b(red, green, blue: GLbyte);
    procedure glColor3bv(v: PGLbyte);
    procedure glColor3d(red, green, blue: GLdouble);
    procedure glColor3dv(v: PGLdouble);
    procedure glColor3f(red, green, blue: GLfloat);
    procedure glColor3fv(v: PGLfloat);
    procedure glColor3i(red, green, blue: GLint);
    procedure glColor3iv(v: PGLint);
    procedure glColor3s(red, green, blue: GLshort);
    procedure glColor3sv(v: PGLshort);
    procedure glColor3ub(red, green, blue: GLubyte);
    procedure glColor3ubv(v: PGLubyte);
    procedure glColor3ui(red, green, blue: GLuint);
    procedure glColor3uiv(v: PGLuint);
    procedure glColor3us(red, green, blue: GLushort);
    procedure glColor3usv(v: PGLushort);
    procedure glColor4b(red, green, blue, alpha: GLbyte);
    procedure glColor4bv(v: PGLbyte);
    procedure glColor4d(red, green, blue, alpha: GLdouble);
    procedure glColor4dv(v: PGLdouble);
    procedure glColor4f(red, green, blue, alpha: GLfloat);
    procedure glColor4fv(v: PGLfloat);
    procedure glColor4i(red, green, blue, alpha: GLint);
    procedure glColor4iv(v: PGLint);
    procedure glColor4s(red, green, blue, alpha: GLshort);
    procedure glColor4sv(v: PGLshort);
    procedure glColor4ub(red, green, blue, alpha: GLubyte);
    procedure glColor4ubv(v: PGLubyte);
    procedure glColor4ui(red, green, blue, alpha: GLuint);
    procedure glColor4uiv(v: PGLuint);
    procedure glColor4us(red, green, blue, alpha: GLushort);
    procedure glColor4usv(v: PGLushort);
    procedure glColorMask(red, green, blue, alpha: GLboolean);
    procedure glColorMaterial(face, mode: GLenum);
    procedure glCopyPixels(x, y: GLint; Width, Height: GLsizei; atype: GLenum);
    procedure glCullFace(mode: GLenum);
    procedure glDeleteLists(list: GLuint; range: GLsizei);
    procedure glDepthFunc(func: GLenum);
    procedure glDepthMask(flag: GLboolean);
    procedure glDepthRange(zNear, zFar: GLclampd);
    procedure glDisable(cap: GLenum);
    procedure glDrawBuffer(mode: GLenum);
    procedure glDrawPixels(Width, Height: GLsizei; format, atype: GLenum; pixels: Pointer);
    procedure glEdgeFlag(flag: GLboolean);
    procedure glEdgeFlagv(flag: PGLboolean);
    procedure glEnable(cap: GLenum);
    procedure glEnd;
    procedure glEndList;
    procedure glEvalCoord1d(u: GLdouble);
    procedure glEvalCoord1dv(u: PGLdouble);
    procedure glEvalCoord1f(u: GLfloat);
    procedure glEvalCoord1fv(u: PGLfloat);
    procedure glEvalCoord2d(u, v: GLdouble);
    procedure glEvalCoord2dv(u: PGLdouble);
    procedure glEvalCoord2f(u, v: GLfloat);
    procedure glEvalCoord2fv(u: PGLfloat);
    procedure glEvalMesh1(mode: GLenum; i1, i2: GLint);
    procedure glEvalMesh2(mode: GLenum; i1, i2, j1, j2: GLint);
    procedure glEvalPoint1(i: GLint);
    procedure glEvalPoint2(i, j: GLint);
    procedure glFeedbackBuffer(size: GLsizei; atype: GLenum; buffer: PGLfloat);
    procedure glFinish;
    procedure glFlush;
    procedure glFogf(pname: GLenum; param: GLfloat);
    procedure glFogfv(pname: GLenum; params: PGLfloat);
    procedure glFogi(pname: GLenum; param: GLint);
    procedure glFogiv(pname: GLenum; params: PGLint);
    procedure glFrontFace(mode: GLenum);
    procedure glFrustum(left, right, bottom, top, zNear, zFar: GLdouble);
    function glGenLists(range: GLsizei): GLuint;
    procedure glGetBooleanv(pname: GLenum; params: PGLboolean);
    procedure glGetClipPlane(plane: GLenum; equation: PGLdouble);
    procedure glGetDoublev(pname: GLenum; params: PGLdouble);
    procedure glGetFloatv(pname: GLenum; params: PGLfloat);
    procedure glGetIntegerv(pname: GLenum; params: PGLint);
    procedure glGetLightfv(light, pname: GLenum; params: PGLfloat);
    procedure glGetLightiv(light, pname: GLenum; params: PGLint);
    procedure glGetMapdv(target, query: GLenum; v: PGLdouble);
    procedure glGetMapfv(target, query: GLenum; v: PGLfloat);
    procedure glGetMapiv(target, query: GLenum; v: PGLint);
    procedure glGetMaterialfv(face, pname: GLenum; params: PGLfloat);
    procedure glGetMaterialiv(face, pname: GLenum; params: PGLint);
    procedure glGetPixelMapfv(map: GLenum; values: PGLfloat);
    procedure glGetPixelMapuiv(map: GLenum; values: PGLuint);
    procedure glGetPixelMapusv(map: GLenum; values: PGLushort);
    procedure glGetPolygonStipple(mask: PGLubyte);
    procedure glGetTexEnvfv(target, pname: GLenum; params: PGLfloat);
    procedure glGetTexEnviv(target, pname: GLenum; params: PGLint);
    procedure glGetTexGendv(coord, pname: GLenum; params: PGLdouble);
    procedure glGetTexGenfv(coord, pname: GLenum; params: PGLfloat);
    procedure glGetTexGeniv(coord, pname: GLenum; params: PGLint);
    procedure glGetTexImage(target: GLenum; level: GLint; format, atype: GLenum; pixels: Pointer);
    procedure glGetTexLevelParameterfv(target: GLenum; level: GLint; pname: GLenum; params: PGLfloat);
    procedure glGetTexLevelParameteriv(target: GLenum; level: GLint; pname: GLenum; params: PGLint);
    procedure glGetTexParameterfv(target, pname: GLenum; params: PGLfloat);
    procedure glGetTexParameteriv(target, pname: GLenum; params: PGLint);
    procedure glHint(target, mode: GLenum);
    procedure glIndexMask(mask: GLuint);
    procedure glIndexd(c: GLdouble);
    procedure glIndexdv(c: PGLdouble);
    procedure glIndexf(c: GLfloat);
    procedure glIndexfv(c: PGLfloat);
    procedure glIndexi(c: GLint);
    procedure glIndexiv(c: PGLint);
    procedure glIndexs(c: GLshort);
    procedure glIndexsv(c: PGLshort);
    procedure glIndexub(c: GLubyte);
    procedure glIndexubv(c: PGLubyte);
    procedure glInitNames;
    function glIsEnabled(cap: GLenum): GLboolean;
    function glIsList(list: GLuint): GLboolean;
    procedure glLightModelf(pname: GLenum; param: GLfloat);
    procedure glLightModelfv(pname: GLenum; params: PGLfloat);
    procedure glLightModeli(pname: GLenum; param: GLint);
    procedure glLightModeliv(pname: GLenum; params: PGLint);
    procedure glLightf(light, pname: GLenum; param: GLfloat);
    procedure glLightfv(light, pname: GLenum; params: PGLfloat);
    procedure glLighti(light, pname: GLenum; param: GLint);
    procedure glLightiv(light, pname: GLenum; params: PGLint);
    procedure glLineStipple(factor: GLint; pattern: GLushort);
    procedure glLineWidth(Width: GLfloat);
    procedure glListBase(base: GLuint);
    procedure glLoadIdentity;
    procedure glLoadMatrixd(m: PGLdouble);
    procedure glLoadMatrixf(m: PGLfloat);
    procedure glLoadName(Name: GLuint);
    procedure glLogicOp(opcode: GLenum);
    procedure glMap1d(target: GLenum; u1, u2: GLdouble; stride, order: GLint; points: PGLdouble);
    procedure glMap1f(target: GLenum; u1, u2: GLfloat; stride, order: GLint; points: PGLfloat);
    procedure glMap2d(target: GLenum; u1, u2: GLdouble; ustride, uorder: GLint; v1, v2: GLdouble; vstride, vorder: GLint; points: PGLdouble);
    procedure glMap2f(target: GLenum; u1, u2: GLfloat; ustride, uorder: GLint; v1, v2: GLfloat; vstride, vorder: GLint; points: PGLfloat);
    procedure glMapGrid1d(un: GLint; u1, u2: GLdouble);
    procedure glMapGrid1f(un: GLint; u1, u2: GLfloat);
    procedure glMapGrid2d(un: GLint; u1, u2: GLdouble; vn: GLint; v1, v2: GLdouble);
    procedure glMapGrid2f(un: GLint; u1, u2: GLfloat; vn: GLint; v1, v2: GLfloat);
    procedure glMaterialf(face, pname: GLenum; param: GLfloat);
    procedure glMaterialfv(face, pname: GLenum; params: PGLfloat);
    procedure glMateriali(face, pname: GLenum; param: GLint);
    procedure glMaterialiv(face, pname: GLenum; params: PGLint);
    procedure glMatrixMode(mode: GLenum);
    procedure glMultMatrixd(m: PGLdouble);
    procedure glMultMatrixf(m: PGLfloat);
    procedure glNewList(list: GLuint; mode: GLenum);
    procedure glNormal3b(nx, ny, nz: GLbyte);
    procedure glNormal3bv(v: PGLbyte);
    procedure glNormal3d(nx, ny, nz: GLdouble);
    procedure glNormal3dv(v: PGLdouble);
    procedure glNormal3f(nx, ny, nz: GLfloat);
    procedure glNormal3fv(v: PGLfloat);
    procedure glNormal3i(nx, ny, nz: GLint);
    procedure glNormal3iv(v: PGLint);
    procedure glNormal3s(nx, ny, nz: GLshort);
    procedure glNormal3sv(v: PGLshort);
    procedure glOrtho(left, right, bottom, top, zNear, zFar: GLdouble);
    procedure glPassThrough(token: GLfloat);
    procedure glPixelMapfv(map: GLenum; mapsize: GLsizei; values: PGLfloat);
    procedure glPixelMapuiv(map: GLenum; mapsize: GLsizei; values: PGLuint);
    procedure glPixelMapusv(map: GLenum; mapsize: GLsizei; values: PGLushort);
    procedure glPixelStoref(pname: GLenum; param: GLfloat);
    procedure glPixelStorei(pname: GLenum; param: GLint);
    procedure glPixelTransferf(pname: GLenum; param: GLfloat);
    procedure glPixelTransferi(pname: GLenum; param: GLint);
    procedure glPixelZoom(xfactor, yfactor: GLfloat);
    procedure glPointSize(size: GLfloat);
    procedure glPolygonMode(face, mode: GLenum);
    procedure glPolygonStipple(mask: PGLubyte);
    procedure glPopAttrib;
    procedure glPopClientAttrib;
    procedure glPopMatrix;
    procedure glPopName;
    procedure glPushAttrib(mask: GLbitfield);
    procedure glPushClientAttrib(mask: GLbitfield);
    procedure glPushMatrix;
    procedure glPushName(Name: GLuint);
    procedure glRasterPos2d(x, y: GLdouble);
    procedure glRasterPos2dv(v: PGLdouble);
    procedure glRasterPos2f(x, y: GLfloat);
    procedure glRasterPos2fv(v: PGLfloat);
    procedure glRasterPos2i(x, y: GLint);
    procedure glRasterPos2iv(v: PGLint);
    procedure glRasterPos2s(x, y: GLshort);
    procedure glRasterPos2sv(v: PGLshort);
    procedure glRasterPos3d(x, y, z: GLdouble);
    procedure glRasterPos3dv(v: PGLdouble);
    procedure glRasterPos3f(x, y, z: GLfloat);
    procedure glRasterPos3fv(v: PGLfloat);
    procedure glRasterPos3i(x, y, z: GLint);
    procedure glRasterPos3iv(v: PGLint);
    procedure glRasterPos3s(x, y, z: GLshort);
    procedure glRasterPos3sv(v: PGLshort);
    procedure glRasterPos4d(x, y, z, w: GLdouble);
    procedure glRasterPos4dv(v: PGLdouble);
    procedure glRasterPos4f(x, y, z, w: GLfloat);
    procedure glRasterPos4fv(v: PGLfloat);
    procedure glRasterPos4i(x, y, z, w: GLint);
    procedure glRasterPos4iv(v: PGLint);
    procedure glRasterPos4s(x, y, z, w: GLshort);
    procedure glRasterPos4sv(v: PGLshort);
    procedure glReadBuffer(mode: GLenum);
    procedure glReadPixels(x, y: GLint; Width, Height: GLsizei; format, atype: GLenum; pixels: Pointer);
    procedure glRectd(x1, y1, x2, y2: GLdouble);
    procedure glRectdv(v1, v2: PGLdouble);
    procedure glRectf(x1, y1, x2, y2: GLfloat);
    procedure glRectfv(v1, v2: PGLfloat);
    procedure glRecti(x1, y1, x2, y2: GLint);
    procedure glRectiv(v1, v2: PGLint);
    procedure glRects(x1, y1, x2, y2: GLshort);
    procedure glRectsv(v1, v2: PGLshort);
    function glRenderMode(mode: GLenum): GLint;
    procedure glRotated(angle, x, y, z: GLdouble);
    procedure glRotatef(angle, x, y, z: GLfloat);
    procedure glScaled(x, y, z: GLdouble);
    procedure glScalef(x, y, z: GLfloat);
    procedure glScissor(x, y: GLint; Width, Height: GLsizei);
    procedure glSelectBuffer(size: GLsizei; buffer: PGLuint);
    procedure glShadeModel(mode: GLenum);
    procedure glStencilFunc(func: GLenum; ref: GLint; mask: GLuint);
    procedure glStencilMask(mask: GLuint);
    procedure glStencilOp(fail, zfail, zpass: GLenum);
    procedure glTexCoord1d(s: GLdouble);
    procedure glTexCoord1dv(v: PGLdouble);
    procedure glTexCoord1f(s: GLfloat);
    procedure glTexCoord1fv(v: PGLfloat);
    procedure glTexCoord1i(s: GLint);
    procedure glTexCoord1iv(v: PGLint);
    procedure glTexCoord1s(s: GLshort);
    procedure glTexCoord1sv(v: PGLshort);
    procedure glTexCoord2d(s, t: GLdouble);
    procedure glTexCoord2dv(v: PGLdouble);
    procedure glTexCoord2f(s, t: GLfloat);
    procedure glTexCoord2fv(v: PGLfloat);
    procedure glTexCoord2i(s, t: GLint);
    procedure glTexCoord2iv(v: PGLint);
    procedure glTexCoord2s(s, t: GLshort);
    procedure glTexCoord2sv(v: PGLshort);
    procedure glTexCoord3d(s, t, r: GLdouble);
    procedure glTexCoord3dv(v: PGLdouble);
    procedure glTexCoord3f(s, t, r: GLfloat);
    procedure glTexCoord3fv(v: PGLfloat);
    procedure glTexCoord3i(s, t, r: GLint);
    procedure glTexCoord3iv(v: PGLint);
    procedure glTexCoord3s(s, t, r: GLshort);
    procedure glTexCoord3sv(v: PGLshort);
    procedure glTexCoord4d(s, t, r, q: GLdouble);
    procedure glTexCoord4dv(v: PGLdouble);
    procedure glTexCoord4f(s, t, r, q: GLfloat);
    procedure glTexCoord4fv(v: PGLfloat);
    procedure glTexCoord4i(s, t, r, q: GLint);
    procedure glTexCoord4iv(v: PGLint);
    procedure glTexCoord4s(s, t, r, q: GLshort);
    procedure glTexCoord4sv(v: PGLshort);
    procedure glTexEnvf(target, pname: GLenum; param: GLfloat);
    procedure glTexEnvfv(target, pname: GLenum; params: PGLfloat);
    procedure glTexEnvi(target, pname: GLenum; param: GLint);
    procedure glTexEnviv(target, pname: GLenum; params: PGLint);
    procedure glTexGend(coord, pname: GLenum; param: GLdouble);
    procedure glTexGendv(coord, pname: GLenum; params: PGLdouble);
    procedure glTexGenf(coord, pname: GLenum; param: GLfloat);
    procedure glTexGenfv(coord, pname: GLenum; params: PGLfloat);
    procedure glTexGeni(coord, pname: GLenum; param: GLint);
    procedure glTexGeniv(coord, pname: GLenum; params: PGLint);
    procedure glTexImage1D(target: GLenum; level, internalformat: GLint; Width: GLsizei; border: GLint; format, atype: GLenum; pixels: Pointer);
    procedure glTexImage2D(target: GLenum; level, internalformat: GLint; Width, Height: GLsizei; border: GLint; format, atype: GLenum; pixels: Pointer);
    procedure glTexParameterf(target, pname: GLenum; param: GLfloat);
    procedure glTexParameterfv(target, pname: GLenum; params: PGLfloat);
    procedure glTexParameteri(target, pname: GLenum; param: GLint);
    procedure glTexParameteriv(target, pname: GLenum; params: PGLint);
    procedure glTranslated(x, y, z: GLdouble);
    procedure glTranslatef(x, y, z: GLfloat);
    procedure glVertex2d(x, y: GLdouble);
    procedure glVertex2dv(v: PGLdouble);
    procedure glVertex2f(x, y: GLfloat);
    procedure glVertex2fv(v: PGLfloat);
    procedure glVertex2i(x, y: GLint);
    procedure glVertex2iv(v: PGLint);
    procedure glVertex2s(x, y: GLshort);
    procedure glVertex2sv(v: PGLshort);
    procedure glVertex3d(x, y, z: GLdouble);
    procedure glVertex3dv(v: PGLdouble);
    procedure glVertex3f(x, y, z: GLfloat);
    procedure glVertex3fv(v: PGLfloat);
    procedure glVertex3i(x, y, z: GLint);
    procedure glVertex3iv(v: PGLint);
    procedure glVertex3s(x, y, z: GLshort);
    procedure glVertex3sv(v: PGLshort);
    procedure glVertex4d(x, y, z, w: GLdouble);
    procedure glVertex4dv(v: PGLdouble);
    procedure glVertex4f(x, y, z, w: GLfloat);
    procedure glVertex4fv(v: PGLfloat);
    procedure glVertex4i(x, y, z, w: GLint);
    procedure glVertex4iv(v: PGLint);
    procedure glVertex4s(x, y, z, w: GLshort);
    procedure glVertex4sv(v: PGLshort);
    procedure glViewport(x, y: GLint; Width, Height: GLsizei);
  end;

  IOpenGL11 = interface(IOpenGL10)
    ['{20E6E8AB-A9FA-43D7-8502-5F297E4BBFEB}']
    function glAreTexturesResident(n: GLsizei; textures: PGLuint; residences: PGLboolean): GLboolean;
    procedure glArrayElement(i: GLint);
    procedure glBindTexture(target: GLenum; texture: GLuint);
    procedure glColorPointer(size: GLint; atype: GLenum; stride: GLsizei; pointer: Pointer);
    procedure glDisableClientState(aArray: GLenum);
    procedure glDrawArrays(mode: GLenum; First: GLint; Count: GLsizei);
    procedure glDrawElements(mode: GLenum; Count: GLsizei; atype: GLenum; indices: Pointer);
    procedure glEdgeFlagPointer(stride: GLsizei; pointer: Pointer);
    procedure glEnableClientState(aArray: GLenum);
    procedure glGetPointerv(pname: GLenum; params: PPointer);
    procedure glIndexPointer(atype: GLenum; stride: GLsizei; pointer: Pointer);
    procedure glInterleavedArrays(format: GLenum; stride: GLsizei; pointer: Pointer);
    procedure glNormalPointer(atype: GLenum; stride: GLsizei; pointer: Pointer);
    procedure glPolygonOffset(factor, units: GLfloat);
    procedure glPrioritizeTextures(n: GLsizei; textures: PGLuint; priorities: PGLclampf);
    procedure glTexCoordPointer(size: GLint; atype: GLenum; stride: GLsizei; pointer: Pointer);
    procedure glTexSubImage1D(target: GLenum; level, xoffset: GLint; Width: GLsizei; format, atype: GLenum; pixels: Pointer);
    procedure glTexSubImage2D(target: GLenum; level, xoffset, yoffset: GLint; Width, Height: GLsizei; format, atype: GLenum; pixels: Pointer);
    procedure glVertexPointer(size: GLint; atype: GLenum; stride: GLsizei; pointer: Pointer);

  end;

  IOpenGL12 = interface(IOpenGL11)
    ['{F24FBECB-BC73-4E01-A271-0B071B96D6F0}']
    procedure glCopyTexSubImage3D(target: GLenum; level: GLint; xoffset, yoffset, zoffset: GLint; x, y: GLint; Width, Height: GLsizei);
    procedure glDrawRangeElements(mode: GLenum; start, aend: GLuint; Count: GLsizei; atype: GLenum; indices: Pointer);
    procedure glTexImage3D(target: GLenum; level: GLint; internalformat: GLint; Width, Height, depth: GLsizei; border: GLint; format, atype: GLenum; pixels: Pointer);
    procedure glTexSubImage3D(target: GLenum; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, atype: GLenum; pixels: Pointer);
  end;

  IOpenGL13 = interface(IOpenGL12)
    ['{4333FD65-A160-4A65-BD3C-70330DC0E388}']
    procedure glActiveTexture(texture: GLenum);
    procedure glClientActiveTexture(texture: GLenum);
    procedure glCompressedTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; border: GLint; imageSize: GLsizei; Data: Pointer);
    procedure glCompressedTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; Width, Height: GLsizei; border: GLint; imageSize: GLsizei; Data: Pointer);
    procedure glCompressedTexImage3D(target: GLenum; level: GLint; internalformat: GLenum; Width, Height, depth: GLsizei; border: GLint; imageSize: GLsizei; Data: Pointer);
    procedure glCompressedTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; Data: Pointer);
    procedure glCompressedTexSubImage2D(target: GLenum; level: GLint; xoffset, yoffset: GLint; Width, Height: GLsizei; format: GLenum; imageSize: GLsizei; Data: Pointer);
    procedure glCompressedTexSubImage3D(target: GLenum; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; imageSize: GLsizei; Data: Pointer);
    procedure glGetCompressedTexImage(target: GLenum; level: GLint; img: Pointer);
    procedure glLoadTransposeMatrixd(m: PGLdouble);
    procedure glLoadTransposeMatrixf(m: PGLfloat);
    procedure glMultTransposeMatrixd(m: PGLdouble);
    procedure glMultTransposeMatrixf(m: PGLfloat);
    procedure glMultiTexCoord1d(target: GLenum; s: GLdouble);
    procedure glMultiTexCoord1dv(target: GLenum; v: PGLdouble);
    procedure glMultiTexCoord1f(target: GLenum; s: GLfloat);
    procedure glMultiTexCoord1fv(target: GLenum; v: PGLfloat);
    procedure glMultiTexCoord1i(target: GLenum; s: GLint);
    procedure glMultiTexCoord1iv(target: GLenum; v: PGLint);
    procedure glMultiTexCoord1s(target: GLenum; s: GLshort);
    procedure glMultiTexCoord1sv(target: GLenum; v: PGLshort);
    procedure glMultiTexCoord2d(target: GLenum; s, t: GLdouble);
    procedure glMultiTexCoord2dv(target: GLenum; v: PGLdouble);
    procedure glMultiTexCoord2f(target: GLenum; s, t: GLfloat);
    procedure glMultiTexCoord2fv(target: GLenum; v: PGLfloat);
    procedure glMultiTexCoord2i(target: GLenum; s, t: GLint);
    procedure glMultiTexCoord2iv(target: GLenum; v: PGLint);
    procedure glMultiTexCoord2s(target: GLenum; s, t: GLshort);
    procedure glMultiTexCoord2sv(target: GLenum; v: PGLshort);
    procedure glMultiTexCoord3d(target: GLenum; s, t, r: GLdouble);
    procedure glMultiTexCoord3dv(target: GLenum; v: PGLdouble);
    procedure glMultiTexCoord3f(target: GLenum; s, t, r: GLfloat);
    procedure glMultiTexCoord3fv(target: GLenum; v: PGLfloat);
    procedure glMultiTexCoord3i(target: GLenum; s, t, r: GLint);
    procedure glMultiTexCoord3iv(target: GLenum; v: PGLint);
    procedure glMultiTexCoord3s(target: GLenum; s, t, r: GLshort);
    procedure glMultiTexCoord3sv(target: GLenum; v: PGLshort);
    procedure glMultiTexCoord4d(target: GLenum; s, t, r, q: GLdouble);
    procedure glMultiTexCoord4dv(target: GLenum; v: PGLdouble);
    procedure glMultiTexCoord4f(target: GLenum; s, t, r, q: GLfloat);
    procedure glMultiTexCoord4fv(target: GLenum; v: PGLfloat);
    procedure glMultiTexCoord4i(target: GLenum; s, t, r, q: GLint);
    procedure glMultiTexCoord4iv(target: GLenum; v: PGLint);
    procedure glMultiTexCoord4s(target: GLenum; s, t, r, q: GLshort);
    procedure glMultiTexCoord4sv(target: GLenum; v: PGLshort);
    procedure glSampleCoverage(Value: GLclampf; invert: GLboolean);
  end;

  IOpenGL14 = interface(IOpenGL13)
    ['{B8EB43C9-5C35-46EF-A38D-A73D094B0A7F}']
    procedure glBlendColor(red, green, blue, alpha: GLclampf);
    procedure glBlendEquation(mode: GLenum);
    procedure glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha: GLenum);
    procedure glFogCoordd(coord: GLdouble);
    procedure glFogCoorddv(coord: PGLdouble);
    procedure glFogCoordf(coord: GLfloat);
    procedure glFogCoordfv(coord: PGLfloat);
    procedure glFogCoordPointer(atype: GLenum; stride: GLsizei; pointer: Pointer);
    procedure glMultiDrawArrays(mode: GLenum; First: PGLint; Count: PGLsizei; primcount: GLsizei);
    procedure glMultiDrawElements(mode: GLenum; Count: PGLsizei; atype: GLenum; indices: PPointer; primcount: GLsizei);
    procedure glPointParameterf(pname: GLenum; param: GLfloat);
    procedure glPointParameterfv(pname: GLenum; params: PGLfloat);
    procedure glPointParameteri(pname: GLenum; param: GLint);
    procedure glPointParameteriv(pname: GLenum; params: PGLint);
    procedure glSecondaryColor3b(red, green, blue: GLbyte);
    procedure glSecondaryColor3bv(v: PGLbyte);
    procedure glSecondaryColor3d(red, green, blue: GLdouble);
    procedure glSecondaryColor3dv(v: PGLdouble);
    procedure glSecondaryColor3f(red, green, blue: GLfloat);
    procedure glSecondaryColor3fv(v: PGLfloat);
    procedure glSecondaryColor3i(red, green, blue: GLint);
    procedure glSecondaryColor3iv(v: PGLint);
    procedure glSecondaryColor3s(red, green, blue: GLshort);
    procedure glSecondaryColor3sv(v: PGLshort);
    procedure glSecondaryColor3ub(red, green, blue: GLubyte);
    procedure glSecondaryColor3ubv(v: PGLubyte);
    procedure glSecondaryColor3ui(red, green, blue: GLuint);
    procedure glSecondaryColor3uiv(v: PGLuint);
    procedure glSecondaryColor3us(red, green, blue: GLushort);
    procedure glSecondaryColor3usv(v: PGLushort);
    procedure glWindowPos2d(x, y: GLdouble);
    procedure glWindowPos2dv(v: PGLdouble);
    procedure glWindowPos2f(x, y: GLfloat);
    procedure glWindowPos2fv(v: PGLfloat);
    procedure glWindowPos2i(x, y: GLint);
    procedure glWindowPos2iv(v: PGLint);
    procedure glWindowPos2s(x, y: GLshort);
    procedure glWindowPos2sv(v: PGLshort);
    procedure glWindowPos3d(x, y, z: GLdouble);
    procedure glWindowPos3dv(v: PGLdouble);
    procedure glWindowPos3f(x, y, z: GLfloat);
    procedure glWindowPos3fv(v: PGLfloat);
    procedure glWindowPos3i(x, y, z: GLint);
    procedure glWindowPos3iv(v: PGLint);
    procedure glWindowPos3s(x, y, z: GLshort);
    procedure glWindowPos3sv(v: PGLshort);
  end;

  IOpenGL15 = interface(IOpenGL14)
    ['{5EDC3854-4945-4BF8-BBC7-2C172A43D78B}']
     procedure glBeginQuery(target: GLenum; id: GLuint);
    procedure glBindBuffer(target: GLenum; buffer: GLuint);
    procedure glBufferData(target: GLenum; size: GLsizeiptr; data: Pointer; usage: GLenum);
    procedure glBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; data: Pointer);
    procedure glDeleteBuffers(n: GLsizei; buffers: PGLuint);
    procedure glDeleteQueries(n: GLsizei; ids: PGLuint);
    procedure glEndQuery(target: GLenum);
    procedure glGenBuffers(n: GLsizei; buffers: PGLuint);
    procedure glGenQueries(n: GLsizei; ids: PGLuint);
    procedure glGetBufferParameteriv(target, pname: GLenum; params: PGLint);
    procedure glGetBufferPointerv(target, pname: GLenum; params: PPointer);
    procedure glGetBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; data: Pointer);
    procedure glGetQueryiv(target, pname: GLenum; params: PGLint);
    procedure glGetQueryObjectiv(id: GLuint; pname: GLenum; params: PGLint);
    procedure glGetQueryObjectuiv(id: GLuint; pname: GLenum; params: PGLuint);
    function  glIsBuffer(buffer: GLuint): GLboolean;
    function  glIsQuery(id: GLuint): GLboolean;
    function glMapBuffer(target: GLenum; access: GLenum): Pointer;
    function  glUnmapBuffer(target: GLenum): GLboolean;
  end;

  IOpenGL20 = interface(IOpenGL15)
    ['{7AAC5368-B939-42DB-8A2A-C7B52404A4A2}']
    function glCreateShader(shaderType: GLenum): GLuint; overload;
    procedure glDeleteShader(shaderObj: GLuint); overload;
    procedure glShaderSource(shaderObj: GLuint; Count: GLsizei; const strings: PPGLchar; const length: PGLint); overload;
    procedure glCompileShader(shaderObj: GLuint); overload;
    procedure glGetShaderiv(shaderObj: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetShaderInfoLog(shaderObj: GLuint; maxLength: GLsizei; length: PGLint; infoLog: PGLchar); overload;
    function glIsShader(shaderObj: GLuint): GLboolean; overload;

    function glCreateProgram: GLuint; overload;
    procedure glDeleteProgram(programObj: GLuint); overload;
    procedure glAttachShader(programObj, shaderObj: GLuint); overload;
    procedure glDetachShader(programObj, shaderObj: GLuint); overload;
    procedure glLinkProgram(programObj: GLuint); overload;
    procedure glUseProgram(programObj: GLuint); overload;
    procedure glValidateProgram(programObj: GLuint); overload;
    procedure glGetProgramiv(programObj: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetProgramInfoLog(programObj: GLuint; maxLength: GLsizei; length: PGLint; infoLog: PGLchar); overload;
    function glIsProgram(programObj: GLuint): GLboolean; overload;
    procedure glBindAttribLocation(programObj: GLuint; index: GLuint; const Name: PGLchar); overload;
    procedure glGetActiveAttrib(programObj, index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; typ: PGLenum; Name: PGLchar); overload;
    procedure glGetAttachedShaders(programObj: GLuint; maxCount: GLsizei; Count: PGLsizei; shaders: PGLuint); overload;
    function glGetAttribLocation(programObj: GLuint; const Name: PGLchar): GLint; overload;
    function glGetUniformLocation(programObj: GLuint; const Name: PGLchar): GLint; overload;
    procedure glGetActiveUniform(programObj, index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; typ: PGLenum; Name: PGLchar); overload;

    procedure glUniform1f(location: GLint; v0: GLfloat); overload;
    procedure glUniform2f(location: GLint; v0, v1: GLfloat); overload;
    procedure glUniform3f(location: GLint; v0, v1, v2: GLfloat); overload;
    procedure glUniform4f(location: GLint; v0, v1, v2, v3: GLfloat); overload;
    procedure glUniform1i(location: GLint; v0: GLint); overload;
    procedure glUniform2i(location: GLint; v0, v1: GLint); overload;
    procedure glUniform3i(location: GLint; v0, v1, v2: GLint); overload;
    procedure glUniform4i(location: GLint; v0, v1, v2, v3: GLint); overload;

    procedure glUniform1fv(location: GLint; Count: GLsizei; Value: PGLfloat); overload;
    procedure glUniform2fv(location: GLint; Count: GLsizei; Value: PGLfloat); overload;
    procedure glUniform3fv(location: GLint; Count: GLsizei; Value: PGLfloat); overload;
    procedure glUniform4fv(location: GLint; Count: GLsizei; Value: PGLfloat); overload;
    procedure glUniform1iv(location: GLint; Count: GLsizei; Value: PGLint); overload;
    procedure glUniform2iv(location: GLint; Count: GLsizei; Value: PGLint); overload;
    procedure glUniform3iv(location: GLint; Count: GLsizei; Value: PGLint); overload;
    procedure glUniform4iv(location: GLint; Count: GLsizei; Value: PGLint); overload;

    procedure glUniformMatrix2fv(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); overload;
    procedure glUniformMatrix3fv(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); overload;
    procedure glUniformMatrix4fv(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); overload;

    procedure glVertexAttribPointer(index: GLuint; size: GLint; typ: GLenum; normalized: GLboolean; stride: GLsizei; const pointer: Pointer); overload;
    procedure glEnableVertexAttribArray(index: GLuint); overload;
    procedure glDisableVertexAttribArray(index: GLuint); overload;
    procedure glGetVertexAttribiv(index: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetVertexAttribfv(index: GLuint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetVertexAttribPointerv(index: GLuint; pname: GLenum; pointer: PPointer); overload;

    procedure glStencilOpSeparate(face, sfail, dpfail, dppass: GLenum); overload;
    procedure glStencilFuncSeparate(face: GLenum; func: GLenum; ref: GLint; mask: GLuint); overload;
    procedure glStencilMaskSeparate(face: GLenum; mask: GLuint); overload;
    procedure glDrawBuffers(n: GLsizei; const bufs: PGLenum); overload;
  end;

  IOpenGL21 = interface(IOpenGL20)
    ['{5D8FF625-789E-4415-BD04-E85ED49F76E8}']
    procedure glUniformMatrix2x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix3x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix2x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix4x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix3x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix4x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
  end;

  IOpenGL30 = interface(IOpenGL21)
    ['{713B8D48-80E4-4BEC-9EAE-4F61450F2D8E}']
    procedure glColorMaski(index: GLuint; r, g, b, a: GLboolean); overload;

    procedure glGetBooleani_v(target: GLenum; index: GLuint; Data: PGLboolean); overload;
    procedure glGetIntegeri_v(target: GLenum; index: GLuint; Data: PGLint); overload;

    procedure glEnablei(target: GLenum; index: GLuint); overload;
    procedure glDisablei(target: GLenum; index: GLuint); overload;
    function glIsEnabledi(target: GLenum; index: GLuint): GLboolean; overload;

    procedure glBeginTransformFeedback(primitiveMode: GLenum); overload;
    procedure glEndTransformFeedback; overload;

    procedure glBindBufferRange(target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glBindBufferBase(target: GLenum; index: GLuint; buffer: GLuint); overload;

    procedure glTransformFeedbackVaryings(aProgram: GLuint; Count: GLsizei; const varyings: PPGLchar; bufferMode: GLenum); overload;
    procedure glGetTransformFeedbackVarying(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; aType: PGLenum; Name: PGLchar); overload;

    procedure glClampColor(target: GLenum; clamp: GLenum); overload;

    procedure glBeginConditionalRender(id: GLuint; mode: GLenum); overload;
    procedure glEndConditionalRender; overload;

    procedure glVertexAttribIPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const pointer: Pointer); overload;
    procedure glGetVertexAttribIiv(index: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetVertexAttribIuiv(index: GLuint; pname: GLenum; params: PGLuint); overload;

    procedure glVertexAttribI1i(index: GLuint; x: GLint); overload;
    procedure glVertexAttribI2i(index: GLuint; x, y: GLint); overload;
    procedure glVertexAttribI3i(index: GLuint; x, y, z: GLint); overload;
    procedure glVertexAttribI4i(index: GLuint; x, y, z, w: GLint); overload;

    procedure glVertexAttribI1ui(index: GLuint; x: GLuint); overload;
    procedure glVertexAttribI2ui(index: GLuint; x, y: GLuint); overload;
    procedure glVertexAttribI3ui(index: GLuint; x, y, z: GLuint); overload;
    procedure glVertexAttribI4ui(index: GLuint; x, y, z, w: GLuint); overload;

    procedure glVertexAttribI1iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI2iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI3iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI4iv(index: GLuint; const v: PGLint); overload;

    procedure glVertexAttribI1uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI2uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI3uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI4uiv(index: GLuint; const v: PGLuint); overload;

    procedure glVertexAttribI4bv(index: GLuint; const v: PGLbyte); overload;
    procedure glVertexAttribI4sv(index: GLuint; const v: PGLshort); overload;
    procedure glVertexAttribI4ubv(index: GLuint; const v: PGLubyte); overload;
    procedure glVertexAttribI4usv(index: GLuint; const v: PGLushort); overload;

    procedure glGetUniformuiv(aProgram: GLuint; location: GLint; params: PGLuint); overload;
    procedure glBindFragDataLocation(aProgram: GLuint; color: GLuint; const Name: PGLchar); overload;
    function glGetFragDataLocation(aProgram: GLuint; const Name: PGLchar): GLint; overload;

    procedure glUniform1ui(location: GLint; v0: GLuint); overload;
    procedure glUniform2ui(location: GLint; v0, v1: GLuint); overload;
    procedure glUniform3ui(location: GLint; v0, v1, v2: GLuint); overload;
    procedure glUniform4ui(location: GLint; v0, v1, v2, v3: GLuint); overload;

    procedure glUniform1uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glUniform2uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glUniform3uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glUniform4uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glTexParameterIiv(target: GLenum; pname: GLenum; const params: PGLint);
    procedure glTexParameterIuiv(target: GLenum; pname: GLenum; const params: PGLuint);
    procedure glGetTexParameterIiv(target: GLenum; pname: GLenum; params: PGLint);
    procedure glGetTexParameterIuiv(target: GLenum; pname: GLenum; params: PGLuint);

    procedure glClearBufferiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLint);
    procedure glClearBufferuiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLuint);
    procedure glClearBufferfv(buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat);
    procedure glClearBufferfi(buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint);

    function glGetStringi(Name: GLenum; index: GLuint): PGLubyte;

    function glIsRenderbuffer(renderbuffer: GLuint): GLboolean;
    procedure glBindRenderbuffer(target: GLenum; renderbuffer: GLuint);
    procedure glDeleteRenderbuffers(n: GLsizei; const renderbuffers: PGLuint);
    procedure glGenRenderbuffers(n: GLsizei; renderbuffers: PGLuint);
    procedure glRenderbufferStorage(target: GLenum; internalformat: GLenum; Width, Height: GLsizei);
    procedure glGetRenderbufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);

    function glIsFramebuffer(framebuffer: GLuint): GLboolean;
    procedure glBindFramebuffer(target: GLenum; framebuffer: GLuint);
    procedure glDeleteFramebuffers(n: GLsizei; const framebuffers: PGLuint);
    procedure glGenFramebuffers(n: GLsizei; framebuffers: PGLuint);
    function glCheckFramebufferStatus(target: GLenum): GLenum;

    procedure glFramebufferTexture1D(target, attachment, textarget: GLenum; texture: GLuint; level: GLint);
    procedure glFramebufferTexture2D(target, attachment, textarget: GLenum; texture: GLuint; level: GLint);
    procedure glFramebufferTexture3D(target, attachment, textarget: GLenum; texture: GLuint; level, zoffset: GLint);
    procedure glFramebufferRenderbuffer(target, attachment, renderbuffertarget: GLenum; renderbuffer: GLuint);
    procedure glGetFramebufferAttachmentParameteriv(target, attachment, pname: GLenum; params: PGLint);

    procedure glGenerateMipmap(target: GLenum);

    procedure glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1: GLint; mask: GLbitfield; filter: GLenum);

    procedure glRenderbufferStorageMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei);

    procedure glFramebufferTextureLayer(target, attachment: GLenum; texture: GLuint; level, layer: GLint);

    function glMapBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer;
    procedure glFlushMappedBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr);
    procedure glBindVertexArray(array_: GLuint);
    procedure glDeleteVertexArrays(n: GLsizei; const arrays: PGLuint);
    procedure glGenVertexArrays(n: GLsizei; arrays: PGLuint);
    function glIsVertexArray(array_: GLuint): GLboolean;
  end;
  // -------------------------------------------------------------------------
  // OpenGL 3.1
  // -------------------------------------------------------------------------
  IOpenGL31 = interface(IOpenGL30)
    ['{477CB265-7902-4C72-B438-7B40F7690CF1}']
    procedure glDrawArraysInstanced(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei); overload;
    procedure glDrawElementsInstanced(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei); overload;
    procedure glTexBuffer(target: GLenum; internalformat: GLenum; buffer: GLuint); overload;
    procedure glPrimitiveRestartIndex(index: GLuint); overload;
    procedure glCopyBufferSubData(readTarget, writeTarget: GLenum; readOffset, writeOffset: GLintptr; size: GLsizeiptr); overload;
    procedure glGetUniformIndices(aProgram: GLuint; uniformCount: GLsizei; const uniformNames: PPGLchar; uniformIndices: PGLuint); overload;
    procedure glGetActiveUniformsiv(aProgram: GLuint; uniformCount: GLsizei; const uniformIndices: PGLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetActiveUniformName(aProgram: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar); overload;
    function glGetUniformBlockIndex(aProgram: GLuint; const uniformBlockName: PGLchar): GLuint; overload;
    procedure glGetActiveUniformBlockiv(aProgram: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetActiveUniformBlockName(aProgram: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar); overload;
    procedure glUniformBlockBinding(aProgram: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint); overload;
  end;

  // -------------------------------------------------------------------------
  // OpenGL 3.2
  // -------------------------------------------------------------------------
  IOpenGL32 = interface(IOpenGL31)
    ['{08EDCAE5-6C64-4F67-9BB9-66E1230E2F0E}']
    procedure glDrawElementsBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); overload;
    procedure glDrawRangeElementsBaseVertex(mode: GLenum; start, end_: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); overload;
    procedure glDrawElementsInstancedBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint); overload;
    procedure glMultiDrawElementsBaseVertex(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: PPointer; drawcount: GLsizei; const basevertex: PGLint); overload;
    procedure glProvokingVertex(mode: GLenum); overload;

    function glFenceSync(condition: GLenum; flags: GLbitfield): GLsync; overload;
    function glIsSync(sync: GLsync): GLboolean; overload;
    procedure glDeleteSync(sync: GLsync); overload;
    function glClientWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum; overload;
    procedure glWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64); overload;

    procedure glGetInteger64v(pname: GLenum; Data: PGLint64); overload;
    procedure glGetSynciv(sync: GLsync; pname: GLenum; bufSize: GLsizei; length: PGLsizei; values: PGLint); overload;
    procedure glGetInteger64i_v(target: GLenum; index: GLuint; Data: PGLint64); overload;
    procedure glGetBufferParameteri64v(target, pname: GLenum; params: PGLint64); overload;

    procedure glFramebufferTexture(target, attachment: GLenum; texture: GLuint; level: GLint); overload;

    procedure glTexImage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTexImage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean); overload;

    procedure glGetMultisamplefv(pname: GLenum; index: GLuint; val: PGLfloat); overload;
    procedure glSampleMaski(maskNumber: GLuint; mask: GLbitfield); overload;
  end;

  // -------------------------------------------------------------------------
  // OpenGL 3.3
  // -------------------------------------------------------------------------
  IOpenGL33 = interface(IOpenGL32)
    ['{AB21BC73-A8AA-4FE4-A735-9B16719C6F7C}']
    procedure glBindFragDataLocationIndexed(aProgram: GLuint; colorNumber: GLuint; index: GLuint; const Name: PGLchar); overload;
    function glGetFragDataIndex(aProgram: GLuint; const Name: PGLchar): GLint; overload;

    procedure glGenSamplers(Count: GLsizei; samplers: PGLuint); overload;
    procedure glDeleteSamplers(Count: GLsizei; const samplers: PGLuint); overload;
    function glIsSampler(sampler: GLuint): GLboolean; overload;
    procedure glBindSampler(aUnit: GLuint; sampler: GLuint); overload;

    procedure glSamplerParameteri(sampler: GLuint; pname: GLenum; param: GLint); overload;
    procedure glSamplerParameteriv(sampler: GLuint; pname: GLenum; const param: PGLint); overload;
    procedure glSamplerParameterf(sampler: GLuint; pname: GLenum; param: GLfloat); overload;
    procedure glSamplerParameterfv(sampler: GLuint; pname: GLenum; const param: PGLfloat); overload;
    procedure glSamplerParameterIiv(sampler: GLuint; pname: GLenum; const param: PGLint); overload;
    procedure glSamplerParameterIuiv(sampler: GLuint; pname: GLenum; const param: PGLuint); overload;

    procedure glGetSamplerParameteriv(sampler: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetSamplerParameterIiv(sampler: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetSamplerParameterfv(sampler: GLuint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetSamplerParameterIuiv(sampler: GLuint; pname: GLenum; params: PGLuint); overload;

    procedure glQueryCounter(id: GLuint; target: GLenum); overload;
    procedure glGetQueryObjecti64v(id: GLuint; pname: GLenum; params: PGLint64); overload;
    procedure glGetQueryObjectui64v(id: GLuint; pname: GLenum; params: PGLuint64); overload;

    procedure glVertexAttribDivisor(index: GLuint; divisor: GLuint); overload;

    procedure glVertexAttribP1ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP1uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexAttribP2ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP2uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexAttribP3ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP3uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexAttribP4ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP4uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
  end;

  // -------------------------------------------------------------------------
  // OpenGL 4.0
  // -------------------------------------------------------------------------
  IOpenGL40 = interface(IOpenGL33)
    ['{C32F36D3-578E-480F-AEF5-A460A950A029}']
    procedure glMinSampleShading(Value: GLfloat); overload;

    procedure glBlendEquationi(buf: GLuint; mode: GLenum); overload;
    procedure glBlendEquationSeparatei(buf: GLuint; modeRGB, modeAlpha: GLenum); overload;
    procedure glBlendFunci(buf: GLuint; src, dst: GLenum); overload;
    procedure glBlendFuncSeparatei(buf: GLuint; srcRGB, dstRGB, srcAlpha, dstAlpha: GLenum); overload;

    procedure glDrawArraysIndirect(mode: GLenum; const indirect: Pointer); overload;
    procedure glDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer); overload;

    procedure glUniform1d(location: GLint; x: GLdouble); overload;
    procedure glUniform2d(location: GLint; x, y: GLdouble); overload;
    procedure glUniform3d(location: GLint; x, y, z: GLdouble); overload;
    procedure glUniform4d(location: GLint; x, y, z, w: GLdouble); overload;

    procedure glUniform1dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniform2dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniform3dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniform4dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;

    procedure glUniformMatrix2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix2x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix2x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix3x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix3x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix4x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix4x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;

    procedure glGetUniformdv(aProgram: GLuint; location: GLint; params: PGLdouble); overload;

    function glGetSubroutineUniformLocation(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLint; overload;
    function glGetSubroutineIndex(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLuint; overload;

    procedure glGetActiveSubroutineUniformiv(aProgram: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint); overload;
    procedure glGetActiveSubroutineUniformName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); overload;
    procedure glGetActiveSubroutineName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); overload;

    procedure glUniformSubroutinesuiv(shadertype: GLenum; Count: GLsizei; const indices: PGLuint); overload;
    procedure glGetUniformSubroutineuiv(shadertype: GLenum; location: GLint; params: PGLuint); overload;

    procedure glGetProgramStageiv(aProgram: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint); overload;

    procedure glPatchParameteri(pname: GLenum; Value: GLint); overload;
    procedure glPatchParameterfv(pname: GLenum; const values: PGLfloat); overload;

    procedure glBindTransformFeedback(target: GLenum; id: GLuint); overload;
    procedure glDeleteTransformFeedbacks(n: GLsizei; const ids: PGLuint); overload;
    procedure glGenTransformFeedbacks(n: GLsizei; ids: PGLuint); overload;
    function glIsTransformFeedback(id: GLuint): GLboolean; overload;
    procedure glPauseTransformFeedback; overload;
    procedure glResumeTransformFeedback; overload;
    procedure glDrawTransformFeedback(mode: GLenum; id: GLuint); overload;
    procedure glDrawTransformFeedbackStream(mode: GLenum; id: GLuint; stream: GLuint); overload;

    procedure glBeginQueryIndexed(target: GLenum; index: GLuint; id: GLuint); overload;
    procedure glEndQueryIndexed(target: GLenum; index: GLuint); overload;
    procedure glGetQueryIndexediv(target: GLenum; index: GLuint; pname: GLenum; params: PGLint); overload;
  end;

  // -------------------------------------------------------------------------
  // OpenGL 4.1
  // -------------------------------------------------------------------------
  IOpenGL41 = interface(IOpenGL40)
    ['{4F1FC8E8-8CF0-462D-A574-12777032F559}']
    procedure glReleaseShaderCompiler; overload;
    procedure glShaderBinary(Count: GLsizei; const shaders: PGLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); overload;
    procedure glGetShaderPrecisionFormat(shadertype, precisiontype: GLenum; range_, precision: PGLint); overload;

    procedure glDepthRangef(n, f: GLfloat); overload;
    procedure glClearDepthf(d: GLfloat); overload;

    procedure glGetProgramBinary(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer); overload;
    procedure glProgramBinary(aProgram: GLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); overload;
    procedure glProgramParameteri(aProgram: GLuint; pname: GLenum; Value: GLint); overload;

    procedure glUseProgramStages(pipeline: GLuint; stages: GLbitfield; aProgram: GLuint); overload;
    procedure glActiveShaderProgram(pipeline, aProgram: GLuint); overload;
    function glCreateShaderProgramv(aType: GLenum; Count: GLsizei; const strings: PPGLchar): GLuint;

    procedure glBindProgramPipeline(pipeline: GLuint); overload;
    procedure glDeleteProgramPipelines(n: GLsizei; const pipelines: PGLuint); overload;
    procedure glGenProgramPipelines(n: GLsizei; pipelines: PGLuint); overload;
    function glIsProgramPipeline(pipeline: GLuint): GLboolean;
    procedure glGetProgramPipelineiv(pipeline: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glValidateProgramPipeline(pipeline: GLuint); overload;
    procedure glGetProgramPipelineInfoLog(pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); overload;

    // ProgramUniform* (Separate Shader Objects)
    procedure glProgramUniform1i(aProgram: GLuint; location: GLint; v0: GLint); overload;
    procedure glProgramUniform1iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform1f(aProgram: GLuint; location: GLint; v0: GLfloat); overload;
    procedure glProgramUniform1fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform1d(aProgram: GLuint; location: GLint; v0: GLdouble); overload;
    procedure glProgramUniform1dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform1ui(aProgram: GLuint; location: GLint; v0: GLuint); overload;
    procedure glProgramUniform1uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glProgramUniform2i(aProgram: GLuint; location: GLint; v0, v1: GLint); overload;
    procedure glProgramUniform2iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform2f(aProgram: GLuint; location: GLint; v0, v1: GLfloat); overload;
    procedure glProgramUniform2fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform2d(aProgram: GLuint; location: GLint; v0, v1: GLdouble); overload;
    procedure glProgramUniform2dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform2ui(aProgram: GLuint; location: GLint; v0, v1: GLuint); overload;
    procedure glProgramUniform2uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glProgramUniform3i(aProgram: GLuint; location: GLint; v0, v1, v2: GLint); overload;
    procedure glProgramUniform3iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform3f(aProgram: GLuint; location: GLint; v0, v1, v2: GLfloat); overload;
    procedure glProgramUniform3fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform3d(aProgram: GLuint; location: GLint; v0, v1, v2: GLdouble); overload;
    procedure glProgramUniform3dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform3ui(aProgram: GLuint; location: GLint; v0, v1, v2: GLuint); overload;
    procedure glProgramUniform3uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glProgramUniform4i(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLint); overload;
    procedure glProgramUniform4iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform4f(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLfloat); overload;
    procedure glProgramUniform4fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform4d(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLdouble); overload;
    procedure glProgramUniform4dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform4ui(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLuint); overload;
    procedure glProgramUniform4uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glProgramUniformMatrix2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;

    procedure glProgramUniformMatrix2x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix3x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix2x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix4x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix3x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix4x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;

    procedure glProgramUniformMatrix2x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix3x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix2x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix4x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix3x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix4x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;

    // Double-precision vertex attributes
    procedure glVertexAttribL1d(index: GLuint; x: GLdouble); overload;
    procedure glVertexAttribL2d(index: GLuint; x, y: GLdouble); overload;
    procedure glVertexAttribL3d(index: GLuint; x, y, z: GLdouble); overload;
    procedure glVertexAttribL4d(index: GLuint; x, y, z, w: GLdouble); overload;
    procedure glVertexAttribL1dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribL2dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribL3dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribL4dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribLPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const pointer: Pointer); overload;
    procedure glGetVertexAttribLdv(index: GLuint; pname: GLenum; params: PGLdouble); overload;

    // Viewport / Scissor / DepthRange arrays
    procedure glViewportArrayv(First: GLuint; Count: GLsizei; const v: PGLfloat); overload;
    procedure glViewportIndexedf(index: GLuint; x, y, w, h: GLfloat); overload;
    procedure glViewportIndexedfv(index: GLuint; const v: PGLfloat); overload;

    procedure glScissorArrayv(First: GLuint; Count: GLsizei; const v: PGLint); overload;
    procedure glScissorIndexed(index: GLuint; left, bottom: GLint; Width, Height: GLsizei); overload;
    procedure glScissorIndexedv(index: GLuint; const v: PGLint); overload;

    procedure glDepthRangeArrayv(First: GLuint; Count: GLsizei; const v: PGLdouble); overload;
    procedure glDepthRangeIndexed(index: GLuint; n, f: GLdouble); overload;

    procedure glGetFloati_v(target: GLenum; index: GLuint; Data: PGLfloat); overload;
    procedure glGetDoublei_v(target: GLenum; index: GLuint; Data: PGLdouble); overload;
  end;

  // -------------------------------------------------------------------------
  // OpenGL 4.2
  // -------------------------------------------------------------------------
  IOpenGL42 = interface(IOpenGL41)
    ['{912AC4D4-DFCA-4C21-9785-B2F9F4FE1A13}']
    procedure glDrawArraysInstancedBaseInstance(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei; baseinstance: GLuint); overload;
    procedure glDrawElementsInstancedBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; baseinstance: GLuint); overload;
    procedure glDrawElementsInstancedBaseVertexBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint); overload;
    procedure glGetInternalformativ(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint); overload;
    procedure glGetActiveAtomicCounterBufferiv(aProgram: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glBindImageTexture(aUnit: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum); overload;
    procedure glMemoryBarrier(barriers: GLbitfield); overload;
    procedure glTexStorage1D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei); overload;
    procedure glTexStorage2D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); overload;
    procedure glTexStorage3D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei); overload;
    procedure glDrawTransformFeedbackInstanced(mode: GLenum; id: GLuint; instancecount: GLsizei); overload;
    procedure glDrawTransformFeedbackStreamInstanced(mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei); overload;
  end;

  // -------------------------------------------------------------------------
  // OpenGL 4.3
  // -------------------------------------------------------------------------
  IOpenGL43 = interface(IOpenGL42)
    ['{958657BC-D67D-4CC1-8A65-E5F7542DFAAD}']
    procedure glClearBufferData(target: GLenum; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glClearBufferSubData(target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer); overload;

    procedure glDispatchCompute(num_groups_x, num_groups_y, num_groups_z: GLuint); overload;
    procedure glDispatchComputeIndirect(indirect: GLintptr); overload;

    procedure glCopyImageSubData(srcName: GLuint; srcTarget: GLenum; srcLevel, srcX, srcY, srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel, dstX, dstY, dstZ: GLint; srcWidth, srcHeight, srcDepth: GLsizei); overload;

    procedure glFramebufferParameteri(target: GLenum; pname: GLenum; param: GLint); overload;
    procedure glGetFramebufferParameteriv(target: GLenum; pname: GLenum; params: PGLint); overload;

    procedure glGetInternalformati64v(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint64); overload;

    procedure glInvalidateTexSubImage(texture: GLuint; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei); overload;
    procedure glInvalidateTexImage(texture: GLuint; level: GLint); overload;
    procedure glInvalidateBufferSubData(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); overload;
    procedure glInvalidateBufferData(buffer: GLuint); overload;
    procedure glInvalidateFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum); overload;
    procedure glInvalidateSubFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum; x, y: GLint; Width, Height: GLsizei); overload;

    procedure glMultiDrawArraysIndirect(mode: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei); overload;
    procedure glMultiDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei); overload;

    procedure glGetProgramInterfaceiv(aProgram: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint); overload;
    function glGetProgramResourceIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLuint; overload;
    procedure glGetProgramResourceName(aProgram: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); overload;
    procedure glGetProgramResourceiv(aProgram: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; const props: PGLenum; Count: GLsizei; length: PGLsizei; params: PGLint); overload;
    function glGetProgramResourceLocation(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; overload;
    function glGetProgramResourceLocationIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; overload;

    procedure glShaderStorageBlockBinding(aProgram: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint); overload;

    procedure glTexBufferRange(target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;

    procedure glTexStorage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTexStorage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean); overload;

    procedure glTextureView(texture, target: GLuint; origtexture: GLuint; internalformat: GLenum; minlevel, numlevels, minlayer, numlayers: GLuint); overload;

    procedure glBindVertexBuffer(bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); overload;
    procedure glVertexAttribFormat(attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); overload;
    procedure glVertexAttribIFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexAttribLFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexAttribBinding(attribindex, bindingindex: GLuint); overload;
    procedure glVertexBindingDivisor(bindingindex: GLuint; divisor: GLuint); overload;

    // Debug
    procedure glDebugMessageControl(Source, aType, severity: GLenum; Count: GLsizei; const ids: PGLuint; Enabled: GLboolean); overload;
    procedure glDebugMessageInsert(Source, aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const buf: PGLchar); overload;
    procedure glDebugMessageCallback(callback: GLDEBUGPROC; const userParam: Pointer); overload;
    function glGetDebugMessageLog(Count: GLuint; bufSize: GLsizei; sources, types: PGLenum; ids, severities: PGLuint; lengths: PGLsizei; messageLog: PGLchar): GLuint; overload;
    procedure glPushDebugGroup(Source: GLenum; id: GLuint; length: GLsizei; const message: PGLchar); overload;
    procedure glPopDebugGroup; overload;
    procedure glObjectLabel(identifier: GLenum; Name: GLuint; length: GLsizei; const aLabel: PGLchar); overload;
    procedure glGetObjectLabel(identifier: GLenum; Name: GLuint; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); overload;
    procedure glObjectPtrLabel(const ptr: Pointer; length: GLsizei; const aLabel: PGLchar); overload;
    procedure glGetObjectPtrLabel(const ptr: Pointer; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); overload;
  end;

  // -------------------------------------------------------------------------
  // OpenGL 4.4
  // -------------------------------------------------------------------------
  IOpenGL44 = interface(IOpenGL43)
    ['{E9BA9DBC-CED7-41C3-9C12-229284A348F2}']
    procedure glBufferStorage(target: GLenum; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); overload;
    procedure glClearTexImage(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glClearTexSubImage(texture: GLuint; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glBindBuffersBase(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint); overload;
    procedure glBindBuffersRange(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const sizes: PGLsizeiptr); overload;
    procedure glBindTextures(First: GLuint; Count: GLsizei; const textures: PGLuint); overload;
    procedure glBindSamplers(First: GLuint; Count: GLsizei; const samplers: PGLuint); overload;
    procedure glBindImageTextures(First: GLuint; Count: GLsizei; const textures: PGLuint); overload;
    procedure glBindVertexBuffers(First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); overload;
  end;

  // -------------------------------------------------------------------------
  // OpenGL 4.5
  // -------------------------------------------------------------------------
  IOpenGL45 = interface(IOpenGL44)
    ['{CDD0EBE9-BA3E-4E8A-B679-9F681632AD0F}']
    procedure glClipControl(origin: GLenum; depth: GLenum); overload;
    procedure glCreateTransformFeedbacks(n: GLsizei; ids: PGLuint); overload;
    procedure glTransformFeedbackBufferBase(xfb: GLuint; index: GLuint; buffer: GLuint); overload;
    procedure glTransformFeedbackBufferRange(xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glGetTransformFeedbackiv(xfb: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetTransformFeedbacki_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint); overload;
    procedure glGetTransformFeedbacki64_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64); overload;

    procedure glCreateBuffers(n: GLsizei; buffers: PGLuint); overload;
    procedure glNamedBufferStorage(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); overload;
    procedure glNamedBufferData(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; usage: GLenum); overload;
    procedure glNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; const Data: Pointer); overload;
    procedure glCopyNamedBufferSubData(readBuffer, writeBuffer: GLuint; readOffset, writeOffset: GLintptr; size: GLsizeiptr); overload;
    procedure glClearNamedBufferData(buffer: GLuint; internalformat, format, aType: GLenum; const Data: Pointer); overload;
    procedure glClearNamedBufferSubData(buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format, aType: GLenum; const Data: Pointer); overload;
    function glMapNamedBuffer(buffer: GLuint; access: GLenum): Pointer;
    function glMapNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer;
    function glUnmapNamedBuffer(buffer: GLuint): GLboolean;
    procedure glFlushMappedNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); overload;
    procedure glGetNamedBufferParameteriv(buffer: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetNamedBufferParameteri64v(buffer: GLuint; pname: GLenum; params: PGLint64); overload;
    procedure glGetNamedBufferPointerv(buffer: GLuint; pname: GLenum; params: PPointer); overload;
    procedure glGetNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer); overload;

    procedure glCreateFramebuffers(n: GLsizei; framebuffers: PGLuint); overload;
    procedure glNamedFramebufferRenderbuffer(framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); overload;
    procedure glNamedFramebufferParameteri(framebuffer: GLuint; pname: GLenum; param: GLint); overload;
    procedure glNamedFramebufferTexture(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint); overload;
    procedure glNamedFramebufferTextureLayer(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level, layer: GLint); overload;
    procedure glNamedFramebufferDrawBuffer(framebuffer: GLuint; buf: GLenum); overload;
    procedure glNamedFramebufferDrawBuffers(framebuffer: GLuint; n: GLsizei; const bufs: PGLenum); overload;
    procedure glNamedFramebufferReadBuffer(framebuffer: GLuint; src: GLenum); overload;
    procedure glInvalidateNamedFramebufferData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum); overload;
    procedure glInvalidateNamedFramebufferSubData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum; x, y: GLint; Width, Height: GLsizei); overload;
    procedure glClearNamedFramebufferiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLint); overload;
    procedure glClearNamedFramebufferuiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLuint); overload;
    procedure glClearNamedFramebufferfv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat); overload;
    procedure glClearNamedFramebufferfi(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); overload;
    procedure glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer: GLuint; srcX0, srcY0, srcX1, srcY1: GLint; dstX0, dstY0, dstX1, dstY1: GLint; mask: GLbitfield; filter: GLenum); overload;
    function glCheckNamedFramebufferStatus(framebuffer: GLuint; target: GLenum): GLenum;
    procedure glGetNamedFramebufferParameteriv(framebuffer: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetNamedFramebufferAttachmentParameteriv(framebuffer: GLuint; attachment, pname: GLenum; params: PGLint); overload;

    procedure glCreateRenderbuffers(n: GLsizei; renderbuffers: PGLuint); overload;
    procedure glNamedRenderbufferStorage(renderbuffer: GLuint; internalformat: GLenum; Width, Height: GLsizei); overload;
    procedure glNamedRenderbufferStorageMultisample(renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei); overload;
    procedure glGetNamedRenderbufferParameteriv(renderbuffer: GLuint; pname: GLenum; params: PGLint); overload;

    procedure glCreateTextures(target: GLenum; n: GLsizei; textures: PGLuint); overload;
    procedure glTextureBuffer(texture: GLuint; internalformat: GLenum; buffer: GLuint); overload;
    procedure glTextureBufferRange(texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glTextureStorage1D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei); overload;
    procedure glTextureStorage2D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width, Height: GLsizei); overload;
    procedure glTextureStorage3D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei); overload;
    procedure glTextureStorage2DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTextureStorage3DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTextureSubImage1D(texture: GLuint; level, xoffset: GLint; Width: GLsizei; format, aType: GLenum; const pixels: Pointer); overload;
    procedure glTextureSubImage2D(texture: GLuint; level, xoffset, yoffset: GLint; Width, Height: GLsizei; format, aType: GLenum; const pixels: Pointer); overload;
    procedure glTextureSubImage3D(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, aType: GLenum; const pixels: Pointer); overload;
    procedure glCompressedTextureSubImage1D(texture: GLuint; level, xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTextureSubImage2D(texture: GLuint; level, xoffset, yoffset: GLint; Width, Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTextureSubImage3D(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCopyTextureSubImage1D(texture: GLuint; level, xoffset, x, y: GLint; Width: GLsizei); overload;
    procedure glCopyTextureSubImage2D(texture: GLuint; level, xoffset, yoffset, x, y: GLint; Width, Height: GLsizei); overload;
    procedure glCopyTextureSubImage3D(texture: GLuint; level, xoffset, yoffset, zoffset, x, y: GLint; Width, Height: GLsizei); overload;
    procedure glTextureParameterf(texture: GLuint; pname: GLenum; param: GLfloat); overload;
    procedure glTextureParameterfv(texture: GLuint; pname: GLenum; const param: PGLfloat); overload;
    procedure glTextureParameteri(texture: GLuint; pname: GLenum; param: GLint); overload;
    procedure glTextureParameterIiv(texture: GLuint; pname: GLenum; const params: PGLint); overload;
    procedure glTextureParameterIuiv(texture: GLuint; pname: GLenum; const params: PGLuint); overload;
    procedure glTextureParameteriv(texture: GLuint; pname: GLenum; const param: PGLint); overload;
    procedure glGenerateTextureMipmap(texture: GLuint); overload;
    procedure glBindTextureUnit(unit_: GLuint; texture: GLuint); overload;
    procedure glGetTextureImage(texture: GLuint; level: GLint; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetCompressedTextureImage(texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetTextureLevelParameterfv(texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTextureLevelParameteriv(texture: GLuint; level: GLint; pname: GLenum; params: PGLint); overload;
    procedure glGetTextureParameterfv(texture: GLuint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTextureParameterIiv(texture: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetTextureParameterIuiv(texture: GLuint; pname: GLenum; params: PGLuint); overload;
    procedure glGetTextureParameteriv(texture: GLuint; pname: GLenum; params: PGLint); overload;

    procedure glCreateVertexArrays(n: GLsizei; arrays: PGLuint); overload;
    procedure glDisableVertexArrayAttrib(vaobj: GLuint; index: GLuint); overload;
    procedure glEnableVertexArrayAttrib(vaobj: GLuint; index: GLuint); overload;
    procedure glVertexArrayElementBuffer(vaobj: GLuint; buffer: GLuint); overload;
    procedure glVertexArrayVertexBuffer(vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); overload;
    procedure glVertexArrayVertexBuffers(vaobj: GLuint; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); overload;
    procedure glVertexArrayAttribBinding(vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint); overload;
    procedure glVertexArrayAttribFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); overload;
    procedure glVertexArrayAttribIFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexArrayAttribLFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexArrayBindingDivisor(vaobj: GLuint; bindingindex: GLuint; divisor: GLuint); overload;
    procedure glGetVertexArrayiv(vaobj: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetVertexArrayIndexediv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetVertexArrayIndexed64iv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64); overload;

    procedure glCreateSamplers(n: GLsizei; samplers: PGLuint); overload;
    procedure glCreateProgramPipelines(n: GLsizei; pipelines: PGLuint); overload;
    procedure glCreateQueries(target: GLenum; n: GLsizei; ids: PGLuint); overload;

    procedure glGetQueryBufferObjecti64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glGetQueryBufferObjectiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glGetQueryBufferObjectui64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glGetQueryBufferObjectuiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;

    procedure glMemoryBarrierByRegion(barriers: GLbitfield); overload;

    procedure glGetTextureSubImage(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetCompressedTextureSubImage(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; bufSize: GLsizei; pixels: Pointer); overload;

    function glGetGraphicsResetStatus: GLenum; overload;
    procedure glGetnCompressedTexImage(target: GLenum; lod: GLint; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetnTexImage(target: GLenum; level: GLint; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetnUniformdv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble); overload;
    procedure glGetnUniformfv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); overload;
    procedure glGetnUniformiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); overload;
    procedure glGetnUniformuiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); overload;
    procedure glReadnPixels(x, y: GLint; Width, Height: GLsizei; format, aType: GLenum; bufSize: GLsizei; Data: Pointer); overload;

    procedure glTextureBarrier; overload;
  end;

  // -------------------------------------------------------------------------
  // OpenGL 4.6  ultima riga
  // -------------------------------------------------------------------------
  IOpenGL46 = interface(IOpenGL45)
    ['{C4AE511D-A8E5-46FE-8C26-75A2FBD02F3B}']
    function glGetTextureHandleARB(texture: GLuint): GLuint64; overload;
    function glGetTextureSamplerHandleARB(texture: GLuint; sampler: GLuint): GLuint64; overload;
    procedure glMakeTextureHandleResidentARB(handle: GLuint64); overload;
    procedure glMakeTextureHandleNonResidentARB(handle: GLuint64); overload;

    function glGetImageHandleARB(texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; format: GLenum): GLuint64; overload;
    procedure glMakeImageHandleResidentARB(handle: GLuint64; access: GLenum); overload;
    procedure glMakeImageHandleNonResidentARB(handle: GLuint64); overload;

    procedure glUniformHandleui64ARB(location: GLint; Value: GLuint64); overload;
    procedure glUniformHandleui64vARB(location: GLint; Count: GLsizei; const Value: PGLuint64); overload;
    procedure glProgramUniformHandleui64ARB(aProgram: GLuint; location: GLint; Value: GLuint64); overload;
    procedure glProgramUniformHandleui64vARB(aProgram: GLuint; location: GLint; Count: GLsizei; const values: PGLuint64); overload;

    function glIsTextureHandleResidentARB(handle: GLuint64): GLboolean; overload;
    function glIsImageHandleResidentARB(handle: GLuint64): GLboolean; overload;

    procedure glVertexAttribL1ui64ARB(index: GLuint; x: GLuint64EXT); overload;
    procedure glVertexAttribL1ui64vARB(index: GLuint; const v: PGLuint64EXT); overload;
    procedure glGetVertexAttribLui64vARB(index: GLuint; pname: GLenum; params: PGLuint64EXT); overload;
  end;

  IOpenGL = IOpenGL46;


function GetOpenGL: IOpenGL; inline;

implementation

uses
  {$IfDef WINDOWS}
  Windows,
  {$EndIf}
  dynlibs;

var
  singleton: IOpenGL = nil;


type
  { TOpenGLBase }

  TOpenGLBase = class(TInterfacedObject)
  protected
    FHandle: TLibHandle;
    {$IFDEF WINDOWS}

  FTempWindow: HWND;
  FTempDC: HDC;
  FTempRC: HGLRC;
    FWGLCreateContextAttribsARB : function(hDC: HDC; hShareContext: HGLRC; attribList: PInteger): HGLRC; stdcall;
    FWGLGetProcAddress: function (ProcName: LPCSTR): Pointer;
    {$EndIf}
  private
    function LoadProc(Name: ansistring): {$ifdef cpui8086}FarPointer{$else}Pointer{$endif};
    {$IfDef Windows}
    procedure CreateTempCoreContext;
    procedure DestroyTempContext;
    {$EndIf}
  protected
    procedure Bind(var FuncPtr: Pointer; const Name: ansistring; Mandatory: boolean = False);
  protected
    procedure bindEntry; virtual;
    function SupportsExtension(const Ext: string): boolean; virtual;
    function SupportsVersion(Major, Minor: integer): boolean; virtual;
  public
    procedure LoadLibrary;
    procedure unLoadLibrary;
  public
    destructor Destroy; override;
  end;

  { TOpenGL_1_0 }

  TOpenGL_1_0 = class(TOpenGLBase, IOpenGL10)
  protected
  type
    TGLCullFace = procedure(mode: GLenum); cdecl;
    TGLFrontFace = procedure(mode: GLenum); cdecl;
    TGLHint = procedure(target, mode: GLenum); cdecl;
    TGLLineWidth = procedure(Width: GLfloat); cdecl;
    TGLPointSize = procedure(size: GLfloat); cdecl;
    TGLPolygonMode = procedure(face, mode: GLenum); cdecl;
    TGLScissor = procedure(x, y: GLint; Width, Height: GLsizei); cdecl;

    TGLTexParameterf = procedure(target, pname: GLenum; param: GLfloat); cdecl;
    TGLTexParameterfv = procedure(target, pname: GLenum; const params: PGLfloat); cdecl;
    TGLTexParameteri = procedure(target, pname: GLenum; param: GLint); cdecl;
    TGLTexParameteriv = procedure(target, pname: GLenum; const params: PGLint); cdecl;

    TGLTexImage1D = procedure(target: GLenum; level, internalformat: GLint; Width: GLsizei; border: GLint; format, aType: GLenum; pixels: PGLvoid); cdecl;

    TGLTexImage2D = procedure(target: GLenum; level, internalformat: GLint; Width, Height: GLsizei; border: GLint; format, aType: GLenum; pixels: PGLvoid); cdecl;

    TGLDrawBuffer = procedure(buf: GLenum); cdecl;
    TGLClear = procedure(mask: GLbitfield); cdecl;
    TGLClearColor = procedure(red, green, blue, alpha: GLfloat); cdecl;
    TGLClearStencil = procedure(s: GLint); cdecl;
    TGLClearDepth = procedure(depth: GLdouble); cdecl;
    TGLStencilMask = procedure(mask: GLuint); cdecl;
    TGLColorMask = procedure(red, green, blue, alpha: GLboolean); cdecl;
    TGLDepthMask = procedure(flag: GLboolean); cdecl;
    TGLDisable = procedure(cap: GLenum); cdecl;
    TGLEnable = procedure(cap: GLenum); cdecl;
    TGLFinish = procedure; cdecl;
    TGLFlush = procedure; cdecl;

    TGLBlendFunc = procedure(sfactor, dfactor: GLenum); cdecl;
    TGLLogicOp = procedure(opcode: GLenum); cdecl;
    TGLStencilFunc = procedure(func: GLenum; ref: GLint; mask: GLuint); cdecl;
    TGLStencilOp = procedure(fail, zfail, zpass: GLenum); cdecl;
    TGLDepthFunc = procedure(func: GLenum); cdecl;

    TGLPixelStoref = procedure(pname: GLenum; param: GLfloat); cdecl;
    TGLPixelStorei = procedure(pname: GLenum; param: GLint); cdecl;
    TGLReadBuffer = procedure(src: GLenum); cdecl;

    TGLReadPixels = procedure(x, y: GLint; Width, Height: GLsizei; format, aType: GLenum; pixels: PGLvoid); cdecl;

    TGLGetBooleanv = procedure(pname: GLenum; Data: PGLboolean); cdecl;
    TGLGetDoublev = procedure(pname: GLenum; Data: PGLdouble); cdecl;
    TGLGetError = function: GLenum; cdecl;
    TGLGetFloatv = procedure(pname: GLenum; Data: PGLfloat); cdecl;
    TGLGetIntegerv = procedure(pname: GLenum; Data: PGLint); cdecl;
    TGLGetString = function(Name: GLenum): PGLubyte; cdecl;

    TGLGetTexImage = procedure(target: GLenum; level: GLint; format, aType: GLenum; pixels: PGLvoid); cdecl;

    TGLGetTexParameterfv = procedure(target, pname: GLenum; params: PGLfloat); cdecl;
    TGLGetTexParameteriv = procedure(target, pname: GLenum; params: PGLint); cdecl;
    TGLGetTexLevelParameterfv = procedure(target: GLenum; level: GLint; pname: GLenum; params: PGLfloat); cdecl;
    TGLGetTexLevelParameteriv = procedure(target: GLenum; level: GLint; pname: GLenum; params: PGLint); cdecl;

    TGLIsEnabled = function(cap: GLenum): GLboolean; cdecl;

    TGLDepthRange = procedure(n, f: GLdouble); cdecl;
    TGLViewport = procedure(x, y: GLint; Width, Height: GLsizei); cdecl;
  var
    FGLCullFace: TGLCullFace;
    FGLFrontFace: TGLFrontFace;
    FGLHint: TGLHint;
    FGLLineWidth: TGLLineWidth;
    FGLPointSize: TGLPointSize;
    FGLPolygonMode: TGLPolygonMode;
    FGLScissor: TGLScissor;
    FGLTexParameterf: TGLTexParameterf;
    FGLTexParameterfv: TGLTexParameterfv;
    FGLTexParameteri: TGLTexParameteri;
    FGLTexParameteriv: TGLTexParameteriv;
    FGLTexImage1D: TGLTexImage1D;
    FGLTexImage2D: TGLTexImage2D;
    FGLDrawBuffer: TGLDrawBuffer;
    FGLClear: TGLClear;
    FGLClearColor: TGLClearColor;
    FGLClearStencil: TGLClearStencil;
    FGLClearDepth: TGLClearDepth;
    FGLStencilMask: TGLStencilMask;
    FGLColorMask: TGLColorMask;
    FGLDepthMask: TGLDepthMask;
    FGLDisable: TGLDisable;
    FGLEnable: TGLEnable;
    FGLFinish: TGLFinish;
    FGLFlush: TGLFlush;
    FGLBlendFunc: TGLBlendFunc;
    FGLLogicOp: TGLLogicOp;
    FGLStencilFunc: TGLStencilFunc;
    FGLStencilOp: TGLStencilOp;
    FGLDepthFunc: TGLDepthFunc;
    FGLPixelStoref: TGLPixelStoref;
    FGLPixelStorei: TGLPixelStorei;
    FGLReadBuffer: TGLReadBuffer;
    FGLReadPixels: TGLReadPixels;
    FGLGetBooleanv: TGLGetBooleanv;
    FGLGetDoublev: TGLGetDoublev;
    FGLgetError: TGLGetError;
    FGLGetFloatv: TGLGetFloatv;
    FGLGetIntegerv: TGLGetIntegerv;
    FGLGetString: TGLGetString;
    FGLGetTexImage: TGLGetTexImage;
    FGLGetTexParameterfv: TGLGetTexParameterfv;
    FGLGetTexParameteriv: TGLGetTexParameteriv;
    FGLGetTexLevelParameterfv: TGLGetTexLevelParameterfv;
    FGLGetTexLevelParameteriv: TGLGetTexLevelParameteriv;
    FGLIsEnabled: TGLIsEnabled;
    FGLDepthRange: TGLDepthRange;
    FGLViewport: TGLViewport;
    FglBegin: procedure(mode: GLenum); cdecl;
    FglEnd: procedure; cdecl;

    FglVertex2f: procedure(x, y: GLfloat); cdecl;
    FglVertex2fv: procedure(v: PGLfloat); cdecl;
    FglVertex3f: procedure(x, y, z: GLfloat); cdecl;
    FglVertex3fv: procedure(v: PGLfloat); cdecl;

    FglColor3f: procedure(red, green, blue: GLfloat); cdecl;
    FglColor3fv: procedure(v: PGLfloat); cdecl;
    FglColor4f: procedure(red, green, blue, alpha: GLfloat); cdecl;
    FglColor4fv: procedure(v: PGLfloat); cdecl;

    FglNormal3f: procedure(nx, ny, nz: GLfloat); cdecl;
    FglNormal3fv: procedure(v: PGLfloat); cdecl;

    FglTexCoord2f: procedure(s, t: GLfloat); cdecl;
    FglTexCoord2fv: procedure(v: PGLfloat); cdecl;

    FglMatrixMode: procedure(mode: GLenum); cdecl;
    FglLoadIdentity: procedure; cdecl;
    FglLoadMatrixf: procedure(const m: PGLfloat); cdecl;
    FglMultMatrixf: procedure(const m: PGLfloat); cdecl;
    FglPushMatrix: procedure; cdecl;
    FglPopMatrix: procedure; cdecl;

    FglTranslatef: procedure(x, y, z: GLfloat); cdecl;
    FglRotatef: procedure(angle, x, y, z: GLfloat); cdecl;
    FglScalef: procedure(x, y, z: GLfloat); cdecl;

    FglShadeModel: procedure(mode: GLenum); cdecl;
    // Display Lists
    FglGenLists: function(range: GLsizei): GLuint; cdecl;
    FglNewList: procedure(list: GLuint; mode: GLenum); cdecl;
    FglEndList: procedure; cdecl;
    FglCallList: procedure(list: GLuint); cdecl;

    // Material & Lighting
    FglMaterialfv: procedure(face, pname: GLenum; const params: PGLfloat); cdecl;
    FglLightfv: procedure(light, pname: GLenum; const params: PGLfloat); cdecl;

    // Projection
    FglFrustum: procedure(left, right, bottom, top, zNear, zFar: GLdouble); cdecl;
    FglOrtho: procedure(left, right, bottom, top, zNear, zFar: GLdouble); cdecl;

  protected
    procedure bindEntry; override;
  public
    procedure glCullFace(mode: GLenum); overload;
    procedure glFrontFace(mode: GLenum); overload;
    procedure glHint(target, mode: GLenum); overload;
    procedure glLineWidth(Width: GLfloat); overload;
    procedure glPointSize(size: GLfloat); overload;
    procedure glPolygonMode(face, mode: GLenum); overload;
    procedure glScissor(x, y: GLint; Width, Height: GLsizei); overload;

    procedure glTexParameterf(target, pname: GLenum; param: GLfloat); overload;
    procedure glTexParameterfv(target, pname: GLenum; const params: PGLfloat); overload;
    procedure glTexParameteri(target, pname: GLenum; param: GLint); overload;
    procedure glTexParameteriv(target, pname: GLenum; const params: PGLint); overload;

    procedure glTexImage1D(target: GLenum; level, internalformat: GLint; Width: GLsizei; border: GLint; format, aType: GLenum; pixels: PGLvoid); overload;

    procedure glTexImage2D(target: GLenum; level, internalformat: GLint; Width, Height: GLsizei; border: GLint; format, aType: GLenum; pixels: PGLvoid); overload;

    procedure glDrawBuffer(buf: GLenum); overload;
    procedure glClear(mask: GLbitfield); overload;
    procedure glClearColor(red, green, blue, alpha: GLfloat); overload;
    procedure glClearStencil(s: GLint); overload;
    procedure glClearDepth(depth: GLdouble); overload;
    procedure glStencilMask(mask: GLuint); overload;
    procedure glColorMask(red, green, blue, alpha: GLboolean); overload;
    procedure glDepthMask(flag: GLboolean); overload;
    procedure glDisable(cap: GLenum); overload;
    procedure glEnable(cap: GLenum); overload;
    procedure glFinish; overload;
    procedure glFlush; overload;

    procedure glBlendFunc(sfactor, dfactor: GLenum); overload;
    procedure glLogicOp(opcode: GLenum); overload;
    procedure glStencilFunc(func: GLenum; ref: GLint; mask: GLuint); overload;
    procedure glStencilOp(fail, zfail, zpass: GLenum); overload;
    procedure glDepthFunc(func: GLenum); overload;

    procedure glPixelStoref(pname: GLenum; param: GLfloat); overload;
    procedure glPixelStorei(pname: GLenum; param: GLint); overload;
    procedure glReadBuffer(src: GLenum); overload;

    procedure glReadPixels(x, y: GLint; Width, Height: GLsizei; format, aType: GLenum; pixels: PGLvoid); overload;

    procedure glGetBooleanv(pname: GLenum; Data: PGLboolean); overload;
    procedure glGetDoublev(pname: GLenum; Data: PGLdouble); overload;
    function glGetError: GLenum; overload;
    procedure glGetFloatv(pname: GLenum; Data: PGLfloat); overload;
    procedure glGetIntegerv(pname: GLenum; Data: PGLint); overload;
    function glGetString(Name: GLenum): PGLubyte; overload;

    procedure glGetTexImage(target: GLenum; level: GLint; format, aType: GLenum; pixels: PGLvoid); overload;

    procedure glGetTexParameterfv(target, pname: GLenum; params: PGLfloat); overload;
    procedure glGetTexParameteriv(target, pname: GLenum; params: PGLint); overload;
    procedure glGetTexLevelParameterfv(target: GLenum; level: GLint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTexLevelParameteriv(target: GLenum; level: GLint; pname: GLenum; params: PGLint); overload;

    function glIsEnabled(cap: GLenum): GLboolean; overload;

    procedure glDepthRange(n, f: GLdouble); overload;
    procedure glViewport(x, y: GLint; Width, Height: GLsizei); overload;

    procedure glBegin(mode: GLenum); inline; overload;
    procedure glEnd; inline; overload;

    procedure glVertex2f(x, y: GLfloat); inline; overload;
    procedure glVertex2fv(v: PGLfloat); inline; overload;
    procedure glVertex3f(x, y, z: GLfloat); inline; overload;
    procedure glVertex3fv(v: PGLfloat); inline; overload;

    procedure glColor3f(red, green, blue: GLfloat); inline; overload;
    procedure glColor3fv(v: PGLfloat); inline; overload;
    procedure glColor4f(red, green, blue, alpha: GLfloat); inline; overload;
    procedure glColor4fv(v: PGLfloat); inline; overload;

    procedure glNormal3f(nx, ny, nz: GLfloat); inline; overload;
    procedure glNormal3fv(v: PGLfloat); inline; overload;

    procedure glTexCoord2f(s, t: GLfloat); inline; overload;
    procedure glTexCoord2fv(v: PGLfloat); inline; overload;

    // Matrix Stack & Transformations
    procedure glMatrixMode(mode: GLenum); inline; overload;
    procedure glLoadIdentity; inline; overload;
    procedure glLoadMatrixf(const m: PGLfloat); inline; overload;
    procedure glMultMatrixf(const m: PGLfloat); inline; overload;
    procedure glPushMatrix; inline; overload;
    procedure glPopMatrix; inline; overload;

    procedure glTranslatef(x, y, z: GLfloat); inline; overload;
    procedure glRotatef(angle, x, y, z: GLfloat); inline; overload;
    procedure glScalef(x, y, z: GLfloat); inline; overload;

    // State
    procedure glShadeModel(mode: GLenum); inline; overload;
    function glGenLists(range: GLsizei): GLuint;
    procedure glNewList(list: GLuint; mode: GLenum);
    procedure glEndList;
    procedure glCallList(list: GLuint);

    // Material & Lighting
    procedure glMaterialfv(face, pname: GLenum; const params: PGLfloat);
    procedure glLightfv(light, pname: GLenum; const params: PGLfloat);

    // Projection
    procedure glFrustum(left, right, bottom, top, zNear, zFar: GLdouble);
    procedure glOrtho(left, right, bottom, top, zNear, zFar: GLdouble);
  end;

  { TOpenGL_1_1 }

  TOpenGL_1_1 = class(TOpenGL_1_0, IOpenGL11)
  protected
  type
    TGLDrawArrays = procedure(mode: GLenum; First: GLint; Count: GLsizei); cdecl;
    TGLDrawElements = procedure(mode: GLenum; Count: GLsizei; typ: GLenum; const indices: PGLvoid); cdecl;
    TGLGetPointerv = procedure(pname: GLenum; params: PPGLvoid); cdecl;
    TGLPolygonOffset = procedure(factor, units: GLfloat); cdecl;
    TGLCopyTexImage1D = procedure(target: GLenum; level: GLint; internalformat: GLenum; x, y: GLint; Width: GLsizei; border: GLint); cdecl;
    TGLCopyTexImage2D = procedure(target: GLenum; level: GLint; internalformat: GLenum; x, y: GLint; Width, Height: GLsizei; border: GLint); cdecl;
    TGLCopyTexSubImage1D = procedure(target: GLenum; level: GLint; xoffset: GLint; x, y: GLint; Width: GLsizei); cdecl;
    TGLCopyTexSubImage2D = procedure(target: GLenum; level: GLint; xoffset, yoffset: GLint; x, y: GLint; Width, Height: GLsizei); cdecl;
    TGLTexSubImage1D = procedure(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format, typ: GLenum; const pixels: PGLvoid); cdecl;
    TGLTexSubImage2D = procedure(target: GLenum; level: GLint; xoffset, yoffset: GLint; Width, Height: GLsizei; format, typ: GLenum; const pixels: PGLvoid); cdecl;
    TGLBindTexture = procedure(target: GLenum; texture: GLuint); cdecl;
    TGLDeleteTextures = procedure(n: GLsizei; const textures: PGLuint); cdecl;
    TGLGenTextures = procedure(n: GLsizei; textures: PGLuint); cdecl;
    TGLIsTexture = function(texture: GLuint): GLboolean; cdecl;
  protected
    FGLDrawArrays: TGLDrawArrays;
    FGLDrawElements: TGLDrawElements;
    FGLGetPointerv: TGLGetPointerv;
    FGLPolygonOffset: TGLPolygonOffset;
    FGLCopyTexImage1D: TGLCopyTexImage1D;
    FGLCopyTexImage2D: TGLCopyTexImage2D;
    FGLCopyTexSubImage1D: TGLCopyTexSubImage1D;
    FGLCopyTexSubImage2D: TGLCopyTexSubImage2D;
    FGLTexSubImage1D: TGLTexSubImage1D;
    FGLTexSubImage2D: TGLTexSubImage2D;
    FGLBindTexture: TGLBindTexture;
    FGLDeleteTextures: TGLDeleteTextures;
    FGLGenTextures: TGLGenTextures;
    FGLIsTexture: TGLIsTexture;
  protected
    procedure bindEntry; override;
  public
    procedure glDrawArrays(mode: GLenum; First: GLint; Count: GLsizei); overload;
    procedure glDrawElements(mode: GLenum; Count: GLsizei; typ: GLenum; const indices: PGLvoid); overload;
    procedure glGetPointerv(pname: GLenum; params: PPGLvoid); overload;
    procedure glPolygonOffset(factor, units: GLfloat); overload;
    procedure glCopyTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; x, y: GLint; Width: GLsizei; border: GLint); overload;
    procedure glCopyTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; x, y: GLint; Width, Height: GLsizei; border: GLint); overload;
    procedure glCopyTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; x, y: GLint; Width: GLsizei); overload;
    procedure glCopyTexSubImage2D(target: GLenum; level: GLint; xoffset, yoffset: GLint; x, y: GLint; Width, Height: GLsizei); overload;
    procedure glTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format, typ: GLenum; const pixels: PGLvoid); overload;
    procedure glTexSubImage2D(target: GLenum; level: GLint; xoffset, yoffset: GLint; Width, Height: GLsizei; format, typ: GLenum; const pixels: PGLvoid); overload;
    procedure glBindTexture(target: GLenum; texture: GLuint); overload;
    procedure glDeleteTextures(n: GLsizei; const textures: PGLuint); overload;
    procedure glGenTextures(n: GLsizei; textures: PGLuint); overload;
    function glIsTexture(texture: GLuint): GLboolean; overload;
  end;


  { TOpenGL_1_2 }

  TOpenGL_1_2 = class(TOpenGL_1_1, IOpenGL12)
  protected
  type
    TGLDrawRangeElements = procedure(mode: uint32; start: uint32; end_: uint32; Count: int32; typ: uint32; const indices: Pointer); cdecl;
    TGLTexImage3D = procedure(target: uint32; level: int32; internalformat: int32; Width: int32; Height: int32; depth: int32; border: int32; format: uint32; typ: uint32; const pixels: Pointer); cdecl;
    TGLTexSubImage3D = procedure(target: uint32; level: int32; xoffset: int32; yoffset: int32; zoffset: int32; Width: int32; Height: int32; depth: int32; format: uint32; typ: uint32; const pixels: Pointer); cdecl;
    TGLCopyTexSubImage3D = procedure(target: uint32; level: int32; xoffset: int32; yoffset: int32; zoffset: int32; x: int32; y: int32; Width: int32; Height: int32); cdecl;
  protected
    FGLDrawRangeElements: TGLDrawRangeElements;
    FGLTexImage3D: TGLTexImage3D;
    FGLTexSubImage3D: TGLTexSubImage3D;
    FGLCopyTexSubImage3D: TGLCopyTexSubImage3D;
  protected
    procedure bindEntry; override;
  public
    procedure glDrawRangeElements(mode: uint32; start: uint32; end_: uint32; Count: int32; typ: uint32; const indices: Pointer); overload;
    procedure glTexImage3D(target: uint32; level: int32; internalformat: int32; Width: int32; Height: int32; depth: int32; border: int32; format: uint32; typ: uint32; const pixels: Pointer); overload;
    procedure glTexSubImage3D(target: uint32; level: int32; xoffset: int32; yoffset: int32; zoffset: int32; Width: int32; Height: int32; depth: int32; format: uint32; typ: uint32; const pixels: Pointer); overload;
    procedure glCopyTexSubImage3D(target: uint32; level: int32; xoffset: int32; yoffset: int32; zoffset: int32; x: int32; y: int32; Width: int32; Height: int32); overload;
  end;


  { TOpenGL_1_3 }

  TOpenGL_1_3 = class(TOpenGL_1_2, IOpenGL13)
  protected
  type
    TGLActiveTexture = procedure(texture: uint32); cdecl;
    TGLSampleCoverage = procedure(Value: single; invert: uint8); cdecl;
    TGLCompressedTexImage3D = procedure(target: uint32; level: int32; internalformat: uint32; Width: int32; Height: int32; depth: int32; border: int32; imageSize: int32; const Data: Pointer); cdecl;
    TGLCompressedTexImage2D = procedure(target: uint32; level: int32; internalformat: uint32; Width: int32; Height: int32; border: int32; imageSize: int32; const Data: Pointer); cdecl;
    TGLCompressedTexImage1D = procedure(target: uint32; level: int32; internalformat: uint32; Width: int32; border: int32; imageSize: int32; const Data: Pointer); cdecl;
    TGLCompressedTexSubImage3D = procedure(target: uint32; level: int32; xoffset: int32; yoffset: int32; zoffset: int32; Width: int32; Height: int32; depth: int32; format: uint32; imageSize: int32; const Data: Pointer); cdecl;
    TGLCompressedTexSubImage2D = procedure(target: uint32; level: int32; xoffset: int32; yoffset: int32; Width: int32; Height: int32; format: uint32; imageSize: int32; const Data: Pointer); cdecl;
    TGLCompressedTexSubImage1D = procedure(target: uint32; level: int32; xoffset: int32; Width: int32; format: uint32; imageSize: int32; const Data: Pointer); cdecl;
    TGLGetCompressedTexImage = procedure(target: uint32; level: int32; img: Pointer); cdecl;
  protected
    FGLActiveTexture: TGLActiveTexture;
    FGLSampleCoverage: TGLSampleCoverage;
    FGLCompressedTexImage3D: TGLCompressedTexImage3D;
    FGLCompressedTexImage2D: TGLCompressedTexImage2D;
    FGLCompressedTexImage1D: TGLCompressedTexImage1D;
    FGLCompressedTexSubImage3D: TGLCompressedTexSubImage3D;
    FGLCompressedTexSubImage2D: TGLCompressedTexSubImage2D;
    FGLCompressedTexSubImage1D: TGLCompressedTexSubImage1D;
    FGLGetCompressedTexImage: TGLGetCompressedTexImage;
  protected
    procedure bindEntry; override;
  public
    procedure glActiveTexture(texture: uint32);
    procedure glSampleCoverage(Value: single; invert: uint8);
    procedure glCompressedTexImage3D(target: uint32; level: int32; internalformat: uint32; Width: int32; Height: int32; depth: int32; border: int32; imageSize: int32; const Data: Pointer); overload;
    procedure glCompressedTexImage2D(target: uint32; level: int32; internalformat: uint32; Width: int32; Height: int32; border: int32; imageSize: int32; const Data: Pointer); overload;
    procedure glCompressedTexImage1D(target: uint32; level: int32; internalformat: uint32; Width: int32; border: int32; imageSize: int32; const Data: Pointer); overload;
    procedure glCompressedTexSubImage3D(target: uint32; level: int32; xoffset: int32; yoffset: int32; zoffset: int32; Width: int32; Height: int32; depth: int32; format: uint32; imageSize: int32; const Data: Pointer); overload;
    procedure glCompressedTexSubImage2D(target: uint32; level: int32; xoffset: int32; yoffset: int32; Width: int32; Height: int32; format: uint32; imageSize: int32; const Data: Pointer); overload;
    procedure glCompressedTexSubImage1D(target: uint32; level: int32; xoffset: int32; Width: int32; format: uint32; imageSize: int32; const Data: Pointer); overload;
    procedure glGetCompressedTexImage(target: uint32; level: int32; img: Pointer); overload;
  end;

  { TOpenGL_1_4 }

  TOpenGL_1_4 = class(TOpenGL_1_3, IOpenGL14)
  protected
  type
    TGLBlendFuncSeparate = procedure(sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); cdecl;
    TGLMultiDrawArrays = procedure(mode: GLenum; const First: PGLint; const Count: PGLsizei; drawcount: GLsizei); cdecl;
    TGLMultiDrawElements = procedure(mode: GLenum; const Count: PGLsizei; typ: GLenum; const indices: PPointer; drawcount: GLsizei); cdecl;
    TGLPointParameterf = procedure(pname: GLenum; param: GLfloat); cdecl;
    TGLPointParameterfv = procedure(pname: GLenum; const params: PGLfloat); cdecl;
    TGLPointParameteri = procedure(pname: GLenum; param: GLint); cdecl;
    TGLPointParameteriv = procedure(pname: GLenum; const params: PGLint); cdecl;
    TGLBlendColor = procedure(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); cdecl;
    TGLBlendEquation = procedure(mode: GLenum); cdecl;
  protected
    FGLBlendFuncSeparate: TGLBlendFuncSeparate;
    FGLMultiDrawArrays: TGLMultiDrawArrays;
    FGLMultiDrawElements: TGLMultiDrawElements;
    FGLPointParameterf: TGLPointParameterf;
    FGLPointParameterfv: TGLPointParameterfv;
    FGLPointParameteri: TGLPointParameteri;
    FGLPointParameteriv: TGLPointParameteriv;
    FGLBlendColor: TGLBlendColor;
    FGLBlendEquation: TGLBlendEquation;
  protected
    procedure bindEntry; override;
  public
    procedure glBlendFuncSeparate(sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); overload;
    procedure glMultiDrawArrays(mode: GLenum; const First: PGLint; const Count: PGLsizei; drawcount: GLsizei); overload;
    procedure glMultiDrawElements(mode: GLenum; const Count: PGLsizei; typ: GLenum; const indices: PPointer; drawcount: GLsizei); overload;
    procedure glPointParameterf(pname: GLenum; param: GLfloat); overload;
    procedure glPointParameterfv(pname: GLenum; const params: PGLfloat); overload;
    procedure glPointParameteri(pname: GLenum; param: GLint); overload;
    procedure glPointParameteriv(pname: GLenum; const params: PGLint); overload;
    procedure glBlendColor(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); overload;
    procedure glBlendEquation(mode: GLenum); overload;
  end;

  { TOpenGL_1_5 }

  TOpenGL_1_5 = class(TOpenGL_1_4, IOpenGL15)
  protected
  type
    TGLGenQueries = procedure(n: GLsizei; ids: PGLuint); cdecl;
    TGLDeleteQueries = procedure(n: GLsizei; const ids: PGLuint); cdecl;
    TGLIsQuery = function(id: GLuint): GLboolean; cdecl;
    TGLBeginQuery = procedure(target: GLenum; id: GLuint); cdecl;
    TGLEndQuery = procedure(target: GLenum); cdecl;
    TGLGetQueryiv = procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    TGLGetQueryObjectiv = procedure(id: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetQueryObjectuiv = procedure(id: GLuint; pname: GLenum; params: PGLuint); cdecl;

    TGLBindBuffer = procedure(target: GLenum; buffer: GLuint); cdecl;
    TGLDeleteBuffers = procedure(n: GLsizei; const buffers: PGLuint); cdecl;
    TGLGenBuffers = procedure(n: GLsizei; buffers: PGLuint); cdecl;
    TGLIsBuffer = function(buffer: GLuint): GLboolean; cdecl;

    TGLBufferData = procedure(target: GLenum; size: GLsizeiptr; const Data: Pointer; usage: GLenum); cdecl;
    TGLBufferSubData = procedure(target: GLenum; offset: GLintptr; size: GLsizeiptr; const Data: Pointer); cdecl;
    TGLGetBufferSubData = procedure(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: Pointer); cdecl;

    TGLMapBuffer = function(target: GLenum; access: GLenum): Pointer; cdecl;
    TGLUnmapBuffer = function(target: GLenum): GLboolean; cdecl;

    TGLGetBufferParameteriv = procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    TGLGetBufferPointerv = procedure(target: GLenum; pname: GLenum; params: PPointer); cdecl;
  protected
    FGLGenQueries: TGLGenQueries;
    FGLDeleteQueries: TGLDeleteQueries;
    FGLIsQuery: TGLIsQuery;
    FGLBeginQuery: TGLBeginQuery;
    FGLEndQuery: TGLEndQuery;
    FGLGetQueryiv: TGLGetQueryiv;
    FGLGetQueryObjectiv: TGLGetQueryObjectiv;
    FGLGetQueryObjectuiv: TGLGetQueryObjectuiv;

    FGLBindBuffer: TGLBindBuffer;
    FGLDeleteBuffers: TGLDeleteBuffers;
    FGLGenBuffers: TGLGenBuffers;
    FGLIsBuffer: TGLIsBuffer;
    FGLBufferData: TGLBufferData;
    FGLBufferSubData: TGLBufferSubData;
    FGLGetBufferSubData: TGLGetBufferSubData;
    FGLMapBuffer: TGLMapBuffer;
    FGLUnmapBuffer: TGLUnmapBuffer;
    FGLGetBufferParameteriv: TGLGetBufferParameteriv;
    FGLGetBufferPointerv: TGLGetBufferPointerv;
  protected
    procedure bindEntry; override;
  public
    procedure glGenBuffers(n: GLsizei; buffers: PGLuint); overload;
    procedure glDeleteBuffers(n: GLsizei; const buffers: PGLuint); overload;
    procedure glBindBuffer(target: GLenum; buffer: GLuint); overload;
    procedure glBufferData(target: GLenum; size: GLsizeiptr; Data: PGLvoid; usage: GLenum); overload;
    procedure glBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: PGLvoid); overload;
    procedure glGetBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: PGLvoid); overload;
    function glMapBuffer(target: GLenum; access: GLenum): PGLvoid; overload;
    function glUnmapBuffer(target: GLenum): GLboolean; overload;
    procedure glGetBufferParameteriv(target: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetBufferPointerv(target: GLenum; pname: GLenum; params: PPGLvoid); overload;
    function glIsBuffer(buffer: GLuint): GLboolean; overload;
    procedure glGenQueries(n: GLsizei; ids: PGLuint); overload;
    procedure glDeleteQueries(n: GLsizei; const ids: PGLuint); overload;
    function glIsQuery(id: GLuint): GLboolean; overload;
    procedure glBeginQuery(target: GLenum; id: GLuint); overload;
    procedure glEndQuery(target: GLenum); overload;
    procedure glGetQueryiv(target: GLenum; pname: GLenum; params: PGLint); overload;
    procedure glGetQueryObjectiv(id: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetQueryObjectuiv(id: GLuint; pname: GLenum; params: PGLuint); overload;
  end;

  { TOpenGL_2_0 }

  TOpenGL_2_0 = class(TOpenGL_1_5, IOpenGL20)
  protected
  type
    TGLAttachShader = procedure(programObj: GLuint; shaderObj: GLuint); cdecl;
    TGLDetachShader = procedure(programObj: GLuint; shaderObj: GLuint); cdecl;
    TGLCreateShader = function(shaderType: GLenum): GLuint; cdecl;
    TGLDeleteShader = procedure(shaderObj: GLuint); cdecl;
    TGLShaderSource = procedure(shaderObj: GLuint; Count: GLsizei; const strings: PPGLchar; const length: PGLint); cdecl;
    TGLCompileShader = procedure(shaderObj: GLuint); cdecl;
    TGLGetShaderiv = procedure(shaderObj: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetShaderInfoLog = procedure(shaderObj: GLuint; maxLength: GLsizei; length: PGLint; infoLog: PGLchar); cdecl;
    TGLIsShader = function(shaderObj: GLuint): GLboolean; cdecl;

    TGLCreateProgram = function(): GLuint; cdecl;
    TGLDeleteProgram = procedure(programObj: GLuint); cdecl;
    TGLLinkProgram = procedure(programObj: GLuint); cdecl;
    TGLUseProgram = procedure(programObj: GLuint); cdecl;
    TGLValidateProgram = procedure(programObj: GLuint); cdecl;
    TGLGetProgramiv = procedure(programObj: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetProgramInfoLog = procedure(programObj: GLuint; maxLength: GLsizei; length: PGLint; infoLog: PGLchar); cdecl;
    TGLIsProgram = function(programObj: GLuint): GLboolean; cdecl;

    TGLBindAttribLocation = procedure(programObj: GLuint; index: GLuint; const Name: PGLchar); cdecl;
    TGLGetActiveAttrib = procedure(programObj, index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; typ: PGLenum; Name: PGLchar); cdecl;
    TGLGetAttachedShaders = procedure(programObj: GLuint; maxCount: GLsizei; Count: PGLsizei; shaders: PGLuint); cdecl;
    TGLGetAttribLocation = function(programObj: GLuint; const Name: PGLchar): GLint; cdecl;
    TGLGetUniformLocation = function(programObj: GLuint; const Name: PGLchar): GLint; cdecl;
    TGLGetActiveUniform = procedure(programObj, index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; typ: PGLenum; Name: PGLchar); cdecl;

    TGLUniform1f = procedure(location: GLint; v0: GLfloat); cdecl;
    TGLUniform2f = procedure(location: GLint; v0, v1: GLfloat); cdecl;
    TGLUniform3f = procedure(location: GLint; v0, v1, v2: GLfloat); cdecl;
    TGLUniform4f = procedure(location: GLint; v0, v1, v2, v3: GLfloat); cdecl;
    TGLUniform1i = procedure(location: GLint; v0: GLint); cdecl;
    TGLUniform2i = procedure(location: GLint; v0, v1: GLint); cdecl;
    TGLUniform3i = procedure(location: GLint; v0, v1, v2: GLint); cdecl;
    TGLUniform4i = procedure(location: GLint; v0, v1, v2, v3: GLint); cdecl;

    TGLUniform1fv = procedure(location: GLint; Count: GLsizei; Value: PGLfloat); cdecl;
    TGLUniform2fv = procedure(location: GLint; Count: GLsizei; Value: PGLfloat); cdecl;
    TGLUniform3fv = procedure(location: GLint; Count: GLsizei; Value: PGLfloat); cdecl;
    TGLUniform4fv = procedure(location: GLint; Count: GLsizei; Value: PGLfloat); cdecl;
    TGLUniform1iv = procedure(location: GLint; Count: GLsizei; Value: PGLint); cdecl;
    TGLUniform2iv = procedure(location: GLint; Count: GLsizei; Value: PGLint); cdecl;
    TGLUniform3iv = procedure(location: GLint; Count: GLsizei; Value: PGLint); cdecl;
    TGLUniform4iv = procedure(location: GLint; Count: GLsizei; Value: PGLint); cdecl;

    TGLUniformMatrix2fv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); cdecl;
    TGLUniformMatrix3fv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); cdecl;
    TGLUniformMatrix4fv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); cdecl;

    TGLVertexAttribPointer = procedure(index: GLuint; size: GLint; typ: GLenum; normalized: GLboolean; stride: GLsizei; const pointer: Pointer); cdecl;
    TGLEnableVertexAttribArray = procedure(index: GLuint); cdecl;
    TGLDisableVertexAttribArray = procedure(index: GLuint); cdecl;
    TGLGetVertexAttribiv = procedure(index: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetVertexAttribfv = procedure(index: GLuint; pname: GLenum; params: PGLfloat); cdecl;
    TGLGetVertexAttribPointerv = procedure(index: GLuint; pname: GLenum; pointer: PPointer); cdecl;

    TGLStencilOpSeparate = procedure(face, sfail, dpfail, dppass: GLenum); cdecl;
    TGLStencilFuncSeparate = procedure(face: GLenum; func: GLenum; ref: GLint; mask: GLuint); cdecl;
    TGLStencilMaskSeparate = procedure(face: GLenum; mask: GLuint); cdecl;
    TGLDrawBuffers = procedure(n: GLsizei; const bufs: PGLenum); cdecl;

  protected
    FGLCreateShader: TGLCreateShader;
    FGLDeleteShader: TGLDeleteShader;
    FGLShaderSource: TGLShaderSource;
    FGLCompileShader: TGLCompileShader;
    FGLGetShaderiv: TGLGetShaderiv;
    FGLGetShaderInfoLog: TGLGetShaderInfoLog;
    FGLAttachShader: TGLAttachShader;
    FGLDetachShader: TGLDetachShader;
    FGLCreateProgram: TGLCreateProgram;
    FGLDeleteProgram: TGLDeleteProgram;
    FGLLinkProgram: TGLLinkProgram;
    FGLUseProgram: TGLUseProgram;
    FGLValidateProgram: TGLValidateProgram;
    FGLGetProgramiv: TGLGetProgramiv;
    FGLGetProgramInfoLog: TGLGetProgramInfoLog;
    FGLIsShader: TGLIsShader;
    FGLIsProgram: TGLIsProgram;
    FGLBindAttribLocation: TGLBindAttribLocation;
    FGLGetActiveAttrib: TGLGetActiveAttrib;
    FGLGetAttachedShaders: TGLGetAttachedShaders;
    FGLGetAttribLocation: TGLGetAttribLocation;
    FGLGetUniformLocation: TGLGetUniformLocation;
    FGLGetActiveUniform: TGLGetActiveUniform;

    FGLUniform1f: TGLUniform1f;
    FGLUniform2f: TGLUniform2f;
    FGLUniform3f: TGLUniform3f;
    FGLUniform4f: TGLUniform4f;
    FGLUniform1i: TGLUniform1i;
    FGLUniform2i: TGLUniform2i;
    FGLUniform3i: TGLUniform3i;
    FGLUniform4i: TGLUniform4i;
    FGLUniform1fv: TGLUniform1fv;
    FGLUniform2fv: TGLUniform2fv;
    FGLUniform3fv: TGLUniform3fv;
    FGLUniform4fv: TGLUniform4fv;
    FGLUniform1iv: TGLUniform1iv;
    FGLUniform2iv: TGLUniform2iv;
    FGLUniform3iv: TGLUniform3iv;
    FGLUniform4iv: TGLUniform4iv;
    FGLUniformMatrix2fv: TGLUniformMatrix2fv;
    FGLUniformMatrix3fv: TGLUniformMatrix3fv;
    FGLUniformMatrix4fv: TGLUniformMatrix4fv;

    FGLVertexAttribPointer: TGLVertexAttribPointer;
    FGLEnableVertexAttribArray: TGLEnableVertexAttribArray;
    FGLDisableVertexAttribArray: TGLDisableVertexAttribArray;
    FGLGetVertexAttribiv: TGLGetVertexAttribiv;
    FGLGetVertexAttribfv: TGLGetVertexAttribfv;
    FGLGetVertexAttribPointerv: TGLGetVertexAttribPointerv;

    FGLStencilOpSeparate: TGLStencilOpSeparate;
    FGLStencilFuncSeparate: TGLStencilFuncSeparate;
    FGLStencilMaskSeparate: TGLStencilMaskSeparate;
    FGLDrawBuffers: TGLDrawBuffers;

  protected
    procedure bindEntry; override;
  public
    function glCreateShader(shaderType: GLenum): GLuint; overload;
    procedure glDeleteShader(shaderObj: GLuint); overload;
    procedure glShaderSource(shaderObj: GLuint; Count: GLsizei; const strings: PPGLchar; const length: PGLint); overload;
    procedure glCompileShader(shaderObj: GLuint); overload;
    procedure glGetShaderiv(shaderObj: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetShaderInfoLog(shaderObj: GLuint; maxLength: GLsizei; length: PGLint; infoLog: PGLchar); overload;
    function glIsShader(shaderObj: GLuint): GLboolean; overload;

    function glCreateProgram: GLuint; overload;
    procedure glDeleteProgram(programObj: GLuint); overload;
    procedure glAttachShader(programObj, shaderObj: GLuint); overload;
    procedure glDetachShader(programObj, shaderObj: GLuint); overload;
    procedure glLinkProgram(programObj: GLuint); overload;
    procedure glUseProgram(programObj: GLuint); overload;
    procedure glValidateProgram(programObj: GLuint); overload;
    procedure glGetProgramiv(programObj: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetProgramInfoLog(programObj: GLuint; maxLength: GLsizei; length: PGLint; infoLog: PGLchar); overload;
    function glIsProgram(programObj: GLuint): GLboolean; overload;
    procedure glBindAttribLocation(programObj: GLuint; index: GLuint; const Name: PGLchar); overload;
    procedure glGetActiveAttrib(programObj, index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; typ: PGLenum; Name: PGLchar); overload;
    procedure glGetAttachedShaders(programObj: GLuint; maxCount: GLsizei; Count: PGLsizei; shaders: PGLuint); overload;
    function glGetAttribLocation(programObj: GLuint; const Name: PGLchar): GLint; overload;
    function glGetUniformLocation(programObj: GLuint; const Name: PGLchar): GLint; overload;
    procedure glGetActiveUniform(programObj, index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; typ: PGLenum; Name: PGLchar); overload;

    procedure glUniform1f(location: GLint; v0: GLfloat); overload;
    procedure glUniform2f(location: GLint; v0, v1: GLfloat); overload;
    procedure glUniform3f(location: GLint; v0, v1, v2: GLfloat); overload;
    procedure glUniform4f(location: GLint; v0, v1, v2, v3: GLfloat); overload;
    procedure glUniform1i(location: GLint; v0: GLint); overload;
    procedure glUniform2i(location: GLint; v0, v1: GLint); overload;
    procedure glUniform3i(location: GLint; v0, v1, v2: GLint); overload;
    procedure glUniform4i(location: GLint; v0, v1, v2, v3: GLint); overload;

    procedure glUniform1fv(location: GLint; Count: GLsizei; Value: PGLfloat); overload;
    procedure glUniform2fv(location: GLint; Count: GLsizei; Value: PGLfloat); overload;
    procedure glUniform3fv(location: GLint; Count: GLsizei; Value: PGLfloat); overload;
    procedure glUniform4fv(location: GLint; Count: GLsizei; Value: PGLfloat); overload;
    procedure glUniform1iv(location: GLint; Count: GLsizei; Value: PGLint); overload;
    procedure glUniform2iv(location: GLint; Count: GLsizei; Value: PGLint); overload;
    procedure glUniform3iv(location: GLint; Count: GLsizei; Value: PGLint); overload;
    procedure glUniform4iv(location: GLint; Count: GLsizei; Value: PGLint); overload;

    procedure glUniformMatrix2fv(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); overload;
    procedure glUniformMatrix3fv(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); overload;
    procedure glUniformMatrix4fv(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); overload;

    procedure glVertexAttribPointer(index: GLuint; size: GLint; typ: GLenum; normalized: GLboolean; stride: GLsizei; const pointer: Pointer); overload;
    procedure glEnableVertexAttribArray(index: GLuint); overload;
    procedure glDisableVertexAttribArray(index: GLuint); overload;
    procedure glGetVertexAttribiv(index: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetVertexAttribfv(index: GLuint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetVertexAttribPointerv(index: GLuint; pname: GLenum; pointer: PPointer); overload;

    procedure glStencilOpSeparate(face, sfail, dpfail, dppass: GLenum); overload;
    procedure glStencilFuncSeparate(face: GLenum; func: GLenum; ref: GLint; mask: GLuint); overload;
    procedure glStencilMaskSeparate(face: GLenum; mask: GLuint); overload;
    procedure glDrawBuffers(n: GLsizei; const bufs: PGLenum); overload;
  end;

  { TOpenGL_2_1 }

  TOpenGL_2_1 = class(TOpenGL_2_0, IOpenGL21)
  protected
  type
    TGLUniformMatrix2x3fv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    TGLUniformMatrix3x2fv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    TGLUniformMatrix2x4fv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    TGLUniformMatrix4x2fv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    TGLUniformMatrix3x4fv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
    TGLUniformMatrix4x3fv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
  protected
    FGLUniformMatrix2x3fv: TGLUniformMatrix2x3fv;
    FGLUniformMatrix3x2fv: TGLUniformMatrix3x2fv;
    FGLUniformMatrix2x4fv: TGLUniformMatrix2x4fv;
    FGLUniformMatrix4x2fv: TGLUniformMatrix4x2fv;
    FGLUniformMatrix3x4fv: TGLUniformMatrix3x4fv;
    FGLUniformMatrix4x3fv: TGLUniformMatrix4x3fv;
  protected
    procedure bindEntry; override;
  public
    procedure glUniformMatrix2x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix3x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix2x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix4x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix3x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glUniformMatrix4x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
  end;


  { TOpenGL_3_0 }

  TOpenGL_3_0 = class(TOpenGL_2_1, IOpenGL30)
  protected
  type
    TGLColorMaski = procedure(index: GLuint; r, g, b, a: GLboolean); cdecl;
    TGLGetBooleani_v = procedure(target: GLenum; index: GLuint; Data: PGLboolean); cdecl;
    TGLGetIntegeri_v = procedure(target: GLenum; index: GLuint; Data: PGLint); cdecl;
    TGLEnablei = procedure(target: GLenum; index: GLuint); cdecl;
    TGLDisablei = procedure(target: GLenum; index: GLuint); cdecl;
    TGLIsEnabledi = function(target: GLenum; index: GLuint): GLboolean; cdecl;

    TGLBeginTransformFeedback = procedure(primitiveMode: GLenum); cdecl;
    TGLEndTransformFeedback = procedure; cdecl;
    TGLBindBufferRange = procedure(target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); cdecl;
    TGLBindBufferBase = procedure(target: GLenum; index: GLuint; buffer: GLuint); cdecl;
    TGLTransformFeedbackVaryings = procedure(aProgram: GLuint; Count: GLsizei; const varyings: PPGLchar; bufferMode: GLenum); cdecl;
    TGLGetTransformFeedbackVarying = procedure(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; aType: PGLenum; Name: PGLchar); cdecl;

    TGLClampColor = procedure(target: GLenum; clamp: GLenum); cdecl;

    TGLBeginConditionalRender = procedure(id: GLuint; mode: GLenum); cdecl;
    TGLEndConditionalRender = procedure; cdecl;

    TGLVertexAttribIPointer = procedure(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const pointer: Pointer); cdecl;
    TGLGetVertexAttribIiv = procedure(index: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetVertexAttribIuiv = procedure(index: GLuint; pname: GLenum; params: PGLuint); cdecl;

    TGLVertexAttribI1i = procedure(index: GLuint; x: GLint); cdecl;
    TGLVertexAttribI2i = procedure(index: GLuint; x, y: GLint); cdecl;
    TGLVertexAttribI3i = procedure(index: GLuint; x, y, z: GLint); cdecl;
    TGLVertexAttribI4i = procedure(index: GLuint; x, y, z, w: GLint); cdecl;
    TGLVertexAttribI1ui = procedure(index: GLuint; x: GLuint); cdecl;
    TGLVertexAttribI2ui = procedure(index: GLuint; x, y: GLuint); cdecl;
    TGLVertexAttribI3ui = procedure(index: GLuint; x, y, z: GLuint); cdecl;
    TGLVertexAttribI4ui = procedure(index: GLuint; x, y, z, w: GLuint); cdecl;

    TGLVertexAttribI1iv = procedure(index: GLuint; const v: PGLint); cdecl;
    TGLVertexAttribI2iv = procedure(index: GLuint; const v: PGLint); cdecl;
    TGLVertexAttribI3iv = procedure(index: GLuint; const v: PGLint); cdecl;
    TGLVertexAttribI4iv = procedure(index: GLuint; const v: PGLint); cdecl;
    TGLVertexAttribI1uiv = procedure(index: GLuint; const v: PGLuint); cdecl;
    TGLVertexAttribI2uiv = procedure(index: GLuint; const v: PGLuint); cdecl;
    TGLVertexAttribI3uiv = procedure(index: GLuint; const v: PGLuint); cdecl;
    TGLVertexAttribI4uiv = procedure(index: GLuint; const v: PGLuint); cdecl;

    TGLVertexAttribI4bv = procedure(index: GLuint; const v: PGLbyte); cdecl;
    TGLVertexAttribI4sv = procedure(index: GLuint; const v: PGLshort); cdecl;
    TGLVertexAttribI4ubv = procedure(index: GLuint; const v: PGLubyte); cdecl;
    TGLVertexAttribI4usv = procedure(index: GLuint; const v: PGLushort); cdecl;

    TGLGetUniformuiv = procedure(aProgram: GLuint; location: GLint; params: PGLuint); cdecl;
    TGLBindFragDataLocation = procedure(aProgram: GLuint; color: GLuint; const Name: PGLchar); cdecl;
    TGLGetFragDataLocation = function(aProgram: GLuint; const Name: PGLchar): GLint; cdecl;

    TGLUniform1ui = procedure(location: GLint; v0: GLuint); cdecl;
    TGLUniform2ui = procedure(location: GLint; v0, v1: GLuint); cdecl;
    TGLUniform3ui = procedure(location: GLint; v0, v1, v2: GLuint); cdecl;
    TGLUniform4ui = procedure(location: GLint; v0, v1, v2, v3: GLuint); cdecl;
    TGLUniform1uiv = procedure(location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    TGLUniform2uiv = procedure(location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    TGLUniform3uiv = procedure(location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;
    TGLUniform4uiv = procedure(location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;

    TGLTexParameterIiv = procedure(target: GLenum; pname: GLenum; const params: PGLint); cdecl;
    TGLTexParameterIuiv = procedure(target: GLenum; pname: GLenum; const params: PGLuint); cdecl;
    TGLGetTexParameterIiv = procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    TGLGetTexParameterIuiv = procedure(target: GLenum; pname: GLenum; params: PGLuint); cdecl;

    TGLClearBufferiv = procedure(buffer: GLenum; drawbuffer: GLint; const Value: PGLint); cdecl;
    TGLClearBufferuiv = procedure(buffer: GLenum; drawbuffer: GLint; const Value: PGLuint); cdecl;
    TGLClearBufferfv = procedure(buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat); cdecl;
    TGLClearBufferfi = procedure(buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); cdecl;

    TGLGetStringi = function(Name: GLenum; index: GLuint): PGLubyte; cdecl;

    TGLIsRenderbuffer = function(renderbuffer: GLuint): GLboolean; cdecl;
    TGLBindRenderbuffer = procedure(target: GLenum; renderbuffer: GLuint); cdecl;
    TGLDeleteRenderbuffers = procedure(n: GLsizei; const renderbuffers: PGLuint); cdecl;
    TGLGenRenderbuffers = procedure(n: GLsizei; renderbuffers: PGLuint); cdecl;
    TGLRenderbufferStorage = procedure(target: GLenum; internalformat: GLenum; Width, Height: GLsizei); cdecl;
    TGLGetRenderbufferParameteriv = procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;

    TGLIsFramebuffer = function(framebuffer: GLuint): GLboolean; cdecl;
    TGLBindFramebuffer = procedure(target: GLenum; framebuffer: GLuint); cdecl;
    TGLDeleteFramebuffers = procedure(n: GLsizei; const framebuffers: PGLuint); cdecl;
    TGLGenFramebuffers = procedure(n: GLsizei; framebuffers: PGLuint); cdecl;
    TGLCheckFramebufferStatus = function(target: GLenum): GLenum; cdecl;
    TGLFramebufferTexture1D = procedure(target, attachment, textarget: GLenum; texture: GLuint; level: GLint); cdecl;
    TGLFramebufferTexture2D = procedure(target, attachment, textarget: GLenum; texture: GLuint; level: GLint); cdecl;
    TGLFramebufferTexture3D = procedure(target, attachment, textarget: GLenum; texture: GLuint; level, zoffset: GLint); cdecl;
    TGLFramebufferRenderbuffer = procedure(target, attachment, renderbuffertarget: GLenum; renderbuffer: GLuint); cdecl;
    TGLGetFramebufferAttachmentParameteriv = procedure(target, attachment, pname: GLenum; params: PGLint); cdecl;

    TGLGenerateMipmap = procedure(target: GLenum); cdecl;

    TGLBlitFramebuffer = procedure(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1: GLint; mask: GLbitfield; filter: GLenum); cdecl;

    TGLRenderbufferStorageMultisample = procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei); cdecl;

    TGLFramebufferTextureLayer = procedure(target, attachment: GLenum; texture: GLuint; level, layer: GLint); cdecl;

    TGLMapBufferRange = function(target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer; cdecl;
    TGLFlushMappedBufferRange = procedure(target: GLenum; offset: GLintptr; length: GLsizeiptr); cdecl;

    TGLBindVertexArray = procedure(array_: GLuint); cdecl;
    TGLDeleteVertexArrays = procedure(n: GLsizei; const arrays: PGLuint); cdecl;
    TGLGenVertexArrays = procedure(n: GLsizei; arrays: PGLuint); cdecl;
    TGLIsVertexArray = function(array_: GLuint): GLboolean; cdecl;
  protected
    FGLColorMaski: TGLColorMaski;
    FGLGetBooleani_v: TGLGetBooleani_v;
    FGLGetIntegeri_v: TGLGetIntegeri_v;
    FGLEnablei: TGLEnablei;
    FGLDisablei: TGLDisablei;
    FGLIsEnabledi: TGLIsEnabledi;

    FGLBeginTransformFeedback: TGLBeginTransformFeedback;
    FGLEndTransformFeedback: TGLEndTransformFeedback;
    FGLBindBufferRange: TGLBindBufferRange;
    FGLBindBufferBase: TGLBindBufferBase;
    FGLTransformFeedbackVaryings: TGLTransformFeedbackVaryings;
    FGLGetTransformFeedbackVarying: TGLGetTransformFeedbackVarying;

    FGLClampColor: TGLClampColor;

    FGLBeginConditionalRender: TGLBeginConditionalRender;
    FGLEndConditionalRender: TGLEndConditionalRender;

    FGLVertexAttribIPointer: TGLVertexAttribIPointer;
    FGLGetVertexAttribIiv: TGLGetVertexAttribIiv;
    FGLGetVertexAttribIuiv: TGLGetVertexAttribIuiv;

    FGLVertexAttribI1i: TGLVertexAttribI1i;
    FGLVertexAttribI2i: TGLVertexAttribI2i;
    FGLVertexAttribI3i: TGLVertexAttribI3i;
    FGLVertexAttribI4i: TGLVertexAttribI4i;
    FGLVertexAttribI1ui: TGLVertexAttribI1ui;
    FGLVertexAttribI2ui: TGLVertexAttribI2ui;
    FGLVertexAttribI3ui: TGLVertexAttribI3ui;
    FGLVertexAttribI4ui: TGLVertexAttribI4ui;

    FGLVertexAttribI1iv: TGLVertexAttribI1iv;
    FGLVertexAttribI2iv: TGLVertexAttribI2iv;
    FGLVertexAttribI3iv: TGLVertexAttribI3iv;
    FGLVertexAttribI4iv: TGLVertexAttribI4iv;
    FGLVertexAttribI1uiv: TGLVertexAttribI1uiv;
    FGLVertexAttribI2uiv: TGLVertexAttribI2uiv;
    FGLVertexAttribI3uiv: TGLVertexAttribI3uiv;
    FGLVertexAttribI4uiv: TGLVertexAttribI4uiv;

    FGLVertexAttribI4bv: TGLVertexAttribI4bv;
    FGLVertexAttribI4sv: TGLVertexAttribI4sv;
    FGLVertexAttribI4ubv: TGLVertexAttribI4ubv;
    FGLVertexAttribI4usv: TGLVertexAttribI4usv;

    FGLGetUniformuiv: TGLGetUniformuiv;
    FGLBindFragDataLocation: TGLBindFragDataLocation;
    FGLGetFragDataLocation: TGLGetFragDataLocation;

    FGLUniform1ui: TGLUniform1ui;
    FGLUniform2ui: TGLUniform2ui;
    FGLUniform3ui: TGLUniform3ui;
    FGLUniform4ui: TGLUniform4ui;
    FGLUniform1uiv: TGLUniform1uiv;
    FGLUniform2uiv: TGLUniform2uiv;
    FGLUniform3uiv: TGLUniform3uiv;
    FGLUniform4uiv: TGLUniform4uiv;

    FGLTexParameterIiv: TGLTexParameterIiv;
    FGLTexParameterIuiv: TGLTexParameterIuiv;
    FGLGetTexParameterIiv: TGLGetTexParameterIiv;
    FGLGetTexParameterIuiv: TGLGetTexParameterIuiv;

    FGLClearBufferiv: TGLClearBufferiv;
    FGLClearBufferuiv: TGLClearBufferuiv;
    FGLClearBufferfv: TGLClearBufferfv;
    FGLClearBufferfi: TGLClearBufferfi;

    FGLGetStringi: TGLGetStringi;

    FGLIsRenderbuffer: TGLIsRenderbuffer;
    FGLBindRenderbuffer: TGLBindRenderbuffer;
    FGLDeleteRenderbuffers: TGLDeleteRenderbuffers;
    FGLGenRenderbuffers: TGLGenRenderbuffers;
    FGLRenderbufferStorage: TGLRenderbufferStorage;
    FGLGetRenderbufferParameteriv: TGLGetRenderbufferParameteriv;

    FGLIsFramebuffer: TGLIsFramebuffer;
    FGLBindFramebuffer: TGLBindFramebuffer;
    FGLDeleteFramebuffers: TGLDeleteFramebuffers;
    FGLGenFramebuffers: TGLGenFramebuffers;
    FGLCheckFramebufferStatus: TGLCheckFramebufferStatus;
    FGLFramebufferTexture1D: TGLFramebufferTexture1D;
    FGLFramebufferTexture2D: TGLFramebufferTexture2D;
    FGLFramebufferTexture3D: TGLFramebufferTexture3D;
    FGLFramebufferRenderbuffer: TGLFramebufferRenderbuffer;
    FGLGetFramebufferAttachmentParameteriv: TGLGetFramebufferAttachmentParameteriv;

    FGLGenerateMipmap: TGLGenerateMipmap;

    FGLBlitFramebuffer: TGLBlitFramebuffer;

    FGLRenderbufferStorageMultisample: TGLRenderbufferStorageMultisample;

    FGLFramebufferTextureLayer: TGLFramebufferTextureLayer;

    FGLMapBufferRange: TGLMapBufferRange;
    FGLFlushMappedBufferRange: TGLFlushMappedBufferRange;

    FGLBindVertexArray: TGLBindVertexArray;
    FGLDeleteVertexArrays: TGLDeleteVertexArrays;
    FGLGenVertexArrays: TGLGenVertexArrays;
    FGLIsVertexArray: TGLIsVertexArray;
  protected
    procedure bindEntry; override;
  public
    procedure glColorMaski(index: GLuint; r, g, b, a: GLboolean); overload;

    procedure glGetBooleani_v(target: GLenum; index: GLuint; Data: PGLboolean); overload;
    procedure glGetIntegeri_v(target: GLenum; index: GLuint; Data: PGLint); overload;

    procedure glEnablei(target: GLenum; index: GLuint); overload;
    procedure glDisablei(target: GLenum; index: GLuint); overload;
    function glIsEnabledi(target: GLenum; index: GLuint): GLboolean; overload;

    procedure glBeginTransformFeedback(primitiveMode: GLenum); overload;
    procedure glEndTransformFeedback; overload;

    procedure glBindBufferRange(target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glBindBufferBase(target: GLenum; index: GLuint; buffer: GLuint); overload;

    procedure glTransformFeedbackVaryings(aProgram: GLuint; Count: GLsizei; const varyings: PPGLchar; bufferMode: GLenum); overload;
    procedure glGetTransformFeedbackVarying(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; aType: PGLenum; Name: PGLchar); overload;

    procedure glClampColor(target: GLenum; clamp: GLenum); overload;

    procedure glBeginConditionalRender(id: GLuint; mode: GLenum); overload;
    procedure glEndConditionalRender; overload;

    procedure glVertexAttribIPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const pointer: Pointer); overload;
    procedure glGetVertexAttribIiv(index: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetVertexAttribIuiv(index: GLuint; pname: GLenum; params: PGLuint); overload;

    procedure glVertexAttribI1i(index: GLuint; x: GLint); overload;
    procedure glVertexAttribI2i(index: GLuint; x, y: GLint); overload;
    procedure glVertexAttribI3i(index: GLuint; x, y, z: GLint); overload;
    procedure glVertexAttribI4i(index: GLuint; x, y, z, w: GLint); overload;

    procedure glVertexAttribI1ui(index: GLuint; x: GLuint); overload;
    procedure glVertexAttribI2ui(index: GLuint; x, y: GLuint); overload;
    procedure glVertexAttribI3ui(index: GLuint; x, y, z: GLuint); overload;
    procedure glVertexAttribI4ui(index: GLuint; x, y, z, w: GLuint); overload;

    procedure glVertexAttribI1iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI2iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI3iv(index: GLuint; const v: PGLint); overload;
    procedure glVertexAttribI4iv(index: GLuint; const v: PGLint); overload;

    procedure glVertexAttribI1uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI2uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI3uiv(index: GLuint; const v: PGLuint); overload;
    procedure glVertexAttribI4uiv(index: GLuint; const v: PGLuint); overload;

    procedure glVertexAttribI4bv(index: GLuint; const v: PGLbyte); overload;
    procedure glVertexAttribI4sv(index: GLuint; const v: PGLshort); overload;
    procedure glVertexAttribI4ubv(index: GLuint; const v: PGLubyte); overload;
    procedure glVertexAttribI4usv(index: GLuint; const v: PGLushort); overload;

    procedure glGetUniformuiv(aProgram: GLuint; location: GLint; params: PGLuint); overload;
    procedure glBindFragDataLocation(aProgram: GLuint; color: GLuint; const Name: PGLchar); overload;
    function glGetFragDataLocation(aProgram: GLuint; const Name: PGLchar): GLint; overload;

    procedure glUniform1ui(location: GLint; v0: GLuint); overload;
    procedure glUniform2ui(location: GLint; v0, v1: GLuint); overload;
    procedure glUniform3ui(location: GLint; v0, v1, v2: GLuint); overload;
    procedure glUniform4ui(location: GLint; v0, v1, v2, v3: GLuint); overload;

    procedure glUniform1uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glUniform2uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glUniform3uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;
    procedure glUniform4uiv(location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glTexParameterIiv(target: GLenum; pname: GLenum; const params: PGLint);
    procedure glTexParameterIuiv(target: GLenum; pname: GLenum; const params: PGLuint);
    procedure glGetTexParameterIiv(target: GLenum; pname: GLenum; params: PGLint);
    procedure glGetTexParameterIuiv(target: GLenum; pname: GLenum; params: PGLuint);

    procedure glClearBufferiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLint);
    procedure glClearBufferuiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLuint);
    procedure glClearBufferfv(buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat);
    procedure glClearBufferfi(buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint);

    function glGetStringi(Name: GLenum; index: GLuint): PGLubyte;

    function glIsRenderbuffer(renderbuffer: GLuint): GLboolean;
    procedure glBindRenderbuffer(target: GLenum; renderbuffer: GLuint);
    procedure glDeleteRenderbuffers(n: GLsizei; const renderbuffers: PGLuint);
    procedure glGenRenderbuffers(n: GLsizei; renderbuffers: PGLuint);
    procedure glRenderbufferStorage(target: GLenum; internalformat: GLenum; Width, Height: GLsizei);
    procedure glGetRenderbufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);

    function glIsFramebuffer(framebuffer: GLuint): GLboolean;
    procedure glBindFramebuffer(target: GLenum; framebuffer: GLuint);
    procedure glDeleteFramebuffers(n: GLsizei; const framebuffers: PGLuint);
    procedure glGenFramebuffers(n: GLsizei; framebuffers: PGLuint);
    function glCheckFramebufferStatus(target: GLenum): GLenum;

    procedure glFramebufferTexture1D(target, attachment, textarget: GLenum; texture: GLuint; level: GLint);
    procedure glFramebufferTexture2D(target, attachment, textarget: GLenum; texture: GLuint; level: GLint);
    procedure glFramebufferTexture3D(target, attachment, textarget: GLenum; texture: GLuint; level, zoffset: GLint);
    procedure glFramebufferRenderbuffer(target, attachment, renderbuffertarget: GLenum; renderbuffer: GLuint);
    procedure glGetFramebufferAttachmentParameteriv(target, attachment, pname: GLenum; params: PGLint);

    procedure glGenerateMipmap(target: GLenum);

    procedure glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1: GLint; mask: GLbitfield; filter: GLenum);

    procedure glRenderbufferStorageMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei);

    procedure glFramebufferTextureLayer(target, attachment: GLenum; texture: GLuint; level, layer: GLint);

    function glMapBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer;
    procedure glFlushMappedBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr);
    procedure glBindVertexArray(array_: GLuint);
    procedure glDeleteVertexArrays(n: GLsizei; const arrays: PGLuint);
    procedure glGenVertexArrays(n: GLsizei; arrays: PGLuint);
    function glIsVertexArray(array_: GLuint): GLboolean;
  end;

  { TOpenGL_3_1 }

  TOpenGL_3_1 = class(TOpenGL_3_0, IOpenGL31)
  protected
  type
    TGLDrawArraysInstanced = procedure(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei); cdecl;
    TGLDrawElementsInstanced = procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei); cdecl;
    TGLTexBuffer = procedure(target: GLenum; internalformat: GLenum; buffer: GLuint); cdecl;
    TGLPrimitiveRestartIndex = procedure(index: GLuint); cdecl;
    TGLCopyBufferSubData = procedure(readTarget, writeTarget: GLenum; readOffset, writeOffset: GLintptr; size: GLsizeiptr); cdecl;
    TGLGetUniformIndices = procedure(aProgram: GLuint; uniformCount: GLsizei; const uniformNames: PPGLchar; uniformIndices: PGLuint); cdecl;
    TGLGetActiveUniformsiv = procedure(aProgram: GLuint; uniformCount: GLsizei; const uniformIndices: PGLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetActiveUniformName = procedure(aProgram: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar); cdecl;
    TGLGetUniformBlockIndex = function(aProgram: GLuint; const uniformBlockName: PGLchar): GLuint; cdecl;
    TGLGetActiveUniformBlockiv = procedure(aProgram: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetActiveUniformBlockName = procedure(aProgram: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar); cdecl;
    TGLUniformBlockBinding = procedure(aProgram: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint); cdecl;

  protected
    FGLDrawArraysInstanced: TGLDrawArraysInstanced;
    FGLDrawElementsInstanced: TGLDrawElementsInstanced;
    FGLTexBuffer: TGLTexBuffer;
    FGLPrimitiveRestartIndex: TGLPrimitiveRestartIndex;
    FGLCopyBufferSubData: TGLCopyBufferSubData;
    FGLGetUniformIndices: TGLGetUniformIndices;
    FGLGetActiveUniformsiv: TGLGetActiveUniformsiv;
    FGLGetActiveUniformName: TGLGetActiveUniformName;
    FGLGetUniformBlockIndex: TGLGetUniformBlockIndex;
    FGLGetActiveUniformBlockiv: TGLGetActiveUniformBlockiv;
    FGLGetActiveUniformBlockName: TGLGetActiveUniformBlockName;
    FGLUniformBlockBinding: TGLUniformBlockBinding;

  protected
    procedure bindEntry; override;
  public
    procedure glDrawArraysInstanced(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei); overload;
    procedure glDrawElementsInstanced(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei); overload;
    procedure glTexBuffer(target: GLenum; internalformat: GLenum; buffer: GLuint); overload;
    procedure glPrimitiveRestartIndex(index: GLuint); overload;
    procedure glCopyBufferSubData(readTarget, writeTarget: GLenum; readOffset, writeOffset: GLintptr; size: GLsizeiptr); overload;
    procedure glGetUniformIndices(aProgram: GLuint; uniformCount: GLsizei; const uniformNames: PPGLchar; uniformIndices: PGLuint); overload;
    procedure glGetActiveUniformsiv(aProgram: GLuint; uniformCount: GLsizei; const uniformIndices: PGLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetActiveUniformName(aProgram: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar); overload;
    function glGetUniformBlockIndex(aProgram: GLuint; const uniformBlockName: PGLchar): GLuint; overload;
    procedure glGetActiveUniformBlockiv(aProgram: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetActiveUniformBlockName(aProgram: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar); overload;
    procedure glUniformBlockBinding(aProgram: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint); overload;
  end;

  { TOpenGL_3_2 }

  TOpenGL_3_2 = class(TOpenGL_3_1, IOpenGL32)
  protected
  type
    TGLDrawElementsBaseVertex = procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); cdecl;
    TGLDrawRangeElementsBaseVertex = procedure(mode: GLenum; start, end_: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); cdecl;
    TGLDrawElementsInstancedBaseVertex = procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint); cdecl;
    TGLMultiDrawElementsBaseVertex = procedure(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: PPointer; drawcount: GLsizei; const basevertex: PGLint); cdecl;
    TGLProvokingVertex = procedure(mode: GLenum); cdecl;

    TGLFenceSync = function(condition: GLenum; flags: GLbitfield): GLsync; cdecl;
    TGLIsSync = function(sync: GLsync): GLboolean; cdecl;
    TGLDeleteSync = procedure(sync: GLsync); cdecl;
    TGLClientWaitSync = function(sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum; cdecl;
    TGLWaitSync = procedure(sync: GLsync; flags: GLbitfield; timeout: GLuint64); cdecl;

    TGLGetInteger64v = procedure(pname: GLenum; Data: PGLint64); cdecl;
    TGLGetSynciv = procedure(sync: GLsync; pname: GLenum; bufSize: GLsizei; length: PGLsizei; values: PGLint); cdecl;
    TGLGetInteger64i_v = procedure(target: GLenum; index: GLuint; Data: PGLint64); cdecl;
    TGLGetBufferParameteri64v = procedure(target, pname: GLenum; params: PGLint64); cdecl;

    TGLFramebufferTexture = procedure(target, attachment: GLenum; texture: GLuint; level: GLint); cdecl;

    TGLTexImage2DMultisample = procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    TGLTexImage3DMultisample = procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean); cdecl;

    TGLGetMultisamplefv = procedure(pname: GLenum; index: GLuint; val: PGLfloat); cdecl;
    TGLSampleMaski = procedure(maskNumber: GLuint; mask: GLbitfield); cdecl;

  protected
    FGLDrawElementsBaseVertex: TGLDrawElementsBaseVertex;
    FGLDrawRangeElementsBaseVertex: TGLDrawRangeElementsBaseVertex;
    FGLDrawElementsInstancedBaseVertex: TGLDrawElementsInstancedBaseVertex;
    FGLMultiDrawElementsBaseVertex: TGLMultiDrawElementsBaseVertex;
    FGLProvokingVertex: TGLProvokingVertex;

    FGLFenceSync: TGLFenceSync;
    FGLIsSync: TGLIsSync;
    FGLDeleteSync: TGLDeleteSync;
    FGLClientWaitSync: TGLClientWaitSync;
    FGLWaitSync: TGLWaitSync;

    FGLGetInteger64v: TGLGetInteger64v;
    FGLGetSynciv: TGLGetSynciv;
    FGLGetInteger64i_v: TGLGetInteger64i_v;
    FGLGetBufferParameteri64v: TGLGetBufferParameteri64v;

    FGLFramebufferTexture: TGLFramebufferTexture;

    FGLTexImage2DMultisample: TGLTexImage2DMultisample;
    FGLTexImage3DMultisample: TGLTexImage3DMultisample;

    FGLGetMultisamplefv: TGLGetMultisamplefv;
    FGLSampleMaski: TGLSampleMaski;

  protected
    procedure bindEntry; override;
  public
    procedure glDrawElementsBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); overload;
    procedure glDrawRangeElementsBaseVertex(mode: GLenum; start, end_: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint); overload;
    procedure glDrawElementsInstancedBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint); overload;
    procedure glMultiDrawElementsBaseVertex(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: PPointer; drawcount: GLsizei; const basevertex: PGLint); overload;
    procedure glProvokingVertex(mode: GLenum); overload;

    function glFenceSync(condition: GLenum; flags: GLbitfield): GLsync; overload;
    function glIsSync(sync: GLsync): GLboolean; overload;
    procedure glDeleteSync(sync: GLsync); overload;
    function glClientWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum; overload;
    procedure glWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64); overload;

    procedure glGetInteger64v(pname: GLenum; Data: PGLint64); overload;
    procedure glGetSynciv(sync: GLsync; pname: GLenum; bufSize: GLsizei; length: PGLsizei; values: PGLint); overload;
    procedure glGetInteger64i_v(target: GLenum; index: GLuint; Data: PGLint64); overload;
    procedure glGetBufferParameteri64v(target, pname: GLenum; params: PGLint64); overload;

    procedure glFramebufferTexture(target, attachment: GLenum; texture: GLuint; level: GLint); overload;

    procedure glTexImage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTexImage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean); overload;

    procedure glGetMultisamplefv(pname: GLenum; index: GLuint; val: PGLfloat); overload;
    procedure glSampleMaski(maskNumber: GLuint; mask: GLbitfield); overload;
  end;

  TOpenGL_3_3 = class(TOpenGL_3_2, IOpenGL33)
  protected
  type
    TGLBindFragDataLocationIndexed = procedure(aProgram: GLuint; colorNumber: GLuint; index: GLuint; const Name: PGLchar); cdecl;
    TGLGetFragDataIndex = function(aProgram: GLuint; const Name: PGLchar): GLint; cdecl;

    TGLGenSamplers = procedure(Count: GLsizei; samplers: PGLuint); cdecl;
    TGLDeleteSamplers = procedure(Count: GLsizei; const samplers: PGLuint); cdecl;
    TGLIsSampler = function(sampler: GLuint): GLboolean; cdecl;
    TGLBindSampler = procedure(aUnit: GLuint; sampler: GLuint); cdecl;

    TGLSamplerParameteri = procedure(sampler: GLuint; pname: GLenum; param: GLint); cdecl;
    TGLSamplerParameteriv = procedure(sampler: GLuint; pname: GLenum; const param: PGLint); cdecl;
    TGLSamplerParameterf = procedure(sampler: GLuint; pname: GLenum; param: GLfloat); cdecl;
    TGLSamplerParameterfv = procedure(sampler: GLuint; pname: GLenum; const param: PGLfloat); cdecl;
    TGLSamplerParameterIiv = procedure(sampler: GLuint; pname: GLenum; const param: PGLint); cdecl;
    TGLSamplerParameterIuiv = procedure(sampler: GLuint; pname: GLenum; const param: PGLuint); cdecl;

    TGLGetSamplerParameteriv = procedure(sampler: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetSamplerParameterIiv = procedure(sampler: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetSamplerParameterfv = procedure(sampler: GLuint; pname: GLenum; params: PGLfloat); cdecl;
    TGLGetSamplerParameterIuiv = procedure(sampler: GLuint; pname: GLenum; params: PGLuint); cdecl;

    TGLQueryCounter = procedure(id: GLuint; target: GLenum); cdecl;
    TGLGetQueryObjecti64v = procedure(id: GLuint; pname: GLenum; params: PGLint64); cdecl;
    TGLGetQueryObjectui64v = procedure(id: GLuint; pname: GLenum; params: PGLuint64); cdecl;

    TGLVertexAttribDivisor = procedure(index: GLuint; divisor: GLuint); cdecl;

    TGLVertexAttribP1ui = procedure(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); cdecl;
    TGLVertexAttribP1uiv = procedure(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); cdecl;
    TGLVertexAttribP2ui = procedure(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); cdecl;
    TGLVertexAttribP2uiv = procedure(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); cdecl;
    TGLVertexAttribP3ui = procedure(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); cdecl;
    TGLVertexAttribP3uiv = procedure(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); cdecl;
    TGLVertexAttribP4ui = procedure(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); cdecl;
    TGLVertexAttribP4uiv = procedure(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); cdecl;

  protected
    FGLBindFragDataLocationIndexed: TGLBindFragDataLocationIndexed;
    FGLGetFragDataIndex: TGLGetFragDataIndex;

    FGLGenSamplers: TGLGenSamplers;
    FGLDeleteSamplers: TGLDeleteSamplers;
    FGLIsSampler: TGLIsSampler;
    FGLBindSampler: TGLBindSampler;

    FGLSamplerParameteri: TGLSamplerParameteri;
    FGLSamplerParameteriv: TGLSamplerParameteriv;
    FGLSamplerParameterf: TGLSamplerParameterf;
    FGLSamplerParameterfv: TGLSamplerParameterfv;
    FGLSamplerParameterIiv: TGLSamplerParameterIiv;
    FGLSamplerParameterIuiv: TGLSamplerParameterIuiv;

    FGLGetSamplerParameteriv: TGLGetSamplerParameteriv;
    FGLGetSamplerParameterIiv: TGLGetSamplerParameterIiv;
    FGLGetSamplerParameterfv: TGLGetSamplerParameterfv;
    FGLGetSamplerParameterIuiv: TGLGetSamplerParameterIuiv;

    FGLQueryCounter: TGLQueryCounter;
    FGLGetQueryObjecti64v: TGLGetQueryObjecti64v;
    FGLGetQueryObjectui64v: TGLGetQueryObjectui64v;

    FGLVertexAttribDivisor: TGLVertexAttribDivisor;

    FGLVertexAttribP1ui: TGLVertexAttribP1ui;
    FGLVertexAttribP1uiv: TGLVertexAttribP1uiv;
    FGLVertexAttribP2ui: TGLVertexAttribP2ui;
    FGLVertexAttribP2uiv: TGLVertexAttribP2uiv;
    FGLVertexAttribP3ui: TGLVertexAttribP3ui;
    FGLVertexAttribP3uiv: TGLVertexAttribP3uiv;
    FGLVertexAttribP4ui: TGLVertexAttribP4ui;
    FGLVertexAttribP4uiv: TGLVertexAttribP4uiv;

  protected
    procedure bindEntry; override;
  public
    procedure glBindFragDataLocationIndexed(aProgram: GLuint; colorNumber: GLuint; index: GLuint; const Name: PGLchar); overload;
    function glGetFragDataIndex(aProgram: GLuint; const Name: PGLchar): GLint; overload;

    procedure glGenSamplers(Count: GLsizei; samplers: PGLuint); overload;
    procedure glDeleteSamplers(Count: GLsizei; const samplers: PGLuint); overload;
    function glIsSampler(sampler: GLuint): GLboolean; overload;
    procedure glBindSampler(aUnit: GLuint; sampler: GLuint); overload;

    procedure glSamplerParameteri(sampler: GLuint; pname: GLenum; param: GLint); overload;
    procedure glSamplerParameteriv(sampler: GLuint; pname: GLenum; const param: PGLint); overload;
    procedure glSamplerParameterf(sampler: GLuint; pname: GLenum; param: GLfloat); overload;
    procedure glSamplerParameterfv(sampler: GLuint; pname: GLenum; const param: PGLfloat); overload;
    procedure glSamplerParameterIiv(sampler: GLuint; pname: GLenum; const param: PGLint); overload;
    procedure glSamplerParameterIuiv(sampler: GLuint; pname: GLenum; const param: PGLuint); overload;

    procedure glGetSamplerParameteriv(sampler: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetSamplerParameterIiv(sampler: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetSamplerParameterfv(sampler: GLuint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetSamplerParameterIuiv(sampler: GLuint; pname: GLenum; params: PGLuint); overload;

    procedure glQueryCounter(id: GLuint; target: GLenum); overload;
    procedure glGetQueryObjecti64v(id: GLuint; pname: GLenum; params: PGLint64); overload;
    procedure glGetQueryObjectui64v(id: GLuint; pname: GLenum; params: PGLuint64); overload;

    procedure glVertexAttribDivisor(index: GLuint; divisor: GLuint); overload;

    procedure glVertexAttribP1ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP1uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexAttribP2ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP2uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexAttribP3ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP3uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;
    procedure glVertexAttribP4ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint); overload;
    procedure glVertexAttribP4uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint); overload;

  end;

  TOpenGL_4_0 = class(TOpenGL_3_3, IOpenGL40)
  protected
  type
    TGLMinSampleShading = procedure(Value: GLfloat); cdecl;

    TGLBlendEquationi = procedure(buf: GLuint; mode: GLenum); cdecl;
    TGLBlendEquationSeparatei = procedure(buf: GLuint; modeRGB, modeAlpha: GLenum); cdecl;
    TGLBlendFunci = procedure(buf: GLuint; src, dst: GLenum); cdecl;
    TGLBlendFuncSeparatei = procedure(buf: GLuint; srcRGB, dstRGB, srcAlpha, dstAlpha: GLenum); cdecl;

    TGLDrawArraysIndirect = procedure(mode: GLenum; const indirect: Pointer); cdecl;
    TGLDrawElementsIndirect = procedure(mode: GLenum; aType: GLenum; const indirect: Pointer); cdecl;

    TGLUniform1d = procedure(location: GLint; x: GLdouble); cdecl;
    TGLUniform2d = procedure(location: GLint; x, y: GLdouble); cdecl;
    TGLUniform3d = procedure(location: GLint; x, y, z: GLdouble); cdecl;
    TGLUniform4d = procedure(location: GLint; x, y, z, w: GLdouble); cdecl;

    TGLUniform1dv = procedure(location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    TGLUniform2dv = procedure(location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    TGLUniform3dv = procedure(location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    TGLUniform4dv = procedure(location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;

    TGLUniformMatrix2dv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLUniformMatrix3dv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLUniformMatrix4dv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLUniformMatrix2x3dv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLUniformMatrix2x4dv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLUniformMatrix3x2dv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLUniformMatrix3x4dv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLUniformMatrix4x2dv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLUniformMatrix4x3dv = procedure(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;

    TGLGetUniformdv = procedure(aProgram: GLuint; location: GLint; params: PGLdouble); cdecl;

    TGLGetSubroutineUniformLocation = function(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLint; cdecl;
    TGLGetSubroutineIndex = function(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLuint; cdecl;

    TGLGetActiveSubroutineUniformiv = procedure(aProgram: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint); cdecl;
    TGLGetActiveSubroutineUniformName = procedure(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); cdecl;
    TGLGetActiveSubroutineName = procedure(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); cdecl;

    TGLUniformSubroutinesuiv = procedure(shadertype: GLenum; Count: GLsizei; const indices: PGLuint); cdecl;
    TGLGetUniformSubroutineuiv = procedure(shadertype: GLenum; location: GLint; params: PGLuint); cdecl;

    TGLGetProgramStageiv = procedure(aProgram: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint); cdecl;

    TGLPatchParameteri = procedure(pname: GLenum; Value: GLint); cdecl;
    TGLPatchParameterfv = procedure(pname: GLenum; const values: PGLfloat); cdecl;

    TGLBindTransformFeedback = procedure(target: GLenum; id: GLuint); cdecl;
    TGLDeleteTransformFeedbacks = procedure(n: GLsizei; const ids: PGLuint); cdecl;
    TGLGenTransformFeedbacks = procedure(n: GLsizei; ids: PGLuint); cdecl;
    TGLIsTransformFeedback = function(id: GLuint): GLboolean; cdecl;
    TGLPauseTransformFeedback = procedure; cdecl;
    TGLResumeTransformFeedback = procedure; cdecl;
    TGLDrawTransformFeedback = procedure(mode: GLenum; id: GLuint); cdecl;
    TGLDrawTransformFeedbackStream = procedure(mode: GLenum; id: GLuint; stream: GLuint); cdecl;

    TGLBeginQueryIndexed = procedure(target: GLenum; index: GLuint; id: GLuint); cdecl;
    TGLEndQueryIndexed = procedure(target: GLenum; index: GLuint); cdecl;
    TGLGetQueryIndexediv = procedure(target: GLenum; index: GLuint; pname: GLenum; params: PGLint); cdecl;

  protected
    FGLMinSampleShading: TGLMinSampleShading;

    FGLBlendEquationi: TGLBlendEquationi;
    FGLBlendEquationSeparatei: TGLBlendEquationSeparatei;
    FGLBlendFunci: TGLBlendFunci;
    FGLBlendFuncSeparatei: TGLBlendFuncSeparatei;

    FGLDrawArraysIndirect: TGLDrawArraysIndirect;
    FGLDrawElementsIndirect: TGLDrawElementsIndirect;

    FGLUniform1d: TGLUniform1d;
    FGLUniform2d: TGLUniform2d;
    FGLUniform3d: TGLUniform3d;
    FGLUniform4d: TGLUniform4d;
    FGLUniform1dv: TGLUniform1dv;
    FGLUniform2dv: TGLUniform2dv;
    FGLUniform3dv: TGLUniform3dv;
    FGLUniform4dv: TGLUniform4dv;
    FGLUniformMatrix2dv: TGLUniformMatrix2dv;
    FGLUniformMatrix3dv: TGLUniformMatrix3dv;
    FGLUniformMatrix4dv: TGLUniformMatrix4dv;
    FGLUniformMatrix2x3dv: TGLUniformMatrix2x3dv;
    FGLUniformMatrix2x4dv: TGLUniformMatrix2x4dv;
    FGLUniformMatrix3x2dv: TGLUniformMatrix3x2dv;
    FGLUniformMatrix3x4dv: TGLUniformMatrix3x4dv;
    FGLUniformMatrix4x2dv: TGLUniformMatrix4x2dv;
    FGLUniformMatrix4x3dv: TGLUniformMatrix4x3dv;

    FGLGetUniformdv: TGLGetUniformdv;

    FGLGetSubroutineUniformLocation: TGLGetSubroutineUniformLocation;
    FGLGetSubroutineIndex: TGLGetSubroutineIndex;

    FGLGetActiveSubroutineUniformiv: TGLGetActiveSubroutineUniformiv;
    FGLGetActiveSubroutineUniformName: TGLGetActiveSubroutineUniformName;
    FGLGetActiveSubroutineName: TGLGetActiveSubroutineName;

    FGLUniformSubroutinesuiv: TGLUniformSubroutinesuiv;
    FGLGetUniformSubroutineuiv: TGLGetUniformSubroutineuiv;

    FGLGetProgramStageiv: TGLGetProgramStageiv;

    FGLPatchParameteri: TGLPatchParameteri;
    FGLPatchParameterfv: TGLPatchParameterfv;

    FGLBindTransformFeedback: TGLBindTransformFeedback;
    FGLDeleteTransformFeedbacks: TGLDeleteTransformFeedbacks;
    FGLGenTransformFeedbacks: TGLGenTransformFeedbacks;
    FGLIsTransformFeedback: TGLIsTransformFeedback;
    FGLPauseTransformFeedback: TGLPauseTransformFeedback;
    FGLResumeTransformFeedback: TGLResumeTransformFeedback;
    FGLDrawTransformFeedback: TGLDrawTransformFeedback;
    FGLDrawTransformFeedbackStream: TGLDrawTransformFeedbackStream;

    FGLBeginQueryIndexed: TGLBeginQueryIndexed;
    FGLEndQueryIndexed: TGLEndQueryIndexed;
    FGLGetQueryIndexediv: TGLGetQueryIndexediv;

  protected
    procedure bindEntry; override;
  public
    procedure glMinSampleShading(Value: GLfloat); overload;

    procedure glBlendEquationi(buf: GLuint; mode: GLenum); overload;
    procedure glBlendEquationSeparatei(buf: GLuint; modeRGB, modeAlpha: GLenum); overload;
    procedure glBlendFunci(buf: GLuint; src, dst: GLenum); overload;
    procedure glBlendFuncSeparatei(buf: GLuint; srcRGB, dstRGB, srcAlpha, dstAlpha: GLenum); overload;

    procedure glDrawArraysIndirect(mode: GLenum; const indirect: Pointer); overload;
    procedure glDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer); overload;

    procedure glUniform1d(location: GLint; x: GLdouble); overload;
    procedure glUniform2d(location: GLint; x, y: GLdouble); overload;
    procedure glUniform3d(location: GLint; x, y, z: GLdouble); overload;
    procedure glUniform4d(location: GLint; x, y, z, w: GLdouble); overload;

    procedure glUniform1dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniform2dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniform3dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glUniform4dv(location: GLint; Count: GLsizei; const Value: PGLdouble); overload;

    procedure glUniformMatrix2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix2x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix2x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix3x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix3x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix4x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glUniformMatrix4x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;

    procedure glGetUniformdv(aProgram: GLuint; location: GLint; params: PGLdouble); overload;

    function glGetSubroutineUniformLocation(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLint; overload;
    function glGetSubroutineIndex(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLuint; overload;

    procedure glGetActiveSubroutineUniformiv(aProgram: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint); overload;
    procedure glGetActiveSubroutineUniformName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); overload;
    procedure glGetActiveSubroutineName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); overload;

    procedure glUniformSubroutinesuiv(shadertype: GLenum; Count: GLsizei; const indices: PGLuint); overload;
    procedure glGetUniformSubroutineuiv(shadertype: GLenum; location: GLint; params: PGLuint); overload;

    procedure glGetProgramStageiv(aProgram: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint); overload;

    procedure glPatchParameteri(pname: GLenum; Value: GLint); overload;
    procedure glPatchParameterfv(pname: GLenum; const values: PGLfloat); overload;

    procedure glBindTransformFeedback(target: GLenum; id: GLuint); overload;
    procedure glDeleteTransformFeedbacks(n: GLsizei; const ids: PGLuint); overload;
    procedure glGenTransformFeedbacks(n: GLsizei; ids: PGLuint); overload;
    function glIsTransformFeedback(id: GLuint): GLboolean; overload;
    procedure glPauseTransformFeedback; overload;
    procedure glResumeTransformFeedback; overload;
    procedure glDrawTransformFeedback(mode: GLenum; id: GLuint); overload;
    procedure glDrawTransformFeedbackStream(mode: GLenum; id: GLuint; stream: GLuint); overload;

    procedure glBeginQueryIndexed(target: GLenum; index: GLuint; id: GLuint); overload;
    procedure glEndQueryIndexed(target: GLenum; index: GLuint); overload;
    procedure glGetQueryIndexediv(target: GLenum; index: GLuint; pname: GLenum; params: PGLint); overload;
  end;


  TOpenGL_4_1 = class(TOpenGL_4_0, IOpenGL41)
  protected
  type
    TGLReleaseShaderCompiler = procedure; cdecl;
    TGLShaderBinary = procedure(Count: GLsizei; const shaders: PGLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); cdecl;
    TGLGetShaderPrecisionFormat = procedure(shadertype, precisiontype: GLenum; range_, precision: PGLint); cdecl;
    TGLDepthRangef = procedure(n, f: GLfloat); cdecl;
    TGLClearDepthf = procedure(d: GLfloat); cdecl;
    TGLGetProgramBinary = procedure(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer); cdecl;
    TGLProgramBinary = procedure(aProgram: GLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); cdecl;
    TGLProgramParameteri = procedure(aProgram: GLuint; pname: GLenum; Value: GLint); cdecl;
    TGLUseProgramStages = procedure(pipeline: GLuint; stages: GLbitfield; aProgram: GLuint); cdecl;
    TGLActiveShaderProgram = procedure(pipeline, aProgram: GLuint); cdecl;
    TGLCreateShaderProgramv = function(aType: GLenum; Count: GLsizei; const strings: PPGLchar): GLuint; cdecl;
    TGLBindProgramPipeline = procedure(pipeline: GLuint); cdecl;
    TGLDeleteProgramPipelines = procedure(n: GLsizei; const pipelines: PGLuint); cdecl;
    TGLGenProgramPipelines = procedure(n: GLsizei; pipelines: PGLuint); cdecl;
    TGLIsProgramPipeline = function(pipeline: GLuint): GLboolean; cdecl;
    TGLGetProgramPipelineiv = procedure(pipeline: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLValidateProgramPipeline = procedure(pipeline: GLuint); cdecl;
    TGLGetProgramPipelineInfoLog = procedure(pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); cdecl;

    TGLProgramUniform1i = procedure(aProgram: GLuint; location: GLint; v0: GLint); cdecl;
    TGLProgramUniform1iv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    TGLProgramUniform1f = procedure(aProgram: GLuint; location: GLint; v0: GLfloat); cdecl;
    TGLProgramUniform1fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    TGLProgramUniform1d = procedure(aProgram: GLuint; location: GLint; v0: GLdouble); cdecl;
    TGLProgramUniform1dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    TGLProgramUniform1ui = procedure(aProgram: GLuint; location: GLint; v0: GLuint); cdecl;
    TGLProgramUniform1uiv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;

    TGLProgramUniform2i = procedure(aProgram: GLuint; location: GLint; v0, v1: GLint); cdecl;
    TGLProgramUniform2iv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    TGLProgramUniform2f = procedure(aProgram: GLuint; location: GLint; v0, v1: GLfloat); cdecl;
    TGLProgramUniform2fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    TGLProgramUniform2d = procedure(aProgram: GLuint; location: GLint; v0, v1: GLdouble); cdecl;
    TGLProgramUniform2dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    TGLProgramUniform2ui = procedure(aProgram: GLuint; location: GLint; v0, v1: GLuint); cdecl;
    TGLProgramUniform2uiv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;

    TGLProgramUniform3i = procedure(aProgram: GLuint; location: GLint; v0, v1, v2: GLint); cdecl;
    TGLProgramUniform3iv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    TGLProgramUniform3f = procedure(aProgram: GLuint; location: GLint; v0, v1, v2: GLfloat); cdecl;
    TGLProgramUniform3fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    TGLProgramUniform3d = procedure(aProgram: GLuint; location: GLint; v0, v1, v2: GLdouble); cdecl;
    TGLProgramUniform3dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    TGLProgramUniform3ui = procedure(aProgram: GLuint; location: GLint; v0, v1, v2: GLuint); cdecl;
    TGLProgramUniform3uiv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;

    TGLProgramUniform4i = procedure(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLint); cdecl;
    TGLProgramUniform4iv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); cdecl;
    TGLProgramUniform4f = procedure(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLfloat); cdecl;
    TGLProgramUniform4fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); cdecl;
    TGLProgramUniform4d = procedure(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLdouble); cdecl;
    TGLProgramUniform4dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); cdecl;
    TGLProgramUniform4ui = procedure(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLuint); cdecl;
    TGLProgramUniform4uiv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); cdecl;

    TGLProgramUniformMatrix2fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    TGLProgramUniformMatrix3fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    TGLProgramUniformMatrix4fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    TGLProgramUniformMatrix2dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLProgramUniformMatrix3dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLProgramUniformMatrix4dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;

    TGLProgramUniformMatrix2x3fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    TGLProgramUniformMatrix3x2fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    TGLProgramUniformMatrix2x4fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    TGLProgramUniformMatrix4x2fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    TGLProgramUniformMatrix3x4fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;
    TGLProgramUniformMatrix4x3fv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); cdecl;

    TGLProgramUniformMatrix2x3dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLProgramUniformMatrix3x2dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLProgramUniformMatrix2x4dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLProgramUniformMatrix4x2dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLProgramUniformMatrix3x4dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;
    TGLProgramUniformMatrix4x3dv = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); cdecl;

    TGLVertexAttribL1d = procedure(index: GLuint; x: GLdouble); cdecl;
    TGLVertexAttribL2d = procedure(index: GLuint; x, y: GLdouble); cdecl;
    TGLVertexAttribL3d = procedure(index: GLuint; x, y, z: GLdouble); cdecl;
    TGLVertexAttribL4d = procedure(index: GLuint; x, y, z, w: GLdouble); cdecl;
    TGLVertexAttribL1dv = procedure(index: GLuint; const v: PGLdouble); cdecl;
    TGLVertexAttribL2dv = procedure(index: GLuint; const v: PGLdouble); cdecl;
    TGLVertexAttribL3dv = procedure(index: GLuint; const v: PGLdouble); cdecl;
    TGLVertexAttribL4dv = procedure(index: GLuint; const v: PGLdouble); cdecl;
    TGLVertexAttribLPointer = procedure(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const pointer: Pointer); cdecl;
    TGLGetVertexAttribLdv = procedure(index: GLuint; pname: GLenum; params: PGLdouble); cdecl;

    TGLViewportArrayv = procedure(First: GLuint; Count: GLsizei; const v: PGLfloat); cdecl;
    TGLViewportIndexedf = procedure(index: GLuint; x, y, w, h: GLfloat); cdecl;
    TGLViewportIndexedfv = procedure(index: GLuint; const v: PGLfloat); cdecl;
    TGLScissorArrayv = procedure(First: GLuint; Count: GLsizei; const v: PGLint); cdecl;
    TGLScissorIndexed = procedure(index: GLuint; left, bottom: GLint; Width, Height: GLsizei); cdecl;
    TGLScissorIndexedv = procedure(index: GLuint; const v: PGLint); cdecl;
    TGLDepthRangeArrayv = procedure(First: GLuint; Count: GLsizei; const v: PGLdouble); cdecl;
    TGLDepthRangeIndexed = procedure(index: GLuint; n, f: GLdouble); cdecl;
    TGLGetFloati_v = procedure(target: GLenum; index: GLuint; Data: PGLfloat); cdecl;
    TGLGetDoublei_v = procedure(target: GLenum; index: GLuint; Data: PGLdouble); cdecl;

  protected
    FGLReleaseShaderCompiler: TGLReleaseShaderCompiler;
    FGLShaderBinary: TGLShaderBinary;
    FGLGetShaderPrecisionFormat: TGLGetShaderPrecisionFormat;
    FGLDepthRangef: TGLDepthRangef;
    FGLClearDepthf: TGLClearDepthf;
    FGLGetProgramBinary: TGLGetProgramBinary;
    FGLProgramBinary: TGLProgramBinary;
    FGLProgramParameteri: TGLProgramParameteri;
    FGLUseProgramStages: TGLUseProgramStages;
    FGLActiveShaderProgram: TGLActiveShaderProgram;
    FGLCreateShaderProgramv: TGLCreateShaderProgramv;
    FGLBindProgramPipeline: TGLBindProgramPipeline;
    FGLDeleteProgramPipelines: TGLDeleteProgramPipelines;
    FGLGenProgramPipelines: TGLGenProgramPipelines;
    FGLIsProgramPipeline: TGLIsProgramPipeline;
    FGLGetProgramPipelineiv: TGLGetProgramPipelineiv;
    FGLValidateProgramPipeline: TGLValidateProgramPipeline;
    FGLGetProgramPipelineInfoLog: TGLGetProgramPipelineInfoLog;

    FGLProgramUniform1i: TGLProgramUniform1i;
    FGLProgramUniform1iv: TGLProgramUniform1iv;
    FGLProgramUniform1f: TGLProgramUniform1f;
    FGLProgramUniform1fv: TGLProgramUniform1fv;
    FGLProgramUniform1d: TGLProgramUniform1d;
    FGLProgramUniform1dv: TGLProgramUniform1dv;
    FGLProgramUniform1ui: TGLProgramUniform1ui;
    FGLProgramUniform1uiv: TGLProgramUniform1uiv;

    FGLProgramUniform2i: TGLProgramUniform2i;
    FGLProgramUniform2iv: TGLProgramUniform2iv;
    FGLProgramUniform2f: TGLProgramUniform2f;
    FGLProgramUniform2fv: TGLProgramUniform2fv;
    FGLProgramUniform2d: TGLProgramUniform2d;
    FGLProgramUniform2dv: TGLProgramUniform2dv;
    FGLProgramUniform2ui: TGLProgramUniform2ui;
    FGLProgramUniform2uiv: TGLProgramUniform2uiv;

    FGLProgramUniform3i: TGLProgramUniform3i;
    FGLProgramUniform3iv: TGLProgramUniform3iv;
    FGLProgramUniform3f: TGLProgramUniform3f;
    FGLProgramUniform3fv: TGLProgramUniform3fv;
    FGLProgramUniform3d: TGLProgramUniform3d;
    FGLProgramUniform3dv: TGLProgramUniform3dv;
    FGLProgramUniform3ui: TGLProgramUniform3ui;
    FGLProgramUniform3uiv: TGLProgramUniform3uiv;

    FGLProgramUniform4i: TGLProgramUniform4i;
    FGLProgramUniform4iv: TGLProgramUniform4iv;
    FGLProgramUniform4f: TGLProgramUniform4f;
    FGLProgramUniform4fv: TGLProgramUniform4fv;
    FGLProgramUniform4d: TGLProgramUniform4d;
    FGLProgramUniform4dv: TGLProgramUniform4dv;
    FGLProgramUniform4ui: TGLProgramUniform4ui;
    FGLProgramUniform4uiv: TGLProgramUniform4uiv;

    FGLProgramUniformMatrix2fv: TGLProgramUniformMatrix2fv;
    FGLProgramUniformMatrix3fv: TGLProgramUniformMatrix3fv;
    FGLProgramUniformMatrix4fv: TGLProgramUniformMatrix4fv;
    FGLProgramUniformMatrix2dv: TGLProgramUniformMatrix2dv;
    FGLProgramUniformMatrix3dv: TGLProgramUniformMatrix3dv;
    FGLProgramUniformMatrix4dv: TGLProgramUniformMatrix4dv;

    FGLProgramUniformMatrix2x3fv: TGLProgramUniformMatrix2x3fv;
    FGLProgramUniformMatrix3x2fv: TGLProgramUniformMatrix3x2fv;
    FGLProgramUniformMatrix2x4fv: TGLProgramUniformMatrix2x4fv;
    FGLProgramUniformMatrix4x2fv: TGLProgramUniformMatrix4x2fv;
    FGLProgramUniformMatrix3x4fv: TGLProgramUniformMatrix3x4fv;
    FGLProgramUniformMatrix4x3fv: TGLProgramUniformMatrix4x3fv;

    FGLProgramUniformMatrix2x3dv: TGLProgramUniformMatrix2x3dv;
    FGLProgramUniformMatrix3x2dv: TGLProgramUniformMatrix3x2dv;
    FGLProgramUniformMatrix2x4dv: TGLProgramUniformMatrix2x4dv;
    FGLProgramUniformMatrix4x2dv: TGLProgramUniformMatrix4x2dv;
    FGLProgramUniformMatrix3x4dv: TGLProgramUniformMatrix3x4dv;
    FGLProgramUniformMatrix4x3dv: TGLProgramUniformMatrix4x3dv;

    FGLVertexAttribL1d: TGLVertexAttribL1d;
    FGLVertexAttribL2d: TGLVertexAttribL2d;
    FGLVertexAttribL3d: TGLVertexAttribL3d;
    FGLVertexAttribL4d: TGLVertexAttribL4d;
    FGLVertexAttribL1dv: TGLVertexAttribL1dv;
    FGLVertexAttribL2dv: TGLVertexAttribL2dv;
    FGLVertexAttribL3dv: TGLVertexAttribL3dv;
    FGLVertexAttribL4dv: TGLVertexAttribL4dv;
    FGLVertexAttribLPointer: TGLVertexAttribLPointer;
    FGLGetVertexAttribLdv: TGLGetVertexAttribLdv;

    FGLViewportArrayv: TGLViewportArrayv;
    FGLViewportIndexedf: TGLViewportIndexedf;
    FGLViewportIndexedfv: TGLViewportIndexedfv;
    FGLScissorArrayv: TGLScissorArrayv;
    FGLScissorIndexed: TGLScissorIndexed;
    FGLScissorIndexedv: TGLScissorIndexedv;
    FGLDepthRangeArrayv: TGLDepthRangeArrayv;
    FGLDepthRangeIndexed: TGLDepthRangeIndexed;
    FGLGetFloati_v: TGLGetFloati_v;
    FGLGetDoublei_v: TGLGetDoublei_v;
  protected
    procedure bindEntry; override;
  public
    procedure glReleaseShaderCompiler; overload;
    procedure glShaderBinary(Count: GLsizei; const shaders: PGLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); overload;
    procedure glGetShaderPrecisionFormat(shadertype, precisiontype: GLenum; range_, precision: PGLint); overload;

    procedure glDepthRangef(n, f: GLfloat); overload;
    procedure glClearDepthf(d: GLfloat); overload;

    procedure glGetProgramBinary(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer); overload;
    procedure glProgramBinary(aProgram: GLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei); overload;
    procedure glProgramParameteri(aProgram: GLuint; pname: GLenum; Value: GLint); overload;

    procedure glUseProgramStages(pipeline: GLuint; stages: GLbitfield; aProgram: GLuint); overload;
    procedure glActiveShaderProgram(pipeline, aProgram: GLuint); overload;
    function glCreateShaderProgramv(aType: GLenum; Count: GLsizei; const strings: PPGLchar): GLuint;

    procedure glBindProgramPipeline(pipeline: GLuint); overload;
    procedure glDeleteProgramPipelines(n: GLsizei; const pipelines: PGLuint); overload;
    procedure glGenProgramPipelines(n: GLsizei; pipelines: PGLuint); overload;
    function glIsProgramPipeline(pipeline: GLuint): GLboolean;
    procedure glGetProgramPipelineiv(pipeline: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glValidateProgramPipeline(pipeline: GLuint); overload;
    procedure glGetProgramPipelineInfoLog(pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); overload;

    // ProgramUniform* (Separate Shader Objects)
    procedure glProgramUniform1i(aProgram: GLuint; location: GLint; v0: GLint); overload;
    procedure glProgramUniform1iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform1f(aProgram: GLuint; location: GLint; v0: GLfloat); overload;
    procedure glProgramUniform1fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform1d(aProgram: GLuint; location: GLint; v0: GLdouble); overload;
    procedure glProgramUniform1dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform1ui(aProgram: GLuint; location: GLint; v0: GLuint); overload;
    procedure glProgramUniform1uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glProgramUniform2i(aProgram: GLuint; location: GLint; v0, v1: GLint); overload;
    procedure glProgramUniform2iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform2f(aProgram: GLuint; location: GLint; v0, v1: GLfloat); overload;
    procedure glProgramUniform2fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform2d(aProgram: GLuint; location: GLint; v0, v1: GLdouble); overload;
    procedure glProgramUniform2dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform2ui(aProgram: GLuint; location: GLint; v0, v1: GLuint); overload;
    procedure glProgramUniform2uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glProgramUniform3i(aProgram: GLuint; location: GLint; v0, v1, v2: GLint); overload;
    procedure glProgramUniform3iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform3f(aProgram: GLuint; location: GLint; v0, v1, v2: GLfloat); overload;
    procedure glProgramUniform3fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform3d(aProgram: GLuint; location: GLint; v0, v1, v2: GLdouble); overload;
    procedure glProgramUniform3dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform3ui(aProgram: GLuint; location: GLint; v0, v1, v2: GLuint); overload;
    procedure glProgramUniform3uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glProgramUniform4i(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLint); overload;
    procedure glProgramUniform4iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint); overload;
    procedure glProgramUniform4f(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLfloat); overload;
    procedure glProgramUniform4fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat); overload;
    procedure glProgramUniform4d(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLdouble); overload;
    procedure glProgramUniform4dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble); overload;
    procedure glProgramUniform4ui(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLuint); overload;
    procedure glProgramUniform4uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint); overload;

    procedure glProgramUniformMatrix2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;

    procedure glProgramUniformMatrix2x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix3x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix2x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix4x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix3x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;
    procedure glProgramUniformMatrix4x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat); overload;

    procedure glProgramUniformMatrix2x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix3x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix2x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix4x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix3x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;
    procedure glProgramUniformMatrix4x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble); overload;

    // Double-precision vertex attributes
    procedure glVertexAttribL1d(index: GLuint; x: GLdouble); overload;
    procedure glVertexAttribL2d(index: GLuint; x, y: GLdouble); overload;
    procedure glVertexAttribL3d(index: GLuint; x, y, z: GLdouble); overload;
    procedure glVertexAttribL4d(index: GLuint; x, y, z, w: GLdouble); overload;
    procedure glVertexAttribL1dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribL2dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribL3dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribL4dv(index: GLuint; const v: PGLdouble); overload;
    procedure glVertexAttribLPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const pointer: Pointer); overload;
    procedure glGetVertexAttribLdv(index: GLuint; pname: GLenum; params: PGLdouble); overload;

    // Viewport / Scissor / DepthRange arrays
    procedure glViewportArrayv(First: GLuint; Count: GLsizei; const v: PGLfloat); overload;
    procedure glViewportIndexedf(index: GLuint; x, y, w, h: GLfloat); overload;
    procedure glViewportIndexedfv(index: GLuint; const v: PGLfloat); overload;

    procedure glScissorArrayv(First: GLuint; Count: GLsizei; const v: PGLint); overload;
    procedure glScissorIndexed(index: GLuint; left, bottom: GLint; Width, Height: GLsizei); overload;
    procedure glScissorIndexedv(index: GLuint; const v: PGLint); overload;

    procedure glDepthRangeArrayv(First: GLuint; Count: GLsizei; const v: PGLdouble); overload;
    procedure glDepthRangeIndexed(index: GLuint; n, f: GLdouble); overload;

    procedure glGetFloati_v(target: GLenum; index: GLuint; Data: PGLfloat); overload;
    procedure glGetDoublei_v(target: GLenum; index: GLuint; Data: PGLdouble); overload;
  end;

  { TOpenGL_4_2 }

  TOpenGL_4_2 = class(TOpenGL_4_1, IOpenGL42)
  protected
  type
    TGLDrawArraysInstancedBaseInstance = procedure(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei; baseinstance: GLuint); cdecl;
    TGLDrawElementsInstancedBaseInstance = procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; baseinstance: GLuint); cdecl;
    TGLDrawElementsInstancedBaseVertexBaseInstance = procedure(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint); cdecl;
    TGLGetInternalformativ = procedure(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint); cdecl;
    TGLGetActiveAtomicCounterBufferiv = procedure(aProgram: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLBindImageTexture = procedure(unit_: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum); cdecl;
    TGLMemoryBarrier = procedure(barriers: GLbitfield); cdecl;
    TGLTexStorage1D = procedure(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei); cdecl;
    TGLTexStorage2D = procedure(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); cdecl;
    TGLTexStorage3D = procedure(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei); cdecl;
    TGLDrawTransformFeedbackInstanced = procedure(mode: GLenum; id: GLuint; instancecount: GLsizei); cdecl;
    TGLDrawTransformFeedbackStreamInstanced = procedure(mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei); cdecl;
  protected
    FGLDrawArraysInstancedBaseInstance: TGLDrawArraysInstancedBaseInstance;
    FGLDrawElementsInstancedBaseInstance: TGLDrawElementsInstancedBaseInstance;
    FGLDrawElementsInstancedBaseVertexBaseInstance: TGLDrawElementsInstancedBaseVertexBaseInstance;
    FGLGetInternalformativ: TGLGetInternalformativ;
    FGLGetActiveAtomicCounterBufferiv: TGLGetActiveAtomicCounterBufferiv;
    FGLBindImageTexture: TGLBindImageTexture;
    FGLMemoryBarrier: TGLMemoryBarrier;
    FGLTexStorage1D: TGLTexStorage1D;
    FGLTexStorage2D: TGLTexStorage2D;
    FGLTexStorage3D: TGLTexStorage3D;
    FGLDrawTransformFeedbackInstanced: TGLDrawTransformFeedbackInstanced;
    FGLDrawTransformFeedbackStreamInstanced: TGLDrawTransformFeedbackStreamInstanced;
  protected
    procedure bindEntry; override;
  public
    procedure glDrawArraysInstancedBaseInstance(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei; baseinstance: GLuint); overload;
    procedure glDrawElementsInstancedBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; baseinstance: GLuint); overload;
    procedure glDrawElementsInstancedBaseVertexBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint); overload;
    procedure glGetInternalformativ(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint); overload;
    procedure glGetActiveAtomicCounterBufferiv(aProgram: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glBindImageTexture(aUnit: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum); overload;
    procedure glMemoryBarrier(barriers: GLbitfield); overload;
    procedure glTexStorage1D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei); overload;
    procedure glTexStorage2D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); overload;
    procedure glTexStorage3D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei); overload;
    procedure glDrawTransformFeedbackInstanced(mode: GLenum; id: GLuint; instancecount: GLsizei); overload;
    procedure glDrawTransformFeedbackStreamInstanced(mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei); overload;
  end;

  TOpenGL_4_3 = class(TOpenGL_4_2, IOpenGL43)
  protected
  type
    TGLClearBufferData = procedure(target: GLenum; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;
    TGLClearBufferSubData = procedure(target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;
    TGLDispatchCompute = procedure(num_groups_x, num_groups_y, num_groups_z: GLuint); cdecl;
    TGLDispatchComputeIndirect = procedure(indirect: GLintptr); cdecl;
    TGLCopyImageSubData = procedure(srcName: GLuint; srcTarget: GLenum; srcLevel, srcX, srcY, srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel, dstX, dstY, dstZ: GLint; srcWidth, srcHeight, srcDepth: GLsizei); cdecl;
    TGLFramebufferParameteri = procedure(target: GLenum; pname: GLenum; param: GLint); cdecl;
    TGLGetFramebufferParameteriv = procedure(target: GLenum; pname: GLenum; params: PGLint); cdecl;
    TGLGetInternalformati64v = procedure(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint64); cdecl;
    TGLInvalidateTexSubImage = procedure(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei); cdecl;
    TGLInvalidateTexImage = procedure(texture: GLuint; level: GLint); cdecl;
    TGLInvalidateBufferSubData = procedure(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); cdecl;
    TGLInvalidateBufferData = procedure(buffer: GLuint); cdecl;
    TGLInvalidateFramebuffer = procedure(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum); cdecl;
    TGLInvalidateSubFramebuffer = procedure(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum; x, y: GLint; Width, Height: GLsizei); cdecl;
    TGLMultiDrawArraysIndirect = procedure(mode: GLenum; const indirect: Pointer; drawcount, stride: GLsizei); cdecl;
    TGLMultiDrawElementsIndirect = procedure(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount, stride: GLsizei); cdecl;
    TGLGetProgramInterfaceiv = procedure(aProgram: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint); cdecl;
    TGLGetProgramResourceIndex = function(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLuint; cdecl;
    TGLGetProgramResourceName = procedure(aProgram: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); cdecl;
    TGLGetProgramResourceiv = procedure(aProgram: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; const props: PGLenum; Count: GLsizei; length: PGLsizei; params: PGLint); cdecl;
    TGLGetProgramResourceLocation = function(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; cdecl;
    TGLGetProgramResourceLocationIndex = function(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; cdecl;
    TGLShaderStorageBlockBinding = procedure(aProgram: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint); cdecl;
    TGLTexBufferRange = procedure(target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); cdecl;
    TGLTexStorage2DMultisample = procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    TGLTexStorage3DMultisample = procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    TGLTextureView = procedure(texture, target: GLuint; origtexture: GLuint; internalformat: GLenum; minlevel, numlevels, minlayer, numlayers: GLuint); cdecl;
    TGLBindVertexBuffer = procedure(bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); cdecl;
    TGLVertexAttribFormat = procedure(attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); cdecl;
    TGLVertexAttribIFormat = procedure(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); cdecl;
    TGLVertexAttribLFormat = procedure(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); cdecl;
    TGLVertexAttribBinding = procedure(attribindex, bindingindex: GLuint); cdecl;
    TGLVertexBindingDivisor = procedure(bindingindex: GLuint; divisor: GLuint); cdecl;
    TGLDebugMessageControl = procedure(Source, aType, severity: GLenum; Count: GLsizei; const ids: PGLuint; Enabled: GLboolean); cdecl;
    TGLDebugMessageInsert = procedure(Source, aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const buf: PGLchar); cdecl;
    TGLDebugMessageCallback = procedure(callback: GLDEBUGPROC; const userParam: Pointer); cdecl;
    TGLGetDebugMessageLog = function(Count: GLuint; bufSize: GLsizei; sources, types: PGLenum; ids, severities: PGLuint; lengths: PGLsizei; messageLog: PGLchar): GLuint; cdecl;
    TGLPushDebugGroup = procedure(Source: GLenum; id: GLuint; length: GLsizei; const message: PGLchar); cdecl;
    TGLPopDebugGroup = procedure; cdecl;
    TGLObjectLabel = procedure(identifier: GLenum; Name: GLuint; length: GLsizei; const aLabel: PGLchar); cdecl;
    TGLGetObjectLabel = procedure(identifier: GLenum; Name: GLuint; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); cdecl;
    TGLObjectPtrLabel = procedure(const ptr: Pointer; length: GLsizei; const aLabel: PGLchar); cdecl;
    TGLGetObjectPtrLabel = procedure(const ptr: Pointer; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); cdecl;
  protected
    FGLClearBufferData: TGLClearBufferData;
    FGLClearBufferSubData: TGLClearBufferSubData;
    FGLDispatchCompute: TGLDispatchCompute;
    FGLDispatchComputeIndirect: TGLDispatchComputeIndirect;
    FGLCopyImageSubData: TGLCopyImageSubData;
    FGLFramebufferParameteri: TGLFramebufferParameteri;
    FGLGetFramebufferParameteriv: TGLGetFramebufferParameteriv;
    FGLGetInternalformati64v: TGLGetInternalformati64v;
    FGLInvalidateTexSubImage: TGLInvalidateTexSubImage;
    FGLInvalidateTexImage: TGLInvalidateTexImage;
    FGLInvalidateBufferSubData: TGLInvalidateBufferSubData;
    FGLInvalidateBufferData: TGLInvalidateBufferData;
    FGLInvalidateFramebuffer: TGLInvalidateFramebuffer;
    FGLInvalidateSubFramebuffer: TGLInvalidateSubFramebuffer;
    FGLMultiDrawArraysIndirect: TGLMultiDrawArraysIndirect;
    FGLMultiDrawElementsIndirect: TGLMultiDrawElementsIndirect;
    FGLGetProgramInterfaceiv: TGLGetProgramInterfaceiv;
    FGLGetProgramResourceIndex: TGLGetProgramResourceIndex;
    FGLGetProgramResourceName: TGLGetProgramResourceName;
    FGLGetProgramResourceiv: TGLGetProgramResourceiv;
    FGLGetProgramResourceLocation: TGLGetProgramResourceLocation;
    FGLGetProgramResourceLocationIndex: TGLGetProgramResourceLocationIndex;
    FGLShaderStorageBlockBinding: TGLShaderStorageBlockBinding;
    FGLTexBufferRange: TGLTexBufferRange;
    FGLTexStorage2DMultisample: TGLTexStorage2DMultisample;
    FGLTexStorage3DMultisample: TGLTexStorage3DMultisample;
    FGLTextureView: TGLTextureView;
    FGLBindVertexBuffer: TGLBindVertexBuffer;
    FGLVertexAttribFormat: TGLVertexAttribFormat;
    FGLVertexAttribIFormat: TGLVertexAttribIFormat;
    FGLVertexAttribLFormat: TGLVertexAttribLFormat;
    FGLVertexAttribBinding: TGLVertexAttribBinding;
    FGLVertexBindingDivisor: TGLVertexBindingDivisor;
    FGLDebugMessageControl: TGLDebugMessageControl;
    FGLDebugMessageInsert: TGLDebugMessageInsert;
    FGLDebugMessageCallback: TGLDebugMessageCallback;
    FGLGetDebugMessageLog: TGLGetDebugMessageLog;
    FGLPushDebugGroup: TGLPushDebugGroup;
    FGLPopDebugGroup: TGLPopDebugGroup;
    FGLObjectLabel: TGLObjectLabel;
    FGLGetObjectLabel: TGLGetObjectLabel;
    FGLObjectPtrLabel: TGLObjectPtrLabel;
    FGLGetObjectPtrLabel: TGLGetObjectPtrLabel;
  protected
    procedure bindEntry; override;
  public
    procedure glClearBufferData(target: GLenum; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glClearBufferSubData(target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer); overload;

    procedure glDispatchCompute(num_groups_x, num_groups_y, num_groups_z: GLuint); overload;
    procedure glDispatchComputeIndirect(indirect: GLintptr); overload;

    procedure glCopyImageSubData(srcName: GLuint; srcTarget: GLenum; srcLevel, srcX, srcY, srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel, dstX, dstY, dstZ: GLint; srcWidth, srcHeight, srcDepth: GLsizei); overload;

    procedure glFramebufferParameteri(target: GLenum; pname: GLenum; param: GLint); overload;
    procedure glGetFramebufferParameteriv(target: GLenum; pname: GLenum; params: PGLint); overload;

    procedure glGetInternalformati64v(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint64); overload;

    procedure glInvalidateTexSubImage(texture: GLuint; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei); overload;
    procedure glInvalidateTexImage(texture: GLuint; level: GLint); overload;
    procedure glInvalidateBufferSubData(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); overload;
    procedure glInvalidateBufferData(buffer: GLuint); overload;
    procedure glInvalidateFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum); overload;
    procedure glInvalidateSubFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum; x, y: GLint; Width, Height: GLsizei); overload;

    procedure glMultiDrawArraysIndirect(mode: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei); overload;
    procedure glMultiDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei); overload;

    procedure glGetProgramInterfaceiv(aProgram: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint); overload;
    function glGetProgramResourceIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLuint; overload;
    procedure glGetProgramResourceName(aProgram: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); overload;
    procedure glGetProgramResourceiv(aProgram: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; const props: PGLenum; Count: GLsizei; length: PGLsizei; params: PGLint); overload;
    function glGetProgramResourceLocation(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; overload;
    function glGetProgramResourceLocationIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint; overload;

    procedure glShaderStorageBlockBinding(aProgram: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint); overload;

    procedure glTexBufferRange(target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;

    procedure glTexStorage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTexStorage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean); overload;

    procedure glTextureView(texture, target: GLuint; origtexture: GLuint; internalformat: GLenum; minlevel, numlevels, minlayer, numlayers: GLuint); overload;

    procedure glBindVertexBuffer(bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); overload;
    procedure glVertexAttribFormat(attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); overload;
    procedure glVertexAttribIFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexAttribLFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexAttribBinding(attribindex, bindingindex: GLuint); overload;
    procedure glVertexBindingDivisor(bindingindex: GLuint; divisor: GLuint); overload;

    // Debug
    procedure glDebugMessageControl(Source, aType, severity: GLenum; Count: GLsizei; const ids: PGLuint; Enabled: GLboolean); overload;
    procedure glDebugMessageInsert(Source, aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const buf: PGLchar); overload;
    procedure glDebugMessageCallback(callback: GLDEBUGPROC; const userParam: Pointer); overload;
    function glGetDebugMessageLog(Count: GLuint; bufSize: GLsizei; sources, types: PGLenum; ids, severities: PGLuint; lengths: PGLsizei; messageLog: PGLchar): GLuint; overload;
    procedure glPushDebugGroup(Source: GLenum; id: GLuint; length: GLsizei; const message: PGLchar); overload;
    procedure glPopDebugGroup; overload;
    procedure glObjectLabel(identifier: GLenum; Name: GLuint; length: GLsizei; const aLabel: PGLchar); overload;
    procedure glGetObjectLabel(identifier: GLenum; Name: GLuint; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); overload;
    procedure glObjectPtrLabel(const ptr: Pointer; length: GLsizei; const aLabel: PGLchar); overload;
    procedure glGetObjectPtrLabel(const ptr: Pointer; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar); overload;
  end;

  TOpenGL_4_4 = class(TOpenGL_4_3, IOpenGL44)
  protected
  type
    TGLBufferStorage = procedure(target: GLenum; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); cdecl;
    TGLClearTexImage = procedure(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;
    TGLClearTexSubImage = procedure(texture: GLuint; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; aType: GLenum; const Data: Pointer); cdecl;

    TGLBindBuffersBase = procedure(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint); cdecl;
    TGLBindBuffersRange = procedure(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const sizes: PGLsizeiptr); cdecl;

    TGLBindTextures = procedure(First: GLuint; Count: GLsizei; const textures: PGLuint); cdecl;
    TGLBindSamplers = procedure(First: GLuint; Count: GLsizei; const samplers: PGLuint); cdecl;
    TGLBindImageTextures = procedure(First: GLuint; Count: GLsizei; const textures: PGLuint); cdecl;

    TGLBindVertexBuffers = procedure(First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); cdecl;

  var
    FGLBufferStorage: TGLBufferStorage;
    FGLClearTexImage: TGLClearTexImage;
    FGLClearTexSubImage: TGLClearTexSubImage;

    FGLBindBuffersBase: TGLBindBuffersBase;
    FGLBindBuffersRange: TGLBindBuffersRange;

    FGLBindTextures: TGLBindTextures;
    FGLBindSamplers: TGLBindSamplers;
    FGLBindImageTextures: TGLBindImageTextures;

    FGLBindVertexBuffers: TGLBindVertexBuffers;
  protected
    procedure bindEntry; override;
  public
    procedure glBufferStorage(target: GLenum; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); overload;
    procedure glClearTexImage(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glClearTexSubImage(texture: GLuint; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; aType: GLenum; const Data: Pointer); overload;
    procedure glBindBuffersBase(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint); overload;
    procedure glBindBuffersRange(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const sizes: PGLsizeiptr); overload;
    procedure glBindTextures(First: GLuint; Count: GLsizei; const textures: PGLuint); overload;
    procedure glBindSamplers(First: GLuint; Count: GLsizei; const samplers: PGLuint); overload;
    procedure glBindImageTextures(First: GLuint; Count: GLsizei; const textures: PGLuint); overload;
    procedure glBindVertexBuffers(First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); overload;

  end;

  TOpenGL_4_5 = class(TOpenGL_4_4, IOpenGL45)
  protected
  type
    TGLClipControl = procedure(origin: GLenum; depth: GLenum); cdecl;
    TGLCreateTransformFeedbacks = procedure(n: GLsizei; ids: PGLuint); cdecl;
    TGLTransformFeedbackBufferBase = procedure(xfb: GLuint; index: GLuint; buffer: GLuint); cdecl;
    TGLTransformFeedbackBufferRange = procedure(xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); cdecl;
    TGLGetTransformFeedbackiv = procedure(xfb: GLuint; pname: GLenum; param: PGLint); cdecl;
    TGLGetTransformFeedbacki_v = procedure(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint); cdecl;
    TGLGetTransformFeedbacki64_v = procedure(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64); cdecl;

    TGLCreateBuffers = procedure(n: GLsizei; buffers: PGLuint); cdecl;
    TGLNamedBufferStorage = procedure(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); cdecl;
    TGLNamedBufferData = procedure(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; usage: GLenum); cdecl;
    TGLNamedBufferSubData = procedure(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; const Data: Pointer); cdecl;
    TGLCopyNamedBufferSubData = procedure(readBuffer, writeBuffer: GLuint; readOffset, writeOffset: GLintptr; size: GLsizeiptr); cdecl;
    TGLClearNamedBufferData = procedure(buffer: GLuint; internalformat, format, aType: GLenum; const Data: Pointer); cdecl;
    TGLClearNamedBufferSubData = procedure(buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format, aType: GLenum; const Data: Pointer); cdecl;
    TGLMapNamedBuffer = function(buffer: GLuint; access: GLenum): Pointer; cdecl;
    TGLMapNamedBufferRange = function(buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer; cdecl;
    TGLUnmapNamedBuffer = function(buffer: GLuint): GLboolean; cdecl;
    TGLFlushMappedNamedBufferRange = procedure(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); cdecl;
    TGLGetNamedBufferParameteriv = procedure(buffer: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetNamedBufferParameteri64v = procedure(buffer: GLuint; pname: GLenum; params: PGLint64); cdecl;
    TGLGetNamedBufferPointerv = procedure(buffer: GLuint; pname: GLenum; params: PPointer); cdecl;
    TGLGetNamedBufferSubData = procedure(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer); cdecl;

    TGLCreateFramebuffers = procedure(n: GLsizei; framebuffers: PGLuint); cdecl;
    TGLNamedFramebufferRenderbuffer = procedure(framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); cdecl;
    TGLNamedFramebufferParameteri = procedure(framebuffer: GLuint; pname: GLenum; param: GLint); cdecl;
    TGLNamedFramebufferTexture = procedure(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint); cdecl;
    TGLNamedFramebufferTextureLayer = procedure(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level, layer: GLint); cdecl;
    TGLNamedFramebufferDrawBuffer = procedure(framebuffer: GLuint; buf: GLenum); cdecl;
    TGLNamedFramebufferDrawBuffers = procedure(framebuffer: GLuint; n: GLsizei; const bufs: PGLenum); cdecl;
    TGLNamedFramebufferReadBuffer = procedure(framebuffer: GLuint; src: GLenum); cdecl;
    TGLInvalidateNamedFramebufferData = procedure(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum); cdecl;
    TGLInvalidateNamedFramebufferSubData = procedure(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum; x, y: GLint; Width, Height: GLsizei); cdecl;
    TGLClearNamedFramebufferiv = procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLint); cdecl;
    TGLClearNamedFramebufferuiv = procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLuint); cdecl;
    TGLClearNamedFramebufferfv = procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat); cdecl;
    TGLClearNamedFramebufferfi = procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); cdecl;
    TGLBlitNamedFramebuffer = procedure(readFramebuffer, drawFramebuffer: GLuint; srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1: GLint; mask: GLbitfield; filter: GLenum); cdecl;
    TGLCheckNamedFramebufferStatus = function(framebuffer: GLuint; target: GLenum): GLenum; cdecl;
    TGLGetNamedFramebufferParameteriv = procedure(framebuffer: GLuint; pname: GLenum; param: PGLint); cdecl;
    TGLGetNamedFramebufferAttachmentParameteriv = procedure(framebuffer: GLuint; attachment, pname: GLenum; params: PGLint); cdecl;

    TGLCreateRenderbuffers = procedure(n: GLsizei; renderbuffers: PGLuint); cdecl;
    TGLNamedRenderbufferStorage = procedure(renderbuffer: GLuint; internalformat: GLenum; Width, Height: GLsizei); cdecl;
    TGLNamedRenderbufferStorageMultisample = procedure(renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei); cdecl;
    TGLGetNamedRenderbufferParameteriv = procedure(renderbuffer: GLuint; pname: GLenum; params: PGLint); cdecl;

    TGLCreateTextures = procedure(target: GLenum; n: GLsizei; textures: PGLuint); cdecl;
    TGLTextureBuffer = procedure(texture: GLuint; internalformat: GLenum; buffer: GLuint); cdecl;
    TGLTextureBufferRange = procedure(texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); cdecl;
    TGLTextureStorage1D = procedure(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei); cdecl;
    TGLTextureStorage2D = procedure(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width, Height: GLsizei); cdecl;
    TGLTextureStorage3D = procedure(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei); cdecl;
    TGLTextureStorage2DMultisample = procedure(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    TGLTextureStorage3DMultisample = procedure(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean); cdecl;
    TGLTextureSubImage1D = procedure(texture: GLuint; level, xoffset: GLint; Width: GLsizei; format, aType: GLenum; const pixels: Pointer); cdecl;
    TGLTextureSubImage2D = procedure(texture: GLuint; level, xoffset, yoffset: GLint; Width, Height: GLsizei; format, aType: GLenum; const pixels: Pointer); cdecl;
    TGLTextureSubImage3D = procedure(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, aType: GLenum; const pixels: Pointer); cdecl;
    TGLCompressedTextureSubImage1D = procedure(texture: GLuint; level, xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); cdecl;
    TGLCompressedTextureSubImage2D = procedure(texture: GLuint; level, xoffset, yoffset: GLint; Width, Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); cdecl;
    TGLCompressedTextureSubImage3D = procedure(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); cdecl;
    TGLCopyTextureSubImage1D = procedure(texture: GLuint; level, xoffset, x, y: GLint; Width: GLsizei); cdecl;
    TGLCopyTextureSubImage2D = procedure(texture: GLuint; level, xoffset, yoffset, x, y: GLint; Width, Height: GLsizei); cdecl;
    TGLCopyTextureSubImage3D = procedure(texture: GLuint; level, xoffset, yoffset, zoffset, x, y: GLint; Width, Height: GLsizei); cdecl;
    TGLTextureParameterf = procedure(texture: GLuint; pname: GLenum; param: GLfloat); cdecl;
    TGLTextureParameterfv = procedure(texture: GLuint; pname: GLenum; const param: PGLfloat); cdecl;
    TGLTextureParameteri = procedure(texture: GLuint; pname: GLenum; param: GLint); cdecl;
    TGLTextureParameterIiv = procedure(texture: GLuint; pname: GLenum; const params: PGLint); cdecl;
    TGLTextureParameterIuiv = procedure(texture: GLuint; pname: GLenum; const params: PGLuint); cdecl;
    TGLTextureParameteriv = procedure(texture: GLuint; pname: GLenum; const param: PGLint); cdecl;
    TGLGenerateTextureMipmap = procedure(texture: GLuint); cdecl;
    TGLBindTextureUnit = procedure(unit_: GLuint; texture: GLuint); cdecl;
    TGLGetTextureImage = procedure(texture: GLuint; level: GLint; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer); cdecl;
    TGLGetCompressedTextureImage = procedure(texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer); cdecl;
    TGLGetTextureLevelParameterfv = procedure(texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat); cdecl;
    TGLGetTextureLevelParameteriv = procedure(texture: GLuint; level: GLint; pname: GLenum; params: PGLint); cdecl;
    TGLGetTextureParameterfv = procedure(texture: GLuint; pname: GLenum; params: PGLfloat); cdecl;
    TGLGetTextureParameterIiv = procedure(texture: GLuint; pname: GLenum; params: PGLint); cdecl;
    TGLGetTextureParameterIuiv = procedure(texture: GLuint; pname: GLenum; params: PGLuint); cdecl;
    TGLGetTextureParameteriv = procedure(texture: GLuint; pname: GLenum; params: PGLint); cdecl;

    TGLCreateVertexArrays = procedure(n: GLsizei; arrays: PGLuint); cdecl;
    TGLDisableVertexArrayAttrib = procedure(vaobj: GLuint; index: GLuint); cdecl;
    TGLEnableVertexArrayAttrib = procedure(vaobj: GLuint; index: GLuint); cdecl;
    TGLVertexArrayElementBuffer = procedure(vaobj: GLuint; buffer: GLuint); cdecl;
    TGLVertexArrayVertexBuffer = procedure(vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); cdecl;
    TGLVertexArrayVertexBuffers = procedure(vaobj: GLuint; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); cdecl;
    TGLVertexArrayAttribBinding = procedure(vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint); cdecl;
    TGLVertexArrayAttribFormat = procedure(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); cdecl;
    TGLVertexArrayAttribIFormat = procedure(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); cdecl;
    TGLVertexArrayAttribLFormat = procedure(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); cdecl;
    TGLVertexArrayBindingDivisor = procedure(vaobj: GLuint; bindingindex: GLuint; divisor: GLuint); cdecl;
    TGLGetVertexArrayiv = procedure(vaobj: GLuint; pname: GLenum; param: PGLint); cdecl;
    TGLGetVertexArrayIndexediv = procedure(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint); cdecl;
    TGLGetVertexArrayIndexed64iv = procedure(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64); cdecl;

    TGLCreateSamplers = procedure(n: GLsizei; samplers: PGLuint); cdecl;
    TGLCreateProgramPipelines = procedure(n: GLsizei; pipelines: PGLuint); cdecl;
    TGLCreateQueries = procedure(target: GLenum; n: GLsizei; ids: PGLuint); cdecl;

    TGLGetQueryBufferObjecti64v = procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); cdecl;
    TGLGetQueryBufferObjectiv = procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); cdecl;
    TGLGetQueryBufferObjectui64v = procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); cdecl;
    TGLGetQueryBufferObjectuiv = procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); cdecl;

    TGLMemoryBarrierByRegion = procedure(barriers: GLbitfield); cdecl;

    TGLGetTextureSubImage = procedure(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer); cdecl;
    TGLGetCompressedTextureSubImage = procedure(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; bufSize: GLsizei; pixels: Pointer); cdecl;

    TGLGetGraphicsResetStatus = function: GLenum; cdecl;
    TGLGetnCompressedTexImage = procedure(target: GLenum; lod: GLint; bufSize: GLsizei; pixels: Pointer); cdecl;
    TGLGetnTexImage = procedure(target: GLenum; level: GLint; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer); cdecl;
    TGLGetnUniformdv = procedure(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble); cdecl;
    TGLGetnUniformfv = procedure(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); cdecl;
    TGLGetnUniformiv = procedure(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); cdecl;
    TGLGetnUniformuiv = procedure(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); cdecl;
    TGLReadnPixels = procedure(x, y: GLint; Width, Height: GLsizei; format, aType: GLenum; bufSize: GLsizei; Data: Pointer); cdecl;

    TGLTextureBarrier = procedure; cdecl;
  protected
    FGLClipControl: TGLClipControl;
    FGLCreateTransformFeedbacks: TGLCreateTransformFeedbacks;
    FGLTransformFeedbackBufferBase: TGLTransformFeedbackBufferBase;
    FGLTransformFeedbackBufferRange: TGLTransformFeedbackBufferRange;
    FGLGetTransformFeedbackiv: TGLGetTransformFeedbackiv;
    FGLGetTransformFeedbacki_v: TGLGetTransformFeedbacki_v;
    FGLGetTransformFeedbacki64_v: TGLGetTransformFeedbacki64_v;

    FGLCreateBuffers: TGLCreateBuffers;
    FGLNamedBufferStorage: TGLNamedBufferStorage;
    FGLNamedBufferData: TGLNamedBufferData;
    FGLNamedBufferSubData: TGLNamedBufferSubData;
    FGLCopyNamedBufferSubData: TGLCopyNamedBufferSubData;
    FGLClearNamedBufferData: TGLClearNamedBufferData;
    FGLClearNamedBufferSubData: TGLClearNamedBufferSubData;
    FGLMapNamedBuffer: TGLMapNamedBuffer;
    FGLMapNamedBufferRange: TGLMapNamedBufferRange;
    FGLUnmapNamedBuffer: TGLUnmapNamedBuffer;
    FGLFlushMappedNamedBufferRange: TGLFlushMappedNamedBufferRange;
    FGLGetNamedBufferParameteriv: TGLGetNamedBufferParameteriv;
    FGLGetNamedBufferParameteri64v: TGLGetNamedBufferParameteri64v;
    FGLGetNamedBufferPointerv: TGLGetNamedBufferPointerv;
    FGLGetNamedBufferSubData: TGLGetNamedBufferSubData;

    FGLCreateFramebuffers: TGLCreateFramebuffers;
    FGLNamedFramebufferRenderbuffer: TGLNamedFramebufferRenderbuffer;
    FGLNamedFramebufferParameteri: TGLNamedFramebufferParameteri;
    FGLNamedFramebufferTexture: TGLNamedFramebufferTexture;
    FGLNamedFramebufferTextureLayer: TGLNamedFramebufferTextureLayer;
    FGLNamedFramebufferDrawBuffer: TGLNamedFramebufferDrawBuffer;
    FGLNamedFramebufferDrawBuffers: TGLNamedFramebufferDrawBuffers;
    FGLNamedFramebufferReadBuffer: TGLNamedFramebufferReadBuffer;
    FGLInvalidateNamedFramebufferData: TGLInvalidateNamedFramebufferData;
    FGLInvalidateNamedFramebufferSubData: TGLInvalidateNamedFramebufferSubData;
    FGLClearNamedFramebufferiv: TGLClearNamedFramebufferiv;
    FGLClearNamedFramebufferuiv: TGLClearNamedFramebufferuiv;
    FGLClearNamedFramebufferfv: TGLClearNamedFramebufferfv;
    FGLClearNamedFramebufferfi: TGLClearNamedFramebufferfi;
    FGLBlitNamedFramebuffer: TGLBlitNamedFramebuffer;
    FGLCheckNamedFramebufferStatus: TGLCheckNamedFramebufferStatus;
    FGLGetNamedFramebufferParameteriv: TGLGetNamedFramebufferParameteriv;
    FGLGetNamedFramebufferAttachmentParameteriv: TGLGetNamedFramebufferAttachmentParameteriv;

    FGLCreateRenderbuffers: TGLCreateRenderbuffers;
    FGLNamedRenderbufferStorage: TGLNamedRenderbufferStorage;
    FGLNamedRenderbufferStorageMultisample: TGLNamedRenderbufferStorageMultisample;
    FGLGetNamedRenderbufferParameteriv: TGLGetNamedRenderbufferParameteriv;

    FGLCreateTextures: TGLCreateTextures;
    FGLTextureBuffer: TGLTextureBuffer;
    FGLTextureBufferRange: TGLTextureBufferRange;
    FGLTextureStorage1D: TGLTextureStorage1D;
    FGLTextureStorage2D: TGLTextureStorage2D;
    FGLTextureStorage3D: TGLTextureStorage3D;
    FGLTextureStorage2DMultisample: TGLTextureStorage2DMultisample;
    FGLTextureStorage3DMultisample: TGLTextureStorage3DMultisample;
    FGLTextureSubImage1D: TGLTextureSubImage1D;
    FGLTextureSubImage2D: TGLTextureSubImage2D;
    FGLTextureSubImage3D: TGLTextureSubImage3D;
    FGLCompressedTextureSubImage1D: TGLCompressedTextureSubImage1D;
    FGLCompressedTextureSubImage2D: TGLCompressedTextureSubImage2D;
    FGLCompressedTextureSubImage3D: TGLCompressedTextureSubImage3D;
    FGLCopyTextureSubImage1D: TGLCopyTextureSubImage1D;
    FGLCopyTextureSubImage2D: TGLCopyTextureSubImage2D;
    FGLCopyTextureSubImage3D: TGLCopyTextureSubImage3D;
    FGLTextureParameterf: TGLTextureParameterf;
    FGLTextureParameterfv: TGLTextureParameterfv;
    FGLTextureParameteri: TGLTextureParameteri;
    FGLTextureParameterIiv: TGLTextureParameterIiv;
    FGLTextureParameterIuiv: TGLTextureParameterIuiv;
    FGLTextureParameteriv: TGLTextureParameteriv;
    FGLGenerateTextureMipmap: TGLGenerateTextureMipmap;
    FGLBindTextureUnit: TGLBindTextureUnit;
    FGLGetTextureImage: TGLGetTextureImage;
    FGLGetCompressedTextureImage: TGLGetCompressedTextureImage;
    FGLGetTextureLevelParameterfv: TGLGetTextureLevelParameterfv;
    FGLGetTextureLevelParameteriv: TGLGetTextureLevelParameteriv;
    FGLGetTextureParameterfv: TGLGetTextureParameterfv;
    FGLGetTextureParameterIiv: TGLGetTextureParameterIiv;
    FGLGetTextureParameterIuiv: TGLGetTextureParameterIuiv;
    FGLGetTextureParameteriv: TGLGetTextureParameteriv;

    FGLCreateVertexArrays: TGLCreateVertexArrays;
    FGLDisableVertexArrayAttrib: TGLDisableVertexArrayAttrib;
    FGLEnableVertexArrayAttrib: TGLEnableVertexArrayAttrib;
    FGLVertexArrayElementBuffer: TGLVertexArrayElementBuffer;
    FGLVertexArrayVertexBuffer: TGLVertexArrayVertexBuffer;
    FGLVertexArrayVertexBuffers: TGLVertexArrayVertexBuffers;
    FGLVertexArrayAttribBinding: TGLVertexArrayAttribBinding;
    FGLVertexArrayAttribFormat: TGLVertexArrayAttribFormat;
    FGLVertexArrayAttribIFormat: TGLVertexArrayAttribIFormat;
    FGLVertexArrayAttribLFormat: TGLVertexArrayAttribLFormat;
    FGLVertexArrayBindingDivisor: TGLVertexArrayBindingDivisor;
    FGLGetVertexArrayiv: TGLGetVertexArrayiv;
    FGLGetVertexArrayIndexediv: TGLGetVertexArrayIndexediv;
    FGLGetVertexArrayIndexed64iv: TGLGetVertexArrayIndexed64iv;

    FGLCreateSamplers: TGLCreateSamplers;
    FGLCreateProgramPipelines: TGLCreateProgramPipelines;
    FGLCreateQueries: TGLCreateQueries;
    FGLGetQueryBufferObjecti64v: TGLGetQueryBufferObjecti64v;
    FGLGetQueryBufferObjectiv: TGLGetQueryBufferObjectiv;
    FGLGetQueryBufferObjectui64v: TGLGetQueryBufferObjectui64v;
    FGLGetQueryBufferObjectuiv: TGLGetQueryBufferObjectuiv;

    FGLMemoryBarrierByRegion: TGLMemoryBarrierByRegion;

    FGLGetTextureSubImage: TGLGetTextureSubImage;
    FGLGetCompressedTextureSubImage: TGLGetCompressedTextureSubImage;

    FGLGetGraphicsResetStatus: TGLGetGraphicsResetStatus;
    FGLGetnCompressedTexImage: TGLGetnCompressedTexImage;
    FGLGetnTexImage: TGLGetnTexImage;
    FGLGetnUniformdv: TGLGetnUniformdv;
    FGLGetnUniformfv: TGLGetnUniformfv;
    FGLGetnUniformiv: TGLGetnUniformiv;
    FGLGetnUniformuiv: TGLGetnUniformuiv;
    FGLReadnPixels: TGLReadnPixels;

    FGLTextureBarrier: TGLTextureBarrier;
  protected
    procedure bindEntry; override;
  public
    procedure glClipControl(origin: GLenum; depth: GLenum); overload;
    procedure glCreateTransformFeedbacks(n: GLsizei; ids: PGLuint); overload;
    procedure glTransformFeedbackBufferBase(xfb: GLuint; index: GLuint; buffer: GLuint); overload;
    procedure glTransformFeedbackBufferRange(xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glGetTransformFeedbackiv(xfb: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetTransformFeedbacki_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint); overload;
    procedure glGetTransformFeedbacki64_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64); overload;

    procedure glCreateBuffers(n: GLsizei; buffers: PGLuint); overload;
    procedure glNamedBufferStorage(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield); overload;
    procedure glNamedBufferData(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; usage: GLenum); overload;
    procedure glNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; const Data: Pointer); overload;
    procedure glCopyNamedBufferSubData(readBuffer, writeBuffer: GLuint; readOffset, writeOffset: GLintptr; size: GLsizeiptr); overload;
    procedure glClearNamedBufferData(buffer: GLuint; internalformat, format, aType: GLenum; const Data: Pointer); overload;
    procedure glClearNamedBufferSubData(buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format, aType: GLenum; const Data: Pointer); overload;
    function glMapNamedBuffer(buffer: GLuint; access: GLenum): Pointer;
    function glMapNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer;
    function glUnmapNamedBuffer(buffer: GLuint): GLboolean;
    procedure glFlushMappedNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); overload;
    procedure glGetNamedBufferParameteriv(buffer: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetNamedBufferParameteri64v(buffer: GLuint; pname: GLenum; params: PGLint64); overload;
    procedure glGetNamedBufferPointerv(buffer: GLuint; pname: GLenum; params: PPointer); overload;
    procedure glGetNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer); overload;

    procedure glCreateFramebuffers(n: GLsizei; framebuffers: PGLuint); overload;
    procedure glNamedFramebufferRenderbuffer(framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); overload;
    procedure glNamedFramebufferParameteri(framebuffer: GLuint; pname: GLenum; param: GLint); overload;
    procedure glNamedFramebufferTexture(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint); overload;
    procedure glNamedFramebufferTextureLayer(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level, layer: GLint); overload;
    procedure glNamedFramebufferDrawBuffer(framebuffer: GLuint; buf: GLenum); overload;
    procedure glNamedFramebufferDrawBuffers(framebuffer: GLuint; n: GLsizei; const bufs: PGLenum); overload;
    procedure glNamedFramebufferReadBuffer(framebuffer: GLuint; src: GLenum); overload;
    procedure glInvalidateNamedFramebufferData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum); overload;
    procedure glInvalidateNamedFramebufferSubData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum; x, y: GLint; Width, Height: GLsizei); overload;
    procedure glClearNamedFramebufferiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLint); overload;
    procedure glClearNamedFramebufferuiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLuint); overload;
    procedure glClearNamedFramebufferfv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat); overload;
    procedure glClearNamedFramebufferfi(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); overload;
    procedure glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer: GLuint; srcX0, srcY0, srcX1, srcY1: GLint; dstX0, dstY0, dstX1, dstY1: GLint; mask: GLbitfield; filter: GLenum); overload;
    function glCheckNamedFramebufferStatus(framebuffer: GLuint; target: GLenum): GLenum;
    procedure glGetNamedFramebufferParameteriv(framebuffer: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetNamedFramebufferAttachmentParameteriv(framebuffer: GLuint; attachment, pname: GLenum; params: PGLint); overload;

    procedure glCreateRenderbuffers(n: GLsizei; renderbuffers: PGLuint); overload;
    procedure glNamedRenderbufferStorage(renderbuffer: GLuint; internalformat: GLenum; Width, Height: GLsizei); overload;
    procedure glNamedRenderbufferStorageMultisample(renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei); overload;
    procedure glGetNamedRenderbufferParameteriv(renderbuffer: GLuint; pname: GLenum; params: PGLint); overload;

    procedure glCreateTextures(target: GLenum; n: GLsizei; textures: PGLuint); overload;
    procedure glTextureBuffer(texture: GLuint; internalformat: GLenum; buffer: GLuint); overload;
    procedure glTextureBufferRange(texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); overload;
    procedure glTextureStorage1D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei); overload;
    procedure glTextureStorage2D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width, Height: GLsizei); overload;
    procedure glTextureStorage3D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei); overload;
    procedure glTextureStorage2DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTextureStorage3DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean); overload;
    procedure glTextureSubImage1D(texture: GLuint; level, xoffset: GLint; Width: GLsizei; format, aType: GLenum; const pixels: Pointer); overload;
    procedure glTextureSubImage2D(texture: GLuint; level, xoffset, yoffset: GLint; Width, Height: GLsizei; format, aType: GLenum; const pixels: Pointer); overload;
    procedure glTextureSubImage3D(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, aType: GLenum; const pixels: Pointer); overload;
    procedure glCompressedTextureSubImage1D(texture: GLuint; level, xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTextureSubImage2D(texture: GLuint; level, xoffset, yoffset: GLint; Width, Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCompressedTextureSubImage3D(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer); overload;
    procedure glCopyTextureSubImage1D(texture: GLuint; level, xoffset, x, y: GLint; Width: GLsizei); overload;
    procedure glCopyTextureSubImage2D(texture: GLuint; level, xoffset, yoffset, x, y: GLint; Width, Height: GLsizei); overload;
    procedure glCopyTextureSubImage3D(texture: GLuint; level, xoffset, yoffset, zoffset, x, y: GLint; Width, Height: GLsizei); overload;
    procedure glTextureParameterf(texture: GLuint; pname: GLenum; param: GLfloat); overload;
    procedure glTextureParameterfv(texture: GLuint; pname: GLenum; const param: PGLfloat); overload;
    procedure glTextureParameteri(texture: GLuint; pname: GLenum; param: GLint); overload;
    procedure glTextureParameterIiv(texture: GLuint; pname: GLenum; const params: PGLint); overload;
    procedure glTextureParameterIuiv(texture: GLuint; pname: GLenum; const params: PGLuint); overload;
    procedure glTextureParameteriv(texture: GLuint; pname: GLenum; const param: PGLint); overload;
    procedure glGenerateTextureMipmap(texture: GLuint); overload;
    procedure glBindTextureUnit(unit_: GLuint; texture: GLuint); overload;
    procedure glGetTextureImage(texture: GLuint; level: GLint; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetCompressedTextureImage(texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetTextureLevelParameterfv(texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTextureLevelParameteriv(texture: GLuint; level: GLint; pname: GLenum; params: PGLint); overload;
    procedure glGetTextureParameterfv(texture: GLuint; pname: GLenum; params: PGLfloat); overload;
    procedure glGetTextureParameterIiv(texture: GLuint; pname: GLenum; params: PGLint); overload;
    procedure glGetTextureParameterIuiv(texture: GLuint; pname: GLenum; params: PGLuint); overload;
    procedure glGetTextureParameteriv(texture: GLuint; pname: GLenum; params: PGLint); overload;

    procedure glCreateVertexArrays(n: GLsizei; arrays: PGLuint); overload;
    procedure glDisableVertexArrayAttrib(vaobj: GLuint; index: GLuint); overload;
    procedure glEnableVertexArrayAttrib(vaobj: GLuint; index: GLuint); overload;
    procedure glVertexArrayElementBuffer(vaobj: GLuint; buffer: GLuint); overload;
    procedure glVertexArrayVertexBuffer(vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); overload;
    procedure glVertexArrayVertexBuffers(vaobj: GLuint; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei); overload;
    procedure glVertexArrayAttribBinding(vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint); overload;
    procedure glVertexArrayAttribFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint); overload;
    procedure glVertexArrayAttribIFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexArrayAttribLFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint); overload;
    procedure glVertexArrayBindingDivisor(vaobj: GLuint; bindingindex: GLuint; divisor: GLuint); overload;
    procedure glGetVertexArrayiv(vaobj: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetVertexArrayIndexediv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint); overload;
    procedure glGetVertexArrayIndexed64iv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64); overload;

    procedure glCreateSamplers(n: GLsizei; samplers: PGLuint); overload;
    procedure glCreateProgramPipelines(n: GLsizei; pipelines: PGLuint); overload;
    procedure glCreateQueries(target: GLenum; n: GLsizei; ids: PGLuint); overload;

    procedure glGetQueryBufferObjecti64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glGetQueryBufferObjectiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glGetQueryBufferObjectui64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;
    procedure glGetQueryBufferObjectuiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); overload;

    procedure glMemoryBarrierByRegion(barriers: GLbitfield); overload;

    procedure glGetTextureSubImage(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetCompressedTextureSubImage(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; bufSize: GLsizei; pixels: Pointer); overload;

    function glGetGraphicsResetStatus: GLenum; overload;
    procedure glGetnCompressedTexImage(target: GLenum; lod: GLint; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetnTexImage(target: GLenum; level: GLint; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer); overload;
    procedure glGetnUniformdv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble); overload;
    procedure glGetnUniformfv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); overload;
    procedure glGetnUniformiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); overload;
    procedure glGetnUniformuiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); overload;
    procedure glReadnPixels(x, y: GLint; Width, Height: GLsizei; format, aType: GLenum; bufSize: GLsizei; Data: Pointer); overload;

    procedure glTextureBarrier; overload;
  end;

  { TOpenGL_4_6 }

  TOpenGL_4_6 = class(TOpenGL_4_5, IOpenGL46)
  protected
  type
    TGLGetTextureHandleARB = function(texture: GLuint): GLuint64; {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLGetTextureSamplerHandleARB = function(texture: GLuint; sampler: GLuint): GLuint64; {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLMakeTextureHandleResidentARB = procedure(handle: GLuint64); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLMakeTextureHandleNonResidentARB = procedure(handle: GLuint64); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}

    TGLGetImageHandleARB = function(texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; format: GLenum): GLuint64; {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLMakeImageHandleResidentARB = procedure(handle: GLuint64; access: GLenum); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLMakeImageHandleNonResidentARB = procedure(handle: GLuint64); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}

    TGLUniformHandleui64ARB = procedure(location: GLint; Value: GLuint64); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLUniformHandleui64vARB = procedure(location: GLint; Count: GLsizei; const Value: PGLuint64); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLProgramUniformHandleui64ARB = procedure(aProgram: GLuint; location: GLint; Value: GLuint64); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLProgramUniformHandleui64vARB = procedure(aProgram: GLuint; location: GLint; Count: GLsizei; const values: PGLuint64); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}

    TGLIsTextureHandleResidentARB = function(handle: GLuint64): GLboolean; {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLIsImageHandleResidentARB = function(handle: GLuint64): GLboolean; {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}

    TGLVertexAttribL1ui64ARB = procedure(index: GLuint; x: GLuint64EXT); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLVertexAttribL1ui64vARB = procedure(index: GLuint; const v: PGLuint64EXT); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}
    TGLGetVertexAttribLui64vARB = procedure(index: GLuint; pname: GLenum; params: PGLuint64EXT); {$IFDEF WINDOWS}stdcall;{$ELSE} cdecl;{$ENDIF}

  protected
    FGLGetTextureHandleARB: TGLGetTextureHandleARB;
    FGLGetTextureSamplerHandleARB: TGLGetTextureSamplerHandleARB;
    FGLMakeTextureHandleResidentARB: TGLMakeTextureHandleResidentARB;
    FGLMakeTextureHandleNonResidentARB: TGLMakeTextureHandleNonResidentARB;

    FGLGetImageHandleARB: TGLGetImageHandleARB;
    FGLMakeImageHandleResidentARB: TGLMakeImageHandleResidentARB;
    FGLMakeImageHandleNonResidentARB: TGLMakeImageHandleNonResidentARB;

    FGLUniformHandleui64ARB: TGLUniformHandleui64ARB;
    FGLUniformHandleui64vARB: TGLUniformHandleui64vARB;
    FGLProgramUniformHandleui64ARB: TGLProgramUniformHandleui64ARB;
    FGLProgramUniformHandleui64vARB: TGLProgramUniformHandleui64vARB;

    FGLIsTextureHandleResidentARB: TGLIsTextureHandleResidentARB;
    FGLIsImageHandleResidentARB: TGLIsImageHandleResidentARB;

    FGLVertexAttribL1ui64ARB: TGLVertexAttribL1ui64ARB;
    FGLVertexAttribL1ui64vARB: TGLVertexAttribL1ui64vARB;
    FGLGetVertexAttribLui64vARB: TGLGetVertexAttribLui64vARB;
  protected
    procedure bindEntry; override;
  public
    function glGetTextureHandleARB(texture: GLuint): GLuint64; overload;
    function glGetTextureSamplerHandleARB(texture: GLuint; sampler: GLuint): GLuint64; overload;
    procedure glMakeTextureHandleResidentARB(handle: GLuint64); overload;
    procedure glMakeTextureHandleNonResidentARB(handle: GLuint64); overload;

    function glGetImageHandleARB(texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; format: GLenum): GLuint64; overload;
    procedure glMakeImageHandleResidentARB(handle: GLuint64; access: GLenum); overload;
    procedure glMakeImageHandleNonResidentARB(handle: GLuint64); overload;

    procedure glUniformHandleui64ARB(location: GLint; Value: GLuint64); overload;
    procedure glUniformHandleui64vARB(location: GLint; Count: GLsizei; const Value: PGLuint64); overload;
    procedure glProgramUniformHandleui64ARB(aProgram: GLuint; location: GLint; Value: GLuint64); overload;
    procedure glProgramUniformHandleui64vARB(aProgram: GLuint; location: GLint; Count: GLsizei; const values: PGLuint64); overload;

    function glIsTextureHandleResidentARB(handle: GLuint64): GLboolean; overload;
    function glIsImageHandleResidentARB(handle: GLuint64): GLboolean; overload;

    procedure glVertexAttribL1ui64ARB(index: GLuint; x: GLuint64EXT); overload;
    procedure glVertexAttribL1ui64vARB(index: GLuint; const v: PGLuint64EXT); overload;
    procedure glGetVertexAttribLui64vARB(index: GLuint; pname: GLenum; params: PGLuint64EXT); overload;
  end;

function GetOpenGL: IOpenGL;
var
  Base: TOpenGL_4_6;
begin
  if singleton = nil then
  begin
    base := TOpenGL_4_6.Create;
    base.LoadLibrary;
    Base.bindEntry;
    singleton := Base;
  end;
  Result := singleton;
end;


var
  debugFile: Text;

function ifThen(test: boolean; ifTrue, ifFalse: string): string;
begin
  if (test) then exit(ifTrue)
  else
    exit(ifFalse);
end;

{ TOpenGLBase }

{$IfDef WINDOWS}
procedure TOpenGLBase.CreateTempCoreContext;
var
  pfd: PIXELFORMATDESCRIPTOR;
  PixelFormat: Integer;
  attribs: array[0..8] of Integer;

  TempLegacyRC :HGLRC;
begin
  if FTempRC <> 0 then Exit; // gi creato
  // 1. Crea finestra invisibile 1x1
  FTempWindow := CreateWindowA(
    'STATIC', 'pax.gl temp', WS_POPUP or WS_DISABLED,
    0, 0, 1, 1, 0, 0, GetModuleHandle(nil), nil);
  FTempDC := GetDC(FTempWindow);

  // 2. Pixel format base (compatibile con tutti)
  FillChar(pfd, SizeOf(pfd), 0);
  pfd.nSize := SizeOf(pfd);
  pfd.nVersion := 1;
  pfd.dwFlags := PFD_DRAW_TO_WINDOW or PFD_SUPPORT_OPENGL or PFD_DOUBLEBUFFER;
  pfd.iPixelType := PFD_TYPE_RGBA;
  pfd.cColorBits := 32;
  pfd.cDepthBits := 24;
  pfd.cStencilBits := 8;

  PixelFormat := ChoosePixelFormat(FTempDC, @pfd);
  if PixelFormat = 0 then raise Exception.Create('ChoosePixelFormat fallito');
  SetPixelFormat(FTempDC, PixelFormat, @pfd);

  // 3. Crea contesto legacy temporaneo (solo per caricare wglCreateContextAttribsARB)
  TempLegacyRC := wglCreateContext(FTempDC);
  wglMakeCurrent(fTempDC, TempLegacyRC);

  // 4. Carica wglCreateContextAttribsARB tramite wglGetProcAddress
  Pointer(FwglCreateContextAttribsARB) := FWGLGetProcAddress('wglCreateContextAttribsARB');
  if not Assigned(FWGLCreateContextAttribsARB) then
  begin
    wglMakeCurrent(0, 0);
    wglDeleteContext(TempLegacyRC);
    raise Exception.Create('wglCreateContextAttribsARB non supportato  driver troppo vecchio');
  end;

  // 5. Distruggi contesto legacy
  wglMakeCurrent(0, 0);
  wglDeleteContext(TempLegacyRC);

  // 6. Crea contesto singleton 4.6 Core Profile
  FillChar(attribs, SizeOf(attribs), 0);
  attribs[0] := $2091; // WGL_CONTEXT_MAJOR_VERSION_ARB
  attribs[1] := 4;
  attribs[2] := $2092; // WGL_CONTEXT_MINOR_VERSION_ARB
  attribs[3] := 6;
  attribs[4] := $9126; // WGL_CONTEXT_PROFILE_MASK_ARB
  attribs[5] := $00000001; // WGL_CONTEXT_CORE_PROFILE_BIT_ARB
  // attribs[6] := $2094; // WGL_CONTEXT_FLAGS_ARB
  // attribs[7] := $00000002; // WGL_CONTEXT_DEBUG_BIT_ARB (opzionale)
  // attribs[8] := 0;

  FTempRC := FWGLCreateContextAttribsARB(FTempDC, 0, @attribs);
  if FTempRC = 0 then
  begin
    // Fallback: prova 4.5, 4.3, 3.3
    attribs[1] := 4; attribs[3] := 5; FTempRC := FwglCreateContextAttribsARB(FTempDC, 0, @attribs);
    if FTempRC = 0 then begin attribs[1] := 4; attribs[3] := 3; FTempRC := FwglCreateContextAttribsARB(FTempDC, 0, @attribs); end;
    if FTempRC = 0 then begin attribs[1] := 3; attribs[3] := 3; FTempRC := FwglCreateContextAttribsARB(FTempDC, 0, @attribs); end;
  end;

  if FTempRC = 0 then
    raise Exception.Create('Impossibile creare contesto OpenGL 3.3+ Core');

  // 7. Attiva il contesto core
  wglMakeCurrent(FTempDC, FTempRC);

  //Writeln('Contesto temporaneo OpenGL ', glGetString(GL_VERSION), ' creato con successo');
end;

procedure TOpenGLBase.DestroyTempContext;
begin
  if FTempRC <> 0 then
  begin
    wglMakeCurrent(0, 0);
    wglDeleteContext(FTempRC);
    FTempRC := 0;
  end;
  if FTempDC <> 0 then
  begin
    ReleaseDC(FTempWindow, FTempDC);
    FTempDC := 0;
  end;
  if FTempWindow <> 0 then
  begin
    DestroyWindow(FTempWindow);
    FTempWindow := 0;
  end;
end;
{$EndIf}

function TOpenGLBase.LoadProc(Name: ansistring): {$ifdef cpui8086}FarPointer{$else}Pointer{$endif};
var
  fileName: TFileName;
begin
  {$IfDef WINDOWS}
  Result := FWGLGetProcAddress(PChar(Name));
  if result = nil then
    Result := dynlibs.GetProcAddress(FHandle, Name);
  {$ELSE}
  Result := dynlibs.GetProcAddress(FHandle, Name);
  {$EndIf}

  fileName := ExpandFileName(ParamStr(0)) + '.opengl.log';
  AssignFile(debugFile, fileName);
  if FileExists(fileName) then
    Append(debugFile)
  else
    Rewrite(debugFile);
  Writeln(debugFile, IfThen(assigned(Result), '     found:', ' not found:'), Name);
  Flush(debugFile);
  CloseFile(debugFile);
end;

procedure TOpenGLBase.Bind(var FuncPtr: Pointer; const Name: ansistring; Mandatory: boolean = False);
begin
  Pointer(FuncPtr) := LoadProc(Name);
  if (Pointer(FuncPtr) = nil) and Mandatory then
    raise Exception.Create('OpenGL function not found: ' + Name);
end;


procedure TOpenGLBase.bindEntry;
begin
  {$IfDef WINDOWS}
 Pointer(FWGLGetProcAddress) := dynlibs.GetProcAddress(FHandle, 'wglGetProcAddress');
  Pointer(FWGLCreateContextAttribsARB) := dynlibs.GetProcAddress(FHandle, 'glCreateContextAttribsARB');
  CreateTempCoreContext;
  {$EndIf}
end;

procedure TOpenGLBase.LoadLibrary;
begin
  FHandle := dynlibs.LoadLibrary(libGL);
end;

procedure TOpenGLBase.unLoadLibrary;
begin
  dynlibs.UnloadLibrary(FHandle);
end;

destructor TOpenGLBase.Destroy;
begin
  unLoadLibrary;
  {$IfDef WINDOWS}
  DestroyTempContext;
  {$EndIf}
  inherited Destroy;
end;

function TOpenGLBase.SupportsVersion(Major, Minor: integer): boolean;
{var
  vmaj, vmin: GLint;
begin
  if Self.FHandle = NilHandle then Exit(False);
  glGetIntegerv(GL_MAJOR_VERSION, @vmaj);
  glGetIntegerv(GL_MINOR_VERSION, @vmin);
  Result := (vmaj > Major) or ((vmaj = Major) and (vmin >= Minor));
end;
}
begin
  Result := False;
end;

function TOpenGLBase.SupportsExtension(const Ext: string): boolean;
{
var
  i, Count: GLint;
  s: string;
begin
  if SupportsVersion(3, 0) then
  begin
    glGetIntegerv(GL_NUM_EXTENSIONS, @Count);
    for i := 0 to Count - 1 do
    begin
      s := string(glGetStringi(GL_EXTENSIONS, i));
      if s = Ext then Exit(True);
    end;
  end
  else
  begin
    s := string(glGetString(GL_EXTENSIONS));
    Result := Pos(Ext, s) > 0;
  end;
end;
}
begin
  Result := False;
end;

{ TOpenGL_1_0 }

procedure TOpenGL_1_0.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLCullFace) := LoadProc('glCullFace');
  Pointer(FGLFrontFace) := LoadProc('glFrontFace');
  Pointer(FGLHint) := LoadProc('glHint');
  Pointer(FGLLineWidth) := LoadProc('glLineWidth');
  Pointer(FGLPointSize) := LoadProc('glPointSize');
  Pointer(FGLPolygonMode) := LoadProc('glPolygonMode');
  Pointer(FGLScissor) := LoadProc('glScissor');
  Pointer(FGLTexParameterf) := LoadProc('glTexParameterf');
  Pointer(FGLTexParameterfv) := LoadProc('glTexParameterfv');
  Pointer(FGLTexParameteri) := LoadProc('glTexParameteri');
  Pointer(FGLTexParameteriv) := LoadProc('glTexParameteriv');
  Pointer(FGLTexImage1D) := LoadProc('glTexImage1D');
  Pointer(FGLTexImage2D) := LoadProc('glTexImage2D');
  Pointer(FGLDrawBuffer) := LoadProc('glDrawBuffer');
  Pointer(FGLClear) := LoadProc('glClear');
  Pointer(FGLClearColor) := LoadProc('glClearColor');
  Pointer(FGLClearStencil) := LoadProc('glClearStencil');
  Pointer(FGLClearDepth) := LoadProc('glClearDepth');
  Pointer(FGLStencilMask) := LoadProc('glStencilMask');
  Pointer(FGLColorMask) := LoadProc('glColorMask');
  Pointer(FGLDepthMask) := LoadProc('glDepthMask');
  Pointer(FGLDisable) := LoadProc('glDisable');
  Pointer(FGLEnable) := LoadProc('glEnable');
  Pointer(FGLFinish) := LoadProc('glFinish');
  Pointer(FGLFlush) := LoadProc('glFlush');
  Pointer(FGLBlendFunc) := LoadProc('glBlendFunc');
  Pointer(FGLLogicOp) := LoadProc('glLogicOp');
  Pointer(FGLStencilFunc) := LoadProc('glStencilFunc');
  Pointer(FGLStencilOp) := LoadProc('glStencilOp');
  Pointer(FGLDepthFunc) := LoadProc('glDepthFunc');
  Pointer(FGLPixelStoref) := LoadProc('glPixelStoref');
  Pointer(FGLPixelStorei) := LoadProc('glPixelStorei');
  Pointer(FGLReadBuffer) := LoadProc('glReadBuffer');
  Pointer(FGLReadPixels) := LoadProc('glReadPixels');
  Pointer(FGLGetBooleanv) := LoadProc('glGetBooleanv');
  Pointer(FGLGetDoublev) := LoadProc('glGetDoublev');
  Pointer(FGLGetError) := LoadProc('glGetError');
  Pointer(FGLGetFloatv) := LoadProc('glGetFloatv');
  Pointer(FGLGetIntegerv) := LoadProc('glGetIntegerv');
  Pointer(FGLGetString) := LoadProc('glGetString');
  Pointer(FGLGetTexImage) := LoadProc('glGetTexImage');
  Pointer(FGLGetTexParameterfv) := LoadProc('glGetTexParameterfv');
  Pointer(FGLGetTexParameteriv) := LoadProc('glGetTexParameteriv');
  Pointer(FGLGetTexLevelParameterfv) := LoadProc('glGetTexLevelParameterfv');
  Pointer(FGLGetTexLevelParameteriv) := LoadProc('glGetTexLevelParameteriv');
  Pointer(FGLIsEnabled) := LoadProc('glIsEnabled');
  Pointer(FGLDepthRange) := LoadProc('glDepthRange');
  Pointer(FGLViewport) := LoadProc('glViewport');
  Pointer(FglBegin) := LoadProc('glBegin');
  Pointer(FglEnd) := LoadProc('glEnd');

  Pointer(FglVertex2f) := LoadProc('glVertex2f');
  Pointer(FglVertex2fv) := LoadProc('glVertex2fv');
  Pointer(FglVertex3f) := LoadProc('glVertex3f');
  Pointer(FglVertex3fv) := LoadProc('glVertex3fv');

  Pointer(FglColor3f) := LoadProc('glColor3f');
  Pointer(FglColor3fv) := LoadProc('glColor3fv');
  Pointer(FglColor4f) := LoadProc('glColor4f');
  Pointer(FglColor4fv) := LoadProc('glColor4fv');

  Pointer(FglNormal3f) := LoadProc('glNormal3f');
  Pointer(FglNormal3fv) := LoadProc('glNormal3fv');

  Pointer(FglTexCoord2f) := LoadProc('glTexCoord2f');
  Pointer(FglTexCoord2fv) := LoadProc('glTexCoord2fv');

  Pointer(FglMatrixMode) := LoadProc('glMatrixMode');
  Pointer(FglLoadIdentity) := LoadProc('glLoadIdentity');
  Pointer(FglLoadMatrixf) := LoadProc('glLoadMatrixf');
  Pointer(FglMultMatrixf) := LoadProc('glMultMatrixf');
  Pointer(FglPushMatrix) := LoadProc('glPushMatrix');
  Pointer(FglPopMatrix) := LoadProc('glPopMatrix');

  Pointer(FglTranslatef) := LoadProc('glTranslatef');
  Pointer(FglRotatef) := LoadProc('glRotatef');
  Pointer(FglScalef) := LoadProc('glScalef');

  Pointer(FglShadeModel) := LoadProc('glShadeModel');
  Pointer(FglGenLists) := LoadProc('glGenLists');
  Pointer(FglNewList) := LoadProc('glNewList');
  Pointer(FglEndList) := LoadProc('glEndList');
  Pointer(FglCallList) := LoadProc('glCallList');

  Pointer(FglMaterialfv) := LoadProc('glMaterialfv');
  Pointer(FglLightfv) := LoadProc('glLightfv');

  Pointer(FglFrustum) := LoadProc('glFrustum');
end;

function TOpenGL_1_0.glGenLists(range: GLsizei): GLuint;
begin
  if Assigned(FglGenLists) then
    Result := FglGenLists(range)
  else
    Result := 0;
end;

procedure TOpenGL_1_0.glNewList(list: GLuint; mode: GLenum);
begin
  if Assigned(FglNewList) then
    FglNewList(list, mode);
end;

procedure TOpenGL_1_0.glEndList;
begin
  if Assigned(FglEndList) then
    FglEndList;
end;

procedure TOpenGL_1_0.glCallList(list: GLuint);
begin
  if Assigned(FglCallList) then
    FglCallList(list);
end;

procedure TOpenGL_1_0.glMaterialfv(face, pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglMaterialfv) then
    FglMaterialfv(face, pname, params);
end;

procedure TOpenGL_1_0.glLightfv(light, pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FglLightfv) then
    FglLightfv(light, pname, params);
end;

procedure TOpenGL_1_0.glFrustum(left, right, bottom, top, zNear, zFar: GLdouble);
begin
  if Assigned(FglFrustum) then
    FglFrustum(left, right, bottom, top, zNear, zFar);
end;

procedure TOpenGL_1_0.glCullFace(mode: GLenum);
begin
  if Assigned(FGLCullFace) then FGLCullFace(mode);
end;

procedure TOpenGL_1_0.glOrtho(left, right, bottom, top, zNear, zFar: GLdouble);
begin
  if Assigned(fglOrtho) then
    fglOrtho(left, right, bottom, top, zNear, zFar);
end;

procedure TOpenGL_1_0.glFrontFace(mode: GLenum);
begin
  if Assigned(FGLFrontFace) then FGLFrontFace(mode);
end;

procedure TOpenGL_1_0.glHint(target, mode: GLenum);
begin
  if Assigned(FGLHint) then FGLHint(target, mode);
end;

procedure TOpenGL_1_0.glLineWidth(Width: GLfloat);
begin
  if Assigned(FGLLineWidth) then FGLLineWidth(Width);
end;

procedure TOpenGL_1_0.glPointSize(size: GLfloat);
begin
  if Assigned(FGLPointSize) then FGLPointSize(size);
end;

procedure TOpenGL_1_0.glPolygonMode(face, mode: GLenum);
begin
  if Assigned(FGLPolygonMode) then FGLPolygonMode(face, mode);
end;

procedure TOpenGL_1_0.glScissor(x, y: GLint; Width, Height: GLsizei);
begin
  if Assigned(FGLScissor) then FGLScissor(x, y, Width, Height);
end;

procedure TOpenGL_1_0.glTexParameterf(target, pname: GLenum; param: GLfloat);
begin
  if Assigned(FGLTexParameterf) then FGLTexParameterf(target, pname, param);
end;

procedure TOpenGL_1_0.glTexParameterfv(target, pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FGLTexParameterfv) then FGLTexParameterfv(target, pname, params);
end;

procedure TOpenGL_1_0.glTexParameteri(target, pname: GLenum; param: GLint);
begin
  if Assigned(FGLTexParameteri) then FGLTexParameteri(target, pname, param);
end;

procedure TOpenGL_1_0.glTexParameteriv(target, pname: GLenum; const params: PGLint);
begin
  if Assigned(FGLTexParameteriv) then FGLTexParameteriv(target, pname, params);
end;

procedure TOpenGL_1_0.glTexImage1D(target: GLenum; level, internalformat: GLint; Width: GLsizei; border: GLint; format, aType: GLenum; pixels: PGLvoid);
begin
  if Assigned(FGLTexImage1D) then FGLTexImage1D(target, level, internalformat, Width, border, format, aType, pixels);
end;

procedure TOpenGL_1_0.glTexImage2D(target: GLenum; level, internalformat: GLint; Width, Height: GLsizei; border: GLint; format, aType: GLenum; pixels: PGLvoid);
begin
  if Assigned(FGLTexImage2D) then FGLTexImage2D(target, level, internalformat, Width, Height, border, format, aType, pixels);
end;

procedure TOpenGL_1_0.glDrawBuffer(buf: GLenum);
begin
  if Assigned(FGLDrawBuffer) then FGLDrawBuffer(buf);
end;

procedure TOpenGL_1_0.glClear(mask: GLbitfield);
begin
  if Assigned(FGLClear) then FGLClear(mask);
end;

procedure TOpenGL_1_0.glClearColor(red, green, blue, alpha: GLfloat);
begin
  if Assigned(FGLClearColor) then FGLClearColor(red, green, blue, alpha);
end;

procedure TOpenGL_1_0.glClearStencil(s: GLint);
begin
  if Assigned(FGLClearStencil) then FGLClearStencil(s);
end;

procedure TOpenGL_1_0.glClearDepth(depth: GLdouble);
begin
  if Assigned(FGLClearDepth) then FGLClearDepth(depth);
end;

procedure TOpenGL_1_0.glStencilMask(mask: GLuint);
begin
  if Assigned(FGLStencilMask) then FGLStencilMask(mask);
end;

procedure TOpenGL_1_0.glColorMask(red, green, blue, alpha: GLboolean);
begin
  if Assigned(FGLColorMask) then FGLColorMask(red, green, blue, alpha);
end;

procedure TOpenGL_1_0.glDepthMask(flag: GLboolean);
begin
  if Assigned(FGLDepthMask) then FGLDepthMask(flag);
end;

procedure TOpenGL_1_0.glDisable(cap: GLenum);
begin
  if Assigned(FGLDisable) then FGLDisable(cap);
end;

procedure TOpenGL_1_0.glEnable(cap: GLenum);
begin
  if Assigned(FGLEnable) then FGLEnable(cap);
end;

procedure TOpenGL_1_0.glFinish;
begin
  if Assigned(FGLFinish) then FGLFinish;
end;

procedure TOpenGL_1_0.glFlush;
begin
  if Assigned(FGLFlush) then FGLFlush;
end;

procedure TOpenGL_1_0.glBlendFunc(sfactor, dfactor: GLenum);
begin
  if Assigned(FGLBlendFunc) then FGLBlendFunc(sfactor, dfactor);
end;

procedure TOpenGL_1_0.glLogicOp(opcode: GLenum);
begin
  if Assigned(FGLLogicOp) then FGLLogicOp(opcode);
end;

procedure TOpenGL_1_0.glStencilFunc(func: GLenum; ref: GLint; mask: GLuint);
begin
  if Assigned(FGLStencilFunc) then FGLStencilFunc(func, ref, mask);
end;

procedure TOpenGL_1_0.glStencilOp(fail, zfail, zpass: GLenum);
begin
  if Assigned(FGLStencilOp) then FGLStencilOp(fail, zfail, zpass);
end;

procedure TOpenGL_1_0.glDepthFunc(func: GLenum);
begin
  if Assigned(FGLDepthFunc) then FGLDepthFunc(func);
end;

procedure TOpenGL_1_0.glPixelStoref(pname: GLenum; param: GLfloat);
begin
  if Assigned(FGLPixelStoref) then FGLPixelStoref(pname, param);
end;

procedure TOpenGL_1_0.glPixelStorei(pname: GLenum; param: GLint);
begin
  if Assigned(FGLPixelStorei) then FGLPixelStorei(pname, param);
end;

procedure TOpenGL_1_0.glReadBuffer(src: GLenum);
begin
  if Assigned(FGLReadBuffer) then FGLReadBuffer(src);
end;

procedure TOpenGL_1_0.glReadPixels(x, y: GLint; Width, Height: GLsizei; format, aType: GLenum; pixels: PGLvoid);
begin
  if Assigned(FGLReadPixels) then FGLReadPixels(x, y, Width, Height, format, aType, pixels);
end;

procedure TOpenGL_1_0.glGetBooleanv(pname: GLenum; Data: PGLboolean);
begin
  if Assigned(FGLGetBooleanv) then FGLGetBooleanv(pname, Data);
end;

procedure TOpenGL_1_0.glGetDoublev(pname: GLenum; Data: PGLdouble);
begin
  if Assigned(FGLGetDoublev) then FGLGetDoublev(pname, Data);
end;

function TOpenGL_1_0.glGetError: GLenum;
begin
  if Assigned(FGLGetError) then
    Result := FGLGetError()
  else
    Result := GL_NO_ERROR;
end;

procedure TOpenGL_1_0.glGetFloatv(pname: GLenum; Data: PGLfloat);
begin
  if Assigned(FGLGetFloatv) then FGLGetFloatv(pname, Data);
end;

procedure TOpenGL_1_0.glGetIntegerv(pname: GLenum; Data: PGLint);
begin
  if Assigned(FGLGetIntegerv) then FGLGetIntegerv(pname, Data);
end;

function TOpenGL_1_0.glGetString(Name: GLenum): PGLubyte;
begin
  if Assigned(FGLGetString) then
    Result := FGLGetString(Name)
  else
    Result := nil;
end;

procedure TOpenGL_1_0.glGetTexImage(target: GLenum; level: GLint; format, aType: GLenum; pixels: PGLvoid);
begin
  if Assigned(FGLGetTexImage) then FGLGetTexImage(target, level, format, aType, pixels);
end;

procedure TOpenGL_1_0.glGetTexParameterfv(target, pname: GLenum; params: PGLfloat);
begin
  if Assigned(FGLGetTexParameterfv) then FGLGetTexParameterfv(target, pname, params);
end;

procedure TOpenGL_1_0.glGetTexParameteriv(target, pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetTexParameteriv) then FGLGetTexParameteriv(target, pname, params);
end;

procedure TOpenGL_1_0.glGetTexLevelParameterfv(target: GLenum; level: GLint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FGLGetTexLevelParameterfv) then FGLGetTexLevelParameterfv(target, level, pname, params);
end;

procedure TOpenGL_1_0.glGetTexLevelParameteriv(target: GLenum; level: GLint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetTexLevelParameteriv) then FGLGetTexLevelParameteriv(target, level, pname, params);
end;

function TOpenGL_1_0.glIsEnabled(cap: GLenum): GLboolean;
begin
  if Assigned(FGLIsEnabled) then
    Result := FGLIsEnabled(cap)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_1_0.glDepthRange(n, f: GLdouble);
begin
  if Assigned(FGLDepthRange) then FGLDepthRange(n, f);
end;

procedure TOpenGL_1_0.glViewport(x, y: GLint; Width, Height: GLsizei);
begin
  if Assigned(FGLViewport) then FGLViewport(x, y, Width, Height);
end;

procedure TOpenGL_1_0.glBegin(mode: GLenum);
begin
  if Assigned(FglBegin) then FglBegin(mode);
end;

procedure TOpenGL_1_0.glEnd;
begin
  if Assigned(FglEnd) then FglEnd;
end;

procedure TOpenGL_1_0.glVertex2f(x, y: GLfloat);
begin
  if Assigned(FglVertex2f) then FglVertex2f(x, y);
end;

procedure TOpenGL_1_0.glVertex2fv(v: PGLfloat);
begin
  if Assigned(FglVertex2fv) then FglVertex2fv(v);
end;

procedure TOpenGL_1_0.glVertex3f(x, y, z: GLfloat);
begin
  if Assigned(FglVertex3f) then FglVertex3f(x, y, z);
end;

procedure TOpenGL_1_0.glVertex3fv(v: PGLfloat);
begin
  if Assigned(FglVertex3fv) then FglVertex3fv(v);
end;

procedure TOpenGL_1_0.glColor3f(red, green, blue: GLfloat);
begin
  if Assigned(FglColor3f) then FglColor3f(red, green, blue);
end;

procedure TOpenGL_1_0.glColor3fv(v: PGLfloat);
begin
  if Assigned(FglColor3fv) then FglColor3fv(v);
end;

procedure TOpenGL_1_0.glColor4f(red, green, blue, alpha: GLfloat);
begin
  if Assigned(FglColor4f) then FglColor4f(red, green, blue, alpha);
end;

procedure TOpenGL_1_0.glColor4fv(v: PGLfloat);
begin
  if Assigned(FglColor4fv) then FglColor4fv(v);
end;

procedure TOpenGL_1_0.glNormal3f(nx, ny, nz: GLfloat);
begin
  if Assigned(FglNormal3f) then FglNormal3f(nx, ny, nz);
end;

procedure TOpenGL_1_0.glNormal3fv(v: PGLfloat);
begin
  if Assigned(FglNormal3fv) then FglNormal3fv(v);
end;

procedure TOpenGL_1_0.glTexCoord2f(s, t: GLfloat);
begin
  if Assigned(FglTexCoord2f) then FglTexCoord2f(s, t);
end;

procedure TOpenGL_1_0.glTexCoord2fv(v: PGLfloat);
begin
  if Assigned(FglTexCoord2fv) then FglTexCoord2fv(v);
end;

// Matrix Stack & Transformations
procedure TOpenGL_1_0.glMatrixMode(mode: GLenum);
begin
  if Assigned(FglMatrixMode) then FglMatrixMode(mode);
end;

procedure TOpenGL_1_0.glLoadIdentity;
begin
  if Assigned(FglLoadIdentity) then FglLoadIdentity;
end;

procedure TOpenGL_1_0.glLoadMatrixf(const m: PGLfloat);
begin
  if Assigned(FglLoadMatrixf) then FglLoadMatrixf(m);
end;

procedure TOpenGL_1_0.glMultMatrixf(const m: PGLfloat);
begin
  if Assigned(FglMultMatrixf) then FglMultMatrixf(m);
end;

procedure TOpenGL_1_0.glPushMatrix;
begin
  if Assigned(FglPushMatrix) then FglPushMatrix;
end;

procedure TOpenGL_1_0.glPopMatrix;
begin
  if Assigned(FglPopMatrix) then FglPopMatrix;
end;

procedure TOpenGL_1_0.glTranslatef(x, y, z: GLfloat);
begin
  if Assigned(FglTranslatef) then FglTranslatef(x, y, z);
end;

procedure TOpenGL_1_0.glRotatef(angle, x, y, z: GLfloat);
begin
  if Assigned(FglRotatef) then FglRotatef(angle, x, y, z);
end;

procedure TOpenGL_1_0.glScalef(x, y, z: GLfloat);
begin
  if Assigned(FglScalef) then FglScalef(x, y, z);
end;

procedure TOpenGL_1_0.glShadeModel(mode: GLenum);
begin
  if Assigned(FglShadeModel) then FglShadeModel(mode);
end;

{ TOpenGL_1_1 }

procedure TOpenGL_1_1.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLDrawArrays) := LoadProc('glDrawArrays');
  Pointer(FGLDrawElements) := LoadProc('glDrawElements');
  Pointer(FGLGetPointerv) := LoadProc('glGetPointerv');
  Pointer(FGLPolygonOffset) := LoadProc('glPolygonOffset');
  Pointer(FGLCopyTexImage1D) := LoadProc('glCopyTexImage1D');
  Pointer(FGLCopyTexImage2D) := LoadProc('glCopyTexImage2D');
  Pointer(FGLCopyTexSubImage1D) := LoadProc('glCopyTexSubImage1D');
  Pointer(FGLCopyTexSubImage2D) := LoadProc('glCopyTexSubImage2D');
  Pointer(FGLTexSubImage1D) := LoadProc('glTexSubImage1D');
  Pointer(FGLTexSubImage2D) := LoadProc('glTexSubImage2D');
  Pointer(FGLBindTexture) := LoadProc('glBindTexture');
  Pointer(FGLDeleteTextures) := LoadProc('glDeleteTextures');
  Pointer(FGLGenTextures) := LoadProc('glGenTextures');
  Pointer(FGLIsTexture) := LoadProc('glIsTexture');
end;

procedure TOpenGL_1_1.glDrawArrays(mode: GLenum; First: GLint; Count: GLsizei);
begin
  if Assigned(FGLDrawArrays) then
    FGLDrawArrays(mode, First, Count);
end;

procedure TOpenGL_1_1.glDrawElements(mode: GLenum; Count: GLsizei; typ: GLenum; const indices: PGLvoid);
begin
  if Assigned(FGLDrawElements) then
    FGLDrawElements(mode, Count, typ, indices);
end;

procedure TOpenGL_1_1.glGetPointerv(pname: GLenum; params: PPGLvoid);
begin
  if Assigned(FGLGetPointerv) then
    FGLGetPointerv(pname, params);
end;

procedure TOpenGL_1_1.glPolygonOffset(factor, units: GLfloat);
begin
  if Assigned(FGLPolygonOffset) then
    FGLPolygonOffset(factor, units);
end;

procedure TOpenGL_1_1.glCopyTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; x, y: GLint; Width: GLsizei; border: GLint);
begin
  if Assigned(FGLCopyTexImage1D) then
    FGLCopyTexImage1D(target, level, internalformat, x, y, Width, border);
end;

procedure TOpenGL_1_1.glCopyTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; x, y: GLint; Width, Height: GLsizei; border: GLint);
begin
  if Assigned(FGLCopyTexImage2D) then
    FGLCopyTexImage2D(target, level, internalformat, x, y, Width, Height, border);
end;

procedure TOpenGL_1_1.glCopyTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; x, y: GLint; Width: GLsizei);
begin
  if Assigned(FGLCopyTexSubImage1D) then
    FGLCopyTexSubImage1D(target, level, xoffset, x, y, Width);
end;

procedure TOpenGL_1_1.glCopyTexSubImage2D(target: GLenum; level: GLint; xoffset, yoffset: GLint; x, y: GLint; Width, Height: GLsizei);
begin
  if Assigned(FGLCopyTexSubImage2D) then
    FGLCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, Width, Height);
end;

procedure TOpenGL_1_1.glTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format, typ: GLenum; const pixels: PGLvoid);
begin
  if Assigned(FGLTexSubImage1D) then
    FGLTexSubImage1D(target, level, xoffset, Width, format, typ, pixels);
end;

procedure TOpenGL_1_1.glTexSubImage2D(target: GLenum; level: GLint; xoffset, yoffset: GLint; Width, Height: GLsizei; format, typ: GLenum; const pixels: PGLvoid);
begin
  if Assigned(FGLTexSubImage2D) then
    FGLTexSubImage2D(target, level, xoffset, yoffset, Width, Height, format, typ, pixels);
end;

procedure TOpenGL_1_1.glBindTexture(target: GLenum; texture: GLuint);
begin
  if Assigned(FGLBindTexture) then
    FGLBindTexture(target, texture);
end;

procedure TOpenGL_1_1.glDeleteTextures(n: GLsizei; const textures: PGLuint);
begin
  if Assigned(FGLDeleteTextures) then
    FGLDeleteTextures(n, textures);
end;

procedure TOpenGL_1_1.glGenTextures(n: GLsizei; textures: PGLuint);
begin
  if Assigned(FGLGenTextures) then
    FGLGenTextures(n, textures);
end;

function TOpenGL_1_1.glIsTexture(texture: GLuint): GLboolean;
begin
  if Assigned(FGLIsTexture) then
    Result := FGLIsTexture(texture)
  else
    Result := GL_FALSE;
end;

{ TOpenGL_1_2 }

procedure TOpenGL_1_2.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLDrawRangeElements) := LoadProc('glDrawRangeElements');
  Pointer(FGLTexImage3D) := LoadProc('glTexImage3D');
  Pointer(FGLTexSubImage3D) := LoadProc('glTexSubImage3D');
  Pointer(FGLCopyTexSubImage3D) := LoadProc('glCopyTexSubImage3D');
end;

procedure TOpenGL_1_2.glDrawRangeElements(mode: GLenum; start, end_: GLuint; Count: GLsizei; typ: GLenum; const indices: Pointer);
begin
  if Assigned(FGLDrawRangeElements) then
    FGLDrawRangeElements(mode, start, end_, Count, typ, indices);
end;

procedure TOpenGL_1_2.glTexImage3D(target: GLenum; level: GLint; internalformat: GLint; Width, Height, depth: GLsizei; border: GLint; format, typ: GLenum; const pixels: Pointer);
begin
  if Assigned(FGLTexImage3D) then
    FGLTexImage3D(target, level, internalformat, Width, Height, depth, border, format, typ, pixels);
end;

procedure TOpenGL_1_2.glTexSubImage3D(target: GLenum; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, typ: GLenum; const pixels: Pointer);
begin
  if Assigned(FGLTexSubImage3D) then
    FGLTexSubImage3D(target, level, xoffset, yoffset, zoffset, Width, Height, depth, format, typ, pixels);
end;

procedure TOpenGL_1_2.glCopyTexSubImage3D(target: GLenum; level: GLint; xoffset, yoffset, zoffset: GLint; x, y: GLint; Width, Height: GLsizei);
begin
  if Assigned(FGLCopyTexSubImage3D) then
    FGLCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, Width, Height);
end;

{ TOpenGL_1_3 }

procedure TOpenGL_1_3.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLActiveTexture) := LoadProc('glActiveTexture');
  Pointer(FGLSampleCoverage) := LoadProc('glSampleCoverage');
  Pointer(FGLCompressedTexImage3D) := LoadProc('glCompressedTexImage3D');
  Pointer(FGLCompressedTexImage2D) := LoadProc('glCompressedTexImage2D');
  Pointer(FGLCompressedTexImage1D) := LoadProc('glCompressedTexImage1D');
  Pointer(FGLCompressedTexSubImage3D) := LoadProc('glCompressedTexSubImage3D');
  Pointer(FGLCompressedTexSubImage2D) := LoadProc('glCompressedTexSubImage2D');
  Pointer(FGLCompressedTexSubImage1D) := LoadProc('glCompressedTexSubImage1D');
  Pointer(FGLGetCompressedTexImage) := LoadProc('glGetCompressedTexImage');
end;

procedure TOpenGL_1_3.glActiveTexture(texture: GLenum);
begin
  if Assigned(FGLActiveTexture) then
    FGLActiveTexture(texture);
end;

procedure TOpenGL_1_3.glSampleCoverage(Value: GLfloat; invert: GLboolean);
begin
  if Assigned(FGLSampleCoverage) then
    FGLSampleCoverage(Value, invert);
end;

procedure TOpenGL_1_3.glCompressedTexImage3D(target: GLenum; level: GLint; internalformat: GLenum; Width, Height, depth: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FGLCompressedTexImage3D) then
    FGLCompressedTexImage3D(target, level, internalformat, Width, Height, depth, border, imageSize, Data);
end;

procedure TOpenGL_1_3.glCompressedTexImage2D(target: GLenum; level: GLint; internalformat: GLenum; Width, Height: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FGLCompressedTexImage2D) then
    FGLCompressedTexImage2D(target, level, internalformat, Width, Height, border, imageSize, Data);
end;

procedure TOpenGL_1_3.glCompressedTexImage1D(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; border: GLint; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FGLCompressedTexImage1D) then
    FGLCompressedTexImage1D(target, level, internalformat, Width, border, imageSize, Data);
end;

procedure TOpenGL_1_3.glCompressedTexSubImage3D(target: GLenum; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FGLCompressedTexSubImage3D) then
    FGLCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, Width, Height, depth, format, imageSize, Data);
end;

procedure TOpenGL_1_3.glCompressedTexSubImage2D(target: GLenum; level: GLint; xoffset, yoffset: GLint; Width, Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FGLCompressedTexSubImage2D) then
    FGLCompressedTexSubImage2D(target, level, xoffset, yoffset, Width, Height, format, imageSize, Data);
end;

procedure TOpenGL_1_3.glCompressedTexSubImage1D(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FGLCompressedTexSubImage1D) then
    FGLCompressedTexSubImage1D(target, level, xoffset, Width, format, imageSize, Data);
end;

procedure TOpenGL_1_3.glGetCompressedTexImage(target: GLenum; level: GLint; img: Pointer);
begin
  if Assigned(FGLGetCompressedTexImage) then
    FGLGetCompressedTexImage(target, level, img);
end;

{ TOpenGL_1_4 }

procedure TOpenGL_1_4.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLBlendFuncSeparate) := LoadProc('glBlendFuncSeparate');
  Pointer(FGLMultiDrawArrays) := LoadProc('glMultiDrawArrays');
  Pointer(FGLMultiDrawElements) := LoadProc('glMultiDrawElements');
  Pointer(FGLPointParameterf) := LoadProc('glPointParameterf');
  Pointer(FGLPointParameterfv) := LoadProc('glPointParameterfv');
  Pointer(FGLPointParameteri) := LoadProc('glPointParameteri');
  Pointer(FGLPointParameteriv) := LoadProc('glPointParameteriv');
  Pointer(FGLBlendColor) := LoadProc('glBlendColor');
  Pointer(FGLBlendEquation) := LoadProc('glBlendEquation');
end;

procedure TOpenGL_1_4.glBlendFuncSeparate(sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum);
begin
  if Assigned(FGLBlendFuncSeparate) then
    FGLBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
end;

procedure TOpenGL_1_4.glMultiDrawArrays(mode: GLenum; const First: PGLint; const Count: PGLsizei; drawcount: GLsizei);
begin
  if Assigned(FGLMultiDrawArrays) then
    FGLMultiDrawArrays(mode, First, Count, drawcount);
end;

procedure TOpenGL_1_4.glMultiDrawElements(mode: GLenum; const Count: PGLsizei; typ: GLenum; const indices: PPointer; drawcount: GLsizei);
begin
  if Assigned(FGLMultiDrawElements) then
    FGLMultiDrawElements(mode, Count, typ, indices, drawcount);
end;

procedure TOpenGL_1_4.glPointParameterf(pname: GLenum; param: GLfloat);
begin
  if Assigned(FGLPointParameterf) then
    FGLPointParameterf(pname, param);
end;

procedure TOpenGL_1_4.glPointParameterfv(pname: GLenum; const params: PGLfloat);
begin
  if Assigned(FGLPointParameterfv) then
    FGLPointParameterfv(pname, params);
end;

procedure TOpenGL_1_4.glPointParameteri(pname: GLenum; param: GLint);
begin
  if Assigned(FGLPointParameteri) then
    FGLPointParameteri(pname, param);
end;

procedure TOpenGL_1_4.glPointParameteriv(pname: GLenum; const params: PGLint);
begin
  if Assigned(FGLPointParameteriv) then
    FGLPointParameteriv(pname, params);
end;

procedure TOpenGL_1_4.glBlendColor(red, green, blue, alpha: GLfloat);
begin
  if Assigned(FGLBlendColor) then
    FGLBlendColor(red, green, blue, alpha);
end;

procedure TOpenGL_1_4.glBlendEquation(mode: GLenum);
begin
  if Assigned(FGLBlendEquation) then
    FGLBlendEquation(mode);
end;

{ TOpenGL_1_5 }

procedure TOpenGL_1_5.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLGenBuffers) := LoadProc('glGenBuffers');
  Pointer(FGLDeleteBuffers) := LoadProc('glDeleteBuffers');
  Pointer(FGLBindBuffer) := LoadProc('glBindBuffer');
  Pointer(FGLBufferData) := LoadProc('glBufferData');
  Pointer(FGLBufferSubData) := LoadProc('glBufferSubData');
  Pointer(FGLGetBufferSubData) := LoadProc('glGetBufferSubData');
  Pointer(FGLMapBuffer) := LoadProc('glMapBuffer');
  Pointer(FGLUnmapBuffer) := LoadProc('glUnmapBuffer');
  Pointer(FGLGetBufferParameteriv) := LoadProc('glGetBufferParameteriv');
  Pointer(FGLGetBufferPointerv) := LoadProc('glGetBufferPointerv');
  Pointer(FGLIsBuffer) := LoadProc('glIsBuffer');

  Pointer(FGLGenQueries) := LoadProc('glGenQueries');
  Pointer(FGLDeleteQueries) := LoadProc('glDeleteQueries');
  Pointer(FGLIsQuery) := LoadProc('glIsQuery');
  Pointer(FGLBeginQuery) := LoadProc('glBeginQuery');
  Pointer(FGLEndQuery) := LoadProc('glEndQuery');
  Pointer(FGLGetQueryiv) := LoadProc('glGetQueryiv');
  Pointer(FGLGetQueryObjectiv) := LoadProc('glGetQueryObjectiv');
  Pointer(FGLGetQueryObjectuiv) := LoadProc('glGetQueryObjectuiv');
end;

procedure TOpenGL_1_5.glGenBuffers(n: GLsizei; buffers: PGLuint);
begin
  if Assigned(FGLGenBuffers) then
    FGLGenBuffers(n, buffers);
end;

procedure TOpenGL_1_5.glDeleteBuffers(n: GLsizei; const buffers: PGLuint);
begin
  if Assigned(FGLDeleteBuffers) then
    FGLDeleteBuffers(n, buffers);
end;

procedure TOpenGL_1_5.glBindBuffer(target: GLenum; buffer: GLuint);
begin
  if Assigned(FGLBindBuffer) then
    FGLBindBuffer(target, buffer);
end;

procedure TOpenGL_1_5.glBufferData(target: GLenum; size: GLsizeiptr; Data: PGLvoid; usage: GLenum);
begin
  if Assigned(FGLBufferData) then
    FGLBufferData(target, size, Data, usage);
end;

procedure TOpenGL_1_5.glBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: PGLvoid);
begin
  if Assigned(FGLBufferSubData) then
    FGLBufferSubData(target, offset, size, Data);
end;

procedure TOpenGL_1_5.glGetBufferSubData(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: PGLvoid);
begin
  if Assigned(FGLGetBufferSubData) then
    FGLGetBufferSubData(target, offset, size, Data);
end;

function TOpenGL_1_5.glMapBuffer(target: GLenum; access: GLenum): PGLvoid;
begin
  if Assigned(FGLMapBuffer) then
    Result := FGLMapBuffer(target, access)
  else
    Result := nil;
end;

function TOpenGL_1_5.glUnmapBuffer(target: GLenum): GLboolean;
begin
  if Assigned(FGLUnmapBuffer) then
    Result := FGLUnmapBuffer(target)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_1_5.glGetBufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetBufferParameteriv) then
    FGLGetBufferParameteriv(target, pname, params);
end;

procedure TOpenGL_1_5.glGetBufferPointerv(target: GLenum; pname: GLenum; params: PPGLvoid);
begin
  if Assigned(FGLGetBufferPointerv) then
    FGLGetBufferPointerv(target, pname, params);
end;

function TOpenGL_1_5.glIsBuffer(buffer: GLuint): GLboolean;
begin
  if Assigned(FGLIsBuffer) then
    Result := FGLIsBuffer(buffer)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_1_5.glGenQueries(n: GLsizei; ids: PGLuint);
begin
  if Assigned(FGLGenQueries) then
    FGLGenQueries(n, ids);
end;

procedure TOpenGL_1_5.glDeleteQueries(n: GLsizei; const ids: PGLuint);
begin
  if Assigned(FGLDeleteQueries) then
    FGLDeleteQueries(n, ids);
end;

function TOpenGL_1_5.glIsQuery(id: GLuint): GLboolean;
begin
  if Assigned(FGLIsQuery) then
    Result := FGLIsQuery(id)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_1_5.glBeginQuery(target: GLenum; id: GLuint);
begin
  if Assigned(FGLBeginQuery) then
    FGLBeginQuery(target, id);
end;

procedure TOpenGL_1_5.glEndQuery(target: GLenum);
begin
  if Assigned(FGLEndQuery) then
    FGLEndQuery(target);
end;

procedure TOpenGL_1_5.glGetQueryiv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetQueryiv) then
    FGLGetQueryiv(target, pname, params);
end;

procedure TOpenGL_1_5.glGetQueryObjectiv(id: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetQueryObjectiv) then
    FGLGetQueryObjectiv(id, pname, params);
end;

procedure TOpenGL_1_5.glGetQueryObjectuiv(id: GLuint; pname: GLenum; params: PGLuint);
begin
  if Assigned(FGLGetQueryObjectuiv) then
    FGLGetQueryObjectuiv(id, pname, params);
end;

{ TOpenGL_2_0 }

procedure TOpenGL_2_0.bindEntry;
begin
  inherited bindEntry;

  Pointer(FGLCreateShader) := LoadProc('glCreateShader');
  Pointer(FGLDeleteShader) := LoadProc('glDeleteShader');
  Pointer(FGLShaderSource) := LoadProc('glShaderSource');
  Pointer(FGLCompileShader) := LoadProc('glCompileShader');
  Pointer(FGLGetShaderiv) := LoadProc('glGetShaderiv');
  Pointer(FGLGetShaderInfoLog) := LoadProc('glGetShaderInfoLog');
  Pointer(FGLAttachShader) := LoadProc('glAttachShader');
  Pointer(FGLDetachShader) := LoadProc('glDetachShader');
  Pointer(FGLCreateProgram) := LoadProc('glCreateProgram');
  Pointer(FGLDeleteProgram) := LoadProc('glDeleteProgram');
  Pointer(FGLLinkProgram) := LoadProc('glLinkProgram');
  Pointer(FGLUseProgram) := LoadProc('glUseProgram');
  Pointer(FGLValidateProgram) := LoadProc('glValidateProgram');
  Pointer(FGLGetProgramiv) := LoadProc('glGetProgramiv');
  Pointer(FGLGetProgramInfoLog) := LoadProc('glGetProgramInfoLog');
  Pointer(FGLIsShader) := LoadProc('glIsShader');
  Pointer(FGLIsProgram) := LoadProc('glIsProgram');
  Pointer(FGLBindAttribLocation) := LoadProc('glBindAttribLocation');
  Pointer(FGLGetActiveAttrib) := LoadProc('glGetActiveAttrib');
  Pointer(FGLGetAttachedShaders) := LoadProc('glGetAttachedShaders');
  Pointer(FGLGetAttribLocation) := LoadProc('glGetAttribLocation');
  Pointer(FGLGetUniformLocation) := LoadProc('glGetUniformLocation');
  Pointer(FGLGetActiveUniform) := LoadProc('glGetActiveUniform');

  Pointer(FGLUniform1f) := LoadProc('glUniform1f');
  Pointer(FGLUniform2f) := LoadProc('glUniform2f');
  Pointer(FGLUniform3f) := LoadProc('glUniform3f');
  Pointer(FGLUniform4f) := LoadProc('glUniform4f');
  Pointer(FGLUniform1i) := LoadProc('glUniform1i');
  Pointer(FGLUniform2i) := LoadProc('glUniform2i');
  Pointer(FGLUniform3i) := LoadProc('glUniform3i');
  Pointer(FGLUniform4i) := LoadProc('glUniform4i');
  Pointer(FGLUniform1fv) := LoadProc('glUniform1fv');
  Pointer(FGLUniform2fv) := LoadProc('glUniform2fv');
  Pointer(FGLUniform3fv) := LoadProc('glUniform3fv');
  Pointer(FGLUniform4fv) := LoadProc('glUniform4fv');
  Pointer(FGLUniform1iv) := LoadProc('glUniform1iv');
  Pointer(FGLUniform2iv) := LoadProc('glUniform2iv');
  Pointer(FGLUniform3iv) := LoadProc('glUniform3iv');
  Pointer(FGLUniform4iv) := LoadProc('glUniform4iv');
  Pointer(FGLUniformMatrix2fv) := LoadProc('glUniformMatrix2fv');
  Pointer(FGLUniformMatrix3fv) := LoadProc('glUniformMatrix3fv');
  Pointer(FGLUniformMatrix4fv) := LoadProc('glUniformMatrix4fv');

  Pointer(FGLVertexAttribPointer) := LoadProc('glVertexAttribPointer');
  Pointer(FGLEnableVertexAttribArray) := LoadProc('glEnableVertexAttribArray');
  Pointer(FGLDisableVertexAttribArray) := LoadProc('glDisableVertexAttribArray');
  Pointer(FGLGetVertexAttribiv) := LoadProc('glGetVertexAttribiv');
  Pointer(FGLGetVertexAttribfv) := LoadProc('glGetVertexAttribfv');
  Pointer(FGLGetVertexAttribPointerv) := LoadProc('glGetVertexAttribPointerv');

  Pointer(FGLStencilOpSeparate) := LoadProc('glStencilOpSeparate');
  Pointer(FGLStencilFuncSeparate) := LoadProc('glStencilFuncSeparate');
  Pointer(FGLStencilMaskSeparate) := LoadProc('glStencilMaskSeparate');
  Pointer(FGLDrawBuffers) := LoadProc('glDrawBuffers');
end;

function TOpenGL_2_0.glCreateShader(shaderType: GLenum): GLuint;
begin
  if Assigned(FGLCreateShader) then
    Result := FGLCreateShader(shaderType)
  else
    Result := 0;
end;

procedure TOpenGL_2_0.glDeleteShader(shaderObj: GLuint);
begin
  if Assigned(FGLDeleteShader) then
    FGLDeleteShader(shaderObj);
end;

procedure TOpenGL_2_0.glShaderSource(shaderObj: GLuint; Count: GLsizei; const strings: PPGLchar; const length: PGLint);
begin
  if Assigned(FGLShaderSource) then
    FGLShaderSource(shaderObj, Count, strings, length);
end;

procedure TOpenGL_2_0.glCompileShader(shaderObj: GLuint);
begin
  if Assigned(FGLCompileShader) then
    FGLCompileShader(shaderObj);
end;

procedure TOpenGL_2_0.glGetShaderiv(shaderObj: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetShaderiv) then
    FGLGetShaderiv(shaderObj, pname, params);
end;

procedure TOpenGL_2_0.glGetShaderInfoLog(shaderObj: GLuint; maxLength: GLsizei; length: PGLint; infoLog: PGLchar);
begin
  if Assigned(FGLGetShaderInfoLog) then
    FGLGetShaderInfoLog(shaderObj, maxLength, length, infoLog);
end;

function TOpenGL_2_0.glIsShader(shaderObj: GLuint): GLboolean;
begin
  if Assigned(FGLIsShader) then
    Result := FGLIsShader(shaderObj)
  else
    Result := GL_FALSE;
end;

function TOpenGL_2_0.glCreateProgram: GLuint;
begin
  if Assigned(FGLCreateProgram) then
    Result := FGLCreateProgram()
  else
    Result := 0;
end;

procedure TOpenGL_2_0.glDeleteProgram(programObj: GLuint);
begin
  if Assigned(FGLDeleteProgram) then
    FGLDeleteProgram(programObj);
end;

procedure TOpenGL_2_0.glAttachShader(programObj, shaderObj: GLuint);
begin
  if Assigned(FGLAttachShader) then
    FGLAttachShader(programObj, shaderObj);
end;

procedure TOpenGL_2_0.glDetachShader(programObj, shaderObj: GLuint);
begin
  if Assigned(FGLDetachShader) then
    FGLDetachShader(programObj, shaderObj);
end;

procedure TOpenGL_2_0.glLinkProgram(programObj: GLuint);
begin
  if Assigned(FGLLinkProgram) then
    FGLLinkProgram(programObj);
end;

procedure TOpenGL_2_0.glUseProgram(programObj: GLuint);
begin
  if Assigned(FGLUseProgram) then
    FGLUseProgram(programObj);
end;

procedure TOpenGL_2_0.glValidateProgram(programObj: GLuint);
begin
  if Assigned(FGLValidateProgram) then
    FGLValidateProgram(programObj);
end;

procedure TOpenGL_2_0.glGetProgramiv(programObj: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetProgramiv) then
    FGLGetProgramiv(programObj, pname, params);
end;

procedure TOpenGL_2_0.glGetProgramInfoLog(programObj: GLuint; maxLength: GLsizei; length: PGLint; infoLog: PGLchar);
begin
  if Assigned(FGLGetProgramInfoLog) then
    FGLGetProgramInfoLog(programObj, maxLength, length, infoLog);
end;

function TOpenGL_2_0.glIsProgram(programObj: GLuint): GLboolean;
begin
  if Assigned(FGLIsProgram) then
    Result := FGLIsProgram(programObj)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_2_0.glBindAttribLocation(programObj: GLuint; index: GLuint; const Name: PGLchar);
begin
  if Assigned(FGLBindAttribLocation) then
    FGLBindAttribLocation(programObj, index, Name);
end;

procedure TOpenGL_2_0.glGetActiveAttrib(programObj, index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; typ: PGLenum; Name: PGLchar);
begin
  if Assigned(FGLGetActiveAttrib) then
    FGLGetActiveAttrib(programObj, index, bufSize, length, size, typ, Name);
end;

procedure TOpenGL_2_0.glGetAttachedShaders(programObj: GLuint; maxCount: GLsizei; Count: PGLsizei; shaders: PGLuint);
begin
  if Assigned(FGLGetAttachedShaders) then
    FGLGetAttachedShaders(programObj, maxCount, Count, shaders);
end;

function TOpenGL_2_0.glGetAttribLocation(programObj: GLuint; const Name: PGLchar): GLint;
begin
  if Assigned(FGLGetAttribLocation) then
    Result := FGLGetAttribLocation(programObj, Name)
  else
    Result := -1;
end;

function TOpenGL_2_0.glGetUniformLocation(programObj: GLuint; const Name: PGLchar): GLint;
begin
  if Assigned(FGLGetUniformLocation) then
    Result := FGLGetUniformLocation(programObj, Name)
  else
    Result := -1;
end;

procedure TOpenGL_2_0.glGetActiveUniform(programObj, index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; typ: PGLenum; Name: PGLchar);
begin
  if Assigned(FGLGetActiveUniform) then
    FGLGetActiveUniform(programObj, index, bufSize, length, size, typ, Name);
end;

// Uniforms float
procedure TOpenGL_2_0.glUniform1f(location: GLint; v0: GLfloat);
begin
  if Assigned(FGLUniform1f) then FGLUniform1f(location, v0);
end;

procedure TOpenGL_2_0.glUniform2f(location: GLint; v0, v1: GLfloat);
begin
  if Assigned(FGLUniform2f) then FGLUniform2f(location, v0, v1);
end;

procedure TOpenGL_2_0.glUniform3f(location: GLint; v0, v1, v2: GLfloat);
begin
  if Assigned(FGLUniform3f) then FGLUniform3f(location, v0, v1, v2);
end;

procedure TOpenGL_2_0.glUniform4f(location: GLint; v0, v1, v2, v3: GLfloat);
begin
  if Assigned(FGLUniform4f) then FGLUniform4f(location, v0, v1, v2, v3);
end;

// Uniforms int
procedure TOpenGL_2_0.glUniform1i(location: GLint; v0: GLint);
begin
  if Assigned(FGLUniform1i) then FGLUniform1i(location, v0);
end;

procedure TOpenGL_2_0.glUniform2i(location: GLint; v0, v1: GLint);
begin
  if Assigned(FGLUniform2i) then FGLUniform2i(location, v0, v1);
end;

procedure TOpenGL_2_0.glUniform3i(location: GLint; v0, v1, v2: GLint);
begin
  if Assigned(FGLUniform3i) then FGLUniform3i(location, v0, v1, v2);
end;

procedure TOpenGL_2_0.glUniform4i(location: GLint; v0, v1, v2, v3: GLint);
begin
  if Assigned(FGLUniform4i) then FGLUniform4i(location, v0, v1, v2, v3);
end;

// Uniform arrays float
procedure TOpenGL_2_0.glUniform1fv(location: GLint; Count: GLsizei; Value: PGLfloat);
begin
  if Assigned(FGLUniform1fv) then FGLUniform1fv(location, Count, Value);
end;

procedure TOpenGL_2_0.glUniform2fv(location: GLint; Count: GLsizei; Value: PGLfloat);
begin
  if Assigned(FGLUniform2fv) then FGLUniform2fv(location, Count, Value);
end;

procedure TOpenGL_2_0.glUniform3fv(location: GLint; Count: GLsizei; Value: PGLfloat);
begin
  if Assigned(FGLUniform3fv) then FGLUniform3fv(location, Count, Value);
end;

procedure TOpenGL_2_0.glUniform4fv(location: GLint; Count: GLsizei; Value: PGLfloat);
begin
  if Assigned(FGLUniform4fv) then FGLUniform4fv(location, Count, Value);
end;

// Uniform arrays int
procedure TOpenGL_2_0.glUniform1iv(location: GLint; Count: GLsizei; Value: PGLint);
begin
  if Assigned(FGLUniform1iv) then FGLUniform1iv(location, Count, Value);
end;

procedure TOpenGL_2_0.glUniform2iv(location: GLint; Count: GLsizei; Value: PGLint);
begin
  if Assigned(FGLUniform2iv) then FGLUniform2iv(location, Count, Value);
end;

procedure TOpenGL_2_0.glUniform3iv(location: GLint; Count: GLsizei; Value: PGLint);
begin
  if Assigned(FGLUniform3iv) then FGLUniform3iv(location, Count, Value);
end;

procedure TOpenGL_2_0.glUniform4iv(location: GLint; Count: GLsizei; Value: PGLint);
begin
  if Assigned(FGLUniform4iv) then FGLUniform4iv(location, Count, Value);
end;

// Matrices
procedure TOpenGL_2_0.glUniformMatrix2fv(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat);
begin
  if Assigned(FGLUniformMatrix2fv) then
    FGLUniformMatrix2fv(location, Count, transpose, Value);
end;

procedure TOpenGL_2_0.glUniformMatrix3fv(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat);
begin
  if Assigned(FGLUniformMatrix3fv) then
    FGLUniformMatrix3fv(location, Count, transpose, Value);
end;

procedure TOpenGL_2_0.glUniformMatrix4fv(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat);
begin
  if Assigned(FGLUniformMatrix4fv) then
    FGLUniformMatrix4fv(location, Count, transpose, Value);
end;

// Vertex attributes
procedure TOpenGL_2_0.glVertexAttribPointer(index: GLuint; size: GLint; typ: GLenum; normalized: GLboolean; stride: GLsizei; const pointer: Pointer);
begin
  if Assigned(FGLVertexAttribPointer) then
    FGLVertexAttribPointer(index, size, typ, normalized, stride, pointer);
end;

procedure TOpenGL_2_0.glEnableVertexAttribArray(index: GLuint);
begin
  if Assigned(FGLEnableVertexAttribArray) then
    FGLEnableVertexAttribArray(index);
end;

procedure TOpenGL_2_0.glDisableVertexAttribArray(index: GLuint);
begin
  if Assigned(FGLDisableVertexAttribArray) then
    FGLDisableVertexAttribArray(index);
end;

procedure TOpenGL_2_0.glGetVertexAttribiv(index: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetVertexAttribiv) then
    FGLGetVertexAttribiv(index, pname, params);
end;

procedure TOpenGL_2_0.glGetVertexAttribfv(index: GLuint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FGLGetVertexAttribfv) then
    FGLGetVertexAttribfv(index, pname, params);
end;

procedure TOpenGL_2_0.glGetVertexAttribPointerv(index: GLuint; pname: GLenum; pointer: PPointer);
begin
  if Assigned(FGLGetVertexAttribPointerv) then
    FGLGetVertexAttribPointerv(index, pname, pointer);
end;

// Stencil separate
procedure TOpenGL_2_0.glStencilOpSeparate(face, sfail, dpfail, dppass: GLenum);
begin
  if Assigned(FGLStencilOpSeparate) then
    FGLStencilOpSeparate(face, sfail, dpfail, dppass);
end;

procedure TOpenGL_2_0.glStencilFuncSeparate(face: GLenum; func: GLenum; ref: GLint; mask: GLuint);
begin
  if Assigned(FGLStencilFuncSeparate) then
    FGLStencilFuncSeparate(face, func, ref, mask);
end;

procedure TOpenGL_2_0.glStencilMaskSeparate(face: GLenum; mask: GLuint);
begin
  if Assigned(FGLStencilMaskSeparate) then
    FGLStencilMaskSeparate(face, mask);
end;

procedure TOpenGL_2_0.glDrawBuffers(n: GLsizei; const bufs: PGLenum);
begin
  if Assigned(FGLDrawBuffers) then
    FGLDrawBuffers(n, bufs);
end;

{ TOpenGL_2_1 }

procedure TOpenGL_2_1.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLUniformMatrix2x3fv) := LoadProc('glUniformMatrix2x3fv');
  Pointer(FGLUniformMatrix3x2fv) := LoadProc('glUniformMatrix3x2fv');
  Pointer(FGLUniformMatrix2x4fv) := LoadProc('glUniformMatrix2x4fv');
  Pointer(FGLUniformMatrix4x2fv) := LoadProc('glUniformMatrix4x2fv');
  Pointer(FGLUniformMatrix3x4fv) := LoadProc('glUniformMatrix3x4fv');
  Pointer(FGLUniformMatrix4x3fv) := LoadProc('glUniformMatrix4x3fv');
end;

procedure TOpenGL_2_1.glUniformMatrix2x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLUniformMatrix2x3fv) then
    FGLUniformMatrix2x3fv(location, Count, transpose, Value);
end;

procedure TOpenGL_2_1.glUniformMatrix3x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLUniformMatrix3x2fv) then
    FGLUniformMatrix3x2fv(location, Count, transpose, Value);
end;

procedure TOpenGL_2_1.glUniformMatrix2x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLUniformMatrix2x4fv) then
    FGLUniformMatrix2x4fv(location, Count, transpose, Value);
end;

procedure TOpenGL_2_1.glUniformMatrix4x2fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLUniformMatrix4x2fv) then
    FGLUniformMatrix4x2fv(location, Count, transpose, Value);
end;

procedure TOpenGL_2_1.glUniformMatrix3x4fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLUniformMatrix3x4fv) then
    FGLUniformMatrix3x4fv(location, Count, transpose, Value);
end;

procedure TOpenGL_2_1.glUniformMatrix4x3fv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLUniformMatrix4x3fv) then
    FGLUniformMatrix4x3fv(location, Count, transpose, Value);
end;

{ TOpenGL_3_0 }

procedure TOpenGL_3_0.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLColorMaski) := LoadProc('glColorMaski');
  Pointer(FGLGetBooleani_v) := LoadProc('glGetBooleani_v');
  Pointer(FGLGetIntegeri_v) := LoadProc('glGetIntegeri_v');
  Pointer(FGLEnablei) := LoadProc('glEnablei');
  Pointer(FGLDisablei) := LoadProc('glDisablei');
  Pointer(FGLIsEnabledi) := LoadProc('glIsEnabledi');
  Pointer(FGLBeginTransformFeedback) := LoadProc('glBeginTransformFeedback');
  Pointer(FGLEndTransformFeedback) := LoadProc('glEndTransformFeedback');
  Pointer(FGLBindBufferRange) := LoadProc('glBindBufferRange');
  Pointer(FGLBindBufferBase) := LoadProc('glBindBufferBase');
  Pointer(FGLTransformFeedbackVaryings) := LoadProc('glTransformFeedbackVaryings');
  Pointer(FGLGetTransformFeedbackVarying) := LoadProc('glGetTransformFeedbackVarying');
  Pointer(FGLClampColor) := LoadProc('glClampColor');
  Pointer(FGLBeginConditionalRender) := LoadProc('glBeginConditionalRender');
  Pointer(FGLEndConditionalRender) := LoadProc('glEndConditionalRender');
  Pointer(FGLVertexAttribIPointer) := LoadProc('glVertexAttribIPointer');
  Pointer(FGLGetVertexAttribIiv) := LoadProc('glGetVertexAttribIiv');
  Pointer(FGLGetVertexAttribIuiv) := LoadProc('glGetVertexAttribIuiv');
  Pointer(FGLVertexAttribI1i) := LoadProc('glVertexAttribI1i');
  Pointer(FGLVertexAttribI2i) := LoadProc('glVertexAttribI2i');
  Pointer(FGLVertexAttribI3i) := LoadProc('glVertexAttribI3i');
  Pointer(FGLVertexAttribI4i) := LoadProc('glVertexAttribI4i');
  Pointer(FGLVertexAttribI1ui) := LoadProc('glVertexAttribI1ui');
  Pointer(FGLVertexAttribI2ui) := LoadProc('glVertexAttribI2ui');
  Pointer(FGLVertexAttribI3ui) := LoadProc('glVertexAttribI3ui');
  Pointer(FGLVertexAttribI4ui) := LoadProc('glVertexAttribI4ui');
  Pointer(FGLVertexAttribI1iv) := LoadProc('glVertexAttribI1iv');
  Pointer(FGLVertexAttribI2iv) := LoadProc('glVertexAttribI2iv');
  Pointer(FGLVertexAttribI3iv) := LoadProc('glVertexAttribI3iv');
  Pointer(FGLVertexAttribI4iv) := LoadProc('glVertexAttribI4iv');
  Pointer(FGLVertexAttribI1uiv) := LoadProc('glVertexAttribI1uiv');
  Pointer(FGLVertexAttribI2uiv) := LoadProc('glVertexAttribI2uiv');
  Pointer(FGLVertexAttribI3uiv) := LoadProc('glVertexAttribI3uiv');
  Pointer(FGLVertexAttribI4uiv) := LoadProc('glVertexAttribI4uiv');
  Pointer(FGLVertexAttribI4bv) := LoadProc('glVertexAttribI4bv');
  Pointer(FGLVertexAttribI4sv) := LoadProc('glVertexAttribI4sv');
  Pointer(FGLVertexAttribI4ubv) := LoadProc('glVertexAttribI4ubv');
  Pointer(FGLVertexAttribI4usv) := LoadProc('glVertexAttribI4usv');
  Pointer(FGLGetUniformuiv) := LoadProc('glGetUniformuiv');
  Pointer(FGLBindFragDataLocation) := LoadProc('glBindFragDataLocation');
  Pointer(FGLGetFragDataLocation) := LoadProc('glGetFragDataLocation');
  Pointer(FGLUniform1ui) := LoadProc('glUniform1ui');
  Pointer(FGLUniform2ui) := LoadProc('glUniform2ui');
  Pointer(FGLUniform3ui) := LoadProc('glUniform3ui');
  Pointer(FGLUniform4ui) := LoadProc('glUniform4ui');
  Pointer(FGLUniform1uiv) := LoadProc('glUniform1uiv');
  Pointer(FGLUniform2uiv) := LoadProc('glUniform2uiv');
  Pointer(FGLUniform3uiv) := LoadProc('glUniform3uiv');
  Pointer(FGLUniform4uiv) := LoadProc('glUniform4uiv');
  Pointer(FGLTexParameterIiv) := LoadProc('glTexParameterIiv');
  Pointer(FGLTexParameterIuiv) := LoadProc('glTexParameterIuiv');
  Pointer(FGLGetTexParameterIiv) := LoadProc('glGetTexParameterIiv');
  Pointer(FGLGetTexParameterIuiv) := LoadProc('glGetTexParameterIuiv');
  Pointer(FGLClearBufferiv) := LoadProc('glClearBufferiv');
  Pointer(FGLClearBufferuiv) := LoadProc('glClearBufferuiv');
  Pointer(FGLClearBufferfv) := LoadProc('glClearBufferfv');
  Pointer(FGLClearBufferfi) := LoadProc('glClearBufferfi');
  Pointer(FGLGetStringi) := LoadProc('glGetStringi');
  Pointer(FGLIsRenderbuffer) := LoadProc('glIsRenderbuffer');
  Pointer(FGLBindRenderbuffer) := LoadProc('glBindRenderbuffer');
  Pointer(FGLDeleteRenderbuffers) := LoadProc('glDeleteRenderbuffers');
  Pointer(FGLGenRenderbuffers) := LoadProc('glGenRenderbuffers');
  Pointer(FGLRenderbufferStorage) := LoadProc('glRenderbufferStorage');
  Pointer(FGLGetRenderbufferParameteriv) := LoadProc('glGetRenderbufferParameteriv');
  Pointer(FGLIsFramebuffer) := LoadProc('glIsFramebuffer');
  Pointer(FGLBindFramebuffer) := LoadProc('glBindFramebuffer');
  Pointer(FGLDeleteFramebuffers) := LoadProc('glDeleteFramebuffers');
  Pointer(FGLGenFramebuffers) := LoadProc('glGenFramebuffers');
  Pointer(FGLCheckFramebufferStatus) := LoadProc('glCheckFramebufferStatus');
  Pointer(FGLFramebufferTexture1D) := LoadProc('glFramebufferTexture1D');
  Pointer(FGLFramebufferTexture2D) := LoadProc('glFramebufferTexture2D');
  Pointer(FGLFramebufferTexture3D) := LoadProc('glFramebufferTexture3D');
  Pointer(FGLFramebufferRenderbuffer) := LoadProc('glFramebufferRenderbuffer');
  Pointer(FGLGetFramebufferAttachmentParameteriv) := LoadProc('glGetFramebufferAttachmentParameteriv');
  Pointer(FGLGenerateMipmap) := LoadProc('glGenerateMipmap');
  Pointer(FGLBlitFramebuffer) := LoadProc('glBlitFramebuffer');
  Pointer(FGLRenderbufferStorageMultisample) := LoadProc('glRenderbufferStorageMultisample');
  Pointer(FGLFramebufferTextureLayer) := LoadProc('glFramebufferTextureLayer');

  Pointer(FGLMapBufferRange) := LoadProc('glMapBufferRange');
  Pointer(FGLFlushMappedBufferRange) := LoadProc('glFlushMappedBufferRange');
  Pointer(FGLBindVertexArray) := LoadProc('glBindVertexArray');
  Pointer(FGLDeleteVertexArrays) := LoadProc('glDeleteVertexArrays');
  Pointer(FGLGenVertexArrays) := LoadProc('glGenVertexArrays');
  Pointer(FGLIsVertexArray) := LoadProc('glIsVertexArray');

end;

procedure TOpenGL_3_0.glColorMaski(index: GLuint; r, g, b, a: GLboolean);
begin
  if Assigned(FGLColorMaski) then
    FGLColorMaski(index, r, g, b, a);
end;

procedure TOpenGL_3_0.glGetBooleani_v(target: GLenum; index: GLuint; Data: PGLboolean);
begin
  if Assigned(FGLGetBooleani_v) then
    FGLGetBooleani_v(target, index, Data);
end;

procedure TOpenGL_3_0.glGetIntegeri_v(target: GLenum; index: GLuint; Data: PGLint);
begin
  if Assigned(FGLGetIntegeri_v) then
    FGLGetIntegeri_v(target, index, Data);
end;

procedure TOpenGL_3_0.glEnablei(target: GLenum; index: GLuint);
begin
  if Assigned(FGLEnablei) then
    FGLEnablei(target, index);
end;

procedure TOpenGL_3_0.glDisablei(target: GLenum; index: GLuint);
begin
  if Assigned(FGLDisablei) then
    FGLDisablei(target, index);
end;

function TOpenGL_3_0.glIsEnabledi(target: GLenum; index: GLuint): GLboolean;
begin
  if Assigned(FGLIsEnabledi) then
    Result := FGLIsEnabledi(target, index)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_3_0.glBeginTransformFeedback(primitiveMode: GLenum);
begin
  if Assigned(FGLBeginTransformFeedback) then
    FGLBeginTransformFeedback(primitiveMode);
end;

procedure TOpenGL_3_0.glEndTransformFeedback;
begin
  if Assigned(FGLEndTransformFeedback) then
    FGLEndTransformFeedback;
end;

procedure TOpenGL_3_0.glBindBufferRange(target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FGLBindBufferRange) then
    FGLBindBufferRange(target, index, buffer, offset, size);
end;

procedure TOpenGL_3_0.glBindBufferBase(target: GLenum; index: GLuint; buffer: GLuint);
begin
  if Assigned(FGLBindBufferBase) then
    FGLBindBufferBase(target, index, buffer);
end;

procedure TOpenGL_3_0.glTransformFeedbackVaryings(aProgram: GLuint; Count: GLsizei; const varyings: PPGLchar; bufferMode: GLenum);
begin
  if Assigned(FGLTransformFeedbackVaryings) then
    FGLTransformFeedbackVaryings(aProgram, Count, varyings, bufferMode);
end;

procedure TOpenGL_3_0.glGetTransformFeedbackVarying(aProgram: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; aType: PGLenum; Name: PGLchar);
begin
  if Assigned(FGLGetTransformFeedbackVarying) then
    FGLGetTransformFeedbackVarying(aProgram, index, bufSize, length, size, aType, Name);
end;

procedure TOpenGL_3_0.glClampColor(target: GLenum; clamp: GLenum);
begin
  if Assigned(FGLClampColor) then
    FGLClampColor(target, clamp);
end;

procedure TOpenGL_3_0.glBeginConditionalRender(id: GLuint; mode: GLenum);
begin
  if Assigned(FGLBeginConditionalRender) then
    FGLBeginConditionalRender(id, mode);
end;

procedure TOpenGL_3_0.glEndConditionalRender;
begin
  if Assigned(FGLEndConditionalRender) then
    FGLEndConditionalRender;
end;

procedure TOpenGL_3_0.glVertexAttribIPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const pointer: Pointer);
begin
  if Assigned(FGLVertexAttribIPointer) then
    FGLVertexAttribIPointer(index, size, aType, stride, pointer);
end;

procedure TOpenGL_3_0.glGetVertexAttribIiv(index: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetVertexAttribIiv) then
    FGLGetVertexAttribIiv(index, pname, params);
end;

procedure TOpenGL_3_0.glGetVertexAttribIuiv(index: GLuint; pname: GLenum; params: PGLuint);
begin
  if Assigned(FGLGetVertexAttribIuiv) then
    FGLGetVertexAttribIuiv(index, pname, params);
end;

// Integer vertex attributes (1-4 componenti)
procedure TOpenGL_3_0.glVertexAttribI1i(index: GLuint; x: GLint);
begin
  if Assigned(FGLVertexAttribI1i) then FGLVertexAttribI1i(index, x);
end;

procedure TOpenGL_3_0.glVertexAttribI2i(index: GLuint; x, y: GLint);
begin
  if Assigned(FGLVertexAttribI2i) then FGLVertexAttribI2i(index, x, y);
end;

procedure TOpenGL_3_0.glVertexAttribI3i(index: GLuint; x, y, z: GLint);
begin
  if Assigned(FGLVertexAttribI3i) then FGLVertexAttribI3i(index, x, y, z);
end;

procedure TOpenGL_3_0.glVertexAttribI4i(index: GLuint; x, y, z, w: GLint);
begin
  if Assigned(FGLVertexAttribI4i) then FGLVertexAttribI4i(index, x, y, z, w);
end;

procedure TOpenGL_3_0.glVertexAttribI1ui(index: GLuint; x: GLuint);
begin
  if Assigned(FGLVertexAttribI1ui) then FGLVertexAttribI1ui(index, x);
end;

procedure TOpenGL_3_0.glVertexAttribI2ui(index: GLuint; x, y: GLuint);
begin
  if Assigned(FGLVertexAttribI2ui) then FGLVertexAttribI2ui(index, x, y);
end;

procedure TOpenGL_3_0.glVertexAttribI3ui(index: GLuint; x, y, z: GLuint);
begin
  if Assigned(FGLVertexAttribI3ui) then FGLVertexAttribI3ui(index, x, y, z);
end;

procedure TOpenGL_3_0.glVertexAttribI4ui(index: GLuint; x, y, z, w: GLuint);
begin
  if Assigned(FGLVertexAttribI4ui) then FGLVertexAttribI4ui(index, x, y, z, w);
end;

procedure TOpenGL_3_0.glVertexAttribI1iv(index: GLuint; const v: PGLint);
begin
  if Assigned(FGLVertexAttribI1iv) then FGLVertexAttribI1iv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI2iv(index: GLuint; const v: PGLint);
begin
  if Assigned(FGLVertexAttribI2iv) then FGLVertexAttribI2iv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI3iv(index: GLuint; const v: PGLint);
begin
  if Assigned(FGLVertexAttribI3iv) then FGLVertexAttribI3iv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI4iv(index: GLuint; const v: PGLint);
begin
  if Assigned(FGLVertexAttribI4iv) then FGLVertexAttribI4iv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI1uiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FGLVertexAttribI1uiv) then FGLVertexAttribI1uiv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI2uiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FGLVertexAttribI2uiv) then FGLVertexAttribI2uiv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI3uiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FGLVertexAttribI3uiv) then FGLVertexAttribI3uiv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI4uiv(index: GLuint; const v: PGLuint);
begin
  if Assigned(FGLVertexAttribI4uiv) then FGLVertexAttribI4uiv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI4bv(index: GLuint; const v: PGLbyte);
begin
  if Assigned(FGLVertexAttribI4bv) then FGLVertexAttribI4bv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI4sv(index: GLuint; const v: PGLshort);
begin
  if Assigned(FGLVertexAttribI4sv) then FGLVertexAttribI4sv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI4ubv(index: GLuint; const v: PGLubyte);
begin
  if Assigned(FGLVertexAttribI4ubv) then FGLVertexAttribI4ubv(index, v);
end;

procedure TOpenGL_3_0.glVertexAttribI4usv(index: GLuint; const v: PGLushort);
begin
  if Assigned(FGLVertexAttribI4usv) then FGLVertexAttribI4usv(index, v);
end;

procedure TOpenGL_3_0.glGetUniformuiv(aProgram: GLuint; location: GLint; params: PGLuint);
begin
  if Assigned(FGLGetUniformuiv) then
    FGLGetUniformuiv(aProgram, location, params);
end;

procedure TOpenGL_3_0.glBindFragDataLocation(aProgram: GLuint; color: GLuint; const Name: PGLchar);
begin
  if Assigned(FGLBindFragDataLocation) then
    FGLBindFragDataLocation(aProgram, color, Name);
end;

function TOpenGL_3_0.glGetFragDataLocation(aProgram: GLuint; const Name: PGLchar): GLint;
begin
  if Assigned(FGLGetFragDataLocation) then
    Result := FGLGetFragDataLocation(aProgram, Name)
  else
    Result := -1;
end;

procedure TOpenGL_3_0.glUniform1ui(location: GLint; v0: GLuint);
begin
  if Assigned(FGLUniform1ui) then FGLUniform1ui(location, v0);
end;

procedure TOpenGL_3_0.glUniform2ui(location: GLint; v0, v1: GLuint);
begin
  if Assigned(FGLUniform2ui) then FGLUniform2ui(location, v0, v1);
end;

procedure TOpenGL_3_0.glUniform3ui(location: GLint; v0, v1, v2: GLuint);
begin
  if Assigned(FGLUniform3ui) then FGLUniform3ui(location, v0, v1, v2);
end;

procedure TOpenGL_3_0.glUniform4ui(location: GLint; v0, v1, v2, v3: GLuint);
begin
  if Assigned(FGLUniform4ui) then FGLUniform4ui(location, v0, v1, v2, v3);
end;

procedure TOpenGL_3_0.glUniform1uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FGLUniform1uiv) then FGLUniform1uiv(location, Count, Value);
end;

procedure TOpenGL_3_0.glUniform2uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FGLUniform2uiv) then FGLUniform2uiv(location, Count, Value);
end;

procedure TOpenGL_3_0.glUniform3uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FGLUniform3uiv) then FGLUniform3uiv(location, Count, Value);
end;

procedure TOpenGL_3_0.glUniform4uiv(location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FGLUniform4uiv) then FGLUniform4uiv(location, Count, Value);
end;

procedure TOpenGL_3_0.glTexParameterIiv(target: GLenum; pname: GLenum; const params: PGLint);
begin
  if Assigned(FGLTexParameterIiv) then FGLTexParameterIiv(target, pname, params);
end;

procedure TOpenGL_3_0.glTexParameterIuiv(target: GLenum; pname: GLenum; const params: PGLuint);
begin
  if Assigned(FGLTexParameterIuiv) then FGLTexParameterIuiv(target, pname, params);
end;

procedure TOpenGL_3_0.glGetTexParameterIiv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetTexParameterIiv) then FGLGetTexParameterIiv(target, pname, params);
end;

procedure TOpenGL_3_0.glGetTexParameterIuiv(target: GLenum; pname: GLenum; params: PGLuint);
begin
  if Assigned(FGLGetTexParameterIuiv) then FGLGetTexParameterIuiv(target, pname, params);
end;

procedure TOpenGL_3_0.glClearBufferiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLint);
begin
  if Assigned(FGLClearBufferiv) then FGLClearBufferiv(buffer, drawbuffer, Value);
end;

procedure TOpenGL_3_0.glClearBufferuiv(buffer: GLenum; drawbuffer: GLint; const Value: PGLuint);
begin
  if Assigned(FGLClearBufferuiv) then FGLClearBufferuiv(buffer, drawbuffer, Value);
end;

procedure TOpenGL_3_0.glClearBufferfv(buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat);
begin
  if Assigned(FGLClearBufferfv) then FGLClearBufferfv(buffer, drawbuffer, Value);
end;

procedure TOpenGL_3_0.glClearBufferfi(buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint);
begin
  if Assigned(FGLClearBufferfi) then FGLClearBufferfi(buffer, drawbuffer, depth, stencil);
end;

function TOpenGL_3_0.glGetStringi(Name: GLenum; index: GLuint): PGLubyte;
begin
  if Assigned(FGLGetStringi) then
    Result := FGLGetStringi(Name, index)
  else
    Result := nil;
end;

// Renderbuffer Objects
function TOpenGL_3_0.glIsRenderbuffer(renderbuffer: GLuint): GLboolean;
begin
  if Assigned(FGLIsRenderbuffer) then Result := FGLIsRenderbuffer(renderbuffer)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_3_0.glBindRenderbuffer(target: GLenum; renderbuffer: GLuint);
begin
  if Assigned(FGLBindRenderbuffer) then FGLBindRenderbuffer(target, renderbuffer);
end;

procedure TOpenGL_3_0.glDeleteRenderbuffers(n: GLsizei; const renderbuffers: PGLuint);
begin
  if Assigned(FGLDeleteRenderbuffers) then FGLDeleteRenderbuffers(n, renderbuffers);
end;

procedure TOpenGL_3_0.glGenRenderbuffers(n: GLsizei; renderbuffers: PGLuint);
begin
  if Assigned(FGLGenRenderbuffers) then FGLGenRenderbuffers(n, renderbuffers);
end;

procedure TOpenGL_3_0.glRenderbufferStorage(target: GLenum; internalformat: GLenum; Width, Height: GLsizei);
begin
  if Assigned(FGLRenderbufferStorage) then FGLRenderbufferStorage(target, internalformat, Width, Height);
end;

procedure TOpenGL_3_0.glGetRenderbufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetRenderbufferParameteriv) then FGLGetRenderbufferParameteriv(target, pname, params);
end;

// Framebuffer Objects
function TOpenGL_3_0.glIsFramebuffer(framebuffer: GLuint): GLboolean;
begin
  if Assigned(FGLIsFramebuffer) then Result := FGLIsFramebuffer(framebuffer)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_3_0.glBindFramebuffer(target: GLenum; framebuffer: GLuint);
begin
  if Assigned(FGLBindFramebuffer) then FGLBindFramebuffer(target, framebuffer);
end;

procedure TOpenGL_3_0.glDeleteFramebuffers(n: GLsizei; const framebuffers: PGLuint);
begin
  if Assigned(FGLDeleteFramebuffers) then FGLDeleteFramebuffers(n, framebuffers);
end;

procedure TOpenGL_3_0.glGenFramebuffers(n: GLsizei; framebuffers: PGLuint);
begin
  if Assigned(FGLGenFramebuffers) then FGLGenFramebuffers(n, framebuffers);
end;

function TOpenGL_3_0.glCheckFramebufferStatus(target: GLenum): GLenum;
begin
  if Assigned(FGLCheckFramebufferStatus) then Result := FGLCheckFramebufferStatus(target)
  else
    Result := GL_FRAMEBUFFER_UNDEFINED;
end;

procedure TOpenGL_3_0.glFramebufferTexture1D(target, attachment, textarget: GLenum; texture: GLuint; level: GLint);
begin
  if Assigned(FGLFramebufferTexture1D) then FGLFramebufferTexture1D(target, attachment, textarget, texture, level);
end;

procedure TOpenGL_3_0.glFramebufferTexture2D(target, attachment, textarget: GLenum; texture: GLuint; level: GLint);
begin
  if Assigned(FGLFramebufferTexture2D) then FGLFramebufferTexture2D(target, attachment, textarget, texture, level);
end;

procedure TOpenGL_3_0.glFramebufferTexture3D(target, attachment, textarget: GLenum; texture: GLuint; level, zoffset: GLint);
begin
  if Assigned(FGLFramebufferTexture3D) then FGLFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
end;

procedure TOpenGL_3_0.glFramebufferRenderbuffer(target, attachment, renderbuffertarget: GLenum; renderbuffer: GLuint);
begin
  if Assigned(FGLFramebufferRenderbuffer) then FGLFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
end;

procedure TOpenGL_3_0.glGetFramebufferAttachmentParameteriv(target, attachment, pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetFramebufferAttachmentParameteriv) then FGLGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
end;

procedure TOpenGL_3_0.glGenerateMipmap(target: GLenum);
begin
  if Assigned(FGLGenerateMipmap) then FGLGenerateMipmap(target);
end;

procedure TOpenGL_3_0.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1: GLint; mask: GLbitfield; filter: GLenum);
begin
  if Assigned(FGLBlitFramebuffer) then
    FGLBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
end;

procedure TOpenGL_3_0.glRenderbufferStorageMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei);
begin
  if Assigned(FGLRenderbufferStorageMultisample) then
    FGLRenderbufferStorageMultisample(target, samples, internalformat, Width, Height);
end;

procedure TOpenGL_3_0.glFramebufferTextureLayer(target, attachment: GLenum; texture: GLuint; level, layer: GLint);
begin
  if Assigned(FGLFramebufferTextureLayer) then
    FGLFramebufferTextureLayer(target, attachment, texture, level, layer);
end;

function TOpenGL_3_0.glMapBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer;
begin
  if Assigned(FGLMapBufferRange) then
    Result := FGLMapBufferRange(target, offset, length, access)
  else
    Result := nil;
end;

procedure TOpenGL_3_0.glFlushMappedBufferRange(target: GLenum; offset: GLintptr; length: GLsizeiptr);
begin
  if Assigned(FGLFlushMappedBufferRange) then
    FGLFlushMappedBufferRange(target, offset, length);
end;

// Vertex Array Objects
procedure TOpenGL_3_0.glBindVertexArray(array_: GLuint);
begin
  if Assigned(FGLBindVertexArray) then
    FGLBindVertexArray(array_);
end;

procedure TOpenGL_3_0.glDeleteVertexArrays(n: GLsizei; const arrays: PGLuint);
begin
  if Assigned(FGLDeleteVertexArrays) then
    FGLDeleteVertexArrays(n, arrays);
end;

procedure TOpenGL_3_0.glGenVertexArrays(n: GLsizei; arrays: PGLuint);
begin
  if Assigned(FGLGenVertexArrays) then
    FGLGenVertexArrays(n, arrays);
end;

function TOpenGL_3_0.glIsVertexArray(array_: GLuint): GLboolean;
begin
  if Assigned(FGLIsVertexArray) then
    Result := FGLIsVertexArray(array_)
  else
    Result := GL_FALSE;
end;
{ TOpenGL_3_1 }

procedure TOpenGL_3_1.bindEntry;
begin
  inherited bindEntry;

  Pointer(FGLDrawArraysInstanced) := LoadProc('glDrawArraysInstanced');
  Pointer(FGLDrawElementsInstanced) := LoadProc('glDrawElementsInstanced');
  Pointer(FGLTexBuffer) := LoadProc('glTexBuffer');
  Pointer(FGLPrimitiveRestartIndex) := LoadProc('glPrimitiveRestartIndex');
  Pointer(FGLCopyBufferSubData) := LoadProc('glCopyBufferSubData');
  Pointer(FGLGetUniformIndices) := LoadProc('glGetUniformIndices');
  Pointer(FGLGetActiveUniformsiv) := LoadProc('glGetActiveUniformsiv');
  Pointer(FGLGetActiveUniformName) := LoadProc('glGetActiveUniformName');
  Pointer(FGLGetUniformBlockIndex) := LoadProc('glGetUniformBlockIndex');
  Pointer(FGLGetActiveUniformBlockiv) := LoadProc('glGetActiveUniformBlockiv');
  Pointer(FGLGetActiveUniformBlockName) := LoadProc('glGetActiveUniformBlockName');
  Pointer(FGLUniformBlockBinding) := LoadProc('glUniformBlockBinding');
end;

procedure TOpenGL_3_1.glDrawArraysInstanced(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei);
begin
  if Assigned(FGLDrawArraysInstanced) then
    FGLDrawArraysInstanced(mode, First, Count, instancecount);
end;

procedure TOpenGL_3_1.glDrawElementsInstanced(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei);
begin
  if Assigned(FGLDrawElementsInstanced) then
    FGLDrawElementsInstanced(mode, Count, aType, indices, instancecount);
end;

procedure TOpenGL_3_1.glTexBuffer(target: GLenum; internalformat: GLenum; buffer: GLuint);
begin
  if Assigned(FGLTexBuffer) then
    FGLTexBuffer(target, internalformat, buffer);
end;

procedure TOpenGL_3_1.glPrimitiveRestartIndex(index: GLuint);
begin
  if Assigned(FGLPrimitiveRestartIndex) then
    FGLPrimitiveRestartIndex(index);
end;

procedure TOpenGL_3_1.glCopyBufferSubData(readTarget, writeTarget: GLenum; readOffset, writeOffset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FGLCopyBufferSubData) then
    FGLCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
end;

procedure TOpenGL_3_1.glGetUniformIndices(aProgram: GLuint; uniformCount: GLsizei; const uniformNames: PPGLchar; uniformIndices: PGLuint);
begin
  if Assigned(FGLGetUniformIndices) then
    FGLGetUniformIndices(aProgram, uniformCount, uniformNames, uniformIndices);
end;

procedure TOpenGL_3_1.glGetActiveUniformsiv(aProgram: GLuint; uniformCount: GLsizei; const uniformIndices: PGLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetActiveUniformsiv) then
    FGLGetActiveUniformsiv(aProgram, uniformCount, uniformIndices, pname, params);
end;

procedure TOpenGL_3_1.glGetActiveUniformName(aProgram: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar);
begin
  if Assigned(FGLGetActiveUniformName) then
    FGLGetActiveUniformName(aProgram, uniformIndex, bufSize, length, uniformName);
end;

function TOpenGL_3_1.glGetUniformBlockIndex(aProgram: GLuint; const uniformBlockName: PGLchar): GLuint;
begin
  if Assigned(FGLGetUniformBlockIndex) then
    Result := FGLGetUniformBlockIndex(aProgram, uniformBlockName)
  else
    Result := GL_INVALID_INDEX;
end;

procedure TOpenGL_3_1.glGetActiveUniformBlockiv(aProgram: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetActiveUniformBlockiv) then
    FGLGetActiveUniformBlockiv(aProgram, uniformBlockIndex, pname, params);
end;

procedure TOpenGL_3_1.glGetActiveUniformBlockName(aProgram: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar);
begin
  if Assigned(FGLGetActiveUniformBlockName) then
    FGLGetActiveUniformBlockName(aProgram, uniformBlockIndex, bufSize, length, uniformBlockName);
end;

procedure TOpenGL_3_1.glUniformBlockBinding(aProgram: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint);
begin
  if Assigned(FGLUniformBlockBinding) then
    FGLUniformBlockBinding(aProgram, uniformBlockIndex, uniformBlockBinding);
end;



{ TOpenGL_3_2 }

procedure TOpenGL_3_2.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLDrawElementsBaseVertex) := LoadProc('glDrawElementsBaseVertex');
  Pointer(FGLDrawRangeElementsBaseVertex) := LoadProc('glDrawRangeElementsBaseVertex');
  Pointer(FGLDrawElementsInstancedBaseVertex) := LoadProc('glDrawElementsInstancedBaseVertex');
  Pointer(FGLMultiDrawElementsBaseVertex) := LoadProc('glMultiDrawElementsBaseVertex');
  Pointer(FGLProvokingVertex) := LoadProc('glProvokingVertex');
  Pointer(FGLFenceSync) := LoadProc('glFenceSync');
  Pointer(FGLIsSync) := LoadProc('glIsSync');
  Pointer(FGLDeleteSync) := LoadProc('glDeleteSync');
  Pointer(FGLClientWaitSync) := LoadProc('glClientWaitSync');
  Pointer(FGLWaitSync) := LoadProc('glWaitSync');
  Pointer(FGLGetInteger64v) := LoadProc('glGetInteger64v');
  Pointer(FGLGetSynciv) := LoadProc('glGetSynciv');
  Pointer(FGLGetInteger64i_v) := LoadProc('glGetInteger64i_v');
  Pointer(FGLGetBufferParameteri64v) := LoadProc('glGetBufferParameteri64v');
  Pointer(FGLFramebufferTexture) := LoadProc('glFramebufferTexture');
  Pointer(FGLTexImage2DMultisample) := LoadProc('glTexImage2DMultisample');
  Pointer(FGLTexImage3DMultisample) := LoadProc('glTexImage3DMultisample');
  Pointer(FGLGetMultisamplefv) := LoadProc('glGetMultisamplefv');
  Pointer(FGLSampleMaski) := LoadProc('glSampleMaski');
end;

procedure TOpenGL_3_2.glDrawElementsBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint);
begin
  if Assigned(FGLDrawElementsBaseVertex) then
    FGLDrawElementsBaseVertex(mode, Count, aType, indices, basevertex);
end;

procedure TOpenGL_3_2.glDrawRangeElementsBaseVertex(mode: GLenum; start, end_: GLuint; Count: GLsizei; aType: GLenum; const indices: Pointer; basevertex: GLint);
begin
  if Assigned(FGLDrawRangeElementsBaseVertex) then
    FGLDrawRangeElementsBaseVertex(mode, start, end_, Count, aType, indices, basevertex);
end;

procedure TOpenGL_3_2.glDrawElementsInstancedBaseVertex(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint);
begin
  if Assigned(FGLDrawElementsInstancedBaseVertex) then
    FGLDrawElementsInstancedBaseVertex(mode, Count, aType, indices, instancecount, basevertex);
end;

procedure TOpenGL_3_2.glMultiDrawElementsBaseVertex(mode: GLenum; const Count: PGLsizei; aType: GLenum; const indices: PPointer; drawcount: GLsizei; const basevertex: PGLint);
begin
  if Assigned(FGLMultiDrawElementsBaseVertex) then
    FGLMultiDrawElementsBaseVertex(mode, Count, aType, indices, drawcount, basevertex);
end;

procedure TOpenGL_3_2.glProvokingVertex(mode: GLenum);
begin
  if Assigned(FGLProvokingVertex) then
    FGLProvokingVertex(mode);
end;

function TOpenGL_3_2.glFenceSync(condition: GLenum; flags: GLbitfield): GLsync;
begin
  if Assigned(FGLFenceSync) then
    Result := FGLFenceSync(condition, flags)
  else
    Result := nil;
end;

function TOpenGL_3_2.glIsSync(sync: GLsync): GLboolean;
begin
  if Assigned(FGLIsSync) then
    Result := FGLIsSync(sync)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_3_2.glDeleteSync(sync: GLsync);
begin
  if Assigned(FGLDeleteSync) then
    FGLDeleteSync(sync);
end;

function TOpenGL_3_2.glClientWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum;
begin
  if Assigned(FGLClientWaitSync) then
    Result := FGLClientWaitSync(sync, flags, timeout)
  else
    Result := GL_TIMEOUT_EXPIRED;
end;

procedure TOpenGL_3_2.glWaitSync(sync: GLsync; flags: GLbitfield; timeout: GLuint64);
begin
  if Assigned(FGLWaitSync) then
    FGLWaitSync(sync, flags, timeout);
end;

procedure TOpenGL_3_2.glGetInteger64v(pname: GLenum; Data: PGLint64);
begin
  if Assigned(FGLGetInteger64v) then
    FGLGetInteger64v(pname, Data);
end;

procedure TOpenGL_3_2.glGetSynciv(sync: GLsync; pname: GLenum; bufSize: GLsizei; length: PGLsizei; values: PGLint);
begin
  if Assigned(FGLGetSynciv) then
    FGLGetSynciv(sync, pname, bufSize, length, values);
end;

procedure TOpenGL_3_2.glGetInteger64i_v(target: GLenum; index: GLuint; Data: PGLint64);
begin
  if Assigned(FGLGetInteger64i_v) then
    FGLGetInteger64i_v(target, index, Data);
end;

procedure TOpenGL_3_2.glGetBufferParameteri64v(target, pname: GLenum; params: PGLint64);
begin
  if Assigned(FGLGetBufferParameteri64v) then
    FGLGetBufferParameteri64v(target, pname, params);
end;

procedure TOpenGL_3_2.glFramebufferTexture(target, attachment: GLenum; texture: GLuint; level: GLint);
begin
  if Assigned(FGLFramebufferTexture) then
    FGLFramebufferTexture(target, attachment, texture, level);
end;

procedure TOpenGL_3_2.glTexImage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FGLTexImage2DMultisample) then
    FGLTexImage2DMultisample(target, samples, internalformat, Width, Height, fixedsamplelocations);
end;

procedure TOpenGL_3_2.glTexImage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FGLTexImage3DMultisample) then
    FGLTexImage3DMultisample(target, samples, internalformat, Width, Height, depth, fixedsamplelocations);
end;

procedure TOpenGL_3_2.glGetMultisamplefv(pname: GLenum; index: GLuint; val: PGLfloat);
begin
  if Assigned(FGLGetMultisamplefv) then
    FGLGetMultisamplefv(pname, index, val);
end;

procedure TOpenGL_3_2.glSampleMaski(maskNumber: GLuint; mask: GLbitfield);
begin
  if Assigned(FGLSampleMaski) then
    FGLSampleMaski(maskNumber, mask);
end;

(*
{ TOpenGL_3_2 }

procedure TOpenGL_3_2.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLDrawElementsBaseVertex) := LoadProc('glDrawElementsBaseVertex');
  Pointer(FGLDrawRangeElementsBaseVertex) := LoadProc('glDrawRangeElementsBaseVertex');
  Pointer(FGLDrawElementsInstancedBaseVertex) := LoadProc('glDrawElementsInstancedBaseVertex');
  Pointer(FGLMultiDrawElementsBaseVertex) := LoadProc('glMultiDrawElementsBaseVertex');
  Pointer(FGLProvokingVertex) := LoadProc('glProvokingVertex');
  Pointer(FGLFenceSync) := LoadProc('glFenceSync');
  Pointer(FGLIsSync) := LoadProc('glIsSync');
  Pointer(FGLDeleteSync) := LoadProc('glDeleteSync');
  Pointer(FGLClientWaitSync) := LoadProc('glClientWaitSync');
  Pointer(FGLWaitSync) := LoadProc('glWaitSync');
  Pointer(FGLGetInteger64v) := LoadProc('glGetInteger64v');
  Pointer(FGLGetSynciv) := LoadProc('glGetSynciv');
  Pointer(FGLGetInteger64i_v) := LoadProc('glGetInteger64i_v');
  Pointer(FGLGetBufferParameteri64v) := LoadProc('glGetBufferParameteri64v');
  Pointer(FGLFramebufferTexture) := LoadProc('glFramebufferTexture');
  Pointer(FGLTexImage2DMultisample) := LoadProc('glTexImage2DMultisample');
  Pointer(FGLTexImage3DMultisample) := LoadProc('glTexImage3DMultisample');
  Pointer(FGLGetMultisamplefv) := LoadProc('glGetMultisamplefv');
  Pointer(FGLSampleMaski) := LoadProc('glSampleMaski');
end;
*)

{ TOpenGL_3_3 }

procedure TOpenGL_3_3.bindEntry;
begin
  inherited bindEntry;

  Pointer(FGLBindFragDataLocationIndexed) := LoadProc('glBindFragDataLocationIndexed');
  Pointer(FGLGetFragDataIndex) := LoadProc('glGetFragDataIndex');

  Pointer(FGLGenSamplers) := LoadProc('glGenSamplers');
  Pointer(FGLDeleteSamplers) := LoadProc('glDeleteSamplers');
  Pointer(FGLIsSampler) := LoadProc('glIsSampler');
  Pointer(FGLBindSampler) := LoadProc('glBindSampler');

  Pointer(FGLSamplerParameteri) := LoadProc('glSamplerParameteri');
  Pointer(FGLSamplerParameteriv) := LoadProc('glSamplerParameteriv');
  Pointer(FGLSamplerParameterf) := LoadProc('glSamplerParameterf');
  Pointer(FGLSamplerParameterfv) := LoadProc('glSamplerParameterfv');
  Pointer(FGLSamplerParameterIiv) := LoadProc('glSamplerParameterIiv');
  Pointer(FGLSamplerParameterIuiv) := LoadProc('glSamplerParameterIuiv');

  Pointer(FGLGetSamplerParameteriv) := LoadProc('glGetSamplerParameteriv');
  Pointer(FGLGetSamplerParameterIiv) := LoadProc('glGetSamplerParameterIiv');
  Pointer(FGLGetSamplerParameterfv) := LoadProc('glGetSamplerParameterfv');
  Pointer(FGLGetSamplerParameterIuiv) := LoadProc('glGetSamplerParameterIuiv');

  Pointer(FGLQueryCounter) := LoadProc('glQueryCounter');
  Pointer(FGLGetQueryObjecti64v) := LoadProc('glGetQueryObjecti64v');
  Pointer(FGLGetQueryObjectui64v) := LoadProc('glGetQueryObjectui64v');

  Pointer(FGLVertexAttribDivisor) := LoadProc('glVertexAttribDivisor');

  Pointer(FGLVertexAttribP1ui) := LoadProc('glVertexAttribP1ui');
  Pointer(FGLVertexAttribP1uiv) := LoadProc('glVertexAttribP1uiv');
  Pointer(FGLVertexAttribP2ui) := LoadProc('glVertexAttribP2ui');
  Pointer(FGLVertexAttribP2uiv) := LoadProc('glVertexAttribP2uiv');
  Pointer(FGLVertexAttribP3ui) := LoadProc('glVertexAttribP3ui');
  Pointer(FGLVertexAttribP3uiv) := LoadProc('glVertexAttribP3uiv');
  Pointer(FGLVertexAttribP4ui) := LoadProc('glVertexAttribP4ui');
  Pointer(FGLVertexAttribP4uiv) := LoadProc('glVertexAttribP4uiv');
end;

procedure TOpenGL_3_3.glBindFragDataLocationIndexed(aProgram: GLuint; colorNumber: GLuint; index: GLuint; const Name: PGLchar);
begin
  if Assigned(FGLBindFragDataLocationIndexed) then
    FGLBindFragDataLocationIndexed(aProgram, colorNumber, index, Name);
end;

function TOpenGL_3_3.glGetFragDataIndex(aProgram: GLuint; const Name: PGLchar): GLint;
begin
  if Assigned(FGLGetFragDataIndex) then
    Result := FGLGetFragDataIndex(aProgram, Name)
  else
    Result := -1;
end;

//  Sampler Objects 
procedure TOpenGL_3_3.glGenSamplers(Count: GLsizei; samplers: PGLuint);
begin
  if Assigned(FGLGenSamplers) then
    FGLGenSamplers(Count, samplers);
end;

procedure TOpenGL_3_3.glDeleteSamplers(Count: GLsizei; const samplers: PGLuint);
begin
  if Assigned(FGLDeleteSamplers) then
    FGLDeleteSamplers(Count, samplers);
end;

function TOpenGL_3_3.glIsSampler(sampler: GLuint): GLboolean;
begin
  if Assigned(FGLIsSampler) then
    Result := FGLIsSampler(sampler)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_3_3.glBindSampler(aUnit: GLuint; sampler: GLuint);
begin
  if Assigned(FGLBindSampler) then
    FGLBindSampler(aUnit, sampler);
end;

procedure TOpenGL_3_3.glSamplerParameteri(sampler: GLuint; pname: GLenum; param: GLint);
begin
  if Assigned(FGLSamplerParameteri) then
    FGLSamplerParameteri(sampler, pname, param);
end;

procedure TOpenGL_3_3.glSamplerParameteriv(sampler: GLuint; pname: GLenum; const param: PGLint);
begin
  if Assigned(FGLSamplerParameteriv) then
    FGLSamplerParameteriv(sampler, pname, param);
end;

procedure TOpenGL_3_3.glSamplerParameterf(sampler: GLuint; pname: GLenum; param: GLfloat);
begin
  if Assigned(FGLSamplerParameterf) then
    FGLSamplerParameterf(sampler, pname, param);
end;

procedure TOpenGL_3_3.glSamplerParameterfv(sampler: GLuint; pname: GLenum; const param: PGLfloat);
begin
  if Assigned(FGLSamplerParameterfv) then
    FGLSamplerParameterfv(sampler, pname, param);
end;

procedure TOpenGL_3_3.glSamplerParameterIiv(sampler: GLuint; pname: GLenum; const param: PGLint);
begin
  if Assigned(FGLSamplerParameterIiv) then
    FGLSamplerParameterIiv(sampler, pname, param);
end;

procedure TOpenGL_3_3.glSamplerParameterIuiv(sampler: GLuint; pname: GLenum; const param: PGLuint);
begin
  if Assigned(FGLSamplerParameterIuiv) then
    FGLSamplerParameterIuiv(sampler, pname, param);
end;

procedure TOpenGL_3_3.glGetSamplerParameteriv(sampler: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetSamplerParameteriv) then
    FGLGetSamplerParameteriv(sampler, pname, params);
end;

procedure TOpenGL_3_3.glGetSamplerParameterIiv(sampler: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetSamplerParameterIiv) then
    FGLGetSamplerParameterIiv(sampler, pname, params);
end;

procedure TOpenGL_3_3.glGetSamplerParameterfv(sampler: GLuint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FGLGetSamplerParameterfv) then
    FGLGetSamplerParameterfv(sampler, pname, params);
end;

procedure TOpenGL_3_3.glGetSamplerParameterIuiv(sampler: GLuint; pname: GLenum; params: PGLuint);
begin
  if Assigned(FGLGetSamplerParameterIuiv) then
    FGLGetSamplerParameterIuiv(sampler, pname, params);
end;

//  Timer Queries (64-bit) 
procedure TOpenGL_3_3.glQueryCounter(id: GLuint; target: GLenum);
begin
  if Assigned(FGLQueryCounter) then
    FGLQueryCounter(id, target);
end;

procedure TOpenGL_3_3.glGetQueryObjecti64v(id: GLuint; pname: GLenum; params: PGLint64);
begin
  if Assigned(FGLGetQueryObjecti64v) then
    FGLGetQueryObjecti64v(id, pname, params);
end;

procedure TOpenGL_3_3.glGetQueryObjectui64v(id: GLuint; pname: GLenum; params: PGLuint64);
begin
  if Assigned(FGLGetQueryObjectui64v) then
    FGLGetQueryObjectui64v(id, pname, params);
end;

//  Instanced Arrays 
procedure TOpenGL_3_3.glVertexAttribDivisor(index: GLuint; divisor: GLuint);
begin
  if Assigned(FGLVertexAttribDivisor) then
    FGLVertexAttribDivisor(index, divisor);
end;

//  Packed Vertex Attributes (ARB_vertex_attrib_64bit) 
procedure TOpenGL_3_3.glVertexAttribP1ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
begin
  if Assigned(FGLVertexAttribP1ui) then
    FGLVertexAttribP1ui(index, aType, normalized, Value);
end;

procedure TOpenGL_3_3.glVertexAttribP1uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
begin
  if Assigned(FGLVertexAttribP1uiv) then
    FGLVertexAttribP1uiv(index, aType, normalized, Value);
end;

procedure TOpenGL_3_3.glVertexAttribP2ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
begin
  if Assigned(FGLVertexAttribP2ui) then
    FGLVertexAttribP2ui(index, aType, normalized, Value);
end;

procedure TOpenGL_3_3.glVertexAttribP2uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
begin
  if Assigned(FGLVertexAttribP2uiv) then
    FGLVertexAttribP2uiv(index, aType, normalized, Value);
end;

procedure TOpenGL_3_3.glVertexAttribP3ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
begin
  if Assigned(FGLVertexAttribP3ui) then
    FGLVertexAttribP3ui(index, aType, normalized, Value);
end;

procedure TOpenGL_3_3.glVertexAttribP3uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
begin
  if Assigned(FGLVertexAttribP3uiv) then
    FGLVertexAttribP3uiv(index, aType, normalized, Value);
end;

procedure TOpenGL_3_3.glVertexAttribP4ui(index: GLuint; aType: GLenum; normalized: GLboolean; Value: GLuint);
begin
  if Assigned(FGLVertexAttribP4ui) then
    FGLVertexAttribP4ui(index, aType, normalized, Value);
end;

procedure TOpenGL_3_3.glVertexAttribP4uiv(index: GLuint; aType: GLenum; normalized: GLboolean; const Value: PGLuint);
begin
  if Assigned(FGLVertexAttribP4uiv) then
    FGLVertexAttribP4uiv(index, aType, normalized, Value);
end;

{ TOpenGL_4_0 }

procedure TOpenGL_4_0.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLMinSampleShading) := LoadProc('glMinSampleShading');
  Pointer(FGLBlendEquationi) := LoadProc('glBlendEquationi');
  Pointer(FGLBlendEquationSeparatei) := LoadProc('glBlendEquationSeparatei');
  Pointer(FGLBlendFunci) := LoadProc('glBlendFunci');
  Pointer(FGLBlendFuncSeparatei) := LoadProc('glBlendFuncSeparatei');
end;

procedure TOpenGL_4_0.glMinSampleShading(Value: GLfloat);
begin
  if Assigned(FGLMinSampleShading) then
    FGLMinSampleShading(Value);
end;

procedure TOpenGL_4_0.glBlendEquationi(buf: GLuint; mode: GLenum);
begin
  if Assigned(FGLBlendEquationi) then
    FGLBlendEquationi(buf, mode);
end;

procedure TOpenGL_4_0.glBlendEquationSeparatei(buf: GLuint; modeRGB, modeAlpha: GLenum);
begin
  if Assigned(FGLBlendEquationSeparatei) then
    FGLBlendEquationSeparatei(buf, modeRGB, modeAlpha);
end;

procedure TOpenGL_4_0.glBlendFunci(buf: GLuint; src, dst: GLenum);
begin
  if Assigned(FGLBlendFunci) then
    FGLBlendFunci(buf, src, dst);
end;

procedure TOpenGL_4_0.glBlendFuncSeparatei(buf: GLuint; srcRGB, dstRGB, srcAlpha, dstAlpha: GLenum);
begin
  if Assigned(FGLBlendFuncSeparatei) then
    FGLBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
end;

procedure TOpenGL_4_0.glDrawArraysIndirect(mode: GLenum; const indirect: Pointer);
begin
  if Assigned(FGLDrawArraysIndirect) then
    FGLDrawArraysIndirect(mode, indirect);
end;

procedure TOpenGL_4_0.glDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer);
begin
  if Assigned(FGLDrawElementsIndirect) then
    FGLDrawElementsIndirect(mode, aType, indirect);
end;

// Double-precision uniforms
procedure TOpenGL_4_0.glUniform1d(location: GLint; x: GLdouble);
begin
  if Assigned(FGLUniform1d) then FGLUniform1d(location, x);
end;

procedure TOpenGL_4_0.glUniform2d(location: GLint; x, y: GLdouble);
begin
  if Assigned(FGLUniform2d) then FGLUniform2d(location, x, y);
end;

procedure TOpenGL_4_0.glUniform3d(location: GLint; x, y, z: GLdouble);
begin
  if Assigned(FGLUniform3d) then FGLUniform3d(location, x, y, z);
end;

procedure TOpenGL_4_0.glUniform4d(location: GLint; x, y, z, w: GLdouble);
begin
  if Assigned(FGLUniform4d) then FGLUniform4d(location, x, y, z, w);
end;

procedure TOpenGL_4_0.glUniform1dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FGLUniform1dv) then FGLUniform1dv(location, Count, Value);
end;

procedure TOpenGL_4_0.glUniform2dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FGLUniform2dv) then FGLUniform2dv(location, Count, Value);
end;

procedure TOpenGL_4_0.glUniform3dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FGLUniform3dv) then FGLUniform3dv(location, Count, Value);
end;

procedure TOpenGL_4_0.glUniform4dv(location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FGLUniform4dv) then FGLUniform4dv(location, Count, Value);
end;

procedure TOpenGL_4_0.glUniformMatrix2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLUniformMatrix2dv) then FGLUniformMatrix2dv(location, Count, transpose, Value);
end;

procedure TOpenGL_4_0.glUniformMatrix3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLUniformMatrix3dv) then FGLUniformMatrix3dv(location, Count, transpose, Value);
end;

procedure TOpenGL_4_0.glUniformMatrix4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLUniformMatrix4dv) then FGLUniformMatrix4dv(location, Count, transpose, Value);
end;

procedure TOpenGL_4_0.glUniformMatrix2x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLUniformMatrix2x3dv) then FGLUniformMatrix2x3dv(location, Count, transpose, Value);
end;

procedure TOpenGL_4_0.glUniformMatrix2x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLUniformMatrix2x4dv) then FGLUniformMatrix2x4dv(location, Count, transpose, Value);
end;

procedure TOpenGL_4_0.glUniformMatrix3x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLUniformMatrix3x2dv) then FGLUniformMatrix3x2dv(location, Count, transpose, Value);
end;

procedure TOpenGL_4_0.glUniformMatrix3x4dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLUniformMatrix3x4dv) then FGLUniformMatrix3x4dv(location, Count, transpose, Value);
end;

procedure TOpenGL_4_0.glUniformMatrix4x2dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLUniformMatrix4x2dv) then FGLUniformMatrix4x2dv(location, Count, transpose, Value);
end;

procedure TOpenGL_4_0.glUniformMatrix4x3dv(location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLUniformMatrix4x3dv) then FGLUniformMatrix4x3dv(location, Count, transpose, Value);
end;

procedure TOpenGL_4_0.glGetUniformdv(aProgram: GLuint; location: GLint; params: PGLdouble);
begin
  if Assigned(FGLGetUniformdv) then
    FGLGetUniformdv(aProgram, location, params);
end;

// Subroutine functions
function TOpenGL_4_0.glGetSubroutineUniformLocation(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLint;
begin
  if Assigned(FGLGetSubroutineUniformLocation) then
    Result := FGLGetSubroutineUniformLocation(aProgram, shadertype, Name)
  else
    Result := -1;
end;

function TOpenGL_4_0.glGetSubroutineIndex(aProgram: GLuint; shadertype: GLenum; const Name: PGLchar): GLuint;
begin
  if Assigned(FGLGetSubroutineIndex) then
    Result := FGLGetSubroutineIndex(aProgram, shadertype, Name)
  else
    Result := GL_INVALID_INDEX;
end;

procedure TOpenGL_4_0.glGetActiveSubroutineUniformiv(aProgram: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint);
begin
  if Assigned(FGLGetActiveSubroutineUniformiv) then
    FGLGetActiveSubroutineUniformiv(aProgram, shadertype, index, pname, values);
end;

procedure TOpenGL_4_0.glGetActiveSubroutineUniformName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar);
begin
  if Assigned(FGLGetActiveSubroutineUniformName) then
    FGLGetActiveSubroutineUniformName(aProgram, shadertype, index, bufSize, length, Name);
end;

procedure TOpenGL_4_0.glGetActiveSubroutineName(aProgram: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar);
begin
  if Assigned(FGLGetActiveSubroutineName) then
    FGLGetActiveSubroutineName(aProgram, shadertype, index, bufSize, length, Name);
end;

procedure TOpenGL_4_0.glUniformSubroutinesuiv(shadertype: GLenum; Count: GLsizei; const indices: PGLuint);
begin
  if Assigned(FGLUniformSubroutinesuiv) then
    FGLUniformSubroutinesuiv(shadertype, Count, indices);
end;

procedure TOpenGL_4_0.glGetUniformSubroutineuiv(shadertype: GLenum; location: GLint; params: PGLuint);
begin
  if Assigned(FGLGetUniformSubroutineuiv) then
    FGLGetUniformSubroutineuiv(shadertype, location, params);
end;

procedure TOpenGL_4_0.glGetProgramStageiv(aProgram: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint);
begin
  if Assigned(FGLGetProgramStageiv) then
    FGLGetProgramStageiv(aProgram, shadertype, pname, values);
end;

// Tessellation / Patch parameters
procedure TOpenGL_4_0.glPatchParameteri(pname: GLenum; Value: GLint);
begin
  if Assigned(FGLPatchParameteri) then
    FGLPatchParameteri(pname, Value);
end;

procedure TOpenGL_4_0.glPatchParameterfv(pname: GLenum; const values: PGLfloat);
begin
  if Assigned(FGLPatchParameterfv) then
    FGLPatchParameterfv(pname, values);
end;

// Transform Feedback Objects
procedure TOpenGL_4_0.glBindTransformFeedback(target: GLenum; id: GLuint);
begin
  if Assigned(FGLBindTransformFeedback) then
    FGLBindTransformFeedback(target, id);
end;

procedure TOpenGL_4_0.glDeleteTransformFeedbacks(n: GLsizei; const ids: PGLuint);
begin
  if Assigned(FGLDeleteTransformFeedbacks) then
    FGLDeleteTransformFeedbacks(n, ids);
end;

procedure TOpenGL_4_0.glGenTransformFeedbacks(n: GLsizei; ids: PGLuint);
begin
  if Assigned(FGLGenTransformFeedbacks) then
    FGLGenTransformFeedbacks(n, ids);
end;

function TOpenGL_4_0.glIsTransformFeedback(id: GLuint): GLboolean;
begin
  if Assigned(FGLIsTransformFeedback) then
    Result := FGLIsTransformFeedback(id)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_4_0.glPauseTransformFeedback;
begin
  if Assigned(FGLPauseTransformFeedback) then
    FGLPauseTransformFeedback;
end;

procedure TOpenGL_4_0.glResumeTransformFeedback;
begin
  if Assigned(FGLResumeTransformFeedback) then
    FGLResumeTransformFeedback;
end;

procedure TOpenGL_4_0.glDrawTransformFeedback(mode: GLenum; id: GLuint);
begin
  if Assigned(FGLDrawTransformFeedback) then
    FGLDrawTransformFeedback(mode, id);
end;

procedure TOpenGL_4_0.glDrawTransformFeedbackStream(mode: GLenum; id: GLuint; stream: GLuint);
begin
  if Assigned(FGLDrawTransformFeedbackStream) then
    FGLDrawTransformFeedbackStream(mode, id, stream);
end;

// Indexed Queries
procedure TOpenGL_4_0.glBeginQueryIndexed(target: GLenum; index: GLuint; id: GLuint);
begin
  if Assigned(FGLBeginQueryIndexed) then
    FGLBeginQueryIndexed(target, index, id);
end;

procedure TOpenGL_4_0.glEndQueryIndexed(target: GLenum; index: GLuint);
begin
  if Assigned(FGLEndQueryIndexed) then
    FGLEndQueryIndexed(target, index);
end;

procedure TOpenGL_4_0.glGetQueryIndexediv(target: GLenum; index: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetQueryIndexediv) then
    FGLGetQueryIndexediv(target, index, pname, params);
end;

{ TOpenGL_4_1 }

procedure TOpenGL_4_1.bindEntry;
begin
  inherited bindEntry;

  Pointer(FGLReleaseShaderCompiler) := LoadProc('glReleaseShaderCompiler');
  Pointer(FGLShaderBinary) := LoadProc('glShaderBinary');
  Pointer(FGLGetShaderPrecisionFormat) := LoadProc('glGetShaderPrecisionFormat');
  Pointer(FGLDepthRangef) := LoadProc('glDepthRangef');
  Pointer(FGLClearDepthf) := LoadProc('glClearDepthf');
  Pointer(FGLGetProgramBinary) := LoadProc('glGetProgramBinary');
  Pointer(FGLProgramBinary) := LoadProc('glProgramBinary');
  Pointer(FGLProgramParameteri) := LoadProc('glProgramParameteri');
  Pointer(FGLUseProgramStages) := LoadProc('glUseProgramStages');
  Pointer(FGLActiveShaderProgram) := LoadProc('glActiveShaderProgram');
  Pointer(FGLCreateShaderProgramv) := LoadProc('glCreateShaderProgramv');
  Pointer(FGLBindProgramPipeline) := LoadProc('glBindProgramPipeline');
  Pointer(FGLDeleteProgramPipelines) := LoadProc('glDeleteProgramPipelines');
  Pointer(FGLGenProgramPipelines) := LoadProc('glGenProgramPipelines');
  Pointer(FGLIsProgramPipeline) := LoadProc('glIsProgramPipeline');
  Pointer(FGLGetProgramPipelineiv) := LoadProc('glGetProgramPipelineiv');
  Pointer(FGLValidateProgramPipeline) := LoadProc('glValidateProgramPipeline');
  Pointer(FGLGetProgramPipelineInfoLog) := LoadProc('glGetProgramPipelineInfoLog');

  Pointer(FGLProgramUniform1i) := LoadProc('glProgramUniform1i');
  Pointer(FGLProgramUniform1iv) := LoadProc('glProgramUniform1iv');
  Pointer(FGLProgramUniform1f) := LoadProc('glProgramUniform1f');
  Pointer(FGLProgramUniform1fv) := LoadProc('glProgramUniform1fv');
  Pointer(FGLProgramUniform1d) := LoadProc('glProgramUniform1d');
  Pointer(FGLProgramUniform1dv) := LoadProc('glProgramUniform1dv');
  Pointer(FGLProgramUniform1ui) := LoadProc('glProgramUniform1ui');
  Pointer(FGLProgramUniform1uiv) := LoadProc('glProgramUniform1uiv');

  Pointer(FGLProgramUniform2i) := LoadProc('glProgramUniform2i');
  Pointer(FGLProgramUniform2iv) := LoadProc('glProgramUniform2iv');
  Pointer(FGLProgramUniform2f) := LoadProc('glProgramUniform2f');
  Pointer(FGLProgramUniform2fv) := LoadProc('glProgramUniform2fv');
  Pointer(FGLProgramUniform2d) := LoadProc('glProgramUniform2d');
  Pointer(FGLProgramUniform2dv) := LoadProc('glProgramUniform2dv');
  Pointer(FGLProgramUniform2ui) := LoadProc('glProgramUniform2ui');
  Pointer(FGLProgramUniform2uiv) := LoadProc('glProgramUniform2uiv');

  Pointer(FGLProgramUniform3i) := LoadProc('glProgramUniform3i');
  Pointer(FGLProgramUniform3iv) := LoadProc('glProgramUniform3iv');
  Pointer(FGLProgramUniform3f) := LoadProc('glProgramUniform3f');
  Pointer(FGLProgramUniform3fv) := LoadProc('glProgramUniform3fv');
  Pointer(FGLProgramUniform3d) := LoadProc('glProgramUniform3d');
  Pointer(FGLProgramUniform3dv) := LoadProc('glProgramUniform3dv');
  Pointer(FGLProgramUniform3ui) := LoadProc('glProgramUniform3ui');
  Pointer(FGLProgramUniform3uiv) := LoadProc('glProgramUniform3uiv');

  Pointer(FGLProgramUniform4i) := LoadProc('glProgramUniform4i');
  Pointer(FGLProgramUniform4iv) := LoadProc('glProgramUniform4iv');
  Pointer(FGLProgramUniform4f) := LoadProc('glProgramUniform4f');
  Pointer(FGLProgramUniform4fv) := LoadProc('glProgramUniform4fv');
  Pointer(FGLProgramUniform4d) := LoadProc('glProgramUniform4d');
  Pointer(FGLProgramUniform4dv) := LoadProc('glProgramUniform4dv');
  Pointer(FGLProgramUniform4ui) := LoadProc('glProgramUniform4ui');
  Pointer(FGLProgramUniform4uiv) := LoadProc('glProgramUniform4uiv');

  Pointer(FGLProgramUniformMatrix2fv) := LoadProc('glProgramUniformMatrix2fv');
  Pointer(FGLProgramUniformMatrix3fv) := LoadProc('glProgramUniformMatrix3fv');
  Pointer(FGLProgramUniformMatrix4fv) := LoadProc('glProgramUniformMatrix4fv');
  Pointer(FGLProgramUniformMatrix2dv) := LoadProc('glProgramUniformMatrix2dv');
  Pointer(FGLProgramUniformMatrix3dv) := LoadProc('glProgramUniformMatrix3dv');
  Pointer(FGLProgramUniformMatrix4dv) := LoadProc('glProgramUniformMatrix4dv');

  Pointer(FGLProgramUniformMatrix2x3fv) := LoadProc('glProgramUniformMatrix2x3fv');
  Pointer(FGLProgramUniformMatrix3x2fv) := LoadProc('glProgramUniformMatrix3x2fv');
  Pointer(FGLProgramUniformMatrix2x4fv) := LoadProc('glProgramUniformMatrix2x4fv');
  Pointer(FGLProgramUniformMatrix4x2fv) := LoadProc('glProgramUniformMatrix4x2fv');
  Pointer(FGLProgramUniformMatrix3x4fv) := LoadProc('glProgramUniformMatrix3x4fv');
  Pointer(FGLProgramUniformMatrix4x3fv) := LoadProc('glProgramUniformMatrix4x3fv');

  Pointer(FGLProgramUniformMatrix2x3dv) := LoadProc('glProgramUniformMatrix2x3dv');
  Pointer(FGLProgramUniformMatrix3x2dv) := LoadProc('glProgramUniformMatrix3x2dv');
  Pointer(FGLProgramUniformMatrix2x4dv) := LoadProc('glProgramUniformMatrix2x4dv');
  Pointer(FGLProgramUniformMatrix4x2dv) := LoadProc('glProgramUniformMatrix4x2dv');
  Pointer(FGLProgramUniformMatrix3x4dv) := LoadProc('glProgramUniformMatrix3x4dv');
  Pointer(FGLProgramUniformMatrix4x3dv) := LoadProc('glProgramUniformMatrix4x3dv');

  Pointer(FGLVertexAttribL1d) := LoadProc('glVertexAttribL1d');
  Pointer(FGLVertexAttribL2d) := LoadProc('glVertexAttribL2d');
  Pointer(FGLVertexAttribL3d) := LoadProc('glVertexAttribL3d');
  Pointer(FGLVertexAttribL4d) := LoadProc('glVertexAttribL4d');
  Pointer(FGLVertexAttribL1dv) := LoadProc('glVertexAttribL1dv');
  Pointer(FGLVertexAttribL2dv) := LoadProc('glVertexAttribL2dv');
  Pointer(FGLVertexAttribL3dv) := LoadProc('glVertexAttribL3dv');
  Pointer(FGLVertexAttribL4dv) := LoadProc('glVertexAttribL4dv');
  Pointer(FGLVertexAttribLPointer) := LoadProc('glVertexAttribLPointer');
  Pointer(FGLGetVertexAttribLdv) := LoadProc('glGetVertexAttribLdv');

  Pointer(FGLViewportArrayv) := LoadProc('glViewportArrayv');
  Pointer(FGLViewportIndexedf) := LoadProc('glViewportIndexedf');
  Pointer(FGLViewportIndexedfv) := LoadProc('glViewportIndexedfv');
  Pointer(FGLScissorArrayv) := LoadProc('glScissorArrayv');
  Pointer(FGLScissorIndexed) := LoadProc('glScissorIndexed');
  Pointer(FGLScissorIndexedv) := LoadProc('glScissorIndexedv');
  Pointer(FGLDepthRangeArrayv) := LoadProc('glDepthRangeArrayv');
  Pointer(FGLDepthRangeIndexed) := LoadProc('glDepthRangeIndexed');
  Pointer(FGLGetFloati_v) := LoadProc('glGetFloati_v');
  Pointer(FGLGetDoublei_v) := LoadProc('glGetDoublei_v');
end;

// 
// OpenGL 4.1  Separate Shader Objects + Program Pipelines + Viewport Arrays
// 

procedure TOpenGL_4_1.glReleaseShaderCompiler;
begin
  if Assigned(FGLReleaseShaderCompiler) then
    FGLReleaseShaderCompiler;
end;

procedure TOpenGL_4_1.glShaderBinary(Count: GLsizei; const shaders: PGLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei);
begin
  if Assigned(FGLShaderBinary) then
    FGLShaderBinary(Count, shaders, binaryFormat, binary, length);
end;

procedure TOpenGL_4_1.glGetShaderPrecisionFormat(shadertype, precisiontype: GLenum; range_, precision: PGLint);
begin
  if Assigned(FGLGetShaderPrecisionFormat) then
    FGLGetShaderPrecisionFormat(shadertype, precisiontype, range_, precision);
end;

procedure TOpenGL_4_1.glDepthRangef(n, f: GLfloat);
begin
  if Assigned(FGLDepthRangef) then
    FGLDepthRangef(n, f);
end;

procedure TOpenGL_4_1.glClearDepthf(d: GLfloat);
begin
  if Assigned(FGLClearDepthf) then
    FGLClearDepthf(d);
end;

procedure TOpenGL_4_1.glGetProgramBinary(aProgram: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer);
begin
  if Assigned(FGLGetProgramBinary) then
    FGLGetProgramBinary(aProgram, bufSize, length, binaryFormat, binary);
end;

procedure TOpenGL_4_1.glProgramBinary(aProgram: GLuint; binaryFormat: GLenum; const binary: Pointer; length: GLsizei);
begin
  if Assigned(FGLProgramBinary) then
    FGLProgramBinary(aProgram, binaryFormat, binary, length);
end;

procedure TOpenGL_4_1.glProgramParameteri(aProgram: GLuint; pname: GLenum; Value: GLint);
begin
  if Assigned(FGLProgramParameteri) then
    FGLProgramParameteri(aProgram, pname, Value);
end;

//  Program Pipelines & Separate Shader Objects 
procedure TOpenGL_4_1.glUseProgramStages(pipeline: GLuint; stages: GLbitfield; aProgram: GLuint);
begin
  if Assigned(FGLUseProgramStages) then
    FGLUseProgramStages(pipeline, stages, aProgram);
end;

procedure TOpenGL_4_1.glActiveShaderProgram(pipeline, aProgram: GLuint);
begin
  if Assigned(FGLActiveShaderProgram) then
    FGLActiveShaderProgram(pipeline, aProgram);
end;

function TOpenGL_4_1.glCreateShaderProgramv(aType: GLenum; Count: GLsizei; const strings: PPGLchar): GLuint;
begin
  if Assigned(FGLCreateShaderProgramv) then
    Result := FGLCreateShaderProgramv(aType, Count, strings)
  else
    Result := 0;
end;

procedure TOpenGL_4_1.glBindProgramPipeline(pipeline: GLuint);
begin
  if Assigned(FGLBindProgramPipeline) then
    FGLBindProgramPipeline(pipeline);
end;

procedure TOpenGL_4_1.glDeleteProgramPipelines(n: GLsizei; const pipelines: PGLuint);
begin
  if Assigned(FGLDeleteProgramPipelines) then
    FGLDeleteProgramPipelines(n, pipelines);
end;

procedure TOpenGL_4_1.glGenProgramPipelines(n: GLsizei; pipelines: PGLuint);
begin
  if Assigned(FGLGenProgramPipelines) then
    FGLGenProgramPipelines(n, pipelines);
end;

function TOpenGL_4_1.glIsProgramPipeline(pipeline: GLuint): GLboolean;
begin
  if Assigned(FGLIsProgramPipeline) then
    Result := FGLIsProgramPipeline(pipeline)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_4_1.glGetProgramPipelineiv(pipeline: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetProgramPipelineiv) then
    FGLGetProgramPipelineiv(pipeline, pname, params);
end;

procedure TOpenGL_4_1.glValidateProgramPipeline(pipeline: GLuint);
begin
  if Assigned(FGLValidateProgramPipeline) then
    FGLValidateProgramPipeline(pipeline);
end;

procedure TOpenGL_4_1.glGetProgramPipelineInfoLog(pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar);
begin
  if Assigned(FGLGetProgramPipelineInfoLog) then
    FGLGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
end;

//  ProgramUniform* (Separate Shader Objects) 
procedure TOpenGL_4_1.glProgramUniform1i(aProgram: GLuint; location: GLint; v0: GLint);
begin
  if Assigned(FGLProgramUniform1i) then FGLProgramUniform1i(aProgram, location, v0);
end;

procedure TOpenGL_4_1.glProgramUniform1iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FGLProgramUniform1iv) then FGLProgramUniform1iv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform1f(aProgram: GLuint; location: GLint; v0: GLfloat);
begin
  if Assigned(FGLProgramUniform1f) then FGLProgramUniform1f(aProgram, location, v0);
end;

procedure TOpenGL_4_1.glProgramUniform1fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniform1fv) then FGLProgramUniform1fv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform1d(aProgram: GLuint; location: GLint; v0: GLdouble);
begin
  if Assigned(FGLProgramUniform1d) then FGLProgramUniform1d(aProgram, location, v0);
end;

procedure TOpenGL_4_1.glProgramUniform1dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniform1dv) then FGLProgramUniform1dv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform1ui(aProgram: GLuint; location: GLint; v0: GLuint);
begin
  if Assigned(FGLProgramUniform1ui) then FGLProgramUniform1ui(aProgram, location, v0);
end;

procedure TOpenGL_4_1.glProgramUniform1uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FGLProgramUniform1uiv) then FGLProgramUniform1uiv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform2i(aProgram: GLuint; location: GLint; v0, v1: GLint);
begin
  if Assigned(FGLProgramUniform2i) then FGLProgramUniform2i(aProgram, location, v0, v1);
end;

procedure TOpenGL_4_1.glProgramUniform2iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FGLProgramUniform2iv) then FGLProgramUniform2iv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform2f(aProgram: GLuint; location: GLint; v0, v1: GLfloat);
begin
  if Assigned(FGLProgramUniform2f) then FGLProgramUniform2f(aProgram, location, v0, v1);
end;

procedure TOpenGL_4_1.glProgramUniform2fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniform2fv) then FGLProgramUniform2fv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform2d(aProgram: GLuint; location: GLint; v0, v1: GLdouble);
begin
  if Assigned(FGLProgramUniform2d) then FGLProgramUniform2d(aProgram, location, v0, v1);
end;

procedure TOpenGL_4_1.glProgramUniform2dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniform2dv) then FGLProgramUniform2dv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform2ui(aProgram: GLuint; location: GLint; v0, v1: GLuint);
begin
  if Assigned(FGLProgramUniform2ui) then FGLProgramUniform2ui(aProgram, location, v0, v1);
end;

procedure TOpenGL_4_1.glProgramUniform2uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FGLProgramUniform2uiv) then FGLProgramUniform2uiv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform3i(aProgram: GLuint; location: GLint; v0, v1, v2: GLint);
begin
  if Assigned(FGLProgramUniform3i) then FGLProgramUniform3i(aProgram, location, v0, v1, v2);
end;

procedure TOpenGL_4_1.glProgramUniform3iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FGLProgramUniform3iv) then FGLProgramUniform3iv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform3f(aProgram: GLuint; location: GLint; v0, v1, v2: GLfloat);
begin
  if Assigned(FGLProgramUniform3f) then FGLProgramUniform3f(aProgram, location, v0, v1, v2);
end;

procedure TOpenGL_4_1.glProgramUniform3fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniform3fv) then FGLProgramUniform3fv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform3d(aProgram: GLuint; location: GLint; v0, v1, v2: GLdouble);
begin
  if Assigned(FGLProgramUniform3d) then FGLProgramUniform3d(aProgram, location, v0, v1, v2);
end;

procedure TOpenGL_4_1.glProgramUniform3dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniform3dv) then FGLProgramUniform3dv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform3ui(aProgram: GLuint; location: GLint; v0, v1, v2: GLuint);
begin
  if Assigned(FGLProgramUniform3ui) then FGLProgramUniform3ui(aProgram, location, v0, v1, v2);
end;

procedure TOpenGL_4_1.glProgramUniform3uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FGLProgramUniform3uiv) then FGLProgramUniform3uiv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform4i(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLint);
begin
  if Assigned(FGLProgramUniform4i) then FGLProgramUniform4i(aProgram, location, v0, v1, v2, v3);
end;

procedure TOpenGL_4_1.glProgramUniform4iv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLint);
begin
  if Assigned(FGLProgramUniform4iv) then FGLProgramUniform4iv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform4f(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLfloat);
begin
  if Assigned(FGLProgramUniform4f) then FGLProgramUniform4f(aProgram, location, v0, v1, v2, v3);
end;

procedure TOpenGL_4_1.glProgramUniform4fv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniform4fv) then FGLProgramUniform4fv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform4d(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLdouble);
begin
  if Assigned(FGLProgramUniform4d) then FGLProgramUniform4d(aProgram, location, v0, v1, v2, v3);
end;

procedure TOpenGL_4_1.glProgramUniform4dv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniform4dv) then FGLProgramUniform4dv(aProgram, location, Count, Value);
end;

procedure TOpenGL_4_1.glProgramUniform4ui(aProgram: GLuint; location: GLint; v0, v1, v2, v3: GLuint);
begin
  if Assigned(FGLProgramUniform4ui) then FGLProgramUniform4ui(aProgram, location, v0, v1, v2, v3);
end;

procedure TOpenGL_4_1.glProgramUniform4uiv(aProgram: GLuint; location: GLint; Count: GLsizei; const Value: PGLuint);
begin
  if Assigned(FGLProgramUniform4uiv) then FGLProgramUniform4uiv(aProgram, location, Count, Value);
end;

// Matrix variants
procedure TOpenGL_4_1.glProgramUniformMatrix2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniformMatrix2fv) then FGLProgramUniformMatrix2fv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniformMatrix3fv) then FGLProgramUniformMatrix3fv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniformMatrix4fv) then FGLProgramUniformMatrix4fv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniformMatrix2dv) then FGLProgramUniformMatrix2dv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniformMatrix3dv) then FGLProgramUniformMatrix3dv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniformMatrix4dv) then FGLProgramUniformMatrix4dv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix2x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniformMatrix2x3fv) then FGLProgramUniformMatrix2x3fv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix3x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniformMatrix3x2fv) then FGLProgramUniformMatrix3x2fv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix2x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniformMatrix2x4fv) then FGLProgramUniformMatrix2x4fv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix4x2fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniformMatrix4x2fv) then FGLProgramUniformMatrix4x2fv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix3x4fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniformMatrix3x4fv) then FGLProgramUniformMatrix3x4fv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix4x3fv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLfloat);
begin
  if Assigned(FGLProgramUniformMatrix4x3fv) then FGLProgramUniformMatrix4x3fv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix2x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniformMatrix2x3dv) then FGLProgramUniformMatrix2x3dv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix3x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniformMatrix3x2dv) then FGLProgramUniformMatrix3x2dv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix2x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniformMatrix2x4dv) then FGLProgramUniformMatrix2x4dv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix4x2dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniformMatrix4x2dv) then FGLProgramUniformMatrix4x2dv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix3x4dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniformMatrix3x4dv) then FGLProgramUniformMatrix3x4dv(aProgram, location, Count, transpose, Value);
end;

procedure TOpenGL_4_1.glProgramUniformMatrix4x3dv(aProgram: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; const Value: PGLdouble);
begin
  if Assigned(FGLProgramUniformMatrix4x3dv) then FGLProgramUniformMatrix4x3dv(aProgram, location, Count, transpose, Value);
end;

//  Double-precision vertex attributes (ARB_vertex_attrib_64bit) 
procedure TOpenGL_4_1.glVertexAttribL1d(index: GLuint; x: GLdouble);
begin
  if Assigned(FGLVertexAttribL1d) then FGLVertexAttribL1d(index, x);
end;

procedure TOpenGL_4_1.glVertexAttribL2d(index: GLuint; x, y: GLdouble);
begin
  if Assigned(FGLVertexAttribL2d) then FGLVertexAttribL2d(index, x, y);
end;

procedure TOpenGL_4_1.glVertexAttribL3d(index: GLuint; x, y, z: GLdouble);
begin
  if Assigned(FGLVertexAttribL3d) then FGLVertexAttribL3d(index, x, y, z);
end;

procedure TOpenGL_4_1.glVertexAttribL4d(index: GLuint; x, y, z, w: GLdouble);
begin
  if Assigned(FGLVertexAttribL4d) then FGLVertexAttribL4d(index, x, y, z, w);
end;

procedure TOpenGL_4_1.glVertexAttribL1dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FGLVertexAttribL1dv) then FGLVertexAttribL1dv(index, v);
end;

procedure TOpenGL_4_1.glVertexAttribL2dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FGLVertexAttribL2dv) then FGLVertexAttribL2dv(index, v);
end;

procedure TOpenGL_4_1.glVertexAttribL3dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FGLVertexAttribL3dv) then FGLVertexAttribL3dv(index, v);
end;

procedure TOpenGL_4_1.glVertexAttribL4dv(index: GLuint; const v: PGLdouble);
begin
  if Assigned(FGLVertexAttribL4dv) then FGLVertexAttribL4dv(index, v);
end;

procedure TOpenGL_4_1.glVertexAttribLPointer(index: GLuint; size: GLint; aType: GLenum; stride: GLsizei; const pointer: Pointer);
begin
  if Assigned(FGLVertexAttribLPointer) then
    FGLVertexAttribLPointer(index, size, aType, stride, pointer);
end;

procedure TOpenGL_4_1.glGetVertexAttribLdv(index: GLuint; pname: GLenum; params: PGLdouble);
begin
  if Assigned(FGLGetVertexAttribLdv) then
    FGLGetVertexAttribLdv(index, pname, params);
end;

//  Viewport / Scissor / DepthRange Arrays (ARB_viewport_array) 
procedure TOpenGL_4_1.glViewportArrayv(First: GLuint; Count: GLsizei; const v: PGLfloat);
begin
  if Assigned(FGLViewportArrayv) then FGLViewportArrayv(First, Count, v);
end;

procedure TOpenGL_4_1.glViewportIndexedf(index: GLuint; x, y, w, h: GLfloat);
begin
  if Assigned(FGLViewportIndexedf) then FGLViewportIndexedf(index, x, y, w, h);
end;

procedure TOpenGL_4_1.glViewportIndexedfv(index: GLuint; const v: PGLfloat);
begin
  if Assigned(FGLViewportIndexedfv) then FGLViewportIndexedfv(index, v);
end;

procedure TOpenGL_4_1.glScissorArrayv(First: GLuint; Count: GLsizei; const v: PGLint);
begin
  if Assigned(FGLScissorArrayv) then FGLScissorArrayv(First, Count, v);
end;

procedure TOpenGL_4_1.glScissorIndexed(index: GLuint; left, bottom: GLint; Width, Height: GLsizei);
begin
  if Assigned(FGLScissorIndexed) then FGLScissorIndexed(index, left, bottom, Width, Height);
end;

procedure TOpenGL_4_1.glScissorIndexedv(index: GLuint; const v: PGLint);
begin
  if Assigned(FGLScissorIndexedv) then FGLScissorIndexedv(index, v);
end;

procedure TOpenGL_4_1.glDepthRangeArrayv(First: GLuint; Count: GLsizei; const v: PGLdouble);
begin
  if Assigned(FGLDepthRangeArrayv) then FGLDepthRangeArrayv(First, Count, v);
end;

procedure TOpenGL_4_1.glDepthRangeIndexed(index: GLuint; n, f: GLdouble);
begin
  if Assigned(FGLDepthRangeIndexed) then FGLDepthRangeIndexed(index, n, f);
end;

procedure TOpenGL_4_1.glGetFloati_v(target: GLenum; index: GLuint; Data: PGLfloat);
begin
  if Assigned(FGLGetFloati_v) then FGLGetFloati_v(target, index, Data);
end;

procedure TOpenGL_4_1.glGetDoublei_v(target: GLenum; index: GLuint; Data: PGLdouble);
begin
  if Assigned(FGLGetDoublei_v) then FGLGetDoublei_v(target, index, Data);
end;

{ TOpenGL_4_2 }

procedure TOpenGL_4_2.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLDrawArraysInstancedBaseInstance) := LoadProc('glDrawArraysInstancedBaseInstance');
  Pointer(FGLDrawElementsInstancedBaseInstance) := LoadProc('glDrawElementsInstancedBaseInstance');
  Pointer(FGLDrawElementsInstancedBaseVertexBaseInstance) := LoadProc('glDrawElementsInstancedBaseVertexBaseInstance');
  Pointer(FGLGetInternalformativ) := LoadProc('glGetInternalformativ');
  Pointer(FGLGetActiveAtomicCounterBufferiv) := LoadProc('glGetActiveAtomicCounterBufferiv');
  Pointer(FGLBindImageTexture) := LoadProc('glBindImageTexture');
  Pointer(FGLMemoryBarrier) := LoadProc('glMemoryBarrier');
  Pointer(FGLTexStorage1D) := LoadProc('glTexStorage1D');
  Pointer(FGLTexStorage2D) := LoadProc('glTexStorage2D');
  Pointer(FGLTexStorage3D) := LoadProc('glTexStorage3D');
  Pointer(FGLDrawTransformFeedbackInstanced) := LoadProc('glDrawTransformFeedbackInstanced');
  Pointer(FGLDrawTransformFeedbackStreamInstanced) := LoadProc('glDrawTransformFeedbackStreamInstanced');
end;

// 
// OpenGL 4.2  Base Instance + Immutable Textures + Image Load/Store + Atomic Counters
// 

procedure TOpenGL_4_2.glDrawArraysInstancedBaseInstance(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei; baseinstance: GLuint);
begin
  if Assigned(FGLDrawArraysInstancedBaseInstance) then
    FGLDrawArraysInstancedBaseInstance(mode, First, Count, instancecount, baseinstance);
end;

procedure TOpenGL_4_2.glDrawElementsInstancedBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; baseinstance: GLuint);
begin
  if Assigned(FGLDrawElementsInstancedBaseInstance) then
    FGLDrawElementsInstancedBaseInstance(mode, Count, aType, indices, instancecount, baseinstance);
end;

procedure TOpenGL_4_2.glDrawElementsInstancedBaseVertexBaseInstance(mode: GLenum; Count: GLsizei; aType: GLenum; const indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint);
begin
  if Assigned(FGLDrawElementsInstancedBaseVertexBaseInstance) then
    FGLDrawElementsInstancedBaseVertexBaseInstance(
      mode, Count, aType, indices, instancecount, basevertex, baseinstance);
end;

procedure TOpenGL_4_2.glGetInternalformativ(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint);
begin
  if Assigned(FGLGetInternalformativ) then
    FGLGetInternalformativ(target, internalformat, pname, Count, params);
end;

procedure TOpenGL_4_2.glGetActiveAtomicCounterBufferiv(aProgram: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetActiveAtomicCounterBufferiv) then
    FGLGetActiveAtomicCounterBufferiv(aProgram, bufferIndex, pname, params);
end;

procedure TOpenGL_4_2.glBindImageTexture(aUnit: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum);
begin
  if Assigned(FGLBindImageTexture) then
    FGLBindImageTexture(aUnit, texture, level, layered, layer, access, format);
end;

procedure TOpenGL_4_2.glMemoryBarrier(barriers: GLbitfield);
begin
  if Assigned(FGLMemoryBarrier) then
    FGLMemoryBarrier(barriers);
end;

//  Immutable Texture Storage (ARB_texture_storage) 
procedure TOpenGL_4_2.glTexStorage1D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei);
begin
  if Assigned(FGLTexStorage1D) then
    FGLTexStorage1D(target, levels, internalformat, Width);
end;

procedure TOpenGL_4_2.glTexStorage2D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width, Height: GLsizei);
begin
  if Assigned(FGLTexStorage2D) then
    FGLTexStorage2D(target, levels, internalformat, Width, Height);
end;

procedure TOpenGL_4_2.glTexStorage3D(target: GLenum; levels: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei);
begin
  if Assigned(FGLTexStorage3D) then
    FGLTexStorage3D(target, levels, internalformat, Width, Height, depth);
end;

//  Instanced Transform Feedback (ARB_transform_feedback_instanced) 
procedure TOpenGL_4_2.glDrawTransformFeedbackInstanced(mode: GLenum; id: GLuint; instancecount: GLsizei);
begin
  if Assigned(FGLDrawTransformFeedbackInstanced) then
    FGLDrawTransformFeedbackInstanced(mode, id, instancecount);
end;

procedure TOpenGL_4_2.glDrawTransformFeedbackStreamInstanced(mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei);
begin
  if Assigned(FGLDrawTransformFeedbackStreamInstanced) then
    FGLDrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount);
end;

{ TOpenGL_4_3 }

procedure TOpenGL_4_3.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLClearBufferData) := LoadProc('glClearBufferData');
  Pointer(FGLClearBufferSubData) := LoadProc('glClearBufferSubData');
  Pointer(FGLDispatchCompute) := LoadProc('glDispatchCompute');
  Pointer(FGLDispatchComputeIndirect) := LoadProc('glDispatchComputeIndirect');
  Pointer(FGLCopyImageSubData) := LoadProc('glCopyImageSubData');
  Pointer(FGLFramebufferParameteri) := LoadProc('glFramebufferParameteri');
  Pointer(FGLGetFramebufferParameteriv) := LoadProc('glGetFramebufferParameteriv');
  Pointer(FGLGetInternalformati64v) := LoadProc('glGetInternalformati64v');
  Pointer(FGLInvalidateTexSubImage) := LoadProc('glInvalidateTexSubImage');
  Pointer(FGLInvalidateTexImage) := LoadProc('glInvalidateTexImage');
  Pointer(FGLInvalidateBufferSubData) := LoadProc('glInvalidateBufferSubData');
  Pointer(FGLInvalidateBufferData) := LoadProc('glInvalidateBufferData');
  Pointer(FGLInvalidateFramebuffer) := LoadProc('glInvalidateFramebuffer');
  Pointer(FGLInvalidateSubFramebuffer) := LoadProc('glInvalidateSubFramebuffer');
  Pointer(FGLMultiDrawArraysIndirect) := LoadProc('glMultiDrawArraysIndirect');
  Pointer(FGLMultiDrawElementsIndirect) := LoadProc('glMultiDrawElementsIndirect');
  Pointer(FGLGetProgramInterfaceiv) := LoadProc('glGetProgramInterfaceiv');
  Pointer(FGLGetProgramResourceIndex) := LoadProc('glGetProgramResourceIndex');
  Pointer(FGLGetProgramResourceName) := LoadProc('glGetProgramResourceName');
  Pointer(FGLGetProgramResourceiv) := LoadProc('glGetProgramResourceiv');
  Pointer(FGLGetProgramResourceLocation) := LoadProc('glGetProgramResourceLocation');
  Pointer(FGLGetProgramResourceLocationIndex) := LoadProc('glGetProgramResourceLocationIndex');
  Pointer(FGLShaderStorageBlockBinding) := LoadProc('glShaderStorageBlockBinding');
  Pointer(FGLTexBufferRange) := LoadProc('glTexBufferRange');
  Pointer(FGLTexStorage2DMultisample) := LoadProc('glTexStorage2DMultisample');
  Pointer(FGLTexStorage3DMultisample) := LoadProc('glTexStorage3DMultisample');
  Pointer(FGLTextureView) := LoadProc('glTextureView');
  Pointer(FGLBindVertexBuffer) := LoadProc('glBindVertexBuffer');
  Pointer(FGLVertexAttribFormat) := LoadProc('glVertexAttribFormat');
  Pointer(FGLVertexAttribIFormat) := LoadProc('glVertexAttribIFormat');
  Pointer(FGLVertexAttribLFormat) := LoadProc('glVertexAttribLFormat');
  Pointer(FGLVertexAttribBinding) := LoadProc('glVertexAttribBinding');
  Pointer(FGLVertexBindingDivisor) := LoadProc('glVertexBindingDivisor');
  Pointer(FGLDebugMessageControl) := LoadProc('glDebugMessageControl');
  Pointer(FGLDebugMessageInsert) := LoadProc('glDebugMessageInsert');
  Pointer(FGLDebugMessageCallback) := LoadProc('glDebugMessageCallback');
  Pointer(FGLGetDebugMessageLog) := LoadProc('glGetDebugMessageLog');
  Pointer(FGLPushDebugGroup) := LoadProc('glPushDebugGroup');
  Pointer(FGLPopDebugGroup) := LoadProc('glPopDebugGroup');
  Pointer(FGLObjectLabel) := LoadProc('glObjectLabel');
  Pointer(FGLGetObjectLabel) := LoadProc('glGetObjectLabel');
  Pointer(FGLObjectPtrLabel) := LoadProc('glObjectPtrLabel');
  Pointer(FGLGetObjectPtrLabel) := LoadProc('glGetObjectPtrLabel');
end;

// 
// OpenGL 4.3  Compute Shaders + Debug Output + Texture Views + MultiDrawIndirect
// 

procedure TOpenGL_4_3.glClearBufferData(target: GLenum; internalformat: GLenum; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FGLClearBufferData) then
    FGLClearBufferData(target, internalformat, format, aType, Data);
end;

procedure TOpenGL_4_3.glClearBufferSubData(target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FGLClearBufferSubData) then
    FGLClearBufferSubData(target, internalformat, offset, size, format, aType, Data);
end;

//  Compute Shaders (ARB_compute_shader) 
procedure TOpenGL_4_3.glDispatchCompute(num_groups_x, num_groups_y, num_groups_z: GLuint);
begin
  if Assigned(FGLDispatchCompute) then
    FGLDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
end;

procedure TOpenGL_4_3.glDispatchComputeIndirect(indirect: GLintptr);
begin
  if Assigned(FGLDispatchComputeIndirect) then
    FGLDispatchComputeIndirect(indirect);
end;

procedure TOpenGL_4_3.glCopyImageSubData(srcName: GLuint; srcTarget: GLenum; srcLevel, srcX, srcY, srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel, dstX, dstY, dstZ: GLint; srcWidth, srcHeight, srcDepth: GLsizei);
begin
  if Assigned(FGLCopyImageSubData) then
    FGLCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ,
      dstName, dstTarget, dstLevel, dstX, dstY, dstZ,
      srcWidth, srcHeight, srcDepth);
end;

procedure TOpenGL_4_3.glFramebufferParameteri(target: GLenum; pname: GLenum; param: GLint);
begin
  if Assigned(FGLFramebufferParameteri) then
    FGLFramebufferParameteri(target, pname, param);
end;

procedure TOpenGL_4_3.glGetFramebufferParameteriv(target: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetFramebufferParameteriv) then
    FGLGetFramebufferParameteriv(target, pname, params);
end;

procedure TOpenGL_4_3.glGetInternalformati64v(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint64);
begin
  if Assigned(FGLGetInternalformati64v) then
    FGLGetInternalformati64v(target, internalformat, pname, Count, params);
end;

//  Invalidate (ARB_invalidate_subdata) 
procedure TOpenGL_4_3.glInvalidateTexSubImage(texture: GLuint; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei);
begin
  if Assigned(FGLInvalidateTexSubImage) then
    FGLInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, Width, Height, depth);
end;

procedure TOpenGL_4_3.glInvalidateTexImage(texture: GLuint; level: GLint);
begin
  if Assigned(FGLInvalidateTexImage) then
    FGLInvalidateTexImage(texture, level);
end;

procedure TOpenGL_4_3.glInvalidateBufferSubData(buffer: GLuint; offset: GLintptr; length: GLsizeiptr);
begin
  if Assigned(FGLInvalidateBufferSubData) then
    FGLInvalidateBufferSubData(buffer, offset, length);
end;

procedure TOpenGL_4_3.glInvalidateBufferData(buffer: GLuint);
begin
  if Assigned(FGLInvalidateBufferData) then
    FGLInvalidateBufferData(buffer);
end;

procedure TOpenGL_4_3.glInvalidateFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum);
begin
  if Assigned(FGLInvalidateFramebuffer) then
    FGLInvalidateFramebuffer(target, numAttachments, attachments);
end;

procedure TOpenGL_4_3.glInvalidateSubFramebuffer(target: GLenum; numAttachments: GLsizei; const attachments: PGLenum; x, y: GLint; Width, Height: GLsizei);
begin
  if Assigned(FGLInvalidateSubFramebuffer) then
    FGLInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, Width, Height);
end;

//  MultiDrawIndirect (ARB_multi_draw_indirect) 
procedure TOpenGL_4_3.glMultiDrawArraysIndirect(mode: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei);
begin
  if Assigned(FGLMultiDrawArraysIndirect) then
    FGLMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
end;

procedure TOpenGL_4_3.glMultiDrawElementsIndirect(mode: GLenum; aType: GLenum; const indirect: Pointer; drawcount: GLsizei; stride: GLsizei);
begin
  if Assigned(FGLMultiDrawElementsIndirect) then
    FGLMultiDrawElementsIndirect(mode, aType, indirect, drawcount, stride);
end;

//  Program Interface Query (ARB_program_interface_query) 
procedure TOpenGL_4_3.glGetProgramInterfaceiv(aProgram: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetProgramInterfaceiv) then
    FGLGetProgramInterfaceiv(aProgram, programInterface, pname, params);
end;

function TOpenGL_4_3.glGetProgramResourceIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLuint;
begin
  if Assigned(FGLGetProgramResourceIndex) then
    Result := FGLGetProgramResourceIndex(aProgram, programInterface, Name)
  else
    Result := GL_INVALID_INDEX;
end;

procedure TOpenGL_4_3.glGetProgramResourceName(aProgram: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar);
begin
  if Assigned(FGLGetProgramResourceName) then
    FGLGetProgramResourceName(aProgram, programInterface, index, bufSize, length, Name);
end;

procedure TOpenGL_4_3.glGetProgramResourceiv(aProgram: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; const props: PGLenum; Count: GLsizei; length: PGLsizei; params: PGLint);
begin
  if Assigned(FGLGetProgramResourceiv) then
    FGLGetProgramResourceiv(aProgram, programInterface, index, propCount, props, Count, length, params);
end;

function TOpenGL_4_3.glGetProgramResourceLocation(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint;
begin
  if Assigned(FGLGetProgramResourceLocation) then
    Result := FGLGetProgramResourceLocation(aProgram, programInterface, Name)
  else
    Result := -1;
end;

function TOpenGL_4_3.glGetProgramResourceLocationIndex(aProgram: GLuint; programInterface: GLenum; const Name: PGLchar): GLint;
begin
  if Assigned(FGLGetProgramResourceLocationIndex) then
    Result := FGLGetProgramResourceLocationIndex(aProgram, programInterface, Name)
  else
    Result := -1;
end;

procedure TOpenGL_4_3.glShaderStorageBlockBinding(aProgram: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint);
begin
  if Assigned(FGLShaderStorageBlockBinding) then
    FGLShaderStorageBlockBinding(aProgram, storageBlockIndex, storageBlockBinding);
end;

procedure TOpenGL_4_3.glTexBufferRange(target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FGLTexBufferRange) then
    FGLTexBufferRange(target, internalformat, buffer, offset, size);
end;

procedure TOpenGL_4_3.glTexStorage2DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FGLTexStorage2DMultisample) then
    FGLTexStorage2DMultisample(target, samples, internalformat, Width, Height, fixedsamplelocations);
end;

procedure TOpenGL_4_3.glTexStorage3DMultisample(target: GLenum; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FGLTexStorage3DMultisample) then
    FGLTexStorage3DMultisample(target, samples, internalformat, Width, Height, depth, fixedsamplelocations);
end;

procedure TOpenGL_4_3.glTextureView(texture, target: GLuint; origtexture: GLuint; internalformat: GLenum; minlevel, numlevels, minlayer, numlayers: GLuint);
begin
  if Assigned(FGLTextureView) then
    FGLTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
end;

//  Vertex Attrib Binding (ARB_vertex_attrib_binding) 
procedure TOpenGL_4_3.glBindVertexBuffer(bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei);
begin
  if Assigned(FGLBindVertexBuffer) then
    FGLBindVertexBuffer(bindingindex, buffer, offset, stride);
end;

procedure TOpenGL_4_3.glVertexAttribFormat(attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint);
begin
  if Assigned(FGLVertexAttribFormat) then
    FGLVertexAttribFormat(attribindex, size, aType, normalized, relativeoffset);
end;

procedure TOpenGL_4_3.glVertexAttribIFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
begin
  if Assigned(FGLVertexAttribIFormat) then
    FGLVertexAttribIFormat(attribindex, size, aType, relativeoffset);
end;

procedure TOpenGL_4_3.glVertexAttribLFormat(attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
begin
  if Assigned(FGLVertexAttribLFormat) then
    FGLVertexAttribLFormat(attribindex, size, aType, relativeoffset);
end;

procedure TOpenGL_4_3.glVertexAttribBinding(attribindex, bindingindex: GLuint);
begin
  if Assigned(FGLVertexAttribBinding) then
    FGLVertexAttribBinding(attribindex, bindingindex);
end;

procedure TOpenGL_4_3.glVertexBindingDivisor(bindingindex: GLuint; divisor: GLuint);
begin
  if Assigned(FGLVertexBindingDivisor) then
    FGLVertexBindingDivisor(bindingindex, divisor);
end;

//  Debug Output (KHR_debug / ARB_debug_output) 
procedure TOpenGL_4_3.glDebugMessageControl(Source, aType, severity: GLenum; Count: GLsizei; const ids: PGLuint; Enabled: GLboolean);
begin
  if Assigned(FGLDebugMessageControl) then
    FGLDebugMessageControl(Source, aType, severity, Count, ids, Enabled);
end;

procedure TOpenGL_4_3.glDebugMessageInsert(Source, aType: GLenum; id: GLuint; severity: GLenum; length: GLsizei; const buf: PGLchar);
begin
  if Assigned(FGLDebugMessageInsert) then
    FGLDebugMessageInsert(Source, aType, id, severity, length, buf);
end;

procedure TOpenGL_4_3.glDebugMessageCallback(callback: GLDEBUGPROC; const userParam: Pointer);
begin
  if Assigned(FGLDebugMessageCallback) then
    FGLDebugMessageCallback(callback, userParam);
end;

function TOpenGL_4_3.glGetDebugMessageLog(Count: GLuint; bufSize: GLsizei; sources, types: PGLenum; ids, severities: PGLuint; lengths: PGLsizei; messageLog: PGLchar): GLuint;
begin
  if Assigned(FGLGetDebugMessageLog) then
    Result := FGLGetDebugMessageLog(Count, bufSize, sources, types, ids, severities, lengths, messageLog)
  else
    Result := 0;
end;

procedure TOpenGL_4_3.glPushDebugGroup(Source: GLenum; id: GLuint; length: GLsizei; const message: PGLchar);
begin
  if Assigned(FGLPushDebugGroup) then
    FGLPushDebugGroup(Source, id, length, message);
end;

procedure TOpenGL_4_3.glPopDebugGroup;
begin
  if Assigned(FGLPopDebugGroup) then
    FGLPopDebugGroup;
end;

procedure TOpenGL_4_3.glObjectLabel(identifier: GLenum; Name: GLuint; length: GLsizei; const aLabel: PGLchar);
begin
  if Assigned(FGLObjectLabel) then
    FGLObjectLabel(identifier, Name, length, aLabel);
end;

procedure TOpenGL_4_3.glGetObjectLabel(identifier: GLenum; Name: GLuint; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar);
begin
  if Assigned(FGLGetObjectLabel) then
    FGLGetObjectLabel(identifier, Name, bufSize, length, aLabel);
end;

procedure TOpenGL_4_3.glObjectPtrLabel(const ptr: Pointer; length: GLsizei; const aLabel: PGLchar);
begin
  if Assigned(FGLObjectPtrLabel) then
    FGLObjectPtrLabel(ptr, length, aLabel);
end;

procedure TOpenGL_4_3.glGetObjectPtrLabel(const ptr: Pointer; bufSize: GLsizei; length: PGLsizei; aLabel: PGLchar);
begin
  if Assigned(FGLGetObjectPtrLabel) then
    FGLGetObjectPtrLabel(ptr, bufSize, length, aLabel);
end;

{ TOpenGL_4_4 }

procedure TOpenGL_4_4.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLBufferStorage) := LoadProc('glBufferStorage');
  Pointer(FGLClearTexImage) := LoadProc('glClearTexImage');
  Pointer(FGLClearTexSubImage) := LoadProc('glClearTexSubImage');

  Pointer(FGLBindBuffersBase) := LoadProc('glBindBuffersBase');
  Pointer(FGLBindBuffersRange) := LoadProc('glBindBuffersRange');

  Pointer(FGLBindTextures) := LoadProc('glBindTextures');
  Pointer(FGLBindSamplers) := LoadProc('glBindSamplers');
  Pointer(FGLBindImageTextures) := LoadProc('glBindImageTextures');

  Pointer(FGLBindVertexBuffers) := LoadProc('glBindVertexBuffers');
end;

procedure TOpenGL_4_4.glBufferStorage(target: GLenum; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield);
begin
  if Assigned(FGLBufferStorage) then
    FGLBufferStorage(target, size, Data, flags);
end;

procedure TOpenGL_4_4.glClearTexImage(texture: GLuint; level: GLint; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FGLClearTexImage) then
    FGLClearTexImage(texture, level, format, aType, Data);
end;

procedure TOpenGL_4_4.glClearTexSubImage(texture: GLuint; level: GLint; xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; aType: GLenum; const Data: Pointer);
begin
  if Assigned(FGLClearTexSubImage) then
    FGLClearTexSubImage(texture, level, xoffset, yoffset, zoffset,
      Width, Height, depth, format, aType, Data);
end;

procedure TOpenGL_4_4.glBindBuffersBase(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint);
begin
  if Assigned(FGLBindBuffersBase) then
    FGLBindBuffersBase(target, First, Count, buffers);
end;

procedure TOpenGL_4_4.glBindBuffersRange(target: GLenum; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const sizes: PGLsizeiptr);
begin
  if Assigned(FGLBindBuffersRange) then
    FGLBindBuffersRange(target, First, Count, buffers, offsets, sizes);
end;

procedure TOpenGL_4_4.glBindTextures(First: GLuint; Count: GLsizei; const textures: PGLuint);
begin
  if Assigned(FGLBindTextures) then
    FGLBindTextures(First, Count, textures);
end;

procedure TOpenGL_4_4.glBindSamplers(First: GLuint; Count: GLsizei; const samplers: PGLuint);
begin
  if Assigned(FGLBindSamplers) then
    FGLBindSamplers(First, Count, samplers);
end;

procedure TOpenGL_4_4.glBindImageTextures(First: GLuint; Count: GLsizei; const textures: PGLuint);
begin
  if Assigned(FGLBindImageTextures) then
    FGLBindImageTextures(First, Count, textures);
end;

procedure TOpenGL_4_4.glBindVertexBuffers(First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei);
begin
  if Assigned(FGLBindVertexBuffers) then
    FGLBindVertexBuffers(First, Count, buffers, offsets, strides);
end;

{ TOpenGL_4_5 }

procedure TOpenGL_4_5.bindEntry;
begin
  inherited bindEntry;

  Pointer(FGLClipControl) := LoadProc('glClipControl');
  Pointer(FGLCreateTransformFeedbacks) := LoadProc('glCreateTransformFeedbacks');
  Pointer(FGLTransformFeedbackBufferBase) := LoadProc('glTransformFeedbackBufferBase');
  Pointer(FGLTransformFeedbackBufferRange) := LoadProc('glTransformFeedbackBufferRange');
  Pointer(FGLGetTransformFeedbackiv) := LoadProc('glGetTransformFeedbackiv');
  Pointer(FGLGetTransformFeedbacki_v) := LoadProc('glGetTransformFeedbacki_v');
  Pointer(FGLGetTransformFeedbacki64_v) := LoadProc('glGetTransformFeedbacki64_v');

  Pointer(FGLCreateBuffers) := LoadProc('glCreateBuffers');
  Pointer(FGLNamedBufferStorage) := LoadProc('glNamedBufferStorage');
  Pointer(FGLNamedBufferData) := LoadProc('glNamedBufferData');
  Pointer(FGLNamedBufferSubData) := LoadProc('glNamedBufferSubData');
  Pointer(FGLCopyNamedBufferSubData) := LoadProc('glCopyNamedBufferSubData');
  Pointer(FGLClearNamedBufferData) := LoadProc('glClearNamedBufferData');
  Pointer(FGLClearNamedBufferSubData) := LoadProc('glClearNamedBufferSubData');
  Pointer(FGLMapNamedBuffer) := LoadProc('glMapNamedBuffer');
  Pointer(FGLMapNamedBufferRange) := LoadProc('glMapNamedBufferRange');
  Pointer(FGLUnmapNamedBuffer) := LoadProc('glUnmapNamedBuffer');
  Pointer(FGLFlushMappedNamedBufferRange) := LoadProc('glFlushMappedNamedBufferRange');
  Pointer(FGLGetNamedBufferParameteriv) := LoadProc('glGetNamedBufferParameteriv');
  Pointer(FGLGetNamedBufferParameteri64v) := LoadProc('glGetNamedBufferParameteri64v');
  Pointer(FGLGetNamedBufferPointerv) := LoadProc('glGetNamedBufferPointerv');
  Pointer(FGLGetNamedBufferSubData) := LoadProc('glGetNamedBufferSubData');

  Pointer(FGLCreateFramebuffers) := LoadProc('glCreateFramebuffers');
  Pointer(FGLNamedFramebufferRenderbuffer) := LoadProc('glNamedFramebufferRenderbuffer');
  Pointer(FGLNamedFramebufferParameteri) := LoadProc('glNamedFramebufferParameteri');
  Pointer(FGLNamedFramebufferTexture) := LoadProc('glNamedFramebufferTexture');
  Pointer(FGLNamedFramebufferTextureLayer) := LoadProc('glNamedFramebufferTextureLayer');
  Pointer(FGLNamedFramebufferDrawBuffer) := LoadProc('glNamedFramebufferDrawBuffer');
  Pointer(FGLNamedFramebufferDrawBuffers) := LoadProc('glNamedFramebufferDrawBuffers');
  Pointer(FGLNamedFramebufferReadBuffer) := LoadProc('glNamedFramebufferReadBuffer');
  Pointer(FGLInvalidateNamedFramebufferData) := LoadProc('glInvalidateNamedFramebufferData');
  Pointer(FGLInvalidateNamedFramebufferSubData) := LoadProc('glInvalidateNamedFramebufferSubData');
  Pointer(FGLClearNamedFramebufferiv) := LoadProc('glClearNamedFramebufferiv');
  Pointer(FGLClearNamedFramebufferuiv) := LoadProc('glClearNamedFramebufferuiv');
  Pointer(FGLClearNamedFramebufferfv) := LoadProc('glClearNamedFramebufferfv');
  Pointer(FGLClearNamedFramebufferfi) := LoadProc('glClearNamedFramebufferfi');
  Pointer(FGLBlitNamedFramebuffer) := LoadProc('glBlitNamedFramebuffer');
  Pointer(FGLCheckNamedFramebufferStatus) := LoadProc('glCheckNamedFramebufferStatus');
  Pointer(FGLGetNamedFramebufferParameteriv) := LoadProc('glGetNamedFramebufferParameteriv');
  Pointer(FGLGetNamedFramebufferAttachmentParameteriv) := LoadProc('glGetNamedFramebufferAttachmentParameteriv');

  Pointer(FGLCreateRenderbuffers) := LoadProc('glCreateRenderbuffers');
  Pointer(FGLNamedRenderbufferStorage) := LoadProc('glNamedRenderbufferStorage');
  Pointer(FGLNamedRenderbufferStorageMultisample) := LoadProc('glNamedRenderbufferStorageMultisample');
  Pointer(FGLGetNamedRenderbufferParameteriv) := LoadProc('glGetNamedRenderbufferParameteriv');

  Pointer(FGLCreateTextures) := LoadProc('glCreateTextures');
  Pointer(FGLTextureBuffer) := LoadProc('glTextureBuffer');
  Pointer(FGLTextureBufferRange) := LoadProc('glTextureBufferRange');
  Pointer(FGLTextureStorage1D) := LoadProc('glTextureStorage1D');
  Pointer(FGLTextureStorage2D) := LoadProc('glTextureStorage2D');
  Pointer(FGLTextureStorage3D) := LoadProc('glTextureStorage3D');
  Pointer(FGLTextureStorage2DMultisample) := LoadProc('glTextureStorage2DMultisample');
  Pointer(FGLTextureStorage3DMultisample) := LoadProc('glTextureStorage3DMultisample');
  Pointer(FGLTextureSubImage1D) := LoadProc('glTextureSubImage1D');
  Pointer(FGLTextureSubImage2D) := LoadProc('glTextureSubImage2D');
  Pointer(FGLTextureSubImage3D) := LoadProc('glTextureSubImage3D');
  Pointer(FGLCompressedTextureSubImage1D) := LoadProc('glCompressedTextureSubImage1D');
  Pointer(FGLCompressedTextureSubImage2D) := LoadProc('glCompressedTextureSubImage2D');
  Pointer(FGLCompressedTextureSubImage3D) := LoadProc('glCompressedTextureSubImage3D');
  Pointer(FGLCopyTextureSubImage1D) := LoadProc('glCopyTextureSubImage1D');
  Pointer(FGLCopyTextureSubImage2D) := LoadProc('glCopyTextureSubImage2D');
  Pointer(FGLCopyTextureSubImage3D) := LoadProc('glCopyTextureSubImage3D');
  Pointer(FGLTextureParameterf) := LoadProc('glTextureParameterf');
  Pointer(FGLTextureParameterfv) := LoadProc('glTextureParameterfv');
  Pointer(FGLTextureParameteri) := LoadProc('glTextureParameteri');
  Pointer(FGLTextureParameterIiv) := LoadProc('glTextureParameterIiv');
  Pointer(FGLTextureParameterIuiv) := LoadProc('glTextureParameterIuiv');
  Pointer(FGLTextureParameteriv) := LoadProc('glTextureParameteriv');
  Pointer(FGLGenerateTextureMipmap) := LoadProc('glGenerateTextureMipmap');
  Pointer(FGLBindTextureUnit) := LoadProc('glBindTextureUnit');
  Pointer(FGLGetTextureImage) := LoadProc('glGetTextureImage');
  Pointer(FGLGetCompressedTextureImage) := LoadProc('glGetCompressedTextureImage');
  Pointer(FGLGetTextureLevelParameterfv) := LoadProc('glGetTextureLevelParameterfv');
  Pointer(FGLGetTextureLevelParameteriv) := LoadProc('glGetTextureLevelParameteriv');
  Pointer(FGLGetTextureParameterfv) := LoadProc('glGetTextureParameterfv');
  Pointer(FGLGetTextureParameterIiv) := LoadProc('glGetTextureParameterIiv');
  Pointer(FGLGetTextureParameterIuiv) := LoadProc('glGetTextureParameterIuiv');
  Pointer(FGLGetTextureParameteriv) := LoadProc('glGetTextureParameteriv');

  Pointer(FGLCreateVertexArrays) := LoadProc('glCreateVertexArrays');
  Pointer(FGLDisableVertexArrayAttrib) := LoadProc('glDisableVertexArrayAttrib');
  Pointer(FGLEnableVertexArrayAttrib) := LoadProc('glEnableVertexArrayAttrib');
  Pointer(FGLVertexArrayElementBuffer) := LoadProc('glVertexArrayElementBuffer');
  Pointer(FGLVertexArrayVertexBuffer) := LoadProc('glVertexArrayVertexBuffer');
  Pointer(FGLVertexArrayVertexBuffers) := LoadProc('glVertexArrayVertexBuffers');
  Pointer(FGLVertexArrayAttribBinding) := LoadProc('glVertexArrayAttribBinding');
  Pointer(FGLVertexArrayAttribFormat) := LoadProc('glVertexArrayAttribFormat');
  Pointer(FGLVertexArrayAttribIFormat) := LoadProc('glVertexArrayAttribIFormat');
  Pointer(FGLVertexArrayAttribLFormat) := LoadProc('glVertexArrayAttribLFormat');
  Pointer(FGLVertexArrayBindingDivisor) := LoadProc('glVertexArrayBindingDivisor');
  Pointer(FGLGetVertexArrayiv) := LoadProc('glGetVertexArrayiv');
  Pointer(FGLGetVertexArrayIndexediv) := LoadProc('glGetVertexArrayIndexediv');
  Pointer(FGLGetVertexArrayIndexed64iv) := LoadProc('glGetVertexArrayIndexed64iv');

  Pointer(FGLCreateSamplers) := LoadProc('glCreateSamplers');
  Pointer(FGLCreateProgramPipelines) := LoadProc('glCreateProgramPipelines');
  Pointer(FGLCreateQueries) := LoadProc('glCreateQueries');
  Pointer(FGLGetQueryBufferObjecti64v) := LoadProc('glGetQueryBufferObjecti64v');
  Pointer(FGLGetQueryBufferObjectiv) := LoadProc('glGetQueryBufferObjectiv');
  Pointer(FGLGetQueryBufferObjectui64v) := LoadProc('glGetQueryBufferObjectui64v');
  Pointer(FGLGetQueryBufferObjectuiv) := LoadProc('glGetQueryBufferObjectuiv');

  Pointer(FGLMemoryBarrierByRegion) := LoadProc('glMemoryBarrierByRegion');

  Pointer(FGLGetTextureSubImage) := LoadProc('glGetTextureSubImage');
  Pointer(FGLGetCompressedTextureSubImage) := LoadProc('glGetCompressedTextureSubImage');

  Pointer(FGLGetGraphicsResetStatus) := LoadProc('glGetGraphicsResetStatus');
  Pointer(FGLGetnCompressedTexImage) := LoadProc('glGetnCompressedTexImage');
  Pointer(FGLGetnTexImage) := LoadProc('glGetnTexImage');
  Pointer(FGLGetnUniformdv) := LoadProc('glGetnUniformdv');
  Pointer(FGLGetnUniformfv) := LoadProc('glGetnUniformfv');
  Pointer(FGLGetnUniformiv) := LoadProc('glGetnUniformiv');
  Pointer(FGLGetnUniformuiv) := LoadProc('glGetnUniformuiv');
  Pointer(FGLReadnPixels) := LoadProc('glReadnPixels');

  Pointer(FGLTextureBarrier) := LoadProc('glTextureBarrier');
end;

procedure TOpenGL_4_5.glClipControl(origin: GLenum; depth: GLenum);
begin
  if Assigned(FGLClipControl) then FGLClipControl(origin, depth);
end;

procedure TOpenGL_4_5.glCreateTransformFeedbacks(n: GLsizei; ids: PGLuint);
begin
  if Assigned(FGLCreateTransformFeedbacks) then FGLCreateTransformFeedbacks(n, ids);
end;

procedure TOpenGL_4_5.glTransformFeedbackBufferBase(xfb: GLuint; index: GLuint; buffer: GLuint);
begin
  if Assigned(FGLTransformFeedbackBufferBase) then FGLTransformFeedbackBufferBase(xfb, index, buffer);
end;

procedure TOpenGL_4_5.glTransformFeedbackBufferRange(xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FGLTransformFeedbackBufferRange) then
    FGLTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
end;

procedure TOpenGL_4_5.glGetTransformFeedbackiv(xfb: GLuint; pname: GLenum; param: PGLint);
begin
  if Assigned(FGLGetTransformFeedbackiv) then FGLGetTransformFeedbackiv(xfb, pname, param);
end;

procedure TOpenGL_4_5.glGetTransformFeedbacki_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint);
begin
  if Assigned(FGLGetTransformFeedbacki_v) then FGLGetTransformFeedbacki_v(xfb, pname, index, param);
end;

procedure TOpenGL_4_5.glGetTransformFeedbacki64_v(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64);
begin
  if Assigned(FGLGetTransformFeedbacki64_v) then FGLGetTransformFeedbacki64_v(xfb, pname, index, param);
end;

//  Buffer DSA (il cuore di tutto) 
procedure TOpenGL_4_5.glCreateBuffers(n: GLsizei; buffers: PGLuint);
begin
  if Assigned(FGLCreateBuffers) then FGLCreateBuffers(n, buffers);
end;

procedure TOpenGL_4_5.glNamedBufferStorage(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; flags: GLbitfield);
begin
  if Assigned(FGLNamedBufferStorage) then FGLNamedBufferStorage(buffer, size, Data, flags);
end;

procedure TOpenGL_4_5.glNamedBufferData(buffer: GLuint; size: GLsizeiptr; const Data: Pointer; usage: GLenum);
begin
  if Assigned(FGLNamedBufferData) then FGLNamedBufferData(buffer, size, Data, usage);
end;

procedure TOpenGL_4_5.glNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; const Data: Pointer);
begin
  if Assigned(FGLNamedBufferSubData) then FGLNamedBufferSubData(buffer, offset, size, Data);
end;

procedure TOpenGL_4_5.glCopyNamedBufferSubData(readBuffer, writeBuffer: GLuint; readOffset, writeOffset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FGLCopyNamedBufferSubData) then
    FGLCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
end;

procedure TOpenGL_4_5.glClearNamedBufferData(buffer: GLuint; internalformat, format, aType: GLenum; const Data: Pointer);
begin
  if Assigned(FGLClearNamedBufferData) then FGLClearNamedBufferData(buffer, internalformat, format, aType, Data);
end;

procedure TOpenGL_4_5.glClearNamedBufferSubData(buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format, aType: GLenum; const Data: Pointer);
begin
  if Assigned(FGLClearNamedBufferSubData) then
    FGLClearNamedBufferSubData(buffer, internalformat, offset, size, format, aType, Data);
end;

function TOpenGL_4_5.glMapNamedBuffer(buffer: GLuint; access: GLenum): Pointer;
begin
  if Assigned(FGLMapNamedBuffer) then
    Result := FGLMapNamedBuffer(buffer, access)
  else
    Result := nil;
end;

function TOpenGL_4_5.glMapNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer;
begin
  if Assigned(FGLMapNamedBufferRange) then
    Result := FGLMapNamedBufferRange(buffer, offset, length, access)
  else
    Result := nil;
end;

function TOpenGL_4_5.glUnmapNamedBuffer(buffer: GLuint): GLboolean;
begin
  if Assigned(FGLUnmapNamedBuffer) then
    Result := FGLUnmapNamedBuffer(buffer)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_4_5.glFlushMappedNamedBufferRange(buffer: GLuint; offset: GLintptr; length: GLsizeiptr);
begin
  if Assigned(FGLFlushMappedNamedBufferRange) then
    FGLFlushMappedNamedBufferRange(buffer, offset, length);
end;

procedure TOpenGL_4_5.glGetNamedBufferParameteriv(buffer: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetNamedBufferParameteriv) then FGLGetNamedBufferParameteriv(buffer, pname, params);
end;

procedure TOpenGL_4_5.glGetNamedBufferParameteri64v(buffer: GLuint; pname: GLenum; params: PGLint64);
begin
  if Assigned(FGLGetNamedBufferParameteri64v) then FGLGetNamedBufferParameteri64v(buffer, pname, params);
end;

procedure TOpenGL_4_5.glGetNamedBufferPointerv(buffer: GLuint; pname: GLenum; params: PPointer);
begin
  if Assigned(FGLGetNamedBufferPointerv) then FGLGetNamedBufferPointerv(buffer, pname, params);
end;

procedure TOpenGL_4_5.glGetNamedBufferSubData(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer);
begin
  if Assigned(FGLGetNamedBufferSubData) then FGLGetNamedBufferSubData(buffer, offset, size, Data);
end;

//  Framebuffer DSA 
procedure TOpenGL_4_5.glCreateFramebuffers(n: GLsizei; framebuffers: PGLuint);
begin
  if Assigned(FGLCreateFramebuffers) then FGLCreateFramebuffers(n, framebuffers);
end;

procedure TOpenGL_4_5.glNamedFramebufferRenderbuffer(framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint);
begin
  if Assigned(FGLNamedFramebufferRenderbuffer) then
    FGLNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
end;

procedure TOpenGL_4_5.glNamedFramebufferParameteri(framebuffer: GLuint; pname: GLenum; param: GLint);
begin
  if Assigned(FGLNamedFramebufferParameteri) then FGLNamedFramebufferParameteri(framebuffer, pname, param);
end;

procedure TOpenGL_4_5.glNamedFramebufferTexture(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint);
begin
  if Assigned(FGLNamedFramebufferTexture) then
    FGLNamedFramebufferTexture(framebuffer, attachment, texture, level);
end;

procedure TOpenGL_4_5.glNamedFramebufferTextureLayer(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level, layer: GLint);
begin
  if Assigned(FGLNamedFramebufferTextureLayer) then
    FGLNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
end;

procedure TOpenGL_4_5.glNamedFramebufferDrawBuffer(framebuffer: GLuint; buf: GLenum);
begin
  if Assigned(FGLNamedFramebufferDrawBuffer) then FGLNamedFramebufferDrawBuffer(framebuffer, buf);
end;

procedure TOpenGL_4_5.glNamedFramebufferDrawBuffers(framebuffer: GLuint; n: GLsizei; const bufs: PGLenum);
begin
  if Assigned(FGLNamedFramebufferDrawBuffers) then FGLNamedFramebufferDrawBuffers(framebuffer, n, bufs);
end;

procedure TOpenGL_4_5.glNamedFramebufferReadBuffer(framebuffer: GLuint; src: GLenum);
begin
  if Assigned(FGLNamedFramebufferReadBuffer) then FGLNamedFramebufferReadBuffer(framebuffer, src);
end;

procedure TOpenGL_4_5.glInvalidateNamedFramebufferData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum);
begin
  if Assigned(FGLInvalidateNamedFramebufferData) then
    FGLInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
end;

procedure TOpenGL_4_5.glInvalidateNamedFramebufferSubData(framebuffer: GLuint; numAttachments: GLsizei; const attachments: PGLenum; x, y: GLint; Width, Height: GLsizei);
begin
  if Assigned(FGLInvalidateNamedFramebufferSubData) then
    FGLInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, Width, Height);
end;

procedure TOpenGL_4_5.glClearNamedFramebufferiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLint);
begin
  if Assigned(FGLClearNamedFramebufferiv) then FGLClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, Value);
end;

procedure TOpenGL_4_5.glClearNamedFramebufferuiv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLuint);
begin
  if Assigned(FGLClearNamedFramebufferuiv) then FGLClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, Value);
end;

procedure TOpenGL_4_5.glClearNamedFramebufferfv(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; const Value: PGLfloat);
begin
  if Assigned(FGLClearNamedFramebufferfv) then FGLClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, Value);
end;

procedure TOpenGL_4_5.glClearNamedFramebufferfi(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint);
begin
  if Assigned(FGLClearNamedFramebufferfi) then FGLClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
end;

procedure TOpenGL_4_5.glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer: GLuint; srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1: GLint; mask: GLbitfield; filter: GLenum);
begin
  if Assigned(FGLBlitNamedFramebuffer) then
    FGLBlitNamedFramebuffer(readFramebuffer, drawFramebuffer,
      srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
end;

function TOpenGL_4_5.glCheckNamedFramebufferStatus(framebuffer: GLuint; target: GLenum): GLenum;
begin
  if Assigned(FGLCheckNamedFramebufferStatus) then
    Result := FGLCheckNamedFramebufferStatus(framebuffer, target)
  else
    Result := GL_FRAMEBUFFER_UNDEFINED;
end;

procedure TOpenGL_4_5.glGetNamedFramebufferParameteriv(framebuffer: GLuint; pname: GLenum; param: PGLint);
begin
  if Assigned(FGLGetNamedFramebufferParameteriv) then FGLGetNamedFramebufferParameteriv(framebuffer, pname, param);
end;

procedure TOpenGL_4_5.glGetNamedFramebufferAttachmentParameteriv(framebuffer: GLuint; attachment, pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetNamedFramebufferAttachmentParameteriv) then
    FGLGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params);
end;

//  Renderbuffer DSA 
procedure TOpenGL_4_5.glCreateRenderbuffers(n: GLsizei; renderbuffers: PGLuint);
begin
  if Assigned(FGLCreateRenderbuffers) then FGLCreateRenderbuffers(n, renderbuffers);
end;

procedure TOpenGL_4_5.glNamedRenderbufferStorage(renderbuffer: GLuint; internalformat: GLenum; Width, Height: GLsizei);
begin
  if Assigned(FGLNamedRenderbufferStorage) then
    FGLNamedRenderbufferStorage(renderbuffer, internalformat, Width, Height);
end;

procedure TOpenGL_4_5.glNamedRenderbufferStorageMultisample(renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei);
begin
  if Assigned(FGLNamedRenderbufferStorageMultisample) then
    FGLNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, Width, Height);
end;

procedure TOpenGL_4_5.glGetNamedRenderbufferParameteriv(renderbuffer: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetNamedRenderbufferParameteriv) then FGLGetNamedRenderbufferParameteriv(renderbuffer, pname, params);
end;

//  Texture DSA (finalmente!) 
procedure TOpenGL_4_5.glCreateTextures(target: GLenum; n: GLsizei; textures: PGLuint);
begin
  if Assigned(FGLCreateTextures) then FGLCreateTextures(target, n, textures);
end;

procedure TOpenGL_4_5.glTextureBuffer(texture: GLuint; internalformat: GLenum; buffer: GLuint);
begin
  if Assigned(FGLTextureBuffer) then FGLTextureBuffer(texture, internalformat, buffer);
end;

procedure TOpenGL_4_5.glTextureBufferRange(texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr);
begin
  if Assigned(FGLTextureBufferRange) then FGLTextureBufferRange(texture, internalformat, buffer, offset, size);
end;

procedure TOpenGL_4_5.glTextureStorage1D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei);
begin
  if Assigned(FGLTextureStorage1D) then FGLTextureStorage1D(texture, levels, internalformat, Width);
end;

procedure TOpenGL_4_5.glTextureStorage2D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width, Height: GLsizei);
begin
  if Assigned(FGLTextureStorage2D) then FGLTextureStorage2D(texture, levels, internalformat, Width, Height);
end;

procedure TOpenGL_4_5.glTextureStorage3D(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei);
begin
  if Assigned(FGLTextureStorage3D) then FGLTextureStorage3D(texture, levels, internalformat, Width, Height, depth);
end;

procedure TOpenGL_4_5.glTextureStorage2DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FGLTextureStorage2DMultisample) then
    FGLTextureStorage2DMultisample(texture, samples, internalformat, Width, Height, fixedsamplelocations);
end;

procedure TOpenGL_4_5.glTextureStorage3DMultisample(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width, Height, depth: GLsizei; fixedsamplelocations: GLboolean);
begin
  if Assigned(FGLTextureStorage3DMultisample) then
    FGLTextureStorage3DMultisample(texture, samples, internalformat, Width, Height, depth, fixedsamplelocations);
end;

procedure TOpenGL_4_5.glTextureSubImage1D(texture: GLuint; level, xoffset: GLint; Width: GLsizei; format, aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FGLTextureSubImage1D) then FGLTextureSubImage1D(texture, level, xoffset, Width, format, aType, pixels);
end;

procedure TOpenGL_4_5.glTextureSubImage2D(texture: GLuint; level, xoffset, yoffset: GLint; Width, Height: GLsizei; format, aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FGLTextureSubImage2D) then FGLTextureSubImage2D(texture, level, xoffset, yoffset, Width, Height, format, aType, pixels);
end;

procedure TOpenGL_4_5.glTextureSubImage3D(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, aType: GLenum; const pixels: Pointer);
begin
  if Assigned(FGLTextureSubImage3D) then
    FGLTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, Width, Height, depth, format, aType, pixels);
end;

procedure TOpenGL_4_5.glCompressedTextureSubImage1D(texture: GLuint; level, xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FGLCompressedTextureSubImage1D) then
    FGLCompressedTextureSubImage1D(texture, level, xoffset, Width, format, imageSize, Data);
end;

procedure TOpenGL_4_5.glCompressedTextureSubImage2D(texture: GLuint; level, xoffset, yoffset: GLint; Width, Height: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FGLCompressedTextureSubImage2D) then
    FGLCompressedTextureSubImage2D(texture, level, xoffset, yoffset, Width, Height, format, imageSize, Data);
end;

procedure TOpenGL_4_5.glCompressedTextureSubImage3D(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format: GLenum; imageSize: GLsizei; const Data: Pointer);
begin
  if Assigned(FGLCompressedTextureSubImage3D) then
    FGLCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, Width, Height, depth, format, imageSize, Data);
end;

procedure TOpenGL_4_5.glCopyTextureSubImage1D(texture: GLuint; level, xoffset, x, y: GLint; Width: GLsizei);
begin
  if Assigned(FGLCopyTextureSubImage1D) then FGLCopyTextureSubImage1D(texture, level, xoffset, x, y, Width);
end;

procedure TOpenGL_4_5.glCopyTextureSubImage2D(texture: GLuint; level, xoffset, yoffset, x, y: GLint; Width, Height: GLsizei);
begin
  if Assigned(FGLCopyTextureSubImage2D) then FGLCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, Width, Height);
end;

procedure TOpenGL_4_5.glCopyTextureSubImage3D(texture: GLuint; level, xoffset, yoffset, zoffset, x, y: GLint; Width, Height: GLsizei);
begin
  if Assigned(FGLCopyTextureSubImage3D) then FGLCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, Width, Height);
end;

procedure TOpenGL_4_5.glTextureParameterf(texture: GLuint; pname: GLenum; param: GLfloat);
begin
  if Assigned(FGLTextureParameterf) then FGLTextureParameterf(texture, pname, param);
end;

procedure TOpenGL_4_5.glTextureParameterfv(texture: GLuint; pname: GLenum; const param: PGLfloat);
begin
  if Assigned(FGLTextureParameterfv) then FGLTextureParameterfv(texture, pname, param);
end;

procedure TOpenGL_4_5.glTextureParameteri(texture: GLuint; pname: GLenum; param: GLint);
begin
  if Assigned(FGLTextureParameteri) then FGLTextureParameteri(texture, pname, param);
end;

procedure TOpenGL_4_5.glTextureParameterIiv(texture: GLuint; pname: GLenum; const params: PGLint);
begin
  if Assigned(FGLTextureParameterIiv) then FGLTextureParameterIiv(texture, pname, params);
end;

procedure TOpenGL_4_5.glTextureParameterIuiv(texture: GLuint; pname: GLenum; const params: PGLuint);
begin
  if Assigned(FGLTextureParameterIuiv) then FGLTextureParameterIuiv(texture, pname, params);
end;

procedure TOpenGL_4_5.glTextureParameteriv(texture: GLuint; pname: GLenum; const param: PGLint);
begin
  if Assigned(FGLTextureParameteriv) then FGLTextureParameteriv(texture, pname, param);
end;

procedure TOpenGL_4_5.glGenerateTextureMipmap(texture: GLuint);
begin
  if Assigned(FGLGenerateTextureMipmap) then FGLGenerateTextureMipmap(texture);
end;

procedure TOpenGL_4_5.glBindTextureUnit(unit_: GLuint; texture: GLuint);
begin
  if Assigned(FGLBindTextureUnit) then FGLBindTextureUnit(unit_, texture);
end;

procedure TOpenGL_4_5.glGetTextureImage(texture: GLuint; level: GLint; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FGLGetTextureImage) then FGLGetTextureImage(texture, level, format, aType, bufSize, pixels);
end;

procedure TOpenGL_4_5.glGetCompressedTextureImage(texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FGLGetCompressedTextureImage) then FGLGetCompressedTextureImage(texture, level, bufSize, pixels);
end;

procedure TOpenGL_4_5.glGetTextureLevelParameterfv(texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FGLGetTextureLevelParameterfv) then FGLGetTextureLevelParameterfv(texture, level, pname, params);
end;

procedure TOpenGL_4_5.glGetTextureLevelParameteriv(texture: GLuint; level: GLint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetTextureLevelParameteriv) then FGLGetTextureLevelParameteriv(texture, level, pname, params);
end;

procedure TOpenGL_4_5.glGetTextureParameterfv(texture: GLuint; pname: GLenum; params: PGLfloat);
begin
  if Assigned(FGLGetTextureParameterfv) then FGLGetTextureParameterfv(texture, pname, params);
end;

procedure TOpenGL_4_5.glGetTextureParameterIiv(texture: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetTextureParameterIiv) then FGLGetTextureParameterIiv(texture, pname, params);
end;

procedure TOpenGL_4_5.glGetTextureParameterIuiv(texture: GLuint; pname: GLenum; params: PGLuint);
begin
  if Assigned(FGLGetTextureParameterIuiv) then FGLGetTextureParameterIuiv(texture, pname, params);
end;

procedure TOpenGL_4_5.glGetTextureParameteriv(texture: GLuint; pname: GLenum; params: PGLint);
begin
  if Assigned(FGLGetTextureParameteriv) then FGLGetTextureParameteriv(texture, pname, params);
end;

//  Vertex Array DSA 
procedure TOpenGL_4_5.glCreateVertexArrays(n: GLsizei; arrays: PGLuint);
begin
  if Assigned(FGLCreateVertexArrays) then FGLCreateVertexArrays(n, arrays);
end;

procedure TOpenGL_4_5.glDisableVertexArrayAttrib(vaobj: GLuint; index: GLuint);
begin
  if Assigned(FGLDisableVertexArrayAttrib) then FGLDisableVertexArrayAttrib(vaobj, index);
end;

procedure TOpenGL_4_5.glEnableVertexArrayAttrib(vaobj: GLuint; index: GLuint);
begin
  if Assigned(FGLEnableVertexArrayAttrib) then FGLEnableVertexArrayAttrib(vaobj, index);
end;

procedure TOpenGL_4_5.glVertexArrayElementBuffer(vaobj: GLuint; buffer: GLuint);
begin
  if Assigned(FGLVertexArrayElementBuffer) then FGLVertexArrayElementBuffer(vaobj, buffer);
end;

procedure TOpenGL_4_5.glVertexArrayVertexBuffer(vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei);
begin
  if Assigned(FGLVertexArrayVertexBuffer) then
    FGLVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
end;

procedure TOpenGL_4_5.glVertexArrayVertexBuffers(vaobj: GLuint; First: GLuint; Count: GLsizei; const buffers: PGLuint; const offsets: PGLintptr; const strides: PGLsizei);
begin
  if Assigned(FGLVertexArrayVertexBuffers) then
    FGLVertexArrayVertexBuffers(vaobj, First, Count, buffers, offsets, strides);
end;

procedure TOpenGL_4_5.glVertexArrayAttribBinding(vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint);
begin
  if Assigned(FGLVertexArrayAttribBinding) then FGLVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
end;

procedure TOpenGL_4_5.glVertexArrayAttribFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; normalized: GLboolean; relativeoffset: GLuint);
begin
  if Assigned(FGLVertexArrayAttribFormat) then
    FGLVertexArrayAttribFormat(vaobj, attribindex, size, aType, normalized, relativeoffset);
end;

procedure TOpenGL_4_5.glVertexArrayAttribIFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
begin
  if Assigned(FGLVertexArrayAttribIFormat) then
    FGLVertexArrayAttribIFormat(vaobj, attribindex, size, aType, relativeoffset);
end;

procedure TOpenGL_4_5.glVertexArrayAttribLFormat(vaobj: GLuint; attribindex: GLuint; size: GLint; aType: GLenum; relativeoffset: GLuint);
begin
  if Assigned(FGLVertexArrayAttribLFormat) then
    FGLVertexArrayAttribLFormat(vaobj, attribindex, size, aType, relativeoffset);
end;

procedure TOpenGL_4_5.glVertexArrayBindingDivisor(vaobj: GLuint; bindingindex: GLuint; divisor: GLuint);
begin
  if Assigned(FGLVertexArrayBindingDivisor) then FGLVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
end;

procedure TOpenGL_4_5.glGetVertexArrayiv(vaobj: GLuint; pname: GLenum; param: PGLint);
begin
  if Assigned(FGLGetVertexArrayiv) then FGLGetVertexArrayiv(vaobj, pname, param);
end;

procedure TOpenGL_4_5.glGetVertexArrayIndexediv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint);
begin
  if Assigned(FGLGetVertexArrayIndexediv) then FGLGetVertexArrayIndexediv(vaobj, index, pname, param);
end;

procedure TOpenGL_4_5.glGetVertexArrayIndexed64iv(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64);
begin
  if Assigned(FGLGetVertexArrayIndexed64iv) then FGLGetVertexArrayIndexed64iv(vaobj, index, pname, param);
end;

//  Object Creation 
procedure TOpenGL_4_5.glCreateSamplers(n: GLsizei; samplers: PGLuint);
begin
  if Assigned(FGLCreateSamplers) then FGLCreateSamplers(n, samplers);
end;

procedure TOpenGL_4_5.glCreateProgramPipelines(n: GLsizei; pipelines: PGLuint);
begin
  if Assigned(FGLCreateProgramPipelines) then FGLCreateProgramPipelines(n, pipelines);
end;

procedure TOpenGL_4_5.glCreateQueries(target: GLenum; n: GLsizei; ids: PGLuint);
begin
  if Assigned(FGLCreateQueries) then FGLCreateQueries(target, n, ids);
end;

// Query Buffer Objects
procedure TOpenGL_4_5.glGetQueryBufferObjecti64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
begin
  if Assigned(FGLGetQueryBufferObjecti64v) then FGLGetQueryBufferObjecti64v(id, buffer, pname, offset);
end;

procedure TOpenGL_4_5.glGetQueryBufferObjectiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
begin
  if Assigned(FGLGetQueryBufferObjectiv) then FGLGetQueryBufferObjectiv(id, buffer, pname, offset);
end;

procedure TOpenGL_4_5.glGetQueryBufferObjectui64v(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
begin
  if Assigned(FGLGetQueryBufferObjectui64v) then FGLGetQueryBufferObjectui64v(id, buffer, pname, offset);
end;

procedure TOpenGL_4_5.glGetQueryBufferObjectuiv(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr);
begin
  if Assigned(FGLGetQueryBufferObjectuiv) then FGLGetQueryBufferObjectuiv(id, buffer, pname, offset);
end;

// Memory Barrier (fine-grained)
procedure TOpenGL_4_5.glMemoryBarrierByRegion(barriers: GLbitfield);
begin
  if Assigned(FGLMemoryBarrierByRegion) then FGLMemoryBarrierByRegion(barriers);
end;

// Get SubImage
procedure TOpenGL_4_5.glGetTextureSubImage(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FGLGetTextureSubImage) then
    FGLGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, Width, Height, depth, format, aType, bufSize, pixels);
end;

procedure TOpenGL_4_5.glGetCompressedTextureSubImage(texture: GLuint; level, xoffset, yoffset, zoffset: GLint; Width, Height, depth: GLsizei; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FGLGetCompressedTextureSubImage) then
    FGLGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, Width, Height, depth, bufSize, pixels);
end;

// Robustness
function TOpenGL_4_5.glGetGraphicsResetStatus: GLenum;
begin
  if Assigned(FGLGetGraphicsResetStatus) then
    Result := FGLGetGraphicsResetStatus()
  else
    Result := GL_NO_ERROR;
end;

procedure TOpenGL_4_5.glGetnCompressedTexImage(target: GLenum; lod: GLint; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FGLGetnCompressedTexImage) then FGLGetnCompressedTexImage(target, lod, bufSize, pixels);
end;

procedure TOpenGL_4_5.glGetnTexImage(target: GLenum; level: GLint; format, aType: GLenum; bufSize: GLsizei; pixels: Pointer);
begin
  if Assigned(FGLGetnTexImage) then FGLGetnTexImage(target, level, format, aType, bufSize, pixels);
end;

procedure TOpenGL_4_5.glGetnUniformdv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble);
begin
  if Assigned(FGLGetnUniformdv) then FGLGetnUniformdv(aProgram, location, bufSize, params);
end;

procedure TOpenGL_4_5.glGetnUniformfv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat);
begin
  if Assigned(FGLGetnUniformfv) then FGLGetnUniformfv(aProgram, location, bufSize, params);
end;

procedure TOpenGL_4_5.glGetnUniformiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLint);
begin
  if Assigned(FGLGetnUniformiv) then FGLGetnUniformiv(aProgram, location, bufSize, params);
end;

procedure TOpenGL_4_5.glGetnUniformuiv(aProgram: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint);
begin
  if Assigned(FGLGetnUniformuiv) then FGLGetnUniformuiv(aProgram, location, bufSize, params);
end;

procedure TOpenGL_4_5.glReadnPixels(x, y: GLint; Width, Height: GLsizei; format, aType: GLenum; bufSize: GLsizei; Data: Pointer);
begin
  if Assigned(FGLReadnPixels) then FGLReadnPixels(x, y, Width, Height, format, aType, bufSize, Data);
end;

procedure TOpenGL_4_5.glTextureBarrier;
begin
  if Assigned(FGLTextureBarrier) then FGLTextureBarrier;
end;

{ TOpenGL_4_6 }

procedure TOpenGL_4_6.bindEntry;
begin
  inherited bindEntry;
  Pointer(FGLGetTextureHandleARB) := LoadProc('glGetTextureHandleARB');
  Pointer(FGLGetTextureSamplerHandleARB) := LoadProc('glGetTextureSamplerHandleARB');
  Pointer(FGLMakeTextureHandleResidentARB) := LoadProc('glMakeTextureHandleResidentARB');
  Pointer(FGLMakeTextureHandleNonResidentARB) := LoadProc('glMakeTextureHandleNonResidentARB');

  Pointer(FGLGetImageHandleARB) := LoadProc('glGetImageHandleARB');
  Pointer(FGLMakeImageHandleResidentARB) := LoadProc('glMakeImageHandleResidentARB');
  Pointer(FGLMakeImageHandleNonResidentARB) := LoadProc('glMakeImageHandleNonResidentARB');

  Pointer(FGLUniformHandleui64ARB) := LoadProc('glUniformHandleui64ARB');
  Pointer(FGLUniformHandleui64vARB) := LoadProc('glUniformHandleui64vARB');
  Pointer(FGLProgramUniformHandleui64ARB) := LoadProc('glProgramUniformHandleui64ARB');
  Pointer(FGLProgramUniformHandleui64vARB) := LoadProc('glProgramUniformHandleui64vARB');

  Pointer(FGLIsTextureHandleResidentARB) := LoadProc('glIsTextureHandleResidentARB');
  Pointer(FGLIsImageHandleResidentARB) := LoadProc('glIsImageHandleResidentARB');

  Pointer(FGLVertexAttribL1ui64ARB) := LoadProc('glVertexAttribL1ui64ARB');
  Pointer(FGLVertexAttribL1ui64vARB) := LoadProc('glVertexAttribL1ui64vARB');
  Pointer(FGLGetVertexAttribLui64vARB) := LoadProc('glGetVertexAttribLui64vARB');
end;

function TOpenGL_4_6.glGetTextureHandleARB(texture: GLuint): GLuint64;
begin
  if Assigned(FGLGetTextureHandleARB) then
    Result := FGLGetTextureHandleARB(texture)
  else
    Result := 0;
end;

function TOpenGL_4_6.glGetTextureSamplerHandleARB(texture: GLuint; sampler: GLuint): GLuint64;
begin
  if Assigned(FGLGetTextureSamplerHandleARB) then
    Result := FGLGetTextureSamplerHandleARB(texture, sampler)
  else
    Result := 0;
end;

procedure TOpenGL_4_6.glMakeTextureHandleResidentARB(handle: GLuint64);
begin
  if Assigned(FGLMakeTextureHandleResidentARB) then
    FGLMakeTextureHandleResidentARB(handle);
end;

procedure TOpenGL_4_6.glMakeTextureHandleNonResidentARB(handle: GLuint64);
begin
  if Assigned(FGLMakeTextureHandleNonResidentARB) then
    FGLMakeTextureHandleNonResidentARB(handle);
end;

function TOpenGL_4_6.glGetImageHandleARB(texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; format: GLenum): GLuint64;
begin
  if Assigned(FGLGetImageHandleARB) then
    Result := FGLGetImageHandleARB(texture, level, layered, layer, format)
  else
    Result := 0;
end;

procedure TOpenGL_4_6.glMakeImageHandleResidentARB(handle: GLuint64; access: GLenum);
begin
  if Assigned(FGLMakeImageHandleResidentARB) then
    FGLMakeImageHandleResidentARB(handle, access);
end;

procedure TOpenGL_4_6.glMakeImageHandleNonResidentARB(handle: GLuint64);
begin
  if Assigned(FGLMakeImageHandleNonResidentARB) then
    FGLMakeImageHandleNonResidentARB(handle);
end;

procedure TOpenGL_4_6.glUniformHandleui64ARB(location: GLint; Value: GLuint64);
begin
  if Assigned(FGLUniformHandleui64ARB) then
    FGLUniformHandleui64ARB(location, Value);
end;

procedure TOpenGL_4_6.glUniformHandleui64vARB(location: GLint; Count: GLsizei; const Value: PGLuint64);
begin
  if Assigned(FGLUniformHandleui64vARB) then
    FGLUniformHandleui64vARB(location, Count, Value);
end;

procedure TOpenGL_4_6.glProgramUniformHandleui64ARB(aProgram: GLuint; location: GLint; Value: GLuint64);
begin
  if Assigned(FGLProgramUniformHandleui64ARB) then
    FGLProgramUniformHandleui64ARB(aProgram, location, Value);
end;

procedure TOpenGL_4_6.glProgramUniformHandleui64vARB(aProgram: GLuint; location: GLint; Count: GLsizei; const values: PGLuint64);
begin
  if Assigned(FGLProgramUniformHandleui64vARB) then
    FGLProgramUniformHandleui64vARB(aProgram, location, Count, values);
end;

function TOpenGL_4_6.glIsTextureHandleResidentARB(handle: GLuint64): GLboolean;
begin
  if Assigned(FGLIsTextureHandleResidentARB) then
    Result := FGLIsTextureHandleResidentARB(handle)
  else
    Result := GL_FALSE;
end;

function TOpenGL_4_6.glIsImageHandleResidentARB(handle: GLuint64): GLboolean;
begin
  if Assigned(FGLIsImageHandleResidentARB) then
    Result := FGLIsImageHandleResidentARB(handle)
  else
    Result := GL_FALSE;
end;

procedure TOpenGL_4_6.glVertexAttribL1ui64ARB(index: GLuint; x: GLuint64EXT);
begin
  if Assigned(FGLVertexAttribL1ui64ARB) then
    FGLVertexAttribL1ui64ARB(index, x);
end;

procedure TOpenGL_4_6.glVertexAttribL1ui64vARB(index: GLuint; const v: PGLuint64EXT);
begin
  if Assigned(FGLVertexAttribL1ui64vARB) then
    FGLVertexAttribL1ui64vARB(index, v);
end;

procedure TOpenGL_4_6.glGetVertexAttribLui64vARB(index: GLuint; pname: GLenum; params: PGLuint64EXT);
begin
  if Assigned(FGLGetVertexAttribLui64vARB) then
    FGLGetVertexAttribLui64vARB(index, pname, params);
end;

initialization
  singleton := nil;

finalization
  singleton := nil;

end.
